"ids","error","source","code","solution"
57,"junit.framework.ComparisonFailure","/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java","@@ -1355,12 +1355,14 @@ private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,
     // Track the start of the line to count whitespace that
     // the tokenizer skipped. Because this case is rare, it's easier
     // to do this here than in the tokenizer.
 
     do {
       switch (token) {
         case STAR:
           if (ignoreStar) {
             // Mark the position after the star as the new start of the line.
           } else {
             // The star is part of the comment.
             if (builder.length() > 0) {
@@ -1379,6 +1381,7 @@ private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,
           }
 
           ignoreStar = true;
           token = next();
           continue;
 
@@ -1386,7 +1389,19 @@ private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,
           ignoreStar = false;
           state = State.SEARCHING_ANNOTATION;
 
               // All tokens must be separated by a space.
 
           if (token == JsDocToken.EOC ||
               token == JsDocToken.EOF ||
@@ -1411,9 +1426,6 @@ private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,
             return new ExtractionInfo(multilineText, token);
           }
 
           builder.append(toString(token));
 
           line = stream.getRemainingJSDocLine();
","@@ -1355,12 +1355,14 @@ private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,
     // Track the start of the line to count whitespace that
     // the tokenizer skipped. Because this case is rare, it's easier
     // to do this here than in the tokenizer.
+    int lineStartChar = -1;
 
     do {
       switch (token) {
         case STAR:
           if (ignoreStar) {
             // Mark the position after the star as the new start of the line.
+            lineStartChar = stream.getCharno() + 1;
           } else {
             // The star is part of the comment.
             if (builder.length() > 0) {
@@ -1379,6 +1381,7 @@ private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,
           }
 
           ignoreStar = true;
+          lineStartChar = 0;
           token = next();
           continue;
 
@@ -1386,7 +1389,19 @@ private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,
           ignoreStar = false;
           state = State.SEARCHING_ANNOTATION;
 
+          boolean isEOC = token == JsDocToken.EOC;
+          if (!isEOC) {
+            if (lineStartChar != -1 && option == WhitespaceOption.PRESERVE) {
+              int numSpaces = stream.getCharno() - lineStartChar;
+              for (int i = 0; i < numSpaces; i++) {
+                builder.append(' ');
+              }
+              lineStartChar = -1;
+            } else if (builder.length() > 0) {
               // All tokens must be separated by a space.
+              builder.append(' ');
+            }
+          }
 
           if (token == JsDocToken.EOC ||
               token == JsDocToken.EOF ||
@@ -1411,9 +1426,6 @@ private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,
             return new ExtractionInfo(multilineText, token);
           }
 
           builder.append(toString(token));
 
           line = stream.getRemainingJSDocLine();
"
58,"junit.framework.AssertionFailedError","/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java","@@ -554,6 +554,9 @@ JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {
   @Override
   public void matchConstraint(ObjectType constraintObj) {
     // We only want to match contraints on anonymous types.
 
     // Handle the case where the constraint object is a record type.
     //
","@@ -554,6 +554,9 @@ JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {
   @Override
   public void matchConstraint(ObjectType constraintObj) {
     // We only want to match contraints on anonymous types.
+    if (hasReferenceName()) {
+      return;
+    }
 
     // Handle the case where the constraint object is a record type.
     //
"
59,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/InlineCostEstimator.java","@@ -99,5 +99,9 @@ void addIdentifier(String identifier) {
      * Constants (true, false, null) are considered basically free,
      * because it's likely that they will get folded when we're done.
      */
   }
 }
","@@ -99,5 +99,9 @@ void addIdentifier(String identifier) {
      * Constants (true, false, null) are considered basically free,
      * because it's likely that they will get folded when we're done.
      */
+    @Override
+    void addConstant(String newcode) {
+      add(""0"");
+    }
   }
 }
"
60,"java.lang.StackOverflowError","/src/com/google/javascript/jscomp/CodeGenerator.java","@@ -119,9 +119,7 @@ void add(Node n, Context context) {
         cc.addOp(opstr, true);
         addExpr(last, p, rhsContext);
       } else {
       }
       return;
     }
@@ -751,7 +749,7 @@ private void unrollBinaryOperator(
     Node current = firstNonOperator;
     do {
       current = current.getParent();
       addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);
     } while (current != n);
   }
/src/com/google/javascript/jscomp/CodePrinter.java @@ -331,7 +331,7 @@ void endCaseBody() {
     @Override
     void appendOp(String op, boolean binOp) {
       if (binOp) {
           append("" "");
         }
         append(op);
","@@ -119,9 +119,7 @@ void add(Node n, Context context) {
         cc.addOp(opstr, true);
         addExpr(last, p, rhsContext);
       } else {
+        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);
       }
       return;
     }
@@ -751,7 +749,7 @@ private void unrollBinaryOperator(
     Node current = firstNonOperator;
     do {
       current = current.getParent();
+      cc.addOp(opStr, true);
       addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);
     } while (current != n);
   }
/src/com/google/javascript/jscomp/CodePrinter.java @@ -331,7 +331,7 @@ void endCaseBody() {
     @Override
     void appendOp(String op, boolean binOp) {
       if (binOp) {
+        if (getLastChar() != ' ' && op.charAt(0) != ',') {
           append("" "");
         }
         append(op);
"
61,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/TypeInference.java","@@ -1118,21 +1118,8 @@ private void inferPropertyTypesToMatchConstraint(
 
     ObjectType constraintObj =
         ObjectType.cast(constraint.restrictByNotNullOrUndefined());
     }
   }
 
","@@ -1118,21 +1118,8 @@ private void inferPropertyTypesToMatchConstraint(
 
     ObjectType constraintObj =
         ObjectType.cast(constraint.restrictByNotNullOrUndefined());
+    if (constraintObj != null) {
+      type.matchConstraint(constraintObj);
     }
   }
 
"
62,"java.lang.RuntimeException","/src/com/google/javascript/jscomp/NodeTraversal.java","@@ -538,7 +538,7 @@ private void traverseFunction(Node n, Node parent) {
 
     // Body
     Preconditions.checkState(body.getNext() == null &&
     traverseBranch(body, n);
 
     popScope();
/src/com/google/javascript/jscomp/parsing/IRFactory.java @@ -664,9 +664,13 @@ Node processFunctionNode(FunctionNode functionNode) {
       node.addChildToBack(lp);
 
       Node bodyNode = transform(functionNode.getBody());
         // When in ideMode Rhino tries to parse some constructs the compiler
         // doesn't support, repair it here. see Rhino's
         // Parser#parseFunctionBodyExpr.
       parseDirectives(bodyNode);
       node.addChildToBack(bodyNode);
      return node;
","@@ -538,7 +538,7 @@ private void traverseFunction(Node n, Node parent) {
 
     // Body
     Preconditions.checkState(body.getNext() == null &&
+            body.isBlock(), body);
     traverseBranch(body, n);
 
     popScope();
/src/com/google/javascript/jscomp/parsing/IRFactory.java @@ -664,9 +664,13 @@ Node processFunctionNode(FunctionNode functionNode) {
       node.addChildToBack(lp);
 
       Node bodyNode = transform(functionNode.getBody());
+      if (!bodyNode.isBlock()) {
         // When in ideMode Rhino tries to parse some constructs the compiler
         // doesn't support, repair it here. see Rhino's
         // Parser#parseFunctionBodyExpr.
+        Preconditions.checkState(config.isIdeMode);
+        bodyNode = IR.block();
+      }
       parseDirectives(bodyNode);
       node.addChildToBack(bodyNode);
      return node;
"
63,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/InlineVariables.java","@@ -572,6 +572,9 @@ private boolean canInline(
 
           // issue 668: Don't inline singleton getter methods
           // calls as this confused class removing logic.
         }
       }
 
","@@ -572,6 +572,9 @@ private boolean canInline(
 
           // issue 668: Don't inline singleton getter methods
           // calls as this confused class removing logic.
+          if (convention.getSingletonGetterClassName(callNode) != null) {
+            return false;
+          }
         }
       }
 
"
64,"junit.framework.ComparisonFailure","/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java","@@ -377,10 +377,10 @@ String toStringHelper(boolean forAnnotations) {
 
         sb.append(property);
         sb.append("": "");
 
         ++i;
           sb.append("", ..."");
           break;
         }
@@ -391,7 +391,7 @@ String toStringHelper(boolean forAnnotations) {
       prettyPrint = true;
       return sb.toString();
     } else {
     }
   }
 
","@@ -377,10 +377,10 @@ String toStringHelper(boolean forAnnotations) {
 
         sb.append(property);
         sb.append("": "");
+        sb.append(getPropertyType(property).toStringHelper(forAnnotations));
 
         ++i;
+        if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) {
           sb.append("", ..."");
           break;
         }
@@ -391,7 +391,7 @@ String toStringHelper(boolean forAnnotations) {
       prettyPrint = true;
       return sb.toString();
     } else {
+      return forAnnotations ? ""?"" : ""{...}"";
     }
   }
 
"
65,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/RemoveUnusedVars.java","@@ -729,6 +729,7 @@ private void interpretAssigns() {
             assignedToUnknownValue = true;
           }
 
           for (Assign assign : assignsByVar.get(var)) {
             if (assign.isPropertyAssign) {
               hasPropertyAssign = true;
@@ -736,9 +737,12 @@ private void interpretAssigns() {
                 assign.assignNode.getLastChild(), true)) {
               assignedToUnknownValue = true;
             }
           }
 
             changes = markReferencedVar(var) || changes;
             maybeUnreferenced.remove(current);
             current--;
@@ -901,7 +905,7 @@ void apply() {
       this.nameNode = nameNode;
       this.isPropertyAssign = isPropertyAssign;
 
       this.mayHaveSecondarySideEffects =
           maybeAliased ||
           NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) ||
","@@ -729,6 +729,7 @@ private void interpretAssigns() {
             assignedToUnknownValue = true;
           }
 
+          boolean maybeEscaped = false;
           for (Assign assign : assignsByVar.get(var)) {
             if (assign.isPropertyAssign) {
               hasPropertyAssign = true;
@@ -736,9 +737,12 @@ private void interpretAssigns() {
                 assign.assignNode.getLastChild(), true)) {
               assignedToUnknownValue = true;
             }
+            if (assign.maybeAliased) {
+              maybeEscaped = true;
+            }
           }
 
+          if ((assignedToUnknownValue || maybeEscaped) && hasPropertyAssign) {
             changes = markReferencedVar(var) || changes;
             maybeUnreferenced.remove(current);
             current--;
@@ -901,7 +905,7 @@ void apply() {
       this.nameNode = nameNode;
       this.isPropertyAssign = isPropertyAssign;
 
+      this.maybeAliased = NodeUtil.isExpressionResultUsed(assignNode);
       this.mayHaveSecondarySideEffects =
           maybeAliased ||
           NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) ||
"
66,"junit.framework.ComparisonFailure","/src/com/google/javascript/jscomp/CodeConsumer.java","@@ -242,7 +242,7 @@ void addNumber(double x) {
     // x--4 (which is a syntax error).
     char prev = getLastChar();
     boolean negativeZero = isNegativeZero(x);
       add("" "");
     }
 
","@@ -242,7 +242,7 @@ void addNumber(double x) {
     // x--4 (which is a syntax error).
     char prev = getLastChar();
     boolean negativeZero = isNegativeZero(x);
+    if ((x < 0 || negativeZero) && prev == '-') {
       add("" "");
     }
 
"
67,"java.lang.RuntimeException","/src/com/google/javascript/jscomp/NameAnalyzer.java","@@ -632,11 +632,9 @@ public void visit(NodeTraversal t, Node n, Node parent) {
         Node nameNode = n.getFirstChild();
         NameInformation ns = createNameInformation(t, nameNode, n);
         if (ns != null && ns.onlyAffectsClassDef) {
           refNodes.add(new ClassDefiningFunctionNode(
               name, n, parent, parent.getParent()));
         }
       }
     }
","@@ -632,11 +632,9 @@ public void visit(NodeTraversal t, Node n, Node parent) {
         Node nameNode = n.getFirstChild();
         NameInformation ns = createNameInformation(t, nameNode, n);
         if (ns != null && ns.onlyAffectsClassDef) {
+          JsName name = getName(ns.name, true);
           refNodes.add(new ClassDefiningFunctionNode(
               name, n, parent, parent.getParent()));
         }
       }
     }
"
68,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/parsing/IRFactory.java","@@ -565,8 +565,15 @@ Node processExpressionStatement(ExpressionStatement statementNode) {
 
     @Override
     Node processForInLoop(ForInLoop loopNode) {
 
         // Return the bare minimum to put the AST in a valid state.
       return newNode(
           Token.FOR,
           transform(loopNode.getIterator()),
","@@ -565,8 +565,15 @@ Node processExpressionStatement(ExpressionStatement statementNode) {
 
     @Override
     Node processForInLoop(ForInLoop loopNode) {
+      if (loopNode.isForEach()) {
+        errorReporter.error(
+            ""unsupported language extension: for each"",
+            sourceName,
+            loopNode.getLineno(), """", 0);
 
         // Return the bare minimum to put the AST in a valid state.
+        return newNode(Token.EXPR_RESULT, Node.newNumber(0));
+      }
       return newNode(
           Token.FOR,
           transform(loopNode.getIterator()),
"
69,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/FunctionTypeBuilder.java","@@ -289,6 +289,9 @@ FunctionTypeBuilder inferFromOverriddenFunction(
       }
 
       // Clone any remaining params that aren't in the function literal.
 
       parametersNode = paramBuilder.build();
     }
@@ -480,6 +483,12 @@ FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,
     }
 
     // Copy over any old parameters that aren't in the param list.
 
     if (templateTypeName != null && !foundTemplateType) {
       reportError(TEMPLATE_TYPE_EXPECTED, fnName);
","@@ -289,6 +289,9 @@ FunctionTypeBuilder inferFromOverriddenFunction(
       }
 
       // Clone any remaining params that aren't in the function literal.
+      while (oldParams.hasNext()) {
+        paramBuilder.newParameterFromNode(oldParams.next());
+      }
 
       parametersNode = paramBuilder.build();
     }
@@ -480,6 +483,12 @@ FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,
     }
 
     // Copy over any old parameters that aren't in the param list.
+    if (!isVarArgs) {
+      while (oldParameterType != null && !isVarArgs) {
+        builder.newParameterFromNode(oldParameterType);
+        oldParameterType = oldParameterType.getNext();
+      }
+    }
 
     if (templateTypeName != null && !foundTemplateType) {
       reportError(TEMPLATE_TYPE_EXPECTED, fnName);
"
70,"junit.framework.ComparisonFailure","/src/com/google/javascript/jscomp/CodeConsumer.java","@@ -191,11 +191,13 @@ void add(String newcode) {
       // need space to separate. This is not pretty printing.
       // For example: ""return foo;""
       append("" "");
       // Do not allow a forward slash to appear after a DIV.
       // For example,
       // REGEXP DIV REGEXP
       // is valid and should print like
       // / // / /
     }
 
     append(newcode);
","@@ -191,11 +191,13 @@ void add(String newcode) {
       // need space to separate. This is not pretty printing.
       // For example: ""return foo;""
       append("" "");
+    } else if (c == '/' && getLastChar() == '/') {
       // Do not allow a forward slash to appear after a DIV.
       // For example,
       // REGEXP DIV REGEXP
       // is valid and should print like
       // / // / /
+      append("" "");
     }
 
     append(newcode);
"
71,"junit.framework.ComparisonFailure","/src/com/google/javascript/jscomp/TypedScopeCreator.java","@@ -390,50 +390,51 @@ private void identifyNameNode(
   private JSType getNativeType(JSTypeNative nativeType) {
     return typeRegistry.getNativeType(nativeType);
   }
 
   private abstract class AbstractScopeBuilder
       implements NodeTraversal.Callback {
 
     /**
      * The scope that we're builidng.
      */
     final Scope scope;
 
     private final List<DeferredSetType> deferredSetTypes =
         Lists.newArrayList();
 
     /**
      * Functions that we found in the global scope and not in externs.
      */
     private final List<Node> nonExternFunctions = Lists.newArrayList();
 
     /**
      * Object literals with a @lends annotation aren't analyzed until we
      * reach the root of the statement they're defined in.
      *
      * This ensures that if there are any @lends annotations on the object
      * literals, the type on the @lends annotation resolves correctly.
      *
      * For more information, see
      * http://code.google.com/p/closure-compiler/issues/detail?id=314
      */
 
     /**
      * Type-less stubs.
      *
      * If at the end of traversal, we still don't have types for these
      * stubs, then we should declare UNKNOWN types.
      */
     private final List<StubDeclaration> stubDeclarations =
         Lists.newArrayList();
 
     /**
      * The current source file that we're in.
      */
     private String sourceName = null;
 
     /**
      * The InputId of the current node.
      */
     private InputId inputId;
 
@@ -498,90 +499,106 @@ public final boolean shouldTraverse(NodeTraversal t, Node n,
     public void visit(NodeTraversal t, Node n, Node parent) {
       inputId = t.getInputId();
       attachLiteralTypes(t, n);
 
       switch (n.getType()) {
         case Token.CALL:
           checkForClassDefiningCalls(t, n, parent);
           checkForCallingConventionDefiningCalls(n, delegateCallingConventions);
           break;
 
         case Token.FUNCTION:
           if (t.getInput() == null || !t.getInput().isExtern()) {
             nonExternFunctions.add(n);
           }
 
           // Hoisted functions are handled during pre-traversal.
           if (!NodeUtil.isHoistedFunctionDeclaration(n)) {
             defineFunctionLiteral(n, parent);
           }
           break;
 
         case Token.ASSIGN:
           // Handle initialization of properties.
           Node firstChild = n.getFirstChild();
           if (firstChild.isGetProp() &&
               firstChild.isQualifiedName()) {
             maybeDeclareQualifiedName(t, n.getJSDocInfo(),
                 firstChild, n, firstChild.getNext());
           }
           break;
 
         case Token.CATCH:
           defineCatch(n, parent);
           break;
 
         case Token.VAR:
           defineVar(n, parent);
           break;
 
         case Token.GETPROP:
           // Handle stubbed properties.
           if (parent.isExprResult() &&
               n.isQualifiedName()) {
             maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);
           }
           break;
       }
 
       // Analyze any @lends object literals in this statement.
     }
 
     private void attachLiteralTypes(NodeTraversal t, Node n) {
       switch (n.getType()) {
         case Token.NULL:
           n.setJSType(getNativeType(NULL_TYPE));
           break;
 
         case Token.VOID:
           n.setJSType(getNativeType(VOID_TYPE));
           break;
 
         case Token.STRING:
           // Defer keys to the Token.OBJECTLIT case
           if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
             n.setJSType(getNativeType(STRING_TYPE));
           }
           break;
 
         case Token.NUMBER:
           n.setJSType(getNativeType(NUMBER_TYPE));
           break;
 
         case Token.TRUE:
         case Token.FALSE:
           n.setJSType(getNativeType(BOOLEAN_TYPE));
           break;
 
         case Token.REGEXP:
           n.setJSType(getNativeType(REGEXP_TYPE));
           break;
 
         case Token.OBJECTLIT:
             defineObjectLiteral(n);
           break;
 
           // NOTE(nicksantos): If we ever support Array tuples,
           // we will need to put ARRAYLIT here as well.
       }
     }
 
","@@ -390,50 +390,51 @@ private void identifyNameNode(
   private JSType getNativeType(JSTypeNative nativeType) {
     return typeRegistry.getNativeType(nativeType);
   }
 
   private abstract class AbstractScopeBuilder
       implements NodeTraversal.Callback {
 
     /**
      * The scope that we're builidng.
      */
     final Scope scope;
 
     private final List<DeferredSetType> deferredSetTypes =
         Lists.newArrayList();
 
     /**
      * Functions that we found in the global scope and not in externs.
      */
     private final List<Node> nonExternFunctions = Lists.newArrayList();
 
     /**
      * Object literals with a @lends annotation aren't analyzed until we
      * reach the root of the statement they're defined in.
      *
      * This ensures that if there are any @lends annotations on the object
      * literals, the type on the @lends annotation resolves correctly.
      *
      * For more information, see
      * http://code.google.com/p/closure-compiler/issues/detail?id=314
      */
+    private List<Node> lentObjectLiterals = null;
 
     /**
      * Type-less stubs.
      *
      * If at the end of traversal, we still don't have types for these
      * stubs, then we should declare UNKNOWN types.
      */
     private final List<StubDeclaration> stubDeclarations =
         Lists.newArrayList();
 
     /**
      * The current source file that we're in.
      */
     private String sourceName = null;
 
     /**
      * The InputId of the current node.
      */
     private InputId inputId;
 
@@ -498,90 +499,106 @@ public final boolean shouldTraverse(NodeTraversal t, Node n,
     public void visit(NodeTraversal t, Node n, Node parent) {
       inputId = t.getInputId();
       attachLiteralTypes(t, n);
 
       switch (n.getType()) {
         case Token.CALL:
           checkForClassDefiningCalls(t, n, parent);
           checkForCallingConventionDefiningCalls(n, delegateCallingConventions);
           break;
 
         case Token.FUNCTION:
           if (t.getInput() == null || !t.getInput().isExtern()) {
             nonExternFunctions.add(n);
           }
 
           // Hoisted functions are handled during pre-traversal.
           if (!NodeUtil.isHoistedFunctionDeclaration(n)) {
             defineFunctionLiteral(n, parent);
           }
           break;
 
         case Token.ASSIGN:
           // Handle initialization of properties.
           Node firstChild = n.getFirstChild();
           if (firstChild.isGetProp() &&
               firstChild.isQualifiedName()) {
             maybeDeclareQualifiedName(t, n.getJSDocInfo(),
                 firstChild, n, firstChild.getNext());
           }
           break;
 
         case Token.CATCH:
           defineCatch(n, parent);
           break;
 
         case Token.VAR:
           defineVar(n, parent);
           break;
 
         case Token.GETPROP:
           // Handle stubbed properties.
           if (parent.isExprResult() &&
               n.isQualifiedName()) {
             maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);
           }
           break;
       }
 
       // Analyze any @lends object literals in this statement.
+      if (n.getParent() != null && NodeUtil.isStatement(n) &&
+          lentObjectLiterals != null) {
+        for (Node objLit : lentObjectLiterals) {
+          defineObjectLiteral(objLit);
+        }
+        lentObjectLiterals.clear();
+      }
     }
 
     private void attachLiteralTypes(NodeTraversal t, Node n) {
       switch (n.getType()) {
         case Token.NULL:
           n.setJSType(getNativeType(NULL_TYPE));
           break;
 
         case Token.VOID:
           n.setJSType(getNativeType(VOID_TYPE));
           break;
 
         case Token.STRING:
           // Defer keys to the Token.OBJECTLIT case
           if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
             n.setJSType(getNativeType(STRING_TYPE));
           }
           break;
 
         case Token.NUMBER:
           n.setJSType(getNativeType(NUMBER_TYPE));
           break;
 
         case Token.TRUE:
         case Token.FALSE:
           n.setJSType(getNativeType(BOOLEAN_TYPE));
           break;
 
         case Token.REGEXP:
           n.setJSType(getNativeType(REGEXP_TYPE));
           break;
 
         case Token.OBJECTLIT:
+          JSDocInfo info = n.getJSDocInfo();
+          if (info != null &&
+              info.getLendsName() != null) {
+            if (lentObjectLiterals == null) {
+              lentObjectLiterals = Lists.newArrayList();
+            }
+            lentObjectLiterals.add(n);
+          } else {
             defineObjectLiteral(n);
+          }
           break;
 
           // NOTE(nicksantos): If we ever support Array tuples,
           // we will need to put ARRAYLIT here as well.
       }
     }
 
"
72,"junit.framework.AssertionFailedError","/src/com/google/javascript/rhino/jstype/RecordType.java","@@ -137,22 +137,6 @@ boolean defineProperty(String propertyName, JSType type,
         propertyNode);
   }
 
   JSType getGreatestSubtypeHelper(JSType that) {
     if (that.isRecordType()) {
       RecordType thatRecord = that.toMaybeRecordType();
","@@ -137,22 +137,6 @@ boolean defineProperty(String propertyName, JSType type,
         propertyNode);
   }
 
   JSType getGreatestSubtypeHelper(JSType that) {
     if (that.isRecordType()) {
       RecordType thatRecord = that.toMaybeRecordType();
"
73,"junit.framework.AssertionFailedError","/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java","@@ -486,8 +486,8 @@ private OriginalMapping getOriginalMappingForEntry(Entry entry) {
       // Adjust the line/column here to be start at 1.
       Builder x = OriginalMapping.newBuilder()
         .setOriginalFile(sources[entry.getSourceFileId()])
       if (entry.getNameId() != UNMAPPED) {
         x.setIdentifier(names[entry.getNameId()]);
       }
/src/com/google/javascript/jscomp/SourceMap.java @@ -135,10 +135,15 @@ public void addMapping(
     // zero based.
     // We don't change this for the v1 or v2 source maps but for
     // v3 we make them both 0 based.
 
     generator.addMapping(
         sourceFile, originalName,
         outputStartPosition, outputEndPosition);
   }
 
","@@ -486,8 +486,8 @@ private OriginalMapping getOriginalMappingForEntry(Entry entry) {
       // Adjust the line/column here to be start at 1.
       Builder x = OriginalMapping.newBuilder()
         .setOriginalFile(sources[entry.getSourceFileId()])
+        .setLineNumber(entry.getSourceLine() + 1)
+        .setColumnPosition(entry.getSourceColumn() + 1);
       if (entry.getNameId() != UNMAPPED) {
         x.setIdentifier(names[entry.getNameId()]);
       }
/src/com/google/javascript/jscomp/SourceMap.java @@ -135,10 +135,15 @@ public void addMapping(
     // zero based.
     // We don't change this for the v1 or v2 source maps but for
     // v3 we make them both 0 based.
+    int lineBaseOffset = 1;
+    if (generator instanceof SourceMapGeneratorV1
+        || generator instanceof SourceMapGeneratorV2) {
+      lineBaseOffset = 0;
+    }
 
     generator.addMapping(
         sourceFile, originalName,
+        new FilePosition(node.getLineno() - lineBaseOffset, node.getCharno()),
         outputStartPosition, outputEndPosition);
   }
 
"
74,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/TypedScopeCreator.java","@@ -1518,11 +1518,14 @@ void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,
             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
       }
 
         // Determining declaration for #2
       }
 
       if (!inferred) {
","@@ -1518,11 +1518,14 @@ void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,
             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
       }
 
+      if (inferred && rhsValue != null && rhsValue.isFunction()) {
         // Determining declaration for #2
+        if (info != null) {
+          inferred = false;
+        } else if (!scope.isDeclared(qName, false) &&
+                   n.isUnscopedQualifiedName()) {
+          inferred = false;
+        }
       }
 
       if (!inferred) {
"
75,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java","@@ -88,14 +88,6 @@ public void enterScope(NodeTraversal t) {
       renamer = nameStack.peek().forChildScope();
     }
 
     if (declarationRoot.getType() != Token.FUNCTION) {
       // Add the block declarations
       findDeclaredNames(declarationRoot, null, renamer);
@@ -127,11 +119,22 @@ public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
             renamer.addDeclaredName(name);
           }
 
 
 
           // Add the function parameters
 
           // Add the function body declarations
 
           nameStack.push(renamer);
         }
@@ -170,13 +173,16 @@ public void visit(NodeTraversal t, Node n, Node parent) {
 
       case Token.FUNCTION:
         // Remove the function body scope
         // Remove function recursive name (if any).
         nameStack.pop();
         break;
 
         // Note: The parameters and function body variables live in the
         // same scope, we introduce the scope when in the ""shouldTraverse""
         // visit of LP, but remove it when when we exit the function above.
 
       case Token.CATCH:
         // Remove catch except name from the stack of names.
","@@ -88,14 +88,6 @@ public void enterScope(NodeTraversal t) {
       renamer = nameStack.peek().forChildScope();
     }
 
     if (declarationRoot.getType() != Token.FUNCTION) {
       // Add the block declarations
       findDeclaredNames(declarationRoot, null, renamer);
@@ -127,11 +119,22 @@ public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
             renamer.addDeclaredName(name);
           }
 
+          nameStack.push(renamer);
+        }
+        break;
 
+      case Token.LP: {
+          Renamer renamer = nameStack.peek().forChildScope();
 
           // Add the function parameters
+          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
+            String name = c.getString();
+            renamer.addDeclaredName(name);
+          }
 
           // Add the function body declarations
+          Node functionBody = n.getNext();
+          findDeclaredNames(functionBody, null, renamer);
 
           nameStack.push(renamer);
         }
@@ -170,13 +173,16 @@ public void visit(NodeTraversal t, Node n, Node parent) {
 
       case Token.FUNCTION:
         // Remove the function body scope
+        nameStack.pop();
         // Remove function recursive name (if any).
         nameStack.pop();
         break;
 
+      case Token.LP:
         // Note: The parameters and function body variables live in the
         // same scope, we introduce the scope when in the ""shouldTraverse""
         // visit of LP, but remove it when when we exit the function above.
+        break;
 
       case Token.CATCH:
         // Remove catch except name from the stack of names.
"
76,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java","@@ -373,7 +373,7 @@ private Node tryFoldArrayJoin(Node n) {
 
     Node right = callTarget.getNext();
     if (right != null) {
         return n;
       }
     }
@@ -386,7 +386,12 @@ private Node tryFoldArrayJoin(Node n) {
       return n;
     }
 
       // "","" is the default, it doesn't need to be explicit
 
     String joinString = (right == null) ? "","" : NodeUtil.getStringValue(right);
     List<Node> arrayFoldedChildren = Lists.newLinkedList();
","@@ -373,7 +373,7 @@ private Node tryFoldArrayJoin(Node n) {
 
     Node right = callTarget.getNext();
     if (right != null) {
+      if (right.getNext() != null || !NodeUtil.isImmutableValue(right)) {
         return n;
       }
     }
@@ -386,7 +386,12 @@ private Node tryFoldArrayJoin(Node n) {
       return n;
     }
 
+    if (right != null && right.getType() == Token.STRING
+        && "","".equals(right.getString())) {
       // "","" is the default, it doesn't need to be explicit
+      n.removeChild(right);
+      reportCodeChange();
+    }
 
     String joinString = (right == null) ? "","" : NodeUtil.getStringValue(right);
     List<Node> arrayFoldedChildren = Lists.newLinkedList();
"
77,"java.lang.RuntimeException","/src/com/google/javascript/jscomp/InlineObjectLiterals.java","@@ -328,6 +328,9 @@ private void replaceAssignmentExpression(Var v, Reference ref,
       }
 
       Node replacement;
         // All assignments evaluate to true, so make sure that the
         // expr statement evaluates to true in case it matters.
         nodes.add(new Node(Token.TRUE));
@@ -347,6 +350,7 @@ private void replaceAssignmentExpression(Var v, Reference ref,
         }
         cur.addChildToFront(nodes.get(i));
         cur.addChildToFront(nodes.get(i + 1));
 
       Node replace = ref.getParent();
       replacement.copyInformationFromForTree(replace);
","@@ -328,6 +328,9 @@ private void replaceAssignmentExpression(Var v, Reference ref,
       }
 
       Node replacement;
+      if (nodes.isEmpty()) {
+        replacement = new Node(Token.TRUE);
+      } else {
         // All assignments evaluate to true, so make sure that the
         // expr statement evaluates to true in case it matters.
         nodes.add(new Node(Token.TRUE));
@@ -347,6 +350,7 @@ private void replaceAssignmentExpression(Var v, Reference ref,
         }
         cur.addChildToFront(nodes.get(i));
         cur.addChildToFront(nodes.get(i + 1));
+      }
 
       Node replace = ref.getParent();
       replacement.copyInformationFromForTree(replace);
"
78,"junit.framework.ComparisonFailure","/src/com/google/javascript/jscomp/CodeConsumer.java","@@ -238,7 +238,7 @@ void addNumber(double x) {
       add("" "");
     }
 
       long value = (long) x;
       long mantissa = value;
       int exp = 0;
","@@ -238,7 +238,7 @@ void addNumber(double x) {
       add("" "");
     }
 
+    if ((long) x == x && !isNegativeZero(x)) {
       long value = (long) x;
       long mantissa = value;
       int exp = 0;
"
79,"junit.framework.ComparisonFailure","/src/com/google/javascript/jscomp/CodeGenerator.java","@@ -742,7 +742,7 @@ static boolean isSimpleNumber(String s) {
         return false;
       }
     }
+    return len > 0 && s.charAt(0) != '0';
   }
 
   static double getSimpleNumber(String s) {
","@@ -742,7 +742,7 @@ static boolean isSimpleNumber(String s) {
         return false;
       }
     }
+    return len > 0 && s.charAt(0) != '0';
   }
 
   static double getSimpleNumber(String s) {
"
80,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/Compiler.java","@@ -252,7 +252,8 @@ public void initOptions(CompilerOptions options) {
           CheckLevel.OFF);
     }
 
+    if (options.checkGlobalThisLevel.isOn() &&
+        !options.disables(DiagnosticGroups.GLOBAL_THIS)) {
       options.setWarningLevel(
           DiagnosticGroups.GLOBAL_THIS,
           options.checkGlobalThisLevel);
","@@ -252,7 +252,8 @@ public void initOptions(CompilerOptions options) {
           CheckLevel.OFF);
     }
 
+    if (options.checkGlobalThisLevel.isOn() &&
+        !options.disables(DiagnosticGroups.GLOBAL_THIS)) {
       options.setWarningLevel(
           DiagnosticGroups.GLOBAL_THIS,
           options.checkGlobalThisLevel);
"
81,"java.lang.IllegalStateException","/src/com/google/javascript/jscomp/FunctionRewriter.java","@@ -114,7 +114,8 @@ public Node parseHelperCode(Reducer reducer) {
   }
 
   private static boolean isReduceableFunctionExpression(Node n) {
+    return NodeUtil.isFunctionExpression(n)
+        && !NodeUtil.isGetOrSetKey(n.getParent());
   }
 
   /**
","@@ -114,7 +114,8 @@ public Node parseHelperCode(Reducer reducer) {
   }
 
   private static boolean isReduceableFunctionExpression(Node n) {
+    return NodeUtil.isFunctionExpression(n)
+        && !NodeUtil.isGetOrSetKey(n.getParent());
   }
 
   /**
"
82,"junit.framework.ComparisonFailure","/src/com/google/javascript/jscomp/TypedScopeCreator.java","@@ -1410,7 +1410,13 @@ void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,
           // then they are responsible for making sure that the object literal's
           // implicit prototype is set up appropriately. We just obey
           // the @extends tag.
+          ObjectType qVarType = ObjectType.cast(qVar.getType());
+          if (qVarType != null &&
+              rhsValue != null &&
+              rhsValue.getType() == Token.OBJECTLIT) {
+            typeRegistry.resetImplicitPrototype(
+                rhsValue.getJSType(), qVarType.getImplicitPrototype());
+          } else if (!qVar.isTypeInferred()) {
             // If the programmer has declared that F inherits from Super,
             // and they assign F.prototype to some arbitrary expression,
             // there's not much we can do. We just ignore the expression,
/src/com/google/javascript/rhino/jstype/FunctionType.java @@ -338,7 +338,6 @@ public void setPrototypeBasedOn(ObjectType baseType) {
     //
     // In the second case, we just use the anonymous object as the prototype.
     if (baseType.hasReferenceName() ||
         isNativeObjectType() ||
         baseType.isFunctionPrototypeType() ||
         !(baseType instanceof PrototypeObjectType)) {
@@ -363,14 +362,18 @@ public boolean setPrototype(PrototypeObjectType prototype) {
       return false;
     }
 
+    PrototypeObjectType oldPrototype = this.prototype;
+    boolean replacedPrototype = oldPrototype != null;
 
     this.prototype = prototype;
     this.prototypeSlot = new SimpleSlot(""prototype"", prototype, true);
     this.prototype.setOwnerFunction(this);
 
+    if (oldPrototype != null) {
       // Disassociating the old prototype makes this easier to debug--
       // we don't have to worry about two prototypes running around.
+      oldPrototype.setOwnerFunction(null);
+    }
 
     if (isConstructor() || isInterface()) {
       FunctionType superClass = getSuperClassConstructor();
","@@ -1410,7 +1410,13 @@ void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,
           // then they are responsible for making sure that the object literal's
           // implicit prototype is set up appropriately. We just obey
           // the @extends tag.
+          ObjectType qVarType = ObjectType.cast(qVar.getType());
+          if (qVarType != null &&
+              rhsValue != null &&
+              rhsValue.getType() == Token.OBJECTLIT) {
+            typeRegistry.resetImplicitPrototype(
+                rhsValue.getJSType(), qVarType.getImplicitPrototype());
+          } else if (!qVar.isTypeInferred()) {
             // If the programmer has declared that F inherits from Super,
             // and they assign F.prototype to some arbitrary expression,
             // there's not much we can do. We just ignore the expression,
/src/com/google/javascript/rhino/jstype/FunctionType.java @@ -338,7 +338,6 @@ public void setPrototypeBasedOn(ObjectType baseType) {
     //
     // In the second case, we just use the anonymous object as the prototype.
     if (baseType.hasReferenceName() ||
         isNativeObjectType() ||
         baseType.isFunctionPrototypeType() ||
         !(baseType instanceof PrototypeObjectType)) {
@@ -363,14 +362,18 @@ public boolean setPrototype(PrototypeObjectType prototype) {
       return false;
     }
 
+    PrototypeObjectType oldPrototype = this.prototype;
+    boolean replacedPrototype = oldPrototype != null;
 
     this.prototype = prototype;
     this.prototypeSlot = new SimpleSlot(""prototype"", prototype, true);
     this.prototype.setOwnerFunction(this);
 
+    if (oldPrototype != null) {
       // Disassociating the old prototype makes this easier to debug--
       // we don't have to worry about two prototypes running around.
+      oldPrototype.setOwnerFunction(null);
+    }
 
     if (isConstructor() || isInterface()) {
       FunctionType superClass = getSuperClassConstructor();
"
83,"junit.framework.ComparisonFailure","/src/com/google/javascript/jscomp/SourceFile.java","@@ -239,7 +239,11 @@ public String getLine(int lineNumber) {
       // If next new line cannot be found, there are two cases
       // 1. pos already reaches the end of file, then null should be returned
       // 2. otherwise, return the contents between pos and the end of file.
+      if (pos >= js.length()) {
         return null;
+      } else {
+        return js.substring(pos, js.length());
+      }
     } else {
       return js.substring(pos, js.indexOf('\n', pos));
     }
","@@ -239,7 +239,11 @@ public String getLine(int lineNumber) {
       // If next new line cannot be found, there are two cases
       // 1. pos already reaches the end of file, then null should be returned
       // 2. otherwise, return the contents between pos and the end of file.
+      if (pos >= js.length()) {
         return null;
+      } else {
+        return js.substring(pos, js.length());
+      }
     } else {
       return js.substring(pos, js.indexOf('\n', pos));
     }
"
84,"java.lang.IllegalStateException","/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java","@@ -203,8 +203,12 @@ private void computeGenKill(Node n, BitSet gen, BitSet kill,
             // for(var x in y) {...}
             lhs = lhs.getLastChild();
           }
+          if (NodeUtil.isName(lhs)) {
             addToSetIfLocal(lhs, kill);
             addToSetIfLocal(lhs, gen);
+          } else {
+            computeGenKill(lhs, gen, kill, conditional);
+          }
           computeGenKill(rhs, gen, kill, conditional);
         }
         return;
","@@ -203,8 +203,12 @@ private void computeGenKill(Node n, BitSet gen, BitSet kill,
             // for(var x in y) {...}
             lhs = lhs.getLastChild();
           }
+          if (NodeUtil.isName(lhs)) {
             addToSetIfLocal(lhs, kill);
             addToSetIfLocal(lhs, gen);
+          } else {
+            computeGenKill(lhs, gen, kill, conditional);
+          }
           computeGenKill(rhs, gen, kill, conditional);
         }
         return;
"
85,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/ClosureCodingConvention.java","@@ -194,7 +194,7 @@ private static String extractClassNameIfGoog(Node node, Node parent,
         String qualifiedName = callee.getQualifiedName();
         if (functionName.equals(qualifiedName)) {
           Node target = callee.getNext();
+          if (target != null && target.getType() == Token.STRING) {
             className = target.getString();
           }
         }
","@@ -194,7 +194,7 @@ private static String extractClassNameIfGoog(Node node, Node parent,
         String qualifiedName = callee.getQualifiedName();
         if (functionName.equals(qualifiedName)) {
           Node target = callee.getNext();
+          if (target != null && target.getType() == Token.STRING) {
             className = target.getString();
           }
         }
"
86,"junit.framework.ComparisonFailure","/src/com/google/javascript/jscomp/LightweightMessageFormatter.java","@@ -95,7 +95,7 @@ private String format(JSError error, boolean warning) {
       // charno == sourceExpert.length() means something is missing
       // at the end of the line
       if (excerpt.equals(LINE)
+          && 0 <= charno && charno <= sourceExcerpt.length()) {
         for (int i = 0; i < charno; i++) {
           char c = sourceExcerpt.charAt(i);
           if (Character.isWhitespace(c)) {
","@@ -95,7 +95,7 @@ private String format(JSError error, boolean warning) {
       // charno == sourceExpert.length() means something is missing
       // at the end of the line
       if (excerpt.equals(LINE)
+          && 0 <= charno && charno <= sourceExcerpt.length()) {
         for (int i = 0; i < charno; i++) {
           char c = sourceExcerpt.charAt(i);
           if (Character.isWhitespace(c)) {
"
87,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/NodeUtil.java","@@ -105,6 +105,8 @@ static TernaryValue getImpureBooleanValue(Node n) {
         // ignoring side-effects
         return TernaryValue.TRUE;
 
+      case Token.VOID:
+        return TernaryValue.FALSE;
 
       default:
         return getPureBooleanValue(n);
@@ -133,7 +135,10 @@ static TernaryValue getPureBooleanValue(Node n) {
         return TernaryValue.FALSE;
 
       case Token.VOID:
+        if (!mayHaveSideEffects(n.getFirstChild())) {
           return TernaryValue.FALSE;
+        }
+        break;
 
       case Token.NAME:
         String name = n.getString();
","@@ -105,6 +105,8 @@ static TernaryValue getImpureBooleanValue(Node n) {
         // ignoring side-effects
         return TernaryValue.TRUE;
 
+      case Token.VOID:
+        return TernaryValue.FALSE;
 
       default:
         return getPureBooleanValue(n);
@@ -133,7 +135,10 @@ static TernaryValue getPureBooleanValue(Node n) {
         return TernaryValue.FALSE;
 
       case Token.VOID:
+        if (!mayHaveSideEffects(n.getFirstChild())) {
           return TernaryValue.FALSE;
+        }
+        break;
 
       case Token.NAME:
         String name = n.getString();
"
88,"junit.framework.ComparisonFailure","/src/com/google/javascript/jscomp/LightweightMessageFormatter.java","@@ -95,7 +95,7 @@ private String format(JSError error, boolean warning) {
       // charno == sourceExpert.length() means something is missing
       // at the end of the line
       if (excerpt.equals(LINE)
+          && 0 <= charno && charno <= sourceExcerpt.length()) {
         for (int i = 0; i < charno; i++) {
           char c = sourceExcerpt.charAt(i);
           if (Character.isWhitespace(c)) {
","@@ -95,7 +95,7 @@ private String format(JSError error, boolean warning) {
       // charno == sourceExpert.length() means something is missing
       // at the end of the line
       if (excerpt.equals(LINE)
+          && 0 <= charno && charno <= sourceExcerpt.length()) {
         for (int i = 0; i < charno; i++) {
           char c = sourceExcerpt.charAt(i);
           if (Character.isWhitespace(c)) {
"
89,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/NodeUtil.java","@@ -955,6 +955,12 @@ static boolean functionCallHasSideEffects(
       }
 
       // Functions in the ""Math"" namespace have no side effects.
+      if (nameNode.getFirstChild().getType() == Token.NAME) {
+        String namespaceName = nameNode.getFirstChild().getString();
+        if (namespaceName.equals(""Math"")) {
+          return false;
+        }
+      }
 
       if (compiler != null && !compiler.hasRegExpGlobalReferences()) {
         if (nameNode.getFirstChild().getType() == Token.REGEXP
","@@ -955,6 +955,12 @@ static boolean functionCallHasSideEffects(
       }
 
       // Functions in the ""Math"" namespace have no side effects.
+      if (nameNode.getFirstChild().getType() == Token.NAME) {
+        String namespaceName = nameNode.getFirstChild().getString();
+        if (namespaceName.equals(""Math"")) {
+          return false;
+        }
+      }
 
       if (compiler != null && !compiler.hasRegExpGlobalReferences()) {
         if (nameNode.getFirstChild().getType() == Token.REGEXP
"
90,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/Compiler.java","@@ -1429,7 +1429,7 @@ public Void call() throws Exception {
 
         // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'
         // for the first input file
+        String code = toSource(root, sourceMap, inputSeqNum == 0);
         if (!code.isEmpty()) {
           cb.append(code);
 
@@ -1458,19 +1458,19 @@ public Void call() throws Exception {
   @Override
   String toSource(Node n) {
     initCompilerOptionsIfTesting();
+    return toSource(n, null, true);
   }
 
   /**
    * Generates JavaScript source code for an AST.
    */
+  private String toSource(Node n, SourceMap sourceMap, boolean firstOutput) {
     CodePrinter.Builder builder = new CodePrinter.Builder(n);
     builder.setPrettyPrint(options.prettyPrint);
     builder.setLineBreak(options.lineBreak);
     builder.setSourceMap(sourceMap);
     builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);
+    builder.setTagAsStrict(firstOutput &&
         options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);
     builder.setLineLengthThreshold(options.lineLengthThreshold);
 
","@@ -1429,7 +1429,7 @@ public Void call() throws Exception {
 
         // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'
         // for the first input file
+        String code = toSource(root, sourceMap, inputSeqNum == 0);
         if (!code.isEmpty()) {
           cb.append(code);
 
@@ -1458,19 +1458,19 @@ public Void call() throws Exception {
   @Override
   String toSource(Node n) {
     initCompilerOptionsIfTesting();
+    return toSource(n, null, true);
   }
 
   /**
    * Generates JavaScript source code for an AST.
    */
+  private String toSource(Node n, SourceMap sourceMap, boolean firstOutput) {
     CodePrinter.Builder builder = new CodePrinter.Builder(n);
     builder.setPrettyPrint(options.prettyPrint);
     builder.setLineBreak(options.lineBreak);
     builder.setSourceMap(sourceMap);
     builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);
+    builder.setTagAsStrict(firstOutput &&
         options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);
     builder.setLineLengthThreshold(options.lineLengthThreshold);
 
"
91,"junit.framework.ComparisonFailure","/src/com/google/javascript/jscomp/CodeGenerator.java","@@ -1012,7 +1012,7 @@ static String strEscape(String s, char quote,
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       switch (c) {
+        case '\0': sb.append(""\\000""); break;
         case '\n': sb.append(""\\n""); break;
         case '\r': sb.append(""\\r""); break;
         case '\t': sb.append(""\\t""); break;
","@@ -1012,7 +1012,7 @@ static String strEscape(String s, char quote,
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       switch (c) {
+        case '\0': sb.append(""\\000""); break;
         case '\n': sb.append(""\\n""); break;
         case '\r': sb.append(""\\r""); break;
         case '\t': sb.append(""\\t""); break;
"
92,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/TypeCheck.java","@@ -513,7 +513,9 @@ public void visit(NodeTraversal t, Node n, Node parent) {
         // Object literal keys are handled with OBJECTLIT
         if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
           ensureTyped(t, n, STRING_TYPE);
+        } else {
           // Object literal keys are not typeable
+          typeable = false;
         }
         break;
 
","@@ -513,7 +513,9 @@ public void visit(NodeTraversal t, Node n, Node parent) {
         // Object literal keys are handled with OBJECTLIT
         if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
           ensureTyped(t, n, STRING_TYPE);
+        } else {
           // Object literal keys are not typeable
+          typeable = false;
         }
         break;
 
"
93,"junit.framework.ComparisonFailure","/src/com/google/javascript/jscomp/CodeGenerator.java","@@ -1042,7 +1042,7 @@ static String strEscape(String s, char quote,
             // No charsetEncoder provided - pass straight latin characters
             // through, and escape the rest.  Doing the explicit character
             // check is measurably faster than using the CharsetEncoder.
+            if (c > 0x1f && c < 0x7f) {
               sb.append(c);
             } else {
               // Other characters can be misinterpreted by some js parsers,
","@@ -1042,7 +1042,7 @@ static String strEscape(String s, char quote,
             // No charsetEncoder provided - pass straight latin characters
             // through, and escape the rest.  Doing the explicit character
             // check is measurably faster than using the CharsetEncoder.
+            if (c > 0x1f && c < 0x7f) {
               sb.append(c);
             } else {
               // Other characters can be misinterpreted by some js parsers,
"
94,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java","@@ -315,7 +315,7 @@ private boolean isPrototypePropertyAssign(Node assign) {
       Node n = assign.getFirstChild();
       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)
           && n.getType() == Token.GETPROP
+          && assign.getParent().getType() == Token.EXPR_RESULT) {
         // We want to exclude the assignment itself from the usage list
         boolean isChainedProperty =
             n.getFirstChild().getType() == Token.GETPROP;
","@@ -315,7 +315,7 @@ private boolean isPrototypePropertyAssign(Node assign) {
       Node n = assign.getFirstChild();
       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)
           && n.getType() == Token.GETPROP
+          && assign.getParent().getType() == Token.EXPR_RESULT) {
         // We want to exclude the assignment itself from the usage list
         boolean isChainedProperty =
             n.getFirstChild().getType() == Token.GETPROP;
"
95,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/PeepholeFoldConstants.java","@@ -904,8 +904,8 @@ private Node tryFoldComparison(Node n, Node left, Node right) {
           && right.getString().equals(""undefined""))
           || (Token.VOID == right.getType()
               && NodeUtil.isLiteralValue(right.getFirstChild(), false)));
+    int lhType = getNormalizedNodeType(left);
+    int rhType = getNormalizedNodeType(right);
     switch (lhType) {
       case Token.VOID:
         if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {
@@ -1071,6 +1071,19 @@ private Node tryFoldComparison(Node n, Node left, Node right) {
   /**
    * @return Translate NOT expressions into TRUE or FALSE when possible.
    */
+  private int getNormalizedNodeType(Node n) {
+    int type = n.getType();
+    if (type == Token.NOT) {
+      TernaryValue value = NodeUtil.getPureBooleanValue(n);
+      switch (value) {
+        case TRUE:
+          return Token.TRUE;
+        case FALSE:
+          return Token.FALSE;
+      }
+    }
+    return type;
+  }
 
   /**
    * The result of the comparison as a Boolean or null if the
","@@ -904,8 +904,8 @@ private Node tryFoldComparison(Node n, Node left, Node right) {
           && right.getString().equals(""undefined""))
           || (Token.VOID == right.getType()
               && NodeUtil.isLiteralValue(right.getFirstChild(), false)));
+    int lhType = getNormalizedNodeType(left);
+    int rhType = getNormalizedNodeType(right);
     switch (lhType) {
       case Token.VOID:
         if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {
@@ -1071,6 +1071,19 @@ private Node tryFoldComparison(Node n, Node left, Node right) {
   /**
    * @return Translate NOT expressions into TRUE or FALSE when possible.
    */
+  private int getNormalizedNodeType(Node n) {
+    int type = n.getType();
+    if (type == Token.NOT) {
+      TernaryValue value = NodeUtil.getPureBooleanValue(n);
+      switch (value) {
+        case TRUE:
+          return Token.TRUE;
+        case FALSE:
+          return Token.FALSE;
+      }
+    }
+    return type;
+  }
 
   /**
    * The result of the comparison as a Boolean or null if the
"
96,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/CheckAccessControls.java","@@ -413,7 +413,7 @@ private void checkPropertyVisibility(NodeTraversal t,
     if (objectType != null) {
       // Is this a normal property access, or are we trying to override
       // an existing property?
+      boolean isOverride = parent.getJSDocInfo() != null &&
           parent.getType() == Token.ASSIGN &&
           parent.getFirstChild() == getprop;
 
","@@ -413,7 +413,7 @@ private void checkPropertyVisibility(NodeTraversal t,
     if (objectType != null) {
       // Is this a normal property access, or are we trying to override
       // an existing property?
+      boolean isOverride = parent.getJSDocInfo() != null &&
           parent.getType() == Token.ASSIGN &&
           parent.getFirstChild() == getprop;
 
"
97,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java","@@ -865,9 +865,9 @@ boolean parse() {
                         }
                         break;
                     }
+                  }
 
                   token = eatTokensUntilEOL();
                   continue retry;
               }
             }
@@ -1706,6 +1706,7 @@ private Node parseBasicTypeExpression(JsDocToken token) {
       }
     }
 
+    restoreLookAhead(token);
     return reportGenericTypeSyntaxWarning();
   }
 
@@ -1758,6 +1759,7 @@ private Node parseFunctionType(JsDocToken token) {
     // NOTE(nicksantos): We're not implementing generics at the moment, so
     // just throw out TypeParameters.
     if (token != JsDocToken.LP) {
+      restoreLookAhead(token);
       return reportTypeSyntaxWarning(""msg.jsdoc.missing.lp"");
     }
 
","@@ -865,9 +865,9 @@ boolean parse() {
                         }
                         break;
                     }
+                  }
 
                   token = eatTokensUntilEOL();
                   continue retry;
               }
             }
@@ -1706,6 +1706,7 @@ private Node parseBasicTypeExpression(JsDocToken token) {
       }
     }
 
+    restoreLookAhead(token);
     return reportGenericTypeSyntaxWarning();
   }
 
@@ -1758,6 +1759,7 @@ private Node parseFunctionType(JsDocToken token) {
     // NOTE(nicksantos): We're not implementing generics at the moment, so
     // just throw out TypeParameters.
     if (token != JsDocToken.LP) {
+      restoreLookAhead(token);
       return reportTypeSyntaxWarning(""msg.jsdoc.missing.lp"");
     }
 
"
98,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/TypeCheck.java","@@ -1577,6 +1577,13 @@ private void visitCall(NodeTraversal t, Node n) {
 
       // Functions with explcit 'this' types must be called in a GETPROP
       // or GETELEM.
+      if (functionType.isOrdinaryFunction() &&
+          !functionType.getTypeOfThis().isUnknownType() &&
+          !functionType.getTypeOfThis().isNativeObjectType() &&
+          !(child.getType() == Token.GETELEM ||
+            child.getType() == Token.GETPROP)) {
+        report(t, n, EXPECTED_THIS_TYPE, functionType.toString());
+      }
 
       visitParameterList(t, n, functionType);
       ensureTyped(t, n, functionType.getReturnType());
","@@ -1577,6 +1577,13 @@ private void visitCall(NodeTraversal t, Node n) {
 
       // Functions with explcit 'this' types must be called in a GETPROP
       // or GETELEM.
+      if (functionType.isOrdinaryFunction() &&
+          !functionType.getTypeOfThis().isUnknownType() &&
+          !functionType.getTypeOfThis().isNativeObjectType() &&
+          !(child.getType() == Token.GETELEM ||
+            child.getType() == Token.GETPROP)) {
+        report(t, n, EXPECTED_THIS_TYPE, functionType.toString());
+      }
 
       visitParameterList(t, n, functionType);
       ensureTyped(t, n, functionType.getReturnType());
"
99,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/TypedScopeCreator.java","@@ -1742,7 +1742,7 @@ private void declareArguments(Node functionNode) {
           for (Node astParameter : astParameters.children()) {
             if (jsDocParameter != null) {
               defineSlot(astParameter, functionNode,
+                  jsDocParameter.getJSType(), false);
               jsDocParameter = jsDocParameter.getNext();
             } else {
               defineSlot(astParameter, functionNode, null, true);
","@@ -1742,7 +1742,7 @@ private void declareArguments(Node functionNode) {
           for (Node astParameter : astParameters.children()) {
             if (jsDocParameter != null) {
               defineSlot(astParameter, functionNode,
+                  jsDocParameter.getJSType(), false);
               jsDocParameter = jsDocParameter.getNext();
             } else {
               defineSlot(astParameter, functionNode, null, true);
"
100,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/FunctionToBlockMutator.java","@@ -149,6 +149,8 @@ private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {
                 ""inline_"",
                 isCallInLoop)));
     // Make label names unique to this instance.
+    new RenameLabels(compiler, new LabelNameSupplier(idSupplier), false)
+        .process(null, fnNode);
   }
 
   static class LabelNameSupplier implements Supplier<String> {
/src/com/google/javascript/jscomp/RenameLabels.java @@ -212,7 +212,7 @@ private void visitLabel(Node node, Node parent) {
       String name = nameNode.getString();
       LabelInfo li = getLabelInfo(name);
       // This is a label...
+      if (li.referenced || !removeUnused) {
         String newName = getNameForId(li.id);
         if (!name.equals(newName)) {
           // ... and it is used, give it the short name.
","@@ -149,6 +149,8 @@ private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {
                 ""inline_"",
                 isCallInLoop)));
     // Make label names unique to this instance.
+    new RenameLabels(compiler, new LabelNameSupplier(idSupplier), false)
+        .process(null, fnNode);
   }
 
   static class LabelNameSupplier implements Supplier<String> {
/src/com/google/javascript/jscomp/RenameLabels.java @@ -212,7 +212,7 @@ private void visitLabel(Node node, Node parent) {
       String name = nameNode.getString();
       LabelInfo li = getLabelInfo(name);
       // This is a label...
+      if (li.referenced || !removeUnused) {
         String newName = getNameForId(li.id);
         if (!name.equals(newName)) {
           // ... and it is used, give it the short name.
"
101,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java","@@ -297,26 +297,40 @@ private boolean isVariableStillLiveWithinExpression(
           // If the currently node is the first child of
           // AND/OR, be conservative only consider the READs
           // of the second operand.
+          if (n.getNext() != null) {
+            state = isVariableReadBeforeKill(
+                n.getNext(), variable);
+            if (state == VariableLiveness.KILL) {
+              state = VariableLiveness.MAYBE_LIVE;
+            }
+          }
+          break;
 
         case Token.HOOK:
           // If current node is the condition, check each following
           // branch, otherwise it is a conditional branch and the
           // other branch can be ignored.
+          if (n.getNext() != null && n.getNext().getNext() != null) {
+            state = checkHookBranchReadBeforeKill(
+                n.getNext(), n.getNext().getNext(), variable);
+          }
+          break;
 
         default:
           for(Node sibling = n.getNext(); sibling != null;
               sibling = sibling.getNext()) {
             state = isVariableReadBeforeKill(sibling, variable);
+            if (state != VariableLiveness.MAYBE_LIVE) {
+              break;
+            }
+          }
+      }
 
       // If we see a READ or KILL there is no need to continue.
       if (state == VariableLiveness.READ) {
         return true;
       } else if (state == VariableLiveness.KILL) {
         return false;
       }
       n = n.getParent();
     }
@@ -337,6 +351,9 @@ private boolean isVariableStillLiveWithinExpression(
    */
   private VariableLiveness isVariableReadBeforeKill(
       Node n, String variable) {
+    if (ControlFlowGraph.isEnteringNewCfgNode(n)) { // Not a FUNCTION
+      return VariableLiveness.MAYBE_LIVE;
+    }
 
     if (NodeUtil.isName(n) && variable.equals(n.getString())) {
       if (NodeUtil.isLhs(n, n.getParent())) {
@@ -359,9 +376,25 @@ private VariableLiveness isVariableReadBeforeKill(
       // Conditionals
       case Token.OR:
       case Token.AND:
+        VariableLiveness v1 = isVariableReadBeforeKill(
+          n.getFirstChild(), variable);
+        VariableLiveness v2 = isVariableReadBeforeKill(
+          n.getLastChild(), variable);
         // With a AND/OR the first branch always runs, but the second is
         // may not.
+        if (v1 != VariableLiveness.MAYBE_LIVE) {
+          return v1;
+        } else if (v2 == VariableLiveness.READ) {
+          return VariableLiveness.READ;
+        } else {
+          return VariableLiveness.MAYBE_LIVE;
+        }
       case Token.HOOK:
+        VariableLiveness first = isVariableReadBeforeKill(
+            n.getFirstChild(), variable);
+        if (first != VariableLiveness.MAYBE_LIVE) {
+          return first;
+        }
         return checkHookBranchReadBeforeKill(
             n.getFirstChild().getNext(), n.getLastChild(), variable);
 
@@ -369,13 +402,11 @@ private VariableLiveness isVariableReadBeforeKill(
         // Expressions are evaluated left-right, depth first.
         for (Node child = n.getFirstChild();
             child != null; child = child.getNext()) {
           VariableLiveness state = isVariableReadBeforeKill(child, variable);
           if (state != VariableLiveness.MAYBE_LIVE) {
             return state;
           }
         }
     }
 
     return VariableLiveness.MAYBE_LIVE;
","@@ -297,26 +297,40 @@ private boolean isVariableStillLiveWithinExpression(
           // If the currently node is the first child of
           // AND/OR, be conservative only consider the READs
           // of the second operand.
+          if (n.getNext() != null) {
+            state = isVariableReadBeforeKill(
+                n.getNext(), variable);
+            if (state == VariableLiveness.KILL) {
+              state = VariableLiveness.MAYBE_LIVE;
+            }
+          }
+          break;
 
         case Token.HOOK:
           // If current node is the condition, check each following
           // branch, otherwise it is a conditional branch and the
           // other branch can be ignored.
+          if (n.getNext() != null && n.getNext().getNext() != null) {
+            state = checkHookBranchReadBeforeKill(
+                n.getNext(), n.getNext().getNext(), variable);
+          }
+          break;
 
         default:
           for(Node sibling = n.getNext(); sibling != null;
               sibling = sibling.getNext()) {
             state = isVariableReadBeforeKill(sibling, variable);
+            if (state != VariableLiveness.MAYBE_LIVE) {
+              break;
+            }
+          }
+      }
 
       // If we see a READ or KILL there is no need to continue.
       if (state == VariableLiveness.READ) {
         return true;
       } else if (state == VariableLiveness.KILL) {
         return false;
       }
       n = n.getParent();
     }
@@ -337,6 +351,9 @@ private boolean isVariableStillLiveWithinExpression(
    */
   private VariableLiveness isVariableReadBeforeKill(
       Node n, String variable) {
+    if (ControlFlowGraph.isEnteringNewCfgNode(n)) { // Not a FUNCTION
+      return VariableLiveness.MAYBE_LIVE;
+    }
 
     if (NodeUtil.isName(n) && variable.equals(n.getString())) {
       if (NodeUtil.isLhs(n, n.getParent())) {
@@ -359,9 +376,25 @@ private VariableLiveness isVariableReadBeforeKill(
       // Conditionals
       case Token.OR:
       case Token.AND:
+        VariableLiveness v1 = isVariableReadBeforeKill(
+          n.getFirstChild(), variable);
+        VariableLiveness v2 = isVariableReadBeforeKill(
+          n.getLastChild(), variable);
         // With a AND/OR the first branch always runs, but the second is
         // may not.
+        if (v1 != VariableLiveness.MAYBE_LIVE) {
+          return v1;
+        } else if (v2 == VariableLiveness.READ) {
+          return VariableLiveness.READ;
+        } else {
+          return VariableLiveness.MAYBE_LIVE;
+        }
       case Token.HOOK:
+        VariableLiveness first = isVariableReadBeforeKill(
+            n.getFirstChild(), variable);
+        if (first != VariableLiveness.MAYBE_LIVE) {
+          return first;
+        }
         return checkHookBranchReadBeforeKill(
             n.getFirstChild().getNext(), n.getLastChild(), variable);
 
@@ -369,13 +402,11 @@ private VariableLiveness isVariableReadBeforeKill(
         // Expressions are evaluated left-right, depth first.
         for (Node child = n.getFirstChild();
             child != null; child = child.getNext()) {
           VariableLiveness state = isVariableReadBeforeKill(child, variable);
           if (state != VariableLiveness.MAYBE_LIVE) {
             return state;
           }
         }
     }
 
     return VariableLiveness.MAYBE_LIVE;
"
102,"java.lang.RuntimeException","/src/com/google/javascript/jscomp/Normalize.java","@@ -119,7 +119,7 @@ private void reportCodeChange(String changeDescription) {
   public void process(Node externs, Node root) {
     new NodeTraversal(
         compiler, new NormalizeStatements(compiler, assertOnChange))
+        .traverseRoots(externs, root);
     if (MAKE_LOCAL_NAMES_UNIQUE) {
       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
       NodeTraversal t = new NodeTraversal(compiler, renamer);
/src/com/google/javascript/jscomp/VarCheck.java @@ -218,6 +218,7 @@ private void createSynthesizedExternVar(String varName) {
     getSynthesizedExternsRoot().addChildToBack(
         new Node(Token.VAR, nameNode));
     varsToDeclareInExterns.remove(varName);
+    compiler.reportCodeChange();
   }
 
   /**
","@@ -119,7 +119,7 @@ private void reportCodeChange(String changeDescription) {
   public void process(Node externs, Node root) {
     new NodeTraversal(
         compiler, new NormalizeStatements(compiler, assertOnChange))
+        .traverseRoots(externs, root);
     if (MAKE_LOCAL_NAMES_UNIQUE) {
       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
       NodeTraversal t = new NodeTraversal(compiler, renamer);
/src/com/google/javascript/jscomp/VarCheck.java @@ -218,6 +218,7 @@ private void createSynthesizedExternVar(String varName) {
     getSynthesizedExternsRoot().addChildToBack(
         new Node(Token.VAR, nameNode));
     varsToDeclareInExterns.remove(varName);
+    compiler.reportCodeChange();
   }
 
   /**
"
103,"junit.framework.ComparisonFailure","/src/com/google/javascript/jscomp/CodeGenerator.java","@@ -963,6 +963,7 @@ static String strEscape(String s, char quote,
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       switch (c) {
+        case '\0': sb.append(""\\0""); break;
         case '\n': sb.append(""\\n""); break;
         case '\r': sb.append(""\\r""); break;
         case '\t': sb.append(""\\t""); break;
","@@ -963,6 +963,7 @@ static String strEscape(String s, char quote,
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       switch (c) {
+        case '\0': sb.append(""\\0""); break;
         case '\n': sb.append(""\\n""); break;
         case '\r': sb.append(""\\r""); break;
         case '\t': sb.append(""\\t""); break;
"
104,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/NodeUtil.java","@@ -310,7 +310,10 @@ static Double getNumberValue(Node n) {
   }
 
   static Double getStringNumberValue(String rawJsString) {
+    if (rawJsString.contains(""\u000b"")) {
       // vertical tab is not always whitespace
+      return null;
+    }
 
     String s = trimJsWhiteSpace(rawJsString);
     // return ScriptRuntime.toNumber(s);
@@ -372,7 +375,7 @@ static String trimJsWhiteSpace(String s) {
   static TernaryValue isStrWhiteSpaceChar(int c) {
     switch (c) {
       case '\u000B': // <VT>
+        return TernaryValue.UNKNOWN;  // IE says ""no"", EcmaScript says ""yes""
       case ' ': // <SP>
       case '\n': // <LF>
       case '\r': // <CR>
","@@ -310,7 +310,10 @@ static Double getNumberValue(Node n) {
   }
 
   static Double getStringNumberValue(String rawJsString) {
+    if (rawJsString.contains(""\u000b"")) {
       // vertical tab is not always whitespace
+      return null;
+    }
 
     String s = trimJsWhiteSpace(rawJsString);
     // return ScriptRuntime.toNumber(s);
@@ -372,7 +375,7 @@ static String trimJsWhiteSpace(String s) {
   static TernaryValue isStrWhiteSpaceChar(int c) {
     switch (c) {
       case '\u000B': // <VT>
+        return TernaryValue.UNKNOWN;  // IE says ""no"", EcmaScript says ""yes""
       case ' ': // <SP>
       case '\n': // <LF>
       case '\r': // <CR>
"
105,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/PeepholeFoldConstants.java","@@ -708,14 +708,12 @@ private Node performArithmeticOp(int opType, Node left, Node right) {
         break;
       case Token.MOD:
         if (rval == 0) {
           return null;
         }
         result = lval % rval;
         break;
       case Token.DIV:
         if (rval == 0) {
           return null;
         }
         result = lval / rval;
","@@ -708,14 +708,12 @@ private Node performArithmeticOp(int opType, Node left, Node right) {
         break;
       case Token.MOD:
         if (rval == 0) {
           return null;
         }
         result = lval % rval;
         break;
       case Token.DIV:
         if (rval == 0) {
           return null;
         }
         result = lval / rval;
"
106,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/CommandLineRunner.java","@@ -331,7 +331,10 @@ public BooleanOptionHandler(
 
       @Override
       public int parseArguments(Parameters params) throws CmdLineException {
+        String param = null;
+        try {
+          param = params.getParameter(0);
+        } catch (CmdLineException e) {}
 
         if (param == null) {
           setter.addValue(true);
","@@ -331,7 +331,10 @@ public BooleanOptionHandler(
 
       @Override
       public int parseArguments(Parameters params) throws CmdLineException {
+        String param = null;
+        try {
+          param = params.getParameter(0);
+        } catch (CmdLineException e) {}
 
         if (param == null) {
           setter.addValue(true);
"
107,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/NodeUtil.java","@@ -1259,6 +1259,7 @@ static boolean isBooleanResultHelper(Node n) {
       // Inversion
       case Token.NOT:
       // delete operator returns a boolean.
+      case Token.DELPROP:
         return true;
       default:
         return false;
@@ -2907,6 +2908,7 @@ static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
       case Token.OBJECTLIT:
         // Literals objects with non-literal children are allowed.
         return true;
+      case Token.DELPROP:
       case Token.IN:
         // TODO(johnlenz): should IN operator be included in #isSimpleOperator?
         return true;
","@@ -1259,6 +1259,7 @@ static boolean isBooleanResultHelper(Node n) {
       // Inversion
       case Token.NOT:
       // delete operator returns a boolean.
+      case Token.DELPROP:
         return true;
       default:
         return false;
@@ -2907,6 +2908,7 @@ static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
       case Token.OBJECTLIT:
         // Literals objects with non-literal children are allowed.
         return true;
+      case Token.DELPROP:
       case Token.IN:
         // TODO(johnlenz): should IN operator be included in #isSimpleOperator?
         return true;
"
108,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/parsing/IRFactory.java","@@ -514,6 +514,13 @@ Node processFunctionNode(FunctionNode functionNode) {
       Name name = functionNode.getFunctionName();
       Boolean isUnnamedFunction = false;
       if (name == null) {
+        int functionType = functionNode.getFunctionType();
+        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {
+          errorReporter.error(
+            ""unnamed function statement"",
+            sourceName,
+            functionNode.getLineno(), """", 0);
+        }
         name = new Name();
         name.setIdentifier("""");
         isUnnamedFunction = true;
","@@ -514,6 +514,13 @@ Node processFunctionNode(FunctionNode functionNode) {
       Name name = functionNode.getFunctionName();
       Boolean isUnnamedFunction = false;
       if (name == null) {
+        int functionType = functionNode.getFunctionType();
+        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {
+          errorReporter.error(
+            ""unnamed function statement"",
+            sourceName,
+            functionNode.getLineno(), """", 0);
+        }
         name = new Name();
         name.setIdentifier("""");
         isUnnamedFunction = true;
"
109,"junit.framework.AssertionFailedError","/src/com/google/javascript/rhino/jstype/JSType.java","@@ -160,7 +160,9 @@ public boolean isNoObjectType() {
   }
 
   public final boolean isEmptyType() {
+    return isNoType() || isNoObjectType() || isNoResolvedType() ||
+        (registry.getNativeFunctionType(
+             JSTypeNative.LEAST_FUNCTION_TYPE) == this);
   }
 
   public boolean isNumberObjectType() {
","@@ -160,7 +160,9 @@ public boolean isNoObjectType() {
   }
 
   public final boolean isEmptyType() {
+    return isNoType() || isNoObjectType() || isNoResolvedType() ||
+        (registry.getNativeFunctionType(
+             JSTypeNative.LEAST_FUNCTION_TYPE) == this);
   }
 
   public boolean isNumberObjectType() {
"
110,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/UnreachableCodeElimination.java","@@ -150,20 +150,7 @@ private Node tryRemoveUnconditionalBranching(Node n) {
       return n;
     }
 
     switch (n.getType()) {
       case Token.RETURN:
         if (n.hasChildren()) {
           break;
@@ -180,7 +167,7 @@ private Node tryRemoveUnconditionalBranching(Node n) {
             (n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) {
 
           Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);
+          Node fallThrough = computeFollowing(n);
           Node nextCfgNode = outEdges.get(0).getDestination().getValue();
           if (nextCfgNode == fallThrough) {
             removeDeadExprStatementSafely(n);
@@ -193,6 +180,13 @@ private Node tryRemoveUnconditionalBranching(Node n) {
 
   private Node computeFollowing(Node n) {
     Node next = ControlFlowAnalysis.computeFollowNode(n);
+    while (next != null && next.getType() == Token.BLOCK) {
+      if (next.hasChildren()) {
+        next = next.getFirstChild();
+      } else {
+        next = computeFollowing(next);
+      }
+    }
     return next;
   }
 
","@@ -150,20 +150,7 @@ private Node tryRemoveUnconditionalBranching(Node n) {
       return n;
     }
 
     switch (n.getType()) {
       case Token.RETURN:
         if (n.hasChildren()) {
           break;
@@ -180,7 +167,7 @@ private Node tryRemoveUnconditionalBranching(Node n) {
             (n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) {
 
           Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);
+          Node fallThrough = computeFollowing(n);
           Node nextCfgNode = outEdges.get(0).getDestination().getValue();
           if (nextCfgNode == fallThrough) {
             removeDeadExprStatementSafely(n);
@@ -193,6 +180,13 @@ private Node tryRemoveUnconditionalBranching(Node n) {
 
   private Node computeFollowing(Node n) {
     Node next = ControlFlowAnalysis.computeFollowNode(n);
+    while (next != null && next.getType() == Token.BLOCK) {
+      if (next.hasChildren()) {
+        next = next.getFirstChild();
+      } else {
+        next = computeFollowing(next);
+      }
+    }
     return next;
   }
 
"
111,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/NodeUtil.java","@@ -2462,7 +2462,7 @@ static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
         // TODO(nicksantos): This needs to be changed so that it
         // returns true iff we're sure the value was never aliased from inside
         // the constructor (similar to callHasLocalResult)
+        return false;
       case Token.FUNCTION:
       case Token.REGEXP:
       case Token.ARRAYLIT:
","@@ -2462,7 +2462,7 @@ static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
         // TODO(nicksantos): This needs to be changed so that it
         // returns true iff we're sure the value was never aliased from inside
         // the constructor (similar to callHasLocalResult)
+        return false;
       case Token.FUNCTION:
       case Token.REGEXP:
       case Token.ARRAYLIT:
"
112,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/parsing/IRFactory.java","@@ -338,6 +338,13 @@ Node processArrayLiteral(ArrayLiteral literalNode) {
     @Override
     Node processAssignment(Assignment assignmentNode) {
       Node assign = processInfixExpression(assignmentNode);
+      Node target = assign.getFirstChild();
+      if (!validAssignmentTarget(target)) {
+        errorReporter.error(
+          ""invalid assignment target"",
+          sourceName,
+          target.getLineno(), """", 0);
+      }
       return assign;
     }
 
@@ -794,6 +801,17 @@ Node processUnaryExpression(UnaryExpression exprNode) {
         operand.setDouble(-operand.getDouble());
         return operand;
       } else {
+        if (type == Token.INC || type == Token.DEC) {
+          if (!validAssignmentTarget(operand)) {
+            String msg = (type == Token.INC)
+                ? ""invalid increment target""
+                : ""invalid decrement target"";
+            errorReporter.error(
+              msg,
+              sourceName,
+              operand.getLineno(), """", 0);
+          }
+        }
 
         Node node = newNode(type, operand);
         if (exprNode.isPostfix()) {
@@ -803,6 +821,15 @@ Node processUnaryExpression(UnaryExpression exprNode) {
       }
     }
 
+    private boolean validAssignmentTarget(Node target) {
+      switch (target.getType()) {
+        case Token.NAME:
+        case Token.GETPROP:
+        case Token.GETELEM:
+          return true;
+      }
+      return false;
+    }
 
     @Override
     Node processVariableDeclaration(VariableDeclaration declarationNode) {
","@@ -338,6 +338,13 @@ Node processArrayLiteral(ArrayLiteral literalNode) {
     @Override
     Node processAssignment(Assignment assignmentNode) {
       Node assign = processInfixExpression(assignmentNode);
+      Node target = assign.getFirstChild();
+      if (!validAssignmentTarget(target)) {
+        errorReporter.error(
+          ""invalid assignment target"",
+          sourceName,
+          target.getLineno(), """", 0);
+      }
       return assign;
     }
 
@@ -794,6 +801,17 @@ Node processUnaryExpression(UnaryExpression exprNode) {
         operand.setDouble(-operand.getDouble());
         return operand;
       } else {
+        if (type == Token.INC || type == Token.DEC) {
+          if (!validAssignmentTarget(operand)) {
+            String msg = (type == Token.INC)
+                ? ""invalid increment target""
+                : ""invalid decrement target"";
+            errorReporter.error(
+              msg,
+              sourceName,
+              operand.getLineno(), """", 0);
+          }
+        }
 
         Node node = newNode(type, operand);
         if (exprNode.isPostfix()) {
@@ -803,6 +821,15 @@ Node processUnaryExpression(UnaryExpression exprNode) {
       }
     }
 
+    private boolean validAssignmentTarget(Node target) {
+      switch (target.getType()) {
+        case Token.NAME:
+        case Token.GETPROP:
+        case Token.GETELEM:
+          return true;
+      }
+      return false;
+    }
 
     @Override
     Node processVariableDeclaration(VariableDeclaration declarationNode) {
"
113,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/CollapseProperties.java","@@ -481,6 +481,9 @@ private void updateSimpleDeclaration(String alias, Name refName, Ref ref) {
     Node greatGramps = gramps.getParent();
     Node greatGreatGramps = greatGramps.getParent();
 
+    if (rvalue != null && rvalue.getType() == Token.FUNCTION) {
+      checkForHosedThisReferences(rvalue, refName.docInfo, refName);
+    }
 
     // Create the new alias node.
     Node nameNode = NodeUtil.newName(
/src/com/google/javascript/jscomp/GlobalNamespace.java @@ -917,7 +917,7 @@ boolean canCollapseUnannotatedChildNames() {
       }
 
       // If this is aliased, then its properties can't be collapsed either.
+      if (aliasingGets > 0) {
         return false;
       }
 
","@@ -481,6 +481,9 @@ private void updateSimpleDeclaration(String alias, Name refName, Ref ref) {
     Node greatGramps = gramps.getParent();
     Node greatGreatGramps = greatGramps.getParent();
 
+    if (rvalue != null && rvalue.getType() == Token.FUNCTION) {
+      checkForHosedThisReferences(rvalue, refName.docInfo, refName);
+    }
 
     // Create the new alias node.
     Node nameNode = NodeUtil.newName(
/src/com/google/javascript/jscomp/GlobalNamespace.java @@ -917,7 +917,7 @@ boolean canCollapseUnannotatedChildNames() {
       }
 
       // If this is aliased, then its properties can't be collapsed either.
+      if (aliasingGets > 0) {
         return false;
       }
 
"
114,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java","@@ -324,9 +324,15 @@ private VariableLiveness isVariableReadBeforeKill(
       Node n, String variable) {
     if (NodeUtil.isName(n) && variable.equals(n.getString())) {
       if (NodeUtil.isLhs(n, n.getParent())) {
+        Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);
         // The expression to which the assignment is made is evaluated before
         // the RHS is evaluated (normal left to right evaluation) but the KILL
         // occurs after the RHS is evaluated.
+        Node rhs = n.getNext();
+        VariableLiveness state = isVariableReadBeforeKill(rhs, variable);
+        if (state == VariableLiveness.READ) {
+          return state;
+        }
         return VariableLiveness.KILL;
       } else {
         return VariableLiveness.READ;
","@@ -324,9 +324,15 @@ private VariableLiveness isVariableReadBeforeKill(
       Node n, String variable) {
     if (NodeUtil.isName(n) && variable.equals(n.getString())) {
       if (NodeUtil.isLhs(n, n.getParent())) {
+        Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);
         // The expression to which the assignment is made is evaluated before
         // the RHS is evaluated (normal left to right evaluation) but the KILL
         // occurs after the RHS is evaluated.
+        Node rhs = n.getNext();
+        VariableLiveness state = isVariableReadBeforeKill(rhs, variable);
+        if (state == VariableLiveness.READ) {
+          return state;
+        }
         return VariableLiveness.KILL;
       } else {
         return VariableLiveness.READ;
"
115,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java","@@ -520,17 +520,29 @@ private boolean isFoldableExpressBlock(Node n) {
     if (n.getType() == Token.BLOCK) {
       if (n.hasOneChild()) {
         Node maybeExpr = n.getFirstChild();
+        if (maybeExpr.getType() == Token.EXPR_RESULT) {
           // IE has a bug where event handlers behave differently when
           // their return value is used vs. when their return value is in
           // an EXPR_RESULT. It's pretty freaking weird. See:
           // http://code.google.com/p/closure-compiler/issues/detail?id=291
           // We try to detect this case, and not fold EXPR_RESULTs
           // into other expressions.
+          if (maybeExpr.getFirstChild().getType() == Token.CALL) {
+            Node calledFn = maybeExpr.getFirstChild().getFirstChild();
 
             // We only have to worry about methods with an implicit 'this'
             // param, or this doesn't happen.
+            if (calledFn.getType() == Token.GETELEM) {
+              return false;
+            } else if (calledFn.getType() == Token.GETPROP &&
+                       calledFn.getLastChild().getString().startsWith(""on"")) {
+              return false;
+            }
+          }
 
+          return true;
+        }
+        return false;
       }
     }
 
","@@ -520,17 +520,29 @@ private boolean isFoldableExpressBlock(Node n) {
     if (n.getType() == Token.BLOCK) {
       if (n.hasOneChild()) {
         Node maybeExpr = n.getFirstChild();
+        if (maybeExpr.getType() == Token.EXPR_RESULT) {
           // IE has a bug where event handlers behave differently when
           // their return value is used vs. when their return value is in
           // an EXPR_RESULT. It's pretty freaking weird. See:
           // http://code.google.com/p/closure-compiler/issues/detail?id=291
           // We try to detect this case, and not fold EXPR_RESULTs
           // into other expressions.
+          if (maybeExpr.getFirstChild().getType() == Token.CALL) {
+            Node calledFn = maybeExpr.getFirstChild().getFirstChild();
 
             // We only have to worry about methods with an implicit 'this'
             // param, or this doesn't happen.
+            if (calledFn.getType() == Token.GETELEM) {
+              return false;
+            } else if (calledFn.getType() == Token.GETPROP &&
+                       calledFn.getLastChild().getString().startsWith(""on"")) {
+              return false;
+            }
+          }
 
+          return true;
+        }
+        return false;
       }
     }
 
"
116,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java","@@ -786,7 +786,7 @@ void replace() {
         } else {
           // In this case, the name was implicitly provided by two independent
           // modules. We need to move this code up to a common module.
+          int indexOfDot = namespace.lastIndexOf('.');
           if (indexOfDot == -1) {
             // Any old place is fine.
             compiler.getNodeForCodeInsertion(minimumModule)
","@@ -786,7 +786,7 @@ void replace() {
         } else {
           // In this case, the name was implicitly provided by two independent
           // modules. We need to move this code up to a common module.
+          int indexOfDot = namespace.lastIndexOf('.');
           if (indexOfDot == -1) {
             // Any old place is fine.
             compiler.getNodeForCodeInsertion(minimumModule)
"
117,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/TypedScopeCreator.java","@@ -896,9 +896,16 @@ void defineSlot(Node n, Node parent, JSType type, boolean inferred) {
       // scope where the root object appears. This helps out people
       // who declare ""global"" names in an anonymous namespace.
       Scope scopeToDeclareIn = scope;
+      if (n.getType() == Token.GETPROP && !scope.isGlobal() &&
+          isQnameRootedInGlobalScope(n)) {
+        Scope globalScope = scope.getGlobalScope();
 
         // don't try to declare in the global scope if there's
         // already a symbol there with this name.
+        if (!globalScope.isDeclared(variableName, false)) {
+          scopeToDeclareIn = scope.getGlobalScope();
+        }
+      }
 
       // declared in closest scope?
       if (scopeToDeclareIn.isDeclared(variableName, false)) {
","@@ -896,9 +896,16 @@ void defineSlot(Node n, Node parent, JSType type, boolean inferred) {
       // scope where the root object appears. This helps out people
       // who declare ""global"" names in an anonymous namespace.
       Scope scopeToDeclareIn = scope;
+      if (n.getType() == Token.GETPROP && !scope.isGlobal() &&
+          isQnameRootedInGlobalScope(n)) {
+        Scope globalScope = scope.getGlobalScope();
 
         // don't try to declare in the global scope if there's
         // already a symbol there with this name.
+        if (!globalScope.isDeclared(variableName, false)) {
+          scopeToDeclareIn = scope.getGlobalScope();
+        }
+      }
 
       // declared in closest scope?
       if (scopeToDeclareIn.isDeclared(variableName, false)) {
"
118,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/FunctionTypeBuilder.java","@@ -181,7 +181,7 @@ public boolean apply(JSType type) {
       // create interfaces JSType, ObjectType, FunctionType etc and have
       // separate implementation instead of the class hierarchy, so that
       // union types can also be object types, etc.
+      if (!type.restrictByNotNullOrUndefined().isSubtype(
               typeRegistry.getNativeType(OBJECT_TYPE))) {
         reportWarning(THIS_TYPE_NON_OBJECT, type.toString());
         return false;
/src/com/google/javascript/rhino/jstype/FunctionType.java @@ -877,6 +877,9 @@ JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {
     // mean ""nullable Foo"". For certain tags (like @extends) we de-nullify
     // the name for them.
     JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);
+    if (maybeTypeOfThis != null) {
+      maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined();
+    }
     if (maybeTypeOfThis instanceof ObjectType) {
       typeOfThis = (ObjectType) maybeTypeOfThis;
     }
","@@ -181,7 +181,7 @@ public boolean apply(JSType type) {
       // create interfaces JSType, ObjectType, FunctionType etc and have
       // separate implementation instead of the class hierarchy, so that
       // union types can also be object types, etc.
+      if (!type.restrictByNotNullOrUndefined().isSubtype(
               typeRegistry.getNativeType(OBJECT_TYPE))) {
         reportWarning(THIS_TYPE_NON_OBJECT, type.toString());
         return false;
/src/com/google/javascript/rhino/jstype/FunctionType.java @@ -877,6 +877,9 @@ JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {
     // mean ""nullable Foo"". For certain tags (like @extends) we de-nullify
     // the name for them.
     JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);
+    if (maybeTypeOfThis != null) {
+      maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined();
+    }
     if (maybeTypeOfThis instanceof ObjectType) {
       typeOfThis = (ObjectType) maybeTypeOfThis;
     }
"
119,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/NodeUtil.java","@@ -326,14 +326,33 @@ static boolean isValidDefineValue(Node val, Set<String> defines) {
         return true;
 
       // Binary operators are only valid if both children are valid.
+      case Token.ADD:
       case Token.BITAND:
       case Token.BITNOT:
       case Token.BITOR:
       case Token.BITXOR:
+      case Token.DIV:
+      case Token.EQ:
+      case Token.GE:
+      case Token.GT:
+      case Token.LE:
+      case Token.LSH:
+      case Token.LT:
+      case Token.MOD:
+      case Token.MUL:
+      case Token.NE:
+      case Token.RSH:
+      case Token.SHEQ:
+      case Token.SHNE:
+      case Token.SUB:
+      case Token.URSH:
+        return isValidDefineValue(val.getFirstChild(), defines)
+            && isValidDefineValue(val.getLastChild(), defines);
 
       // Uniary operators are valid if the child is valid.
       case Token.NOT:
       case Token.NEG:
+      case Token.POS:
         return isValidDefineValue(val.getFirstChild(), defines);
 
       // Names are valid if and only if they are defines themselves.
","@@ -326,14 +326,33 @@ static boolean isValidDefineValue(Node val, Set<String> defines) {
         return true;
 
       // Binary operators are only valid if both children are valid.
+      case Token.ADD:
       case Token.BITAND:
       case Token.BITNOT:
       case Token.BITOR:
       case Token.BITXOR:
+      case Token.DIV:
+      case Token.EQ:
+      case Token.GE:
+      case Token.GT:
+      case Token.LE:
+      case Token.LSH:
+      case Token.LT:
+      case Token.MOD:
+      case Token.MUL:
+      case Token.NE:
+      case Token.RSH:
+      case Token.SHEQ:
+      case Token.SHNE:
+      case Token.SUB:
+      case Token.URSH:
+        return isValidDefineValue(val.getFirstChild(), defines)
+            && isValidDefineValue(val.getLastChild(), defines);
 
       // Uniary operators are valid if the child is valid.
       case Token.NOT:
       case Token.NEG:
+      case Token.POS:
         return isValidDefineValue(val.getFirstChild(), defines);
 
       // Names are valid if and only if they are defines themselves.
"
120,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/CheckGlobalThis.java","@@ -112,6 +112,15 @@ public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
       }
 
       // Don't traverse functions that are getting lent to a prototype.
+      Node gramps = parent.getParent();
+      if (NodeUtil.isObjectLitKey(parent, gramps)) {
+        JSDocInfo maybeLends = gramps.getJSDocInfo();
+        if (maybeLends != null &&
+            maybeLends.getLendsName() != null &&
+            maybeLends.getLendsName().endsWith("".prototype"")) {
+          return false;
+        }
+      }
     }
 
     if (parent != null && parent.getType() == Token.ASSIGN) {
","@@ -112,6 +112,15 @@ public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
       }
 
       // Don't traverse functions that are getting lent to a prototype.
+      Node gramps = parent.getParent();
+      if (NodeUtil.isObjectLitKey(parent, gramps)) {
+        JSDocInfo maybeLends = gramps.getJSDocInfo();
+        if (maybeLends != null &&
+            maybeLends.getLendsName() != null &&
+            maybeLends.getLendsName().endsWith("".prototype"")) {
+          return false;
+        }
+      }
     }
 
     if (parent != null && parent.getType() == Token.ASSIGN) {
"
121,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java","@@ -786,7 +786,7 @@ void replace() {
         } else {
           // In this case, the name was implicitly provided by two independent
           // modules. We need to move this code up to a common module.
+          int indexOfDot = namespace.lastIndexOf('.');
           if (indexOfDot == -1) {
             // Any old place is fine.
             compiler.getNodeForCodeInsertion(minimumModule)
","@@ -786,7 +786,7 @@ void replace() {
         } else {
           // In this case, the name was implicitly provided by two independent
           // modules. We need to move this code up to a common module.
+          int indexOfDot = namespace.lastIndexOf('.');
           if (indexOfDot == -1) {
             // Any old place is fine.
             compiler.getNodeForCodeInsertion(minimumModule)
"
122,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/PeepholeFoldConstants.java","@@ -695,7 +695,8 @@ private Node tryFoldShift(Node n, Node left, Node right) {
           // JavaScript handles zero shifts on signed numbers differently than
           // Java as an Java int can not represent the unsigned 32-bit number
           // where JavaScript can so use a long here.
+          long lvalLong = lvalInt & 0xffffffffL;
+          result = lvalLong >>> rvalInt;
           break;
         default:
           throw new AssertionError(""Unknown shift operator: "" +
","@@ -695,7 +695,8 @@ private Node tryFoldShift(Node n, Node left, Node right) {
           // JavaScript handles zero shifts on signed numbers differently than
           // Java as an Java int can not represent the unsigned 32-bit number
           // where JavaScript can so use a long here.
+          long lvalLong = lvalInt & 0xffffffffL;
+          result = lvalLong >>> rvalInt;
           break;
         default:
           throw new AssertionError(""Unknown shift operator: "" +
"
123,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/TypeCheck.java","@@ -1406,10 +1406,13 @@ private void visitParameterList(NodeTraversal t, Node call,
     Node parameter = null;
     Node argument = null;
     while (arguments.hasNext() &&
+           (parameters.hasNext() ||
+            parameter != null && parameter.isVarArgs())) {
       // If there are no parameters left in the list, then the while loop
       // above implies that this must be a var_args function.
+      if (parameters.hasNext()) {
         parameter = parameters.next();
+      }
       argument = arguments.next();
       ordinal++;
 
","@@ -1406,10 +1406,13 @@ private void visitParameterList(NodeTraversal t, Node call,
     Node parameter = null;
     Node argument = null;
     while (arguments.hasNext() &&
+           (parameters.hasNext() ||
+            parameter != null && parameter.isVarArgs())) {
       // If there are no parameters left in the list, then the while loop
       // above implies that this must be a var_args function.
+      if (parameters.hasNext()) {
         parameter = parameters.next();
+      }
       argument = arguments.next();
       ordinal++;
 
"
124,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/CommandLineRunner.java","@@ -430,10 +430,8 @@ protected CompilerOptions createOptions() {
     for (FormattingOption formattingOption : flags.formatting) {
       formattingOption.applyToOptions(options);
     }
 
+    options.closurePass = flags.process_closure_primitives;
     initOptionsFromFlags(options);
     return options;
   }
","@@ -430,10 +430,8 @@ protected CompilerOptions createOptions() {
     for (FormattingOption formattingOption : flags.formatting) {
       formattingOption.applyToOptions(options);
     }
 
+    options.closurePass = flags.process_closure_primitives;
     initOptionsFromFlags(options);
     return options;
   }
"
125,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/CheckGlobalThis.java","@@ -96,6 +96,13 @@ public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
       // var a = function() { }; // or
       // function a() {} // or
       // a.x = function() {};
+      int pType = parent.getType();
+      if (!(pType == Token.BLOCK ||
+            pType == Token.SCRIPT ||
+            pType == Token.NAME ||
+            pType == Token.ASSIGN)) {
+        return false;
+      }
     }
 
     if (parent != null && parent.getType() == Token.ASSIGN) {
@@ -143,7 +150,7 @@ private boolean shouldReportThis(Node n, Node parent) {
     }
 
     // Also report a THIS with a property access.
+    return parent != null && NodeUtil.isGet(parent);
   }
 
   /**
","@@ -96,6 +96,13 @@ public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
       // var a = function() { }; // or
       // function a() {} // or
       // a.x = function() {};
+      int pType = parent.getType();
+      if (!(pType == Token.BLOCK ||
+            pType == Token.SCRIPT ||
+            pType == Token.NAME ||
+            pType == Token.ASSIGN)) {
+        return false;
+      }
     }
 
     if (parent != null && parent.getType() == Token.ASSIGN) {
@@ -143,7 +150,7 @@ private boolean shouldReportThis(Node n, Node parent) {
     }
 
     // Also report a THIS with a property access.
+    return parent != null && NodeUtil.isGet(parent);
   }
 
   /**
"
126,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java","@@ -354,15 +354,23 @@ Reference getInitializingReferenceForConstants() {
     boolean isAssignedOnceInLifetime() {
       Reference ref = getOneAndOnlyAssignment();
       if (ref == null) {
         return false;
       }
 
       // Make sure this assignment is not in a loop.
+      for (BasicBlock block = ref.getBasicBlock();
+           block != null; block = block.getParent()) {
+        if (block.isFunction) {
+          break;
+        } else if (block.isLoop) {
+          return false;
+        }
+      }
 
       return true;
     }
 
     /**
      * @return The one and only assignment. Returns if there are 0 or 2+
      *    assignments.
      */
@@ -523,41 +531,52 @@ Scope getScope() {
     public String getSourceName() {
       return sourceName;
     }
   }
 
   /**
    * Represents a section of code that is uninterrupted by control structures
    * (conditional or iterative logic).
    */
   static final class BasicBlock {
 
     private final BasicBlock parent;
 
     /**
      * Determines whether the block may not be part of the normal control flow,
      * but instead ""hoisted"" to the top of the scope.
      */
     private final boolean isHoisted;
 
     /**
      * Whether this block denotes a function scope.
      */
+    private final boolean isFunction;
 
     /**
      * Whether this block denotes a loop.
      */
+    private final boolean isLoop;
 
     /**
      * Creates a new block.
      * @param parent The containing block.
      * @param root The root node of the block.
      */
     BasicBlock(BasicBlock parent, Node root) {
       this.parent = parent;
 
       // only named functions may be hoisted.
       this.isHoisted = NodeUtil.isHoistedFunctionDeclaration(root);
 
+      this.isFunction = root.getType() == Token.FUNCTION;
 
+      if (root.getParent() != null) {
+        int pType = root.getParent().getType();
+        this.isLoop = pType == Token.DO ||
+            pType == Token.WHILE ||
+            pType == Token.FOR;
+      } else {
+        this.isLoop = false;
+      }
     }
 
","@@ -354,15 +354,23 @@ Reference getInitializingReferenceForConstants() {
     boolean isAssignedOnceInLifetime() {
       Reference ref = getOneAndOnlyAssignment();
       if (ref == null) {
         return false;
       }
 
       // Make sure this assignment is not in a loop.
+      for (BasicBlock block = ref.getBasicBlock();
+           block != null; block = block.getParent()) {
+        if (block.isFunction) {
+          break;
+        } else if (block.isLoop) {
+          return false;
+        }
+      }
 
       return true;
     }
 
     /**
      * @return The one and only assignment. Returns if there are 0 or 2+
      *    assignments.
      */
@@ -523,41 +531,52 @@ Scope getScope() {
     public String getSourceName() {
       return sourceName;
     }
   }
 
   /**
    * Represents a section of code that is uninterrupted by control structures
    * (conditional or iterative logic).
    */
   static final class BasicBlock {
 
     private final BasicBlock parent;
 
     /**
      * Determines whether the block may not be part of the normal control flow,
      * but instead ""hoisted"" to the top of the scope.
      */
     private final boolean isHoisted;
 
     /**
      * Whether this block denotes a function scope.
      */
+    private final boolean isFunction;
 
     /**
      * Whether this block denotes a loop.
      */
+    private final boolean isLoop;
 
     /**
      * Creates a new block.
      * @param parent The containing block.
      * @param root The root node of the block.
      */
     BasicBlock(BasicBlock parent, Node root) {
       this.parent = parent;
 
       // only named functions may be hoisted.
       this.isHoisted = NodeUtil.isHoistedFunctionDeclaration(root);
 
+      this.isFunction = root.getType() == Token.FUNCTION;
 
+      if (root.getParent() != null) {
+        int pType = root.getParent().getType();
+        this.isLoop = pType == Token.DO ||
+            pType == Token.WHILE ||
+            pType == Token.FOR;
+      } else {
+        this.isLoop = false;
+      }
     }
 
"
127,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/CheckGlobalThis.java","@@ -89,6 +89,7 @@ public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
       JSDocInfo jsDoc = getFunctionJsDocInfo(n);
       if (jsDoc != null &&
           (jsDoc.isConstructor() ||
+           jsDoc.isInterface() ||
            jsDoc.hasThisType() ||
            jsDoc.isOverride())) {
         return false;
@@ -122,13 +123,17 @@ public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
       } else {
         // Only traverse the right side if it's not an assignment to a prototype
         // property or subproperty.
+        if (NodeUtil.isGet(lhs)) {
           if (lhs.getType() == Token.GETPROP &&
               lhs.getLastChild().getString().equals(""prototype"")) {
             return false;
           }
+          Node llhs = lhs.getFirstChild();
+          if (llhs.getType() == Token.GETPROP &&
+              llhs.getLastChild().getString().equals(""prototype"")) {
             return false;
           }
+        }
       }
     }
 
","@@ -89,6 +89,7 @@ public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
       JSDocInfo jsDoc = getFunctionJsDocInfo(n);
       if (jsDoc != null &&
           (jsDoc.isConstructor() ||
+           jsDoc.isInterface() ||
            jsDoc.hasThisType() ||
            jsDoc.isOverride())) {
         return false;
@@ -122,13 +123,17 @@ public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
       } else {
         // Only traverse the right side if it's not an assignment to a prototype
         // property or subproperty.
+        if (NodeUtil.isGet(lhs)) {
           if (lhs.getType() == Token.GETPROP &&
               lhs.getLastChild().getString().equals(""prototype"")) {
             return false;
           }
+          Node llhs = lhs.getFirstChild();
+          if (llhs.getType() == Token.GETPROP &&
+              llhs.getLastChild().getString().equals(""prototype"")) {
             return false;
           }
+        }
       }
     }
 
"
128,"junit.framework.AssertionFailedError","/src/com/google/javascript/rhino/jstype/UnionType.java","@@ -288,7 +288,7 @@ JSType meet(JSType that) {
       builder.addAlternate(that);
     }
     JSType result = builder.build();
+    if (!result.isNoType()) {
       return result;
     } else if (this.isObject() && that.isObject()) {
       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);
","@@ -288,7 +288,7 @@ JSType meet(JSType that) {
       builder.addAlternate(that);
     }
     JSType result = builder.build();
+    if (!result.isNoType()) {
       return result;
     } else if (this.isObject() && that.isObject()) {
       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);
"
129,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/FoldConstants.java","@@ -1474,22 +1474,24 @@ void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,
 
     String joinString = NodeUtil.getStringValue(right);
     List<Node> arrayFoldedChildren = Lists.newLinkedList();
+    StringBuilder sb = null;
     int foldedSize = 0;
     Node elem = arrayNode.getFirstChild();
     // Merges adjacent String nodes.
     while (elem != null) {
       if (NodeUtil.isImmutableValue(elem)) {
+        if (sb == null) {
+          sb = new StringBuilder();
+        } else {
           sb.append(joinString);
         }
         sb.append(NodeUtil.getStringValue(elem));
       } else {
+        if (sb != null) {
           // + 2 for the quotes.
           foldedSize += sb.length() + 2;
           arrayFoldedChildren.add(Node.newString(sb.toString()));
+          sb = null;
         }
         foldedSize += InlineCostEstimator.getCost(elem);
         arrayFoldedChildren.add(elem);
@@ -1497,7 +1499,7 @@ void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,
       elem = elem.getNext();
     }
 
+    if (sb != null) {
       // + 2 for the quotes.
       foldedSize += sb.length() + 2;
       arrayFoldedChildren.add(Node.newString(sb.toString()));
","@@ -1474,22 +1474,24 @@ void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,
 
     String joinString = NodeUtil.getStringValue(right);
     List<Node> arrayFoldedChildren = Lists.newLinkedList();
+    StringBuilder sb = null;
     int foldedSize = 0;
     Node elem = arrayNode.getFirstChild();
     // Merges adjacent String nodes.
     while (elem != null) {
       if (NodeUtil.isImmutableValue(elem)) {
+        if (sb == null) {
+          sb = new StringBuilder();
+        } else {
           sb.append(joinString);
         }
         sb.append(NodeUtil.getStringValue(elem));
       } else {
+        if (sb != null) {
           // + 2 for the quotes.
           foldedSize += sb.length() + 2;
           arrayFoldedChildren.add(Node.newString(sb.toString()));
+          sb = null;
         }
         foldedSize += InlineCostEstimator.getCost(elem);
         arrayFoldedChildren.add(elem);
@@ -1497,7 +1499,7 @@ void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,
       elem = elem.getNext();
     }
 
+    if (sb != null) {
       // + 2 for the quotes.
       foldedSize += sb.length() + 2;
       arrayFoldedChildren.add(Node.newString(sb.toString()));
"
130,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/GlobalNamespace.java","@@ -904,6 +904,10 @@ boolean canCollapseUnannotatedChildNames() {
       // Don't try to collapse if the one global set is a twin reference.
       // We could theoretically handle this case in CollapseProperties, but
       // it's probably not worth the effort.
+      Preconditions.checkNotNull(declaration);
+      if (declaration.getTwin() != null) {
+        return false;
+      }
 
       if (isClassOrEnum) {
         return true;
/src/com/google/javascript/rhino/JSDocInfoBuilder.java @@ -186,9 +186,7 @@ public void markName(String name, int lineno, int charno) {
    * @return {@code true} if the description was recorded.
    */
   public boolean recordBlockDescription(String description) {
     populated = true;
     return currentInfo.documentBlock(description);
   }
 
","@@ -904,6 +904,10 @@ boolean canCollapseUnannotatedChildNames() {
       // Don't try to collapse if the one global set is a twin reference.
       // We could theoretically handle this case in CollapseProperties, but
       // it's probably not worth the effort.
+      Preconditions.checkNotNull(declaration);
+      if (declaration.getTwin() != null) {
+        return false;
+      }
 
       if (isClassOrEnum) {
         return true;
/src/com/google/javascript/rhino/JSDocInfoBuilder.java @@ -186,9 +186,7 @@ public void markName(String name, int lineno, int charno) {
    * @return {@code true} if the description was recorded.
    */
   public boolean recordBlockDescription(String description) {
     populated = true;
     return currentInfo.documentBlock(description);
   }
 
"
131,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/Normalize.java","@@ -86,12 +86,12 @@ private void reportCodeChange(String changeDescription) {
   @Override
   public void process(Node externs, Node root) {
     NodeTraversal.traverse(compiler, root, this);
+    removeDuplicateDeclarations(root);
     if (MAKE_LOCAL_NAMES_UNIQUE) {
       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
       NodeTraversal t = new NodeTraversal(compiler, renamer);
       t.traverseRoots(externs, root);
     }
     new PropogateConstantAnnotations(compiler, assertOnChange)
         .process(externs, root);
   }
","@@ -86,12 +86,12 @@ private void reportCodeChange(String changeDescription) {
   @Override
   public void process(Node externs, Node root) {
     NodeTraversal.traverse(compiler, root, this);
+    removeDuplicateDeclarations(root);
     if (MAKE_LOCAL_NAMES_UNIQUE) {
       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
       NodeTraversal t = new NodeTraversal(compiler, renamer);
       t.traverseRoots(externs, root);
     }
     new PropogateConstantAnnotations(compiler, assertOnChange)
         .process(externs, root);
   }
"
132,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/ControlFlowAnalysis.java","@@ -891,6 +891,7 @@ private static boolean mayThrowException(Node n) {
       case Token.ASSIGN:
       case Token.INC:
       case Token.DEC:
+      case Token.INSTANCEOF:
         return true;
       case Token.FUNCTION:
         return false;
/src/com/google/javascript/jscomp/DisambiguateProperties.java @@ -760,9 +760,16 @@ public JSTypeSystem(AbstractCompiler compiler) {
       }
       // If the property does not exist on the referenced type but the original
       // type is an object type, see if any subtype has the property.
+      if (foundType == null) {
+        ObjectType maybeType = ObjectType.cast(
+            registry.getGreatestSubtypeWithProperty(type, field));
         // getGreatestSubtypeWithProperty does not guarantee that the property
         // is defined on the returned type, it just indicates that it might be,
         // so we have to double check.
+        if (maybeType != null && maybeType.hasOwnProperty(field)) {
+          foundType = maybeType;
+        }
+      }
       return foundType;
     }
 
","@@ -891,6 +891,7 @@ private static boolean mayThrowException(Node n) {
       case Token.ASSIGN:
       case Token.INC:
       case Token.DEC:
+      case Token.INSTANCEOF:
         return true;
       case Token.FUNCTION:
         return false;
/src/com/google/javascript/jscomp/DisambiguateProperties.java @@ -760,9 +760,16 @@ public JSTypeSystem(AbstractCompiler compiler) {
       }
       // If the property does not exist on the referenced type but the original
       // type is an object type, see if any subtype has the property.
+      if (foundType == null) {
+        ObjectType maybeType = ObjectType.cast(
+            registry.getGreatestSubtypeWithProperty(type, field));
         // getGreatestSubtypeWithProperty does not guarantee that the property
         // is defined on the returned type, it just indicates that it might be,
         // so we have to double check.
+        if (maybeType != null && maybeType.hasOwnProperty(field)) {
+          foundType = maybeType;
+        }
+      }
       return foundType;
     }
 
"
133,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/CommandLineRunner.java","@@ -859,6 +859,7 @@ protected CompilerOptions createOptions() {
       // so we might as well inline it. But shut off the i18n warnings,
       // because the user didn't really ask for i18n.
       options.messageBundle = new EmptyMessageBundle();
+      options.setWarningLevel(JsMessageVisitor.MSG_CONVENTIONS, CheckLevel.OFF);
     }
 
     return options;
","@@ -859,6 +859,7 @@ protected CompilerOptions createOptions() {
       // so we might as well inline it. But shut off the i18n warnings,
       // because the user didn't really ask for i18n.
       options.messageBundle = new EmptyMessageBundle();
+      options.setWarningLevel(JsMessageVisitor.MSG_CONVENTIONS, CheckLevel.OFF);
     }
 
     return options;
"
134,"java.lang.IllegalStateException","/src/com/google/javascript/jscomp/ScopedAliases.java","@@ -256,6 +256,7 @@ public void applyAlias() {
     private final Map<String, Var> aliases = Maps.newHashMap();
 
     // Also temporary and cleared for each scope.
+    private final Set<Node> injectedDecls = Sets.newHashSet();
 
     // Suppose you create an alias.
     // var x = goog.x;
@@ -313,6 +314,7 @@ public void exitScope(NodeTraversal t) {
 
       if (t.getScopeDepth() == 2) {
         renameNamespaceShadows(t);
+        injectedDecls.clear();
         aliases.clear();
         forbiddenLocals.clear();
         transformation = null;
@@ -429,6 +431,7 @@ private void findAliases(NodeTraversal t) {
             } else {
               grandparent.addChildBefore(newDecl, varNode);
             }
+            injectedDecls.add(newDecl.getFirstChild());
           }
 
           // Rewrite ""var name = EXPR;"" to ""var name = $jscomp.scope.name;""
@@ -578,7 +581,7 @@ public void visit(NodeTraversal t, Node n, Node parent) {
         // When we inject declarations, we duplicate jsdoc. Make sure
         // we only process that jsdoc once.
         JSDocInfo info = n.getJSDocInfo();
+        if (info != null && !injectedDecls.contains(n)) {
           for (Node node : info.getTypeNodes()) {
             fixTypeNode(node);
           }
","@@ -256,6 +256,7 @@ public void applyAlias() {
     private final Map<String, Var> aliases = Maps.newHashMap();
 
     // Also temporary and cleared for each scope.
+    private final Set<Node> injectedDecls = Sets.newHashSet();
 
     // Suppose you create an alias.
     // var x = goog.x;
@@ -313,6 +314,7 @@ public void exitScope(NodeTraversal t) {
 
       if (t.getScopeDepth() == 2) {
         renameNamespaceShadows(t);
+        injectedDecls.clear();
         aliases.clear();
         forbiddenLocals.clear();
         transformation = null;
@@ -429,6 +431,7 @@ private void findAliases(NodeTraversal t) {
             } else {
               grandparent.addChildBefore(newDecl, varNode);
             }
+            injectedDecls.add(newDecl.getFirstChild());
           }
 
           // Rewrite ""var name = EXPR;"" to ""var name = $jscomp.scope.name;""
@@ -578,7 +581,7 @@ public void visit(NodeTraversal t, Node n, Node parent) {
         // When we inject declarations, we duplicate jsdoc. Make sure
         // we only process that jsdoc once.
         JSDocInfo info = n.getJSDocInfo();
+        if (info != null && !injectedDecls.contains(n)) {
           for (Node node : info.getTypeNodes()) {
             fixTypeNode(node);
           }
"
135,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java","@@ -1905,7 +1905,11 @@ private Node parseTypeExpression(JsDocToken token) {
    * For expressions on the right hand side of a this: or new:
    */
   private Node parseContextTypeExpression(JsDocToken token) {
+    if (token == JsDocToken.QMARK) {
+      return newNode(Token.QMARK);
+    } else {
+      return parseBasicTypeExpression(token);
+    }
   }
 
   /**
","@@ -1905,7 +1905,11 @@ private Node parseTypeExpression(JsDocToken token) {
    * For expressions on the right hand side of a this: or new:
    */
   private Node parseContextTypeExpression(JsDocToken token) {
+    if (token == JsDocToken.QMARK) {
+      return newNode(Token.QMARK);
+    } else {
+      return parseBasicTypeExpression(token);
+    }
   }
 
   /**
"
136,"junit.framework.ComparisonFailure","/src/com/google/javascript/jscomp/TypeValidator.java","@@ -722,8 +722,20 @@ private String formatFoundRequired(String description, JSType found,
    *     to an Object type, if possible.
    */
   String getReadableJSTypeName(Node n, boolean dereference) {
+    JSType type = getJSType(n);
+    if (dereference) {
+      ObjectType dereferenced = type.dereference();
+      if (dereferenced != null) {
+        type = dereferenced;
+      }
+    }
 
     // The best type name is the actual type name.
+    if (type.isFunctionPrototypeType() ||
+        (type.toObjectType() != null &&
+         type.toObjectType().getConstructor() != null)) {
+      return type.toString();
+    }
 
     // If we're analyzing a GETPROP, the property may be inherited by the
     // prototype chain. So climb the prototype chain and find out where
@@ -753,18 +765,6 @@ String getReadableJSTypeName(Node n, boolean dereference) {
       }
     }
 
     String qualifiedName = n.getQualifiedName();
     if (qualifiedName != null) {
       return qualifiedName;
","@@ -722,8 +722,20 @@ private String formatFoundRequired(String description, JSType found,
    *     to an Object type, if possible.
    */
   String getReadableJSTypeName(Node n, boolean dereference) {
+    JSType type = getJSType(n);
+    if (dereference) {
+      ObjectType dereferenced = type.dereference();
+      if (dereferenced != null) {
+        type = dereferenced;
+      }
+    }
 
     // The best type name is the actual type name.
+    if (type.isFunctionPrototypeType() ||
+        (type.toObjectType() != null &&
+         type.toObjectType().getConstructor() != null)) {
+      return type.toString();
+    }
 
     // If we're analyzing a GETPROP, the property may be inherited by the
     // prototype chain. So climb the prototype chain and find out where
@@ -753,18 +765,6 @@ String getReadableJSTypeName(Node n, boolean dereference) {
       }
     }
 
     String qualifiedName = n.getQualifiedName();
     if (qualifiedName != null) {
       return qualifiedName;
"
137,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/TypeInference.java","@@ -1189,9 +1189,15 @@ private boolean inferTemplatedTypesForCall(
     }
 
     // Try to infer the template types
-
+    Map<TemplateType, JSType> inferred = Maps.filterKeys(
+        inferTemplateTypesFromParameters(fnType, n),
+        new Predicate<TemplateType>() {
+
+          @Override
+          public boolean apply(TemplateType key) {
+            return keys.contains(key);
+          }}
+        );
 
     // Replace all template types. If we couldn't find a replacement, we
     // replace it with UNKNOWN.
","@@ -1189,9 +1189,15 @@ private boolean inferTemplatedTypesForCall(
     }
 
     // Try to infer the template types
-
+    Map<TemplateType, JSType> inferred = Maps.filterKeys(
+        inferTemplateTypesFromParameters(fnType, n),
+        new Predicate<TemplateType>() {
+
+          @Override
+          public boolean apply(TemplateType key) {
+            return keys.contains(key);
+          }}
+        );
 
     // Replace all template types. If we couldn't find a replacement, we
     // replace it with UNKNOWN.
"
138,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/NameAnalyzer.java","@@ -575,7 +575,7 @@ private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {
           } else {
             recordDepScope(nameNode, ns);
           }
+        } else if (!(parent.isCall() && parent.getFirstChild() == n)) {
           // The rhs of the assignment is the caller, so it's used by the
           // context. Don't associate it w/ the lhs.
           // FYI: this fixes only the specific case where the assignment is the
","@@ -575,7 +575,7 @@ private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {
           } else {
             recordDepScope(nameNode, ns);
           }
+        } else if (!(parent.isCall() && parent.getFirstChild() == n)) {
           // The rhs of the assignment is the caller, so it's used by the
           // context. Don't associate it w/ the lhs.
           // FYI: this fixes only the specific case where the assignment is the
"
139,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java","@@ -326,7 +326,7 @@ private void processRequireCall(NodeTraversal t, Node n, Node parent) {
       // the checks for broken requires turned off. In these cases, we
       // allow broken requires to be preserved by the first run to
       // let them be caught in the subsequent run.
+      if (provided != null || requiresLevel.isOn()) {
         parent.detachFromParent();
         compiler.reportCodeChange();
       }
","@@ -326,7 +326,7 @@ private void processRequireCall(NodeTraversal t, Node n, Node parent) {
       // the checks for broken requires turned off. In these cases, we
       // allow broken requires to be preserved by the first run to
       // let them be caught in the subsequent run.
+      if (provided != null || requiresLevel.isOn()) {
         parent.detachFromParent();
         compiler.reportCodeChange();
       }
"
140,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/FunctionInjector.java","@@ -694,14 +694,6 @@ private CanInlineResult canInlineReferenceDirectly(
 
     Node block = fnNode.getLastChild();
 
     // CALL NODE: [ NAME, ARG1, ARG2, ... ]
     Node cArg = callNode.getFirstChild().getNext();
 
@@ -727,9 +719,6 @@ private CanInlineResult canInlineReferenceDirectly(
       // For each named parameter check if a mutable argument use more than one.
       if (fnParam != null) {
         if (cArg != null) {
           // Check for arguments that are evaluated more than once.
           // Note: Unlike block inlining, there it is not possible that a
           // parameter reference will be in a loop.
","@@ -694,14 +694,6 @@ private CanInlineResult canInlineReferenceDirectly(
 
     Node block = fnNode.getLastChild();
 
     // CALL NODE: [ NAME, ARG1, ARG2, ... ]
     Node cArg = callNode.getFirstChild().getNext();
 
@@ -727,9 +719,6 @@ private CanInlineResult canInlineReferenceDirectly(
       // For each named parameter check if a mutable argument use more than one.
       if (fnParam != null) {
         if (cArg != null) {
           // Check for arguments that are evaluated more than once.
           // Note: Unlike block inlining, there it is not possible that a
           // parameter reference will be in a loop.
"
141,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/FunctionInjector.java","@@ -694,6 +694,15 @@ private CanInlineResult canInlineReferenceDirectly(
 
     Node block = fnNode.getLastChild();
 
+    boolean hasSideEffects = false;  // empty function case
+    if (block.hasChildren()) {
+      Preconditions.checkState(block.hasOneChild());
+      Node stmt = block.getFirstChild();
+      if (stmt.isReturn()) {
+        hasSideEffects = NodeUtil.mayHaveSideEffects(
+            stmt.getFirstChild(), compiler);
+      }
+    }
 
     // CALL NODE: [ NAME, ARG1, ARG2, ... ]
     Node cArg = callNode.getFirstChild().getNext();
@@ -720,6 +729,9 @@ private CanInlineResult canInlineReferenceDirectly(
       // For each named parameter check if a mutable argument use more than one.
       if (fnParam != null) {
         if (cArg != null) {
+          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {
+            return CanInlineResult.NO;
+          }
 
           // Check for arguments that are evaluated more than once.
           // Note: Unlike block inlining, there it is not possible that a
","@@ -694,6 +694,15 @@ private CanInlineResult canInlineReferenceDirectly(
 
     Node block = fnNode.getLastChild();
 
+    boolean hasSideEffects = false;  // empty function case
+    if (block.hasChildren()) {
+      Preconditions.checkState(block.hasOneChild());
+      Node stmt = block.getFirstChild();
+      if (stmt.isReturn()) {
+        hasSideEffects = NodeUtil.mayHaveSideEffects(
+            stmt.getFirstChild(), compiler);
+      }
+    }
 
     // CALL NODE: [ NAME, ARG1, ARG2, ... ]
     Node cArg = callNode.getFirstChild().getNext();
@@ -720,6 +729,9 @@ private CanInlineResult canInlineReferenceDirectly(
       // For each named parameter check if a mutable argument use more than one.
       if (fnParam != null) {
         if (cArg != null) {
+          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {
+            return CanInlineResult.NO;
+          }
 
           // Check for arguments that are evaluated more than once.
           // Note: Unlike block inlining, there it is not possible that a
"
142,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java","@@ -51,7 +51,8 @@
       new RestrictByTrueTypeOfResultVisitor() {
         @Override
         protected JSType caseTopType(JSType topType) {
+          return topType.isAllType() ?
+              getNativeType(ARRAY_TYPE) : topType;
         }
 
         @Override
","@@ -51,7 +51,8 @@
       new RestrictByTrueTypeOfResultVisitor() {
         @Override
         protected JSType caseTopType(JSType topType) {
+          return topType.isAllType() ?
+              getNativeType(ARRAY_TYPE) : topType;
         }
 
         @Override
"
143,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/ScopedAliases.java","@@ -355,6 +355,7 @@ private void findAliases(NodeTraversal t) {
         Node n = v.getNode();
         Node parent = n.getParent();
         boolean isVar = parent.isVar();
+        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);
         if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {
           recordAlias(v);
         } else if (v.isBleedingFunction()) {
@@ -363,12 +364,13 @@ private void findAliases(NodeTraversal t) {
         } else if (parent.getType() == Token.LP) {
           // Parameters of the scope function also get a BAD_PARAMETERS
           // error.
+        } else if (isVar || isFunctionDecl) {
+          boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);
           Node grandparent = parent.getParent();
+          Node value = v.getInitialValue() != null ?
+              v.getInitialValue() :
               null;
+          Node varNode = null;
 
           String name = n.getString();
           int nameCount = scopedAliasNames.count(name);
@@ -380,7 +382,9 @@ private void findAliases(NodeTraversal t) {
 
           // First, we need to free up the function expression (EXPR)
           // to be used in another expression.
+          if (isFunctionDecl) {
             // Replace ""function NAME() { ... }"" with ""var NAME;"".
+            Node existingName = v.getNameNode();
 
             // We can't keep the local name on the function expression,
             // because IE is buggy and will leak the name into the global
@@ -389,9 +393,19 @@ private void findAliases(NodeTraversal t) {
             //
             // This will only cause problems if this is a hoisted, recursive
             // function, and the programmer is using the hoisting.
+            Node newName = IR.name("""").useSourceInfoFrom(existingName);
+            value.replaceChild(existingName, newName);
 
+            varNode = IR.var(existingName).useSourceInfoFrom(existingName);
+            grandparent.replaceChild(parent, varNode);
+          } else {
+            if (value != null) {
               // If this is a VAR, we can just detach the expression and
               // the tree will still be valid.
+              value.detachFromParent();
+            }
+            varNode = parent;
+          }
 
           // Add $jscomp.scope.name = EXPR;
           // Make sure we copy over all the jsdoc and debug info.
@@ -405,7 +419,11 @@ private void findAliases(NodeTraversal t) {
             NodeUtil.setDebugInformation(
                 newDecl.getFirstChild().getFirstChild(), n, name);
 
+            if (isHoisted) {
+              grandparent.addChildToFront(newDecl);
+            } else {
               grandparent.addChildBefore(newDecl, varNode);
+            }
           }
 
           // Rewrite ""var name = EXPR;"" to ""var name = $jscomp.scope.name;""
/src/com/google/javascript/rhino/Node.java @@ -551,6 +551,9 @@ public Node getChildBefore(Node child) {
       return null;
     }
     Node n = first;
+    if (n == null) {
+      throw new RuntimeException(""node is not a child"");
+    }
 
     while (n.next != child) {
       n = n.next;
","@@ -355,6 +355,7 @@ private void findAliases(NodeTraversal t) {
         Node n = v.getNode();
         Node parent = n.getParent();
         boolean isVar = parent.isVar();
+        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);
         if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {
           recordAlias(v);
         } else if (v.isBleedingFunction()) {
@@ -363,12 +364,13 @@ private void findAliases(NodeTraversal t) {
         } else if (parent.getType() == Token.LP) {
           // Parameters of the scope function also get a BAD_PARAMETERS
           // error.
+        } else if (isVar || isFunctionDecl) {
+          boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);
           Node grandparent = parent.getParent();
+          Node value = v.getInitialValue() != null ?
+              v.getInitialValue() :
               null;
+          Node varNode = null;
 
           String name = n.getString();
           int nameCount = scopedAliasNames.count(name);
@@ -380,7 +382,9 @@ private void findAliases(NodeTraversal t) {
 
           // First, we need to free up the function expression (EXPR)
           // to be used in another expression.
+          if (isFunctionDecl) {
             // Replace ""function NAME() { ... }"" with ""var NAME;"".
+            Node existingName = v.getNameNode();
 
             // We can't keep the local name on the function expression,
             // because IE is buggy and will leak the name into the global
@@ -389,9 +393,19 @@ private void findAliases(NodeTraversal t) {
             //
             // This will only cause problems if this is a hoisted, recursive
             // function, and the programmer is using the hoisting.
+            Node newName = IR.name("""").useSourceInfoFrom(existingName);
+            value.replaceChild(existingName, newName);
 
+            varNode = IR.var(existingName).useSourceInfoFrom(existingName);
+            grandparent.replaceChild(parent, varNode);
+          } else {
+            if (value != null) {
               // If this is a VAR, we can just detach the expression and
               // the tree will still be valid.
+              value.detachFromParent();
+            }
+            varNode = parent;
+          }
 
           // Add $jscomp.scope.name = EXPR;
           // Make sure we copy over all the jsdoc and debug info.
@@ -405,7 +419,11 @@ private void findAliases(NodeTraversal t) {
             NodeUtil.setDebugInformation(
                 newDecl.getFirstChild().getFirstChild(), n, name);
 
+            if (isHoisted) {
+              grandparent.addChildToFront(newDecl);
+            } else {
               grandparent.addChildBefore(newDecl, varNode);
+            }
           }
 
           // Rewrite ""var name = EXPR;"" to ""var name = $jscomp.scope.name;""
/src/com/google/javascript/rhino/Node.java @@ -551,6 +551,9 @@ public Node getChildBefore(Node child) {
       return null;
     }
     Node n = first;
+    if (n == null) {
+      throw new RuntimeException(""node is not a child"");
+    }
 
     while (n.next != child) {
       n = n.next;
"
144,"junit.framework.ComparisonFailure","/src/com/google/javascript/jscomp/DisambiguateProperties.java","@@ -492,6 +492,9 @@ private void handleObjectLit(NodeTraversal t, Node n) {
           child != null;
           child = child.getNext()) {
         // Maybe STRING, GET, SET
+        if (child.isQuotedString()) {
+          continue;
+        }
 
         // We should never see a mix of numbers and strings.
         String name = child.getString();
","@@ -492,6 +492,9 @@ private void handleObjectLit(NodeTraversal t, Node n) {
           child != null;
           child = child.getNext()) {
         // Maybe STRING, GET, SET
+        if (child.isQuotedString()) {
+          continue;
+        }
 
         // We should never see a mix of numbers and strings.
         String name = child.getString();
"
145,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java","@@ -428,6 +428,9 @@ boolean isAssignedOnceInLifetime() {
       for (BasicBlock block = ref.getBasicBlock();
            block != null; block = block.getParent()) {
         if (block.isFunction) {
+          if (ref.getSymbol().getScope() != ref.scope) {
+            return false;
+          }
           break;
         } else if (block.isLoop) {
           return false;
","@@ -428,6 +428,9 @@ boolean isAssignedOnceInLifetime() {
       for (BasicBlock block = ref.getBasicBlock();
            block != null; block = block.getParent()) {
         if (block.isFunction) {
+          if (ref.getSymbol().getScope() != ref.scope) {
+            return false;
+          }
           break;
         } else if (block.isLoop) {
           return false;
"
146,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/GlobalNamespace.java","@@ -363,6 +363,7 @@ public void collect(JSModule module, Scope scope, Node n) {
                 isSet = true;
                 type = Name.Type.FUNCTION;
                 break;
+              case Token.CATCH:
               case Token.INC:
               case Token.DEC:
                 isSet = true;
","@@ -363,6 +363,7 @@ public void collect(JSModule module, Scope scope, Node n) {
                 isSet = true;
                 type = Name.Type.FUNCTION;
                 break;
+              case Token.CATCH:
               case Token.INC:
               case Token.DEC:
                 isSet = true;
"
147,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/InlineVariables.java","@@ -301,10 +301,12 @@ private void inlineNonConstants(
       if (!maybeModifiedArguments &&
           !staleVars.contains(v) &&
           referenceInfo.isWellDefined() &&
+          referenceInfo.isAssignedOnceInLifetime() &&
           // Inlining the variable based solely on well-defined and assigned
           // once is *NOT* correct. We relax the correctness requirement if
           // the variable is declared constant.
+          (isInlineableDeclaredConstant(v, referenceInfo) ||
+           referenceInfo.isOnlyAssignmentSameScopeAsDeclaration())) {
         List<Reference> refs = referenceInfo.references;
         for (int i = 1 /* start from a read */; i < refs.size(); i++) {
           Node nameNode = refs.get(i).getNode();
","@@ -301,10 +301,12 @@ private void inlineNonConstants(
       if (!maybeModifiedArguments &&
           !staleVars.contains(v) &&
           referenceInfo.isWellDefined() &&
+          referenceInfo.isAssignedOnceInLifetime() &&
           // Inlining the variable based solely on well-defined and assigned
           // once is *NOT* correct. We relax the correctness requirement if
           // the variable is declared constant.
+          (isInlineableDeclaredConstant(v, referenceInfo) ||
+           referenceInfo.isOnlyAssignmentSameScopeAsDeclaration())) {
         List<Reference> refs = referenceInfo.references;
         for (int i = 1 /* start from a read */; i < refs.size(); i++) {
           Node nameNode = refs.get(i).getNode();
"
148,"junit.framework.ComparisonFailure","/src/com/google/javascript/jscomp/CodeGenerator.java","@@ -282,7 +282,7 @@ void add(Node n, Context context) {
       case Token.HOOK: {
         Preconditions.checkState(childCount == 3);
         int p = NodeUtil.precedence(type);
+        Context rhsContext = getContextForNoInOperator(context);
         addExpr(first, p + 1, context);
         cc.addOp(""?"", true);
         addExpr(first.getNext(), 1, rhsContext);
","@@ -282,7 +282,7 @@ void add(Node n, Context context) {
       case Token.HOOK: {
         Preconditions.checkState(childCount == 3);
         int p = NodeUtil.precedence(type);
+        Context rhsContext = getContextForNoInOperator(context);
         addExpr(first, p + 1, context);
         cc.addOp(""?"", true);
         addExpr(first.getNext(), 1, rhsContext);
"
149,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/parsing/IRFactory.java","@@ -249,7 +249,8 @@ private Node transformBlock(AstNode node) {
    * Check to see if the given block comment looks like it should be JSDoc.
    */
   private void handleBlockComment(Comment comment) {
+    Pattern p = Pattern.compile(""(/|(\n[ \t]*))\\*[ \t]*@[a-zA-Z]"");
+    if (p.matcher(comment.getValue()).find()) {
       errorReporter.warning(
           SUSPICIOUS_COMMENT_WARNING,
           sourceName,
","@@ -249,7 +249,8 @@ private Node transformBlock(AstNode node) {
    * Check to see if the given block comment looks like it should be JSDoc.
    */
   private void handleBlockComment(Comment comment) {
+    Pattern p = Pattern.compile(""(/|(\n[ \t]*))\\*[ \t]*@[a-zA-Z]"");
+    if (p.matcher(comment.getValue()).find()) {
       errorReporter.warning(
           SUSPICIOUS_COMMENT_WARNING,
           sourceName,
"
150,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/MinimizeExitPoints.java","@@ -138,10 +138,6 @@ void tryMinimizeExits(Node n, int exitType, String labelName) {
        * can cause problems if it changes the completion type of the finally
        * block. See ECMA 262 Sections 8.9 & 12.14
        */
     }
 
     // Just a 'label'.
","@@ -138,10 +138,6 @@ void tryMinimizeExits(Node n, int exitType, String labelName) {
        * can cause problems if it changes the completion type of the finally
        * block. See ECMA 262 Sections 8.9 & 12.14
        */
     }
 
     // Just a 'label'.
"
151,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/ExploitAssigns.java","@@ -210,7 +210,9 @@ private boolean isSafeReplacement(Node node, Node replacement) {
     }
     Preconditions.checkArgument(node.isGetProp());
 
+    while (node.isGetProp()) {
       node = node.getFirstChild();
+    }
     if (node.isName()
         && isNameAssignedTo(node.getString(), replacement)) {
       return false;
","@@ -210,7 +210,9 @@ private boolean isSafeReplacement(Node node, Node replacement) {
     }
     Preconditions.checkArgument(node.isGetProp());
 
+    while (node.isGetProp()) {
       node = node.getFirstChild();
+    }
     if (node.isName()
         && isNameAssignedTo(node.getString(), replacement)) {
       return false;
"
152,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/UnreachableCodeElimination.java","@@ -167,13 +167,22 @@ private void tryRemoveUnconditionalBranching(Node n) {
                 outEdges.get(0).getValue() == Branch.UNCOND);
             Node fallThrough = computeFollowing(n);
             Node nextCfgNode = outEdges.get(0).getDestination().getValue();
+            if (nextCfgNode == fallThrough && !inFinally(n.getParent(), n)) {
               removeNode(n);
             }
           }
       }
     }
 
+    private boolean inFinally(Node parent, Node child) {
+      if (parent == null || parent.isFunction()) {
+        return false;
+      } else if (NodeUtil.isTryFinallyNode(parent, child)) {
+        return true;
+      } else {
+        return inFinally(parent.getParent(), parent);
+      }
+    }
 
     private Node computeFollowing(Node n) {
       Node next = ControlFlowAnalysis.computeFollowNode(n);
","@@ -167,13 +167,22 @@ private void tryRemoveUnconditionalBranching(Node n) {
                 outEdges.get(0).getValue() == Branch.UNCOND);
             Node fallThrough = computeFollowing(n);
             Node nextCfgNode = outEdges.get(0).getDestination().getValue();
+            if (nextCfgNode == fallThrough && !inFinally(n.getParent(), n)) {
               removeNode(n);
             }
           }
       }
     }
 
+    private boolean inFinally(Node parent, Node child) {
+      if (parent == null || parent.isFunction()) {
+        return false;
+      } else if (NodeUtil.isTryFinallyNode(parent, child)) {
+        return true;
+      } else {
+        return inFinally(parent.getParent(), parent);
+      }
+    }
 
     private Node computeFollowing(Node n) {
       Node next = ControlFlowAnalysis.computeFollowNode(n);
"
153,"java.lang.IllegalStateException","/src/com/google/javascript/jscomp/TypeCheck.java","@@ -1658,7 +1658,7 @@ private void visitNew(NodeTraversal t, Node n) {
     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();
     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {
       FunctionType fnType = type.toMaybeFunctionType();
+      if (fnType != null && fnType.hasInstanceType()) {
         visitParameterList(t, n, fnType);
         ensureTyped(t, n, fnType.getInstanceType());
       } else {
","@@ -1658,7 +1658,7 @@ private void visitNew(NodeTraversal t, Node n) {
     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();
     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {
       FunctionType fnType = type.toMaybeFunctionType();
+      if (fnType != null && fnType.hasInstanceType()) {
         visitParameterList(t, n, fnType);
         ensureTyped(t, n, fnType.getInstanceType());
       } else {
"
154,"junit.framework.ComparisonFailure","/src/com/google/javascript/jscomp/CodeGenerator.java","@@ -782,13 +782,16 @@ private void unrollBinaryOperator(
 
   static boolean isSimpleNumber(String s) {
     int len = s.length();
+    if (len == 0) {
+      return false;
+    }
     for (int index = 0; index < len; index++) {
       char c = s.charAt(index);
       if (c < '0' || c > '9') {
         return false;
       }
     }
+    return len == 1 || s.charAt(0) != '0';
   }
 
   static double getSimpleNumber(String s) {
","@@ -782,13 +782,16 @@ private void unrollBinaryOperator(
 
   static boolean isSimpleNumber(String s) {
     int len = s.length();
+    if (len == 0) {
+      return false;
+    }
     for (int index = 0; index < len; index++) {
       char c = s.charAt(index);
       if (c < '0' || c > '9') {
         return false;
       }
     }
+    return len == 1 || s.charAt(0) != '0';
   }
 
   static double getSimpleNumber(String s) {
"
155,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/math/NumberUtils.java","@@ -590,18 +590,22 @@ public static Number createNumber(final String str) throws NumberFormatException
         //Must be a Float, Double, BigDecimal
         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
         try {
+            if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float
                 final Float f = createFloat(str);
                 if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                     return f;
                 }
+            }
         } catch (final NumberFormatException nfe) { // NOPMD
             // ignore the bad number
         }
         try {
+            if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double
                 final Double d = createDouble(str);
                 if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                     return d;
                 }
+            }
         } catch (final NumberFormatException nfe) { // NOPMD
             // ignore the bad number
         }
","@@ -590,18 +590,22 @@ public static Number createNumber(final String str) throws NumberFormatException
         //Must be a Float, Double, BigDecimal
         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
         try {
+            if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float
                 final Float f = createFloat(str);
                 if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                     return f;
                 }
+            }
         } catch (final NumberFormatException nfe) { // NOPMD
             // ignore the bad number
         }
         try {
+            if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double
                 final Double d = createDouble(str);
                 if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                     return d;
                 }
+            }
         } catch (final NumberFormatException nfe) { // NOPMD
             // ignore the bad number
         }
"
156,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/LocaleUtils.java","@@ -89,6 +89,9 @@ public static Locale toLocale(final String str) {
         if (str == null) {
             return null;
         }
+        if (str.contains(""#"")) { // LANG-879 - Cannot handle Java 7 script & extensions
+            throw new IllegalArgumentException(""Invalid locale format: "" + str);
+        }
         final int len = str.length();
         if (len < 2) {
             throw new IllegalArgumentException(""Invalid locale format: "" + str);
","@@ -89,6 +89,9 @@ public static Locale toLocale(final String str) {
         if (str == null) {
             return null;
         }
+        if (str.contains(""#"")) { // LANG-879 - Cannot handle Java 7 script & extensions
+            throw new IllegalArgumentException(""Invalid locale format: "" + str);
+        }
         final int len = str.length();
         if (len < 2) {
             throw new IllegalArgumentException(""Invalid locale format: "" + str);
"
157,"java.lang.IllegalArgumentException","/src/main/java/org/apache/commons/lang3/LocaleUtils.java","@@ -94,6 +94,26 @@ public static Locale toLocale(final String str) {
             throw new IllegalArgumentException(""Invalid locale format: "" + str);
         }
         final char ch0 = str.charAt(0);
+        if (ch0 == '_') {
+            if (len < 3) {
+                throw new IllegalArgumentException(""Invalid locale format: "" + str);
+            }
+            final char ch1 = str.charAt(1);
+            final char ch2 = str.charAt(2);
+            if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {
+                throw new IllegalArgumentException(""Invalid locale format: "" + str);
+            }
+            if (len == 3) {
+                return new Locale("""", str.substring(1, 3));
+            }
+            if (len < 5) {
+                throw new IllegalArgumentException(""Invalid locale format: "" + str);
+            }
+            if (str.charAt(3) != '_') {
+                throw new IllegalArgumentException(""Invalid locale format: "" + str);
+            }
+            return new Locale("""", str.substring(1, 3), str.substring(4));
+        } else {
             final char ch1 = str.charAt(1);
             if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
@@ -125,6 +145,7 @@ public static Locale toLocale(final String str) {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
             }
             return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
+        }
     }
 
     //-----------------------------------------------------------------------
","@@ -94,6 +94,26 @@ public static Locale toLocale(final String str) {
             throw new IllegalArgumentException(""Invalid locale format: "" + str);
         }
         final char ch0 = str.charAt(0);
+        if (ch0 == '_') {
+            if (len < 3) {
+                throw new IllegalArgumentException(""Invalid locale format: "" + str);
+            }
+            final char ch1 = str.charAt(1);
+            final char ch2 = str.charAt(2);
+            if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {
+                throw new IllegalArgumentException(""Invalid locale format: "" + str);
+            }
+            if (len == 3) {
+                return new Locale("""", str.substring(1, 3));
+            }
+            if (len < 5) {
+                throw new IllegalArgumentException(""Invalid locale format: "" + str);
+            }
+            if (str.charAt(3) != '_') {
+                throw new IllegalArgumentException(""Invalid locale format: "" + str);
+            }
+            return new Locale("""", str.substring(1, 3), str.substring(4));
+        } else {
             final char ch1 = str.charAt(1);
             if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
@@ -125,6 +145,7 @@ public static Locale toLocale(final String str) {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
             }
             return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
+        }
     }
 
     //-----------------------------------------------------------------------
"
158,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/CollapseProperties.java","@@ -169,7 +169,7 @@ private void inlineAliases(GlobalNamespace namespace) {
         continue;
       }
 
+      if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 &&
           name.aliasingGets > 0) {
         // {@code name} meets condition (b). Find all of its local aliases
         // and try to inline them.
","@@ -169,7 +169,7 @@ private void inlineAliases(GlobalNamespace namespace) {
         continue;
       }
 
+      if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 &&
           name.aliasingGets > 0) {
         // {@code name} meets condition (b). Find all of its local aliases
         // and try to inline them.
"
159,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/text/translate/LookupTranslator.java","@@ -28,7 +28,7 @@
  */
 public class LookupTranslator extends CharSequenceTranslator {
 
+    private final HashMap<String, CharSequence> lookupMap;
     private final int shortest;
     private final int longest;
 
@@ -43,12 +43,12 @@
      * @param lookup CharSequence[][] table of size [*][2]
      */
     public LookupTranslator(final CharSequence[]... lookup) {
+        lookupMap = new HashMap<String, CharSequence>();
         int _shortest = Integer.MAX_VALUE;
         int _longest = 0;
         if (lookup != null) {
             for (final CharSequence[] seq : lookup) {
+                this.lookupMap.put(seq[0].toString(), seq[1]);
                 final int sz = seq[0].length();
                 if (sz < _shortest) {
                     _shortest = sz;
@@ -74,7 +74,7 @@ public int translate(final CharSequence input, final int index, final Writer out
         // descend so as to get a greedy algorithm
         for (int i = max; i >= shortest; i--) {
             final CharSequence subSeq = input.subSequence(index, index + i);
+            final CharSequence result = lookupMap.get(subSeq.toString());
             if (result != null) {
                 out.write(result.toString());
                 return i;
","@@ -28,7 +28,7 @@
  */
 public class LookupTranslator extends CharSequenceTranslator {
 
+    private final HashMap<String, CharSequence> lookupMap;
     private final int shortest;
     private final int longest;
 
@@ -43,12 +43,12 @@
      * @param lookup CharSequence[][] table of size [*][2]
      */
     public LookupTranslator(final CharSequence[]... lookup) {
+        lookupMap = new HashMap<String, CharSequence>();
         int _shortest = Integer.MAX_VALUE;
         int _longest = 0;
         if (lookup != null) {
             for (final CharSequence[] seq : lookup) {
+                this.lookupMap.put(seq[0].toString(), seq[1]);
                 final int sz = seq[0].length();
                 if (sz < _shortest) {
                     _shortest = sz;
@@ -74,7 +74,7 @@ public int translate(final CharSequence input, final int index, final Writer out
         // descend so as to get a greedy algorithm
         for (int i = max; i >= shortest; i--) {
             final CharSequence subSeq = input.subSequence(index, index + i);
+            final CharSequence result = lookupMap.get(subSeq.toString());
             if (result != null) {
                 out.write(result.toString());
                 return i;
"
160,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/PrepareAst.java","@@ -163,6 +163,9 @@ private void annotateCalls(Node n) {
       Node first = n.getFirstChild();
 
       // ignore cast nodes.
+      while (first.isCast()) {
+        first = first.getFirstChild();
+      }
 
       if (!NodeUtil.isGet(first)) {
         n.putBooleanProp(Node.FREE_CALL, true);
","@@ -163,6 +163,9 @@ private void annotateCalls(Node n) {
       Node first = n.getFirstChild();
 
       // ignore cast nodes.
+      while (first.isCast()) {
+        first = first.getFirstChild();
+      }
 
       if (!NodeUtil.isGet(first)) {
         n.putBooleanProp(Node.FREE_CALL, true);
"
161,"java.lang.NumberFormatException","/src/main/java/org/apache/commons/lang3/math/NumberUtils.java","@@ -464,11 +464,20 @@ public static Number createNumber(final String str) throws NumberFormatException
             }
         }
         if (pfxLen > 0) { // we have a hex number
+            char firstSigDigit = 0; // strip leading zeroes
+            for(int i = pfxLen; i < str.length(); i++) {
+                firstSigDigit = str.charAt(i);
+                if (firstSigDigit == '0') { // count leading zeroes
+                    pfxLen++;
+                } else {
+                    break;
+                }
+            }
             final int hexDigits = str.length() - pfxLen;
+            if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { // too many for Long
                 return createBigInteger(str);
             }
+            if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { // too many for an int
                 return createLong(str);
             }
             return createInteger(str);
","@@ -464,11 +464,20 @@ public static Number createNumber(final String str) throws NumberFormatException
             }
         }
         if (pfxLen > 0) { // we have a hex number
+            char firstSigDigit = 0; // strip leading zeroes
+            for(int i = pfxLen; i < str.length(); i++) {
+                firstSigDigit = str.charAt(i);
+                if (firstSigDigit == '0') { // count leading zeroes
+                    pfxLen++;
+                } else {
+                    break;
+                }
+            }
             final int hexDigits = str.length() - pfxLen;
+            if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { // too many for Long
                 return createBigInteger(str);
             }
+            if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { // too many for an int
                 return createLong(str);
             }
             return createInteger(str);
"
162,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java","@@ -779,7 +779,9 @@ private Node tryMinimizeIf(Node n) {
               // evaluates LHS before cond]
               // NOTE - there are some circumstances where we can
               // proceed even if there are side effects...
+              !mayEffectMutableState(lhs) &&
+              (!mayHaveSideEffects(cond) ||
+                  (thenOp.isAssign() && thenOp.getFirstChild().isName()))) {
 
             n.removeChild(cond);
             Node assignName = thenOp.removeFirstChild();
","@@ -779,7 +779,9 @@ private Node tryMinimizeIf(Node n) {
               // evaluates LHS before cond]
               // NOTE - there are some circumstances where we can
               // proceed even if there are side effects...
+              !mayEffectMutableState(lhs) &&
+              (!mayHaveSideEffects(cond) ||
+                  (thenOp.isAssign() && thenOp.getFirstChild().isName()))) {
 
             n.removeChild(cond);
             Node assignName = thenOp.removeFirstChild();
"
163,"java.lang.StringIndexOutOfBoundsException","/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java","@@ -92,7 +92,7 @@ public final void translate(CharSequence input, Writer out) throws IOException {
 //          // contract with translators is that they have to understand codepoints 
 //          // and they just took care of a surrogate pair
             for (int pt = 0; pt < consumed; pt++) {
+                pos += Character.charCount(Character.codePointAt(input, pt));
             }
         }
     }
","@@ -92,7 +92,7 @@ public final void translate(CharSequence input, Writer out) throws IOException {
 //          // contract with translators is that they have to understand codepoints 
 //          // and they just took care of a surrogate pair
             for (int pt = 0; pt < consumed; pt++) {
+                pos += Character.charCount(Character.codePointAt(input, pt));
             }
         }
     }
"
164,"java.lang.IllegalStateException","/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java","@@ -2398,6 +2398,7 @@ private void skipEOLs() {
    */
   private String getRemainingJSDocLine() {
     String result = stream.getRemainingJSDocLine();
+    unreadToken = NO_UNREAD_TOKEN;
     return result;
   }
 
","@@ -2398,6 +2398,7 @@ private void skipEOLs() {
    */
   private String getRemainingJSDocLine() {
     String result = stream.getRemainingJSDocLine();
+    unreadToken = NO_UNREAD_TOKEN;
     return result;
   }
 
"
165,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/math/NumberUtils.java","@@ -449,9 +449,6 @@ public static Number createNumber(String str) throws NumberFormatException {
         if (StringUtils.isBlank(str)) {
             throw new NumberFormatException(""A blank string is not a valid number"");
         }  
         if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) {
             int hexDigits = str.length() - 2; // drop 0x
             if (str.startsWith(""-"")) { // drop -
@@ -718,10 +715,13 @@ public static BigDecimal createBigDecimal(String str) {
         if (StringUtils.isBlank(str)) {
             throw new NumberFormatException(""A blank string is not a valid number"");
         }
+        if (str.trim().startsWith(""--"")) {
             // this is protection for poorness in java.lang.BigDecimal.
             // it accepts this as a legal value, but it does not appear 
             // to be in specification of class. OS X Java parses it to 
             // a wrong value.
+            throw new NumberFormatException(str + "" is not a valid number."");
+        }
         return new BigDecimal(str);
     }
 
","@@ -449,9 +449,6 @@ public static Number createNumber(String str) throws NumberFormatException {
         if (StringUtils.isBlank(str)) {
             throw new NumberFormatException(""A blank string is not a valid number"");
         }  
         if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) {
             int hexDigits = str.length() - 2; // drop 0x
             if (str.startsWith(""-"")) { // drop -
@@ -718,10 +715,13 @@ public static BigDecimal createBigDecimal(String str) {
         if (StringUtils.isBlank(str)) {
             throw new NumberFormatException(""A blank string is not a valid number"");
         }
+        if (str.trim().startsWith(""--"")) {
             // this is protection for poorness in java.lang.BigDecimal.
             // it accepts this as a legal value, but it does not appear 
             // to be in specification of class. OS X Java parses it to 
             // a wrong value.
+            throw new NumberFormatException(str + "" is not a valid number."");
+        }
         return new BigDecimal(str);
     }
 
"
166,"junit.framework.AssertionFailedError","/src/com/google/javascript/rhino/TokenStream.java","@@ -191,12 +191,13 @@ public static boolean isJSIdentifier(String s) {
       int length = s.length();
 
       if (length == 0 ||
+          Character.isIdentifierIgnorable(s.charAt(0)) ||
           !Character.isJavaIdentifierStart(s.charAt(0))) {
         return false;
       }
 
       for (int i = 1; i < length; i++) {
+        if (Character.isIdentifierIgnorable(s.charAt(i)) ||
             !Character.isJavaIdentifierPart(s.charAt(i))) {
           return false;
         }
","@@ -191,12 +191,13 @@ public static boolean isJSIdentifier(String s) {
       int length = s.length();
 
       if (length == 0 ||
+          Character.isIdentifierIgnorable(s.charAt(0)) ||
           !Character.isJavaIdentifierStart(s.charAt(0))) {
         return false;
       }
 
       for (int i = 1; i < length; i++) {
+        if (Character.isIdentifierIgnorable(s.charAt(i)) ||
             !Character.isJavaIdentifierPart(s.charAt(i))) {
           return false;
         }
"
167,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java","@@ -1095,7 +1095,6 @@ static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Local
     private static class TimeZoneNameRule implements Rule {
         private final Locale mLocale;
         private final int mStyle;
         private final String mStandard;
         private final String mDaylight;
 
@@ -1109,7 +1108,6 @@ static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Local
         TimeZoneNameRule(TimeZone timeZone, Locale locale, int style) {
             mLocale = locale;
             mStyle = style;
             
             mStandard = getTimeZoneDisplay(timeZone, false, style, locale);
             mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);
@@ -1131,6 +1129,7 @@ public int estimateLength() {
          */
         @Override
         public void appendTo(StringBuffer buffer, Calendar calendar) {
+            TimeZone zone = calendar.getTimeZone();
             if (zone.useDaylightTime()
                     && calendar.get(Calendar.DST_OFFSET) != 0) {
                 buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));
","@@ -1095,7 +1095,6 @@ static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Local
     private static class TimeZoneNameRule implements Rule {
         private final Locale mLocale;
         private final int mStyle;
         private final String mStandard;
         private final String mDaylight;
 
@@ -1109,7 +1108,6 @@ static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Local
         TimeZoneNameRule(TimeZone timeZone, Locale locale, int style) {
             mLocale = locale;
             mStyle = style;
             
             mStandard = getTimeZoneDisplay(timeZone, false, style, locale);
             mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);
@@ -1131,6 +1129,7 @@ public int estimateLength() {
          */
         @Override
         public void appendTo(StringBuffer buffer, Calendar calendar) {
+            TimeZone zone = calendar.getTimeZone();
             if (zone.useDaylightTime()
                     && calendar.get(Calendar.DST_OFFSET) != 0) {
                 buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));
"
168,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/time/FastDateParser.java","@@ -301,17 +301,8 @@ public Date parse(String source, ParsePosition pos) {
      * @return The <code>StringBuilder</code>
      */
     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {
         for(int i= 0; i<value.length(); ++i) {
             char c= value.charAt(i);
             switch(c) {
             case '\'':
                 if(unquote) {
","@@ -301,17 +301,8 @@ public Date parse(String source, ParsePosition pos) {
      * @return The <code>StringBuilder</code>
      */
     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {
         for(int i= 0; i<value.length(); ++i) {
             char c= value.charAt(i);
             switch(c) {
             case '\'':
                 if(unquote) {
"
169,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/RandomStringUtils.java","@@ -242,6 +242,10 @@ public static String random(int count, int start, int end, boolean letters, bool
                     start = ' ';                
                 }
             }
+        } else {
+            if (end <= start) {
+                throw new IllegalArgumentException(""Parameter end ("" + end + "") must be greater than start ("" + start + "")"");
+            }
         }
 
         char[] buffer = new char[count];
","@@ -242,6 +242,10 @@ public static String random(int count, int start, int end, boolean letters, bool
                     start = ' ';                
                 }
             }
+        } else {
+            if (end <= start) {
+                throw new IllegalArgumentException(""Parameter end ("" + end + "") must be greater than start ("" + start + "")"");
+            }
         }
 
         char[] buffer = new char[count];
"
170,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/time/FastDateParser.java","@@ -141,6 +141,9 @@ private void init() {
             currentFormatField= nextFormatField;
             currentStrategy= nextStrategy;
         }
+        if (patternMatcher.regionStart() != patternMatcher.regionEnd()) {
+            throw new IllegalArgumentException(""Failed to parse \""""+pattern+""\"" ; gave up at index ""+patternMatcher.regionStart());
+        }
         if(currentStrategy.addRegex(this, regex)) {
             collector.add(currentStrategy);
         }
","@@ -141,6 +141,9 @@ private void init() {
             currentFormatField= nextFormatField;
             currentStrategy= nextStrategy;
         }
+        if (patternMatcher.regionStart() != patternMatcher.regionEnd()) {
+            throw new IllegalArgumentException(""Failed to parse \""""+pattern+""\"" ; gave up at index ""+patternMatcher.regionStart());
+        }
         if(currentStrategy.addRegex(this, regex)) {
             collector.add(currentStrategy);
         }
"
171,"org.apache.commons.lang3.SerializationException","/src/main/java/org/apache/commons/lang3/SerializationUtils.java","@@ -217,58 +217,77 @@ public static Object deserialize(InputStream inputStream) {
     public static Object deserialize(byte[] objectData) {
         if (objectData == null) {
             throw new IllegalArgumentException(""The byte[] must not be null"");
         }
         ByteArrayInputStream bais = new ByteArrayInputStream(objectData);
         return deserialize(bais);
     }
 
     /**
      * <p>Custom specialization of the standard JDK {@link java.io.ObjectInputStream}
      * that uses a custom  <code>ClassLoader</code> to resolve a class.
      * If the specified <code>ClassLoader</code> is not able to resolve the class,
      * the context classloader of the current thread will be used.
      * This way, the standard deserialization work also in web-application
      * containers and application servers, no matter in which of the
      * <code>ClassLoader</code> the particular class that encapsulates
      * serialization/deserialization lives. </p>
      * 
      * <p>For more in-depth information about the problem for which this
      * class here is a workaround, see the JIRA issue LANG-626. </p>
      */
      static class ClassLoaderAwareObjectInputStream extends ObjectInputStream {
+        private static final Map<String, Class<?>> primitiveTypes = 
+                new HashMap<String, Class<?>>();
         private ClassLoader classLoader;
         
         /**
          * Constructor.
          * @param in The <code>InputStream</code>.
          * @param classLoader classloader to use
          * @throws IOException if an I/O error occurs while reading stream header.
          * @see java.io.ObjectInputStream
          */
         public ClassLoaderAwareObjectInputStream(InputStream in, ClassLoader classLoader) throws IOException {
             super(in);
             this.classLoader = classLoader;
 
+            primitiveTypes.put(""byte"", byte.class);
+            primitiveTypes.put(""short"", short.class);
+            primitiveTypes.put(""int"", int.class);
+            primitiveTypes.put(""long"", long.class);
+            primitiveTypes.put(""float"", float.class);
+            primitiveTypes.put(""double"", double.class);
+            primitiveTypes.put(""boolean"", boolean.class);
+            primitiveTypes.put(""char"", char.class);
+            primitiveTypes.put(""void"", void.class);
         }
 
         /**
          * Overriden version that uses the parametrized <code>ClassLoader</code> or the <code>ClassLoader</code>
          * of the current <code>Thread</code> to resolve the class.
          * @param desc An instance of class <code>ObjectStreamClass</code>.
          * @return A <code>Class</code> object corresponding to <code>desc</code>.
          * @throws IOException Any of the usual Input/Output exceptions.
          * @throws ClassNotFoundException If class of a serialized object cannot be found.
          */
         @Override
         protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
             String name = desc.getName();
             try {
                 return Class.forName(name, false, classLoader);
             } catch (ClassNotFoundException ex) {
+                try {
                     return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
+                } catch (ClassNotFoundException cnfe) {
+                    Class<?> cls = primitiveTypes.get(name);
+                    if (cls != null)
+                        return cls;
+                    else
+                        throw cnfe;
+                }
             }
         }
 
     }
 
 }
","@@ -217,58 +217,77 @@ public static Object deserialize(InputStream inputStream) {
     public static Object deserialize(byte[] objectData) {
         if (objectData == null) {
             throw new IllegalArgumentException(""The byte[] must not be null"");
         }
         ByteArrayInputStream bais = new ByteArrayInputStream(objectData);
         return deserialize(bais);
     }
 
     /**
      * <p>Custom specialization of the standard JDK {@link java.io.ObjectInputStream}
      * that uses a custom  <code>ClassLoader</code> to resolve a class.
      * If the specified <code>ClassLoader</code> is not able to resolve the class,
      * the context classloader of the current thread will be used.
      * This way, the standard deserialization work also in web-application
      * containers and application servers, no matter in which of the
      * <code>ClassLoader</code> the particular class that encapsulates
      * serialization/deserialization lives. </p>
      * 
      * <p>For more in-depth information about the problem for which this
      * class here is a workaround, see the JIRA issue LANG-626. </p>
      */
      static class ClassLoaderAwareObjectInputStream extends ObjectInputStream {
+        private static final Map<String, Class<?>> primitiveTypes = 
+                new HashMap<String, Class<?>>();
         private ClassLoader classLoader;
         
         /**
          * Constructor.
          * @param in The <code>InputStream</code>.
          * @param classLoader classloader to use
          * @throws IOException if an I/O error occurs while reading stream header.
          * @see java.io.ObjectInputStream
          */
         public ClassLoaderAwareObjectInputStream(InputStream in, ClassLoader classLoader) throws IOException {
             super(in);
             this.classLoader = classLoader;
 
+            primitiveTypes.put(""byte"", byte.class);
+            primitiveTypes.put(""short"", short.class);
+            primitiveTypes.put(""int"", int.class);
+            primitiveTypes.put(""long"", long.class);
+            primitiveTypes.put(""float"", float.class);
+            primitiveTypes.put(""double"", double.class);
+            primitiveTypes.put(""boolean"", boolean.class);
+            primitiveTypes.put(""char"", char.class);
+            primitiveTypes.put(""void"", void.class);
         }
 
         /**
          * Overriden version that uses the parametrized <code>ClassLoader</code> or the <code>ClassLoader</code>
          * of the current <code>Thread</code> to resolve the class.
          * @param desc An instance of class <code>ObjectStreamClass</code>.
          * @return A <code>Class</code> object corresponding to <code>desc</code>.
          * @throws IOException Any of the usual Input/Output exceptions.
          * @throws ClassNotFoundException If class of a serialized object cannot be found.
          */
         @Override
         protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
             String name = desc.getName();
             try {
                 return Class.forName(name, false, classLoader);
             } catch (ClassNotFoundException ex) {
+                try {
                     return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
+                } catch (ClassNotFoundException cnfe) {
+                    Class<?> cls = primitiveTypes.get(name);
+                    if (cls != null)
+                        return cls;
+                    else
+                        throw cnfe;
+                }
             }
         }
 
     }
 
 }
"
172,"java.lang.ArrayIndexOutOfBoundsException","/src/main/java/org/apache/commons/lang3/RandomStringUtils.java","@@ -227,14 +227,21 @@ public static String random(int count, int start, int end, boolean letters, bool
         } else if (count < 0) {
             throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0."");
         }
+        if (chars != null && chars.length == 0) {
+            throw new IllegalArgumentException(""The chars array must not be empty"");
+        }
 
         if (start == 0 && end == 0) {
+            if (chars != null) {
+                end = chars.length;
+            } else {
                 if (!letters && !numbers) {
                     end = Integer.MAX_VALUE;
                 } else {
                     end = 'z' + 1;
                     start = ' ';                
                 }
+            }
         }
 
         char[] buffer = new char[count];
","@@ -227,14 +227,21 @@ public static String random(int count, int start, int end, boolean letters, bool
         } else if (count < 0) {
             throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0."");
         }
+        if (chars != null && chars.length == 0) {
+            throw new IllegalArgumentException(""The chars array must not be empty"");
+        }
 
         if (start == 0 && end == 0) {
+            if (chars != null) {
+                end = chars.length;
+            } else {
                 if (!letters && !numbers) {
                     end = Integer.MAX_VALUE;
                 } else {
                     end = 'z' + 1;
                     start = ' ';                
                 }
+            }
         }
 
         char[] buffer = new char[count];
"
173,"junit.framework.ComparisonFailure","/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java","@@ -492,10 +492,10 @@ private void init() {
                 rule = new TextField(Calendar.ERA, ERAs);
                 break;
             case 'y': // year (number)
+                if (tokenLen == 2) {
                     rule = TwoDigitYearField.INSTANCE;
+                } else {
+                    rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen);
                 }
                 break;
             case 'M': // month in year (text and number)
","@@ -492,10 +492,10 @@ private void init() {
                 rule = new TextField(Calendar.ERA, ERAs);
                 break;
             case 'y': // year (number)
+                if (tokenLen == 2) {
                     rule = TwoDigitYearField.INSTANCE;
+                } else {
+                    rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen);
                 }
                 break;
             case 'M': // month in year (text and number)
"
174,"junit.framework.ComparisonFailure","/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java","@@ -80,26 +80,20 @@ public final void translate(CharSequence input, Writer out) throws IOException {
             return;
         }
         int pos = 0;
+        int len = input.length();
         while (pos < len) {
             int consumed = translate(input, pos, out);
             if (consumed == 0) {
                 char[] c = Character.toChars(Character.codePointAt(input, pos));
                 out.write(c);
+                pos+= c.length;
+                continue;
             }
 //          // contract with translators is that they have to understand codepoints 
 //          // and they just took care of a surrogate pair
             for (int pt = 0; pt < consumed; pt++) {
                 pos += Character.charCount(Character.codePointAt(input, pos));
             }
         }
     }
 
","@@ -80,26 +80,20 @@ public final void translate(CharSequence input, Writer out) throws IOException {
             return;
         }
         int pos = 0;
+        int len = input.length();
         while (pos < len) {
             int consumed = translate(input, pos, out);
             if (consumed == 0) {
                 char[] c = Character.toChars(Character.codePointAt(input, pos));
                 out.write(c);
+                pos+= c.length;
+                continue;
             }
 //          // contract with translators is that they have to understand codepoints 
 //          // and they just took care of a surrogate pair
             for (int pt = 0; pt < consumed; pt++) {
                 pos += Character.charCount(Character.codePointAt(input, pos));
             }
         }
     }
 
"
175,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/StringUtils.java","@@ -785,7 +785,10 @@ public static boolean equals(CharSequence cs1, CharSequence cs2) {
         if (cs1 == null || cs2 == null) {
             return false;
         }
+        if (cs1 instanceof String && cs2 instanceof String) {
             return cs1.equals(cs2);
+        }
+        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));
     }
 
     /**
","@@ -785,7 +785,10 @@ public static boolean equals(CharSequence cs1, CharSequence cs2) {
         if (cs1 == null || cs2 == null) {
             return false;
         }
+        if (cs1 instanceof String && cs2 instanceof String) {
             return cs1.equals(cs2);
+        }
+        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));
     }
 
     /**
"
176,"java.lang.NumberFormatException","/src/main/java/org/apache/commons/lang3/math/NumberUtils.java","@@ -455,7 +455,7 @@ public static Number createNumber(String str) throws NumberFormatException {
             // a wrong value.
             return null;
         }
+        if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) {
             return createInteger(str);
         }   
         char lastChar = str.charAt(str.length() - 1);
","@@ -455,7 +455,7 @@ public static Number createNumber(String str) throws NumberFormatException {
             // a wrong value.
             return null;
         }
+        if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) {
             return createInteger(str);
         }   
         char lastChar = str.charAt(str.length() - 1);
"
177,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java","@@ -216,9 +216,9 @@ private static boolean isAssignable(Type type, ParameterizedType toParameterized
                 toClass, typeVarAssigns);
 
         // now to check each type argument
+        for (TypeVariable<?> var : toTypeVarAssigns.keySet()) {
+            Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns);
+            Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns);
 
             // parameters must either be absent from the subject type, within
             // the bounds of the wildcard type, or be an exact match to the
@@ -672,7 +672,7 @@ private static Type substituteTypeVariables(Type type, Map<TypeVariable<?>, Type
                 : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);
 
         // has target class been reached?
+        if (toClass.equals(cls)) {
             return typeVarAssigns;
         }
 
","@@ -216,9 +216,9 @@ private static boolean isAssignable(Type type, ParameterizedType toParameterized
                 toClass, typeVarAssigns);
 
         // now to check each type argument
+        for (TypeVariable<?> var : toTypeVarAssigns.keySet()) {
+            Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns);
+            Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns);
 
             // parameters must either be absent from the subject type, within
             // the bounds of the wildcard type, or be an exact match to the
@@ -672,7 +672,7 @@ private static Type substituteTypeVariables(Type type, Map<TypeVariable<?>, Type
                 : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);
 
         // has target class been reached?
+        if (toClass.equals(cls)) {
             return typeVarAssigns;
         }
 
"
178,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/time/DateUtils.java","@@ -262,7 +262,7 @@ public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {
         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&
                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&
                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&
+                cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&
                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&
                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&
                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&
","@@ -262,7 +262,7 @@ public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {
         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&
                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&
                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&
+                cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&
                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&
                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&
                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&
"
179,"java.lang.StringIndexOutOfBoundsException","/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java","@@ -37,7 +37,7 @@
     public int translate(CharSequence input, int index, Writer out) throws IOException {
         int seqEnd = input.length();
         // Uses -2 to ensure there is something after the &#
+        if(input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {
             int start = index + 2;
             boolean isHex = false;
 
@@ -47,11 +47,16 @@ public int translate(CharSequence input, int index, Writer out) throws IOExcepti
                 isHex = true;
 
                 // Check there's more than just an x after the &#
+                if(start == seqEnd) {
+                    return 0;
+                }
             }
 
             int end = start;
             // Note that this supports character codes without a ; on the end
+            while(end < seqEnd && ( (input.charAt(end) >= '0' && input.charAt(end) <= '9') ||
+                                    (input.charAt(end) >= 'a' && input.charAt(end) <= 'f') ||
+                                    (input.charAt(end) >= 'A' && input.charAt(end) <= 'F') ) )
             {
                 end++;
             }
@@ -76,8 +81,9 @@ public int translate(CharSequence input, int index, Writer out) throws IOExcepti
                 out.write(entityValue);
             }
 
+            boolean semiNext = (end != seqEnd) && (input.charAt(end) == ';');
 
+            return 2 + (end - start) + (isHex ? 1 : 0) + (semiNext ? 1 : 0);
         }
         return 0;
     }
","@@ -37,7 +37,7 @@
     public int translate(CharSequence input, int index, Writer out) throws IOException {
         int seqEnd = input.length();
         // Uses -2 to ensure there is something after the &#
+        if(input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {
             int start = index + 2;
             boolean isHex = false;
 
@@ -47,11 +47,16 @@ public int translate(CharSequence input, int index, Writer out) throws IOExcepti
                 isHex = true;
 
                 // Check there's more than just an x after the &#
+                if(start == seqEnd) {
+                    return 0;
+                }
             }
 
             int end = start;
             // Note that this supports character codes without a ; on the end
+            while(end < seqEnd && ( (input.charAt(end) >= '0' && input.charAt(end) <= '9') ||
+                                    (input.charAt(end) >= 'a' && input.charAt(end) <= 'f') ||
+                                    (input.charAt(end) >= 'A' && input.charAt(end) <= 'F') ) )
             {
                 end++;
             }
@@ -76,8 +81,9 @@ public int translate(CharSequence input, int index, Writer out) throws IOExcepti
                 out.write(entityValue);
             }
 
+            boolean semiNext = (end != seqEnd) && (input.charAt(end) == ';');
 
+            return 2 + (end - start) + (isHex ? 1 : 0) + (semiNext ? 1 : 0);
         }
         return 0;
     }
"
180,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java","@@ -70,6 +70,7 @@
  */
 public class ExtendedMessageFormat extends MessageFormat {
     private static final long serialVersionUID = -2362048321261811743L;
+    private static final int HASH_SEED = 31;
 
     private static final String DUMMY_PATTERN = """";
     private static final String ESCAPED_QUOTE = ""''"";
@@ -260,12 +261,42 @@ public void setFormatsByArgumentIndex(Format[] newFormats) {
      * @param obj the object to compare to
      * @return true if this object equals the other, otherwise false
      */
+    @Override
+    public boolean equals(Object obj) {
+        if (obj == this) {
+            return true;
+        }
+        if (obj == null) {
+            return false;
+        }
+        if (!super.equals(obj)) {
+            return false;
+        }
+        if (ObjectUtils.notEqual(getClass(), obj.getClass())) {
+          return false;
+        }
+        ExtendedMessageFormat rhs = (ExtendedMessageFormat)obj;
+        if (ObjectUtils.notEqual(toPattern, rhs.toPattern)) {
+            return false;
+        }
+        if (ObjectUtils.notEqual(registry, rhs.registry)) {
+            return false;
+        }
+        return true;
+    }
 
     /**
      * Return the hashcode.
      *
      * @return the hashcode
      */
+    @Override
+    public int hashCode() {
+        int result = super.hashCode();
+        result = HASH_SEED * result + ObjectUtils.hashCode(registry);
+        result = HASH_SEED * result + ObjectUtils.hashCode(toPattern);
+        return result;
+    }
 
     /**
      * Get a custom format from a format description.
","@@ -70,6 +70,7 @@
  */
 public class ExtendedMessageFormat extends MessageFormat {
     private static final long serialVersionUID = -2362048321261811743L;
+    private static final int HASH_SEED = 31;
 
     private static final String DUMMY_PATTERN = """";
     private static final String ESCAPED_QUOTE = ""''"";
@@ -260,12 +261,42 @@ public void setFormatsByArgumentIndex(Format[] newFormats) {
      * @param obj the object to compare to
      * @return true if this object equals the other, otherwise false
      */
+    @Override
+    public boolean equals(Object obj) {
+        if (obj == this) {
+            return true;
+        }
+        if (obj == null) {
+            return false;
+        }
+        if (!super.equals(obj)) {
+            return false;
+        }
+        if (ObjectUtils.notEqual(getClass(), obj.getClass())) {
+          return false;
+        }
+        ExtendedMessageFormat rhs = (ExtendedMessageFormat)obj;
+        if (ObjectUtils.notEqual(toPattern, rhs.toPattern)) {
+            return false;
+        }
+        if (ObjectUtils.notEqual(registry, rhs.registry)) {
+            return false;
+        }
+        return true;
+    }
 
     /**
      * Return the hashcode.
      *
      * @return the hashcode
      */
+    @Override
+    public int hashCode() {
+        int result = super.hashCode();
+        result = HASH_SEED * result + ObjectUtils.hashCode(registry);
+        result = HASH_SEED * result + ObjectUtils.hashCode(toPattern);
+        return result;
+    }
 
     /**
      * Get a custom format from a format description.
"
181,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/math/Fraction.java","@@ -580,8 +580,14 @@ public Fraction pow(int power) {
      */
     private static int greatestCommonDivisor(int u, int v) {
         // From Commons Math:
+        if ((u == 0) || (v == 0)) {
+            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {
+                throw new ArithmeticException(""overflow: gcd is 2^31"");
+            }
+            return Math.abs(u) + Math.abs(v);
+        }
         //if either operand is abs 1, return 1:
+        if (Math.abs(u) == 1 || Math.abs(v) == 1) {
             return 1;
         }
         // keep u and v negative, as negative integers range down to
","@@ -580,8 +580,14 @@ public Fraction pow(int power) {
      */
     private static int greatestCommonDivisor(int u, int v) {
         // From Commons Math:
+        if ((u == 0) || (v == 0)) {
+            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {
+                throw new ArithmeticException(""overflow: gcd is 2^31"");
+            }
+            return Math.abs(u) + Math.abs(v);
+        }
         //if either operand is abs 1, return 1:
+        if (Math.abs(u) == 1 || Math.abs(v) == 1) {
             return 1;
         }
         // keep u and v negative, as negative integers range down to
"
182,"java.lang.NullPointerException","/src/main/java/org/apache/commons/lang3/StringUtils.java","@@ -3295,7 +3295,7 @@ public static String join(Object[] array, char separator, int startIndex, int en
             return EMPTY;
         }
         
+        StringBuilder buf = new StringBuilder(noOfItems * 16);
 
         for (int i = startIndex; i < endIndex; i++) {
             if (i > startIndex) {
@@ -3380,7 +3380,7 @@ public static String join(Object[] array, String separator, int startIndex, int
             return EMPTY;
         }
 
+        StringBuilder buf = new StringBuilder(noOfItems * 16);
 
         for (int i = startIndex; i < endIndex; i++) {
             if (i > startIndex) {
","@@ -3295,7 +3295,7 @@ public static String join(Object[] array, char separator, int startIndex, int en
             return EMPTY;
         }
         
+        StringBuilder buf = new StringBuilder(noOfItems * 16);
 
         for (int i = startIndex; i < endIndex; i++) {
             if (i > startIndex) {
@@ -3380,7 +3380,7 @@ public static String join(Object[] array, String separator, int startIndex, int
             return EMPTY;
         }
 
+        StringBuilder buf = new StringBuilder(noOfItems * 16);
 
         for (int i = startIndex; i < endIndex; i++) {
             if (i > startIndex) {
"
183,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/math/NumberUtils.java","@@ -1410,7 +1410,7 @@ public static boolean isNumber(String str) {
             if (chars[i] == 'l'
                 || chars[i] == 'L') {
                 // not allowing L with an exponent or decimal point
+                return foundDigit && !hasExp && !hasDecPoint;
             }
             // last character is illegal
             return false;
","@@ -1410,7 +1410,7 @@ public static boolean isNumber(String str) {
             if (chars[i] == 'l'
                 || chars[i] == 'L') {
                 // not allowing L with an exponent or decimal point
+                return foundDigit && !hasExp && !hasDecPoint;
             }
             // last character is illegal
             return false;
"
184,"junit.framework.ComparisonFailure","/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java","@@ -817,7 +817,7 @@ public String format(long millis) {
      * @return the formatted string
      */
     public String format(Date date) {
+        Calendar c = new GregorianCalendar(mTimeZone, mLocale);
         c.setTime(date);
         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
     }
","@@ -817,7 +817,7 @@ public String format(long millis) {
      * @return the formatted string
      */
     public String format(Date date) {
+        Calendar c = new GregorianCalendar(mTimeZone, mLocale);
         c.setTime(date);
         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
     }
"
185,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java","@@ -71,33 +71,33 @@
         {""\u00C7"", ""&Ccedil;""}, //  - uppercase C, cedilla
         {""\u00C8"", ""&Egrave;""}, //  - uppercase E, grave accent
         {""\u00C9"", ""&Eacute;""}, //  - uppercase E, acute accent
+        {""\u00CA"", ""&Ecirc;""}, //  - uppercase E, circumflex accent
+        {""\u00CB"", ""&Euml;""}, //  - uppercase E, umlaut
+        {""\u00CC"", ""&Igrave;""}, //  - uppercase I, grave accent
+        {""\u00CD"", ""&Iacute;""}, //  - uppercase I, acute accent
+        {""\u00CE"", ""&Icirc;""}, //  - uppercase I, circumflex accent
+        {""\u00CF"", ""&Iuml;""}, //  - uppercase I, umlaut
+        {""\u00D0"", ""&ETH;""}, //  - uppercase Eth, Icelandic
+        {""\u00D1"", ""&Ntilde;""}, //  - uppercase N, tilde
+        {""\u00D2"", ""&Ograve;""}, //  - uppercase O, grave accent
+        {""\u00D3"", ""&Oacute;""}, //  - uppercase O, acute accent
+        {""\u00D4"", ""&Ocirc;""}, //  - uppercase O, circumflex accent
+        {""\u00D5"", ""&Otilde;""}, //  - uppercase O, tilde
+        {""\u00D6"", ""&Ouml;""}, //  - uppercase O, umlaut
+        {""\u00D7"", ""&times;""}, // multiplication sign
+        {""\u00D8"", ""&Oslash;""}, //  - uppercase O, slash
+        {""\u00D9"", ""&Ugrave;""}, //  - uppercase U, grave accent
+        {""\u00DA"", ""&Uacute;""}, //  - uppercase U, acute accent
+        {""\u00DB"", ""&Ucirc;""}, //  - uppercase U, circumflex accent
+        {""\u00DC"", ""&Uuml;""}, //  - uppercase U, umlaut
+        {""\u00DD"", ""&Yacute;""}, //  - uppercase Y, acute accent
+        {""\u00DE"", ""&THORN;""}, //  - uppercase THORN, Icelandic
+        {""\u00DF"", ""&szlig;""}, //  - lowercase sharps, German
+        {""\u00E0"", ""&agrave;""}, //  - lowercase a, grave accent
+        {""\u00E1"", ""&aacute;""}, //  - lowercase a, acute accent
+        {""\u00E2"", ""&acirc;""}, //  - lowercase a, circumflex accent
+        {""\u00E3"", ""&atilde;""}, //  - lowercase a, tilde
+        {""\u00E4"", ""&auml;""}, //  - lowercase a, umlaut
         {""\u00E5"", ""&aring;""}, //  - lowercase a, ring
         {""\u00E6"", ""&aelig;""}, //  - lowercase ae
         {""\u00E7"", ""&ccedil;""}, //  - lowercase c, cedilla
","@@ -71,33 +71,33 @@
         {""\u00C7"", ""&Ccedil;""}, //  - uppercase C, cedilla
         {""\u00C8"", ""&Egrave;""}, //  - uppercase E, grave accent
         {""\u00C9"", ""&Eacute;""}, //  - uppercase E, acute accent
+        {""\u00CA"", ""&Ecirc;""}, //  - uppercase E, circumflex accent
+        {""\u00CB"", ""&Euml;""}, //  - uppercase E, umlaut
+        {""\u00CC"", ""&Igrave;""}, //  - uppercase I, grave accent
+        {""\u00CD"", ""&Iacute;""}, //  - uppercase I, acute accent
+        {""\u00CE"", ""&Icirc;""}, //  - uppercase I, circumflex accent
+        {""\u00CF"", ""&Iuml;""}, //  - uppercase I, umlaut
+        {""\u00D0"", ""&ETH;""}, //  - uppercase Eth, Icelandic
+        {""\u00D1"", ""&Ntilde;""}, //  - uppercase N, tilde
+        {""\u00D2"", ""&Ograve;""}, //  - uppercase O, grave accent
+        {""\u00D3"", ""&Oacute;""}, //  - uppercase O, acute accent
+        {""\u00D4"", ""&Ocirc;""}, //  - uppercase O, circumflex accent
+        {""\u00D5"", ""&Otilde;""}, //  - uppercase O, tilde
+        {""\u00D6"", ""&Ouml;""}, //  - uppercase O, umlaut
+        {""\u00D7"", ""&times;""}, // multiplication sign
+        {""\u00D8"", ""&Oslash;""}, //  - uppercase O, slash
+        {""\u00D9"", ""&Ugrave;""}, //  - uppercase U, grave accent
+        {""\u00DA"", ""&Uacute;""}, //  - uppercase U, acute accent
+        {""\u00DB"", ""&Ucirc;""}, //  - uppercase U, circumflex accent
+        {""\u00DC"", ""&Uuml;""}, //  - uppercase U, umlaut
+        {""\u00DD"", ""&Yacute;""}, //  - uppercase Y, acute accent
+        {""\u00DE"", ""&THORN;""}, //  - uppercase THORN, Icelandic
+        {""\u00DF"", ""&szlig;""}, //  - lowercase sharps, German
+        {""\u00E0"", ""&agrave;""}, //  - lowercase a, grave accent
+        {""\u00E1"", ""&aacute;""}, //  - lowercase a, acute accent
+        {""\u00E2"", ""&acirc;""}, //  - lowercase a, circumflex accent
+        {""\u00E3"", ""&atilde;""}, //  - lowercase a, tilde
+        {""\u00E4"", ""&auml;""}, //  - lowercase a, umlaut
         {""\u00E5"", ""&aring;""}, //  - lowercase a, ring
         {""\u00E6"", ""&aelig;""}, //  - lowercase ae
         {""\u00E7"", ""&ccedil;""}, //  - lowercase c, cedilla
"
186,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/SystemUtils.java","@@ -1669,7 +1669,7 @@ static float toJavaVersionFloat(String version) {
      * 
      * @return the version, for example 131 for Java 1.3.1
      */
+    static int toJavaVersionInt(String version) {
         return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));
     }
 
","@@ -1669,7 +1669,7 @@ static float toJavaVersionFloat(String version) {
      * 
      * @return the version, for example 131 for Java 1.3.1
      */
+    static int toJavaVersionInt(String version) {
         return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));
     }
 
"
187,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/StringUtils.java","@@ -1373,13 +1373,21 @@ public static int indexOfAny(CharSequence cs, char[] searchChars) {
             return INDEX_NOT_FOUND;
         }
         int csLen = cs.length();
+        int csLast = csLen - 1;
         int searchLen = searchChars.length;
+        int searchLast = searchLen - 1;
         for (int i = 0; i < csLen; i++) {
             char ch = cs.charAt(i);
             for (int j = 0; j < searchLen; j++) {
                 if (searchChars[j] == ch) {
+                    if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {
                         // ch is a supplementary character
+                        if (searchChars[j + 1] == cs.charAt(i + 1)) {
+                            return i;
+                        }
+                    } else {
                         return i;
+                    }
                 }
             }
         }
@@ -1440,7 +1448,7 @@ public static int indexOfAny(CharSequence cs, String searchChars) {
      * <code>false</code> if no match or null input
      * @since 2.4
      */
+    public static boolean containsAny(String cs, char[] searchChars) {
         if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
             return false;
         }
@@ -1452,9 +1460,12 @@ public static boolean containsAny(CharSequence cs, char[] searchChars) {
             char ch = cs.charAt(i);
             for (int j = 0; j < searchLength; j++) {
                 if (searchChars[j] == ch) {
+                    if (Character.isHighSurrogate(ch)) {
+                        if (j == searchLast) {
                             // missing low surrogate, fine, like String.indexOf(String)
+                            return true;
+                        }
+                        if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {
                             return true;
                         }
                     } else {
@@ -1494,7 +1505,7 @@ public static boolean containsAny(CharSequence cs, char[] searchChars) {
      * @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input
      * @since 2.4
      */
+    public static boolean containsAny(String cs, String searchChars) {
         if (searchChars == null) {
             return false;
         }
@@ -1530,13 +1541,21 @@ public static int indexOfAnyBut(CharSequence cs, char[] searchChars) {
             return INDEX_NOT_FOUND;
         }
         int csLen = cs.length();
+        int csLast = csLen - 1;
         int searchLen = searchChars.length;
+        int searchLast = searchLen - 1;
         outer:
         for (int i = 0; i < csLen; i++) {
             char ch = cs.charAt(i);
             for (int j = 0; j < searchLen; j++) {
                 if (searchChars[j] == ch) {
+                    if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {
+                        if (searchChars[j + 1] == cs.charAt(i + 1)) {
+                            continue outer;
+                        }
+                    } else {
                         continue outer;
+                    }
                 }
             }
             return i;
@@ -1573,8 +1592,16 @@ public static int indexOfAnyBut(String str, String searchChars) {
         int strLen = str.length();
         for (int i = 0; i < strLen; i++) {
             char ch = str.charAt(i);
+            boolean chFound = searchChars.indexOf(ch) >= 0;
+            if (i + 1 < strLen && Character.isHighSurrogate(ch)) {
+                char ch2 = str.charAt(i + 1);
+                if (chFound && searchChars.indexOf(ch2) < 0) {
                     return i;
+                }
+            } else {
+                if (!chFound) {
+                    return i;
+                }
             }
         }
         return INDEX_NOT_FOUND;
@@ -1675,14 +1702,25 @@ public static boolean containsNone(CharSequence cs, char[] searchChars) {
             return true;
         }
         int csLen = cs.length();
+        int csLast = csLen - 1;
         int searchLen = searchChars.length;
+        int searchLast = searchLen - 1;
         for (int i = 0; i < csLen; i++) {
             char ch = cs.charAt(i);
             for (int j = 0; j < searchLen; j++) {
                 if (searchChars[j] == ch) {
+                    if (Character.isHighSurrogate(ch)) {
+                        if (j == searchLast) {
                             // missing low surrogate, fine, like String.indexOf(String)
+                            return false;
+                        }
+                        if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {
+                            return false;
+                        }
+                    } else {
                         // ch is in the Basic Multilingual Plane
                         return false;
+                    }
                 }
             }
         }
","@@ -1373,13 +1373,21 @@ public static int indexOfAny(CharSequence cs, char[] searchChars) {
             return INDEX_NOT_FOUND;
         }
         int csLen = cs.length();
+        int csLast = csLen - 1;
         int searchLen = searchChars.length;
+        int searchLast = searchLen - 1;
         for (int i = 0; i < csLen; i++) {
             char ch = cs.charAt(i);
             for (int j = 0; j < searchLen; j++) {
                 if (searchChars[j] == ch) {
+                    if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {
                         // ch is a supplementary character
+                        if (searchChars[j + 1] == cs.charAt(i + 1)) {
+                            return i;
+                        }
+                    } else {
                         return i;
+                    }
                 }
             }
         }
@@ -1440,7 +1448,7 @@ public static int indexOfAny(CharSequence cs, String searchChars) {
      * <code>false</code> if no match or null input
      * @since 2.4
      */
+    public static boolean containsAny(String cs, char[] searchChars) {
         if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
             return false;
         }
@@ -1452,9 +1460,12 @@ public static boolean containsAny(CharSequence cs, char[] searchChars) {
             char ch = cs.charAt(i);
             for (int j = 0; j < searchLength; j++) {
                 if (searchChars[j] == ch) {
+                    if (Character.isHighSurrogate(ch)) {
+                        if (j == searchLast) {
                             // missing low surrogate, fine, like String.indexOf(String)
+                            return true;
+                        }
+                        if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {
                             return true;
                         }
                     } else {
@@ -1494,7 +1505,7 @@ public static boolean containsAny(CharSequence cs, char[] searchChars) {
      * @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input
      * @since 2.4
      */
+    public static boolean containsAny(String cs, String searchChars) {
         if (searchChars == null) {
             return false;
         }
@@ -1530,13 +1541,21 @@ public static int indexOfAnyBut(CharSequence cs, char[] searchChars) {
             return INDEX_NOT_FOUND;
         }
         int csLen = cs.length();
+        int csLast = csLen - 1;
         int searchLen = searchChars.length;
+        int searchLast = searchLen - 1;
         outer:
         for (int i = 0; i < csLen; i++) {
             char ch = cs.charAt(i);
             for (int j = 0; j < searchLen; j++) {
                 if (searchChars[j] == ch) {
+                    if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {
+                        if (searchChars[j + 1] == cs.charAt(i + 1)) {
+                            continue outer;
+                        }
+                    } else {
                         continue outer;
+                    }
                 }
             }
             return i;
@@ -1573,8 +1592,16 @@ public static int indexOfAnyBut(String str, String searchChars) {
         int strLen = str.length();
         for (int i = 0; i < strLen; i++) {
             char ch = str.charAt(i);
+            boolean chFound = searchChars.indexOf(ch) >= 0;
+            if (i + 1 < strLen && Character.isHighSurrogate(ch)) {
+                char ch2 = str.charAt(i + 1);
+                if (chFound && searchChars.indexOf(ch2) < 0) {
                     return i;
+                }
+            } else {
+                if (!chFound) {
+                    return i;
+                }
             }
         }
         return INDEX_NOT_FOUND;
@@ -1675,14 +1702,25 @@ public static boolean containsNone(CharSequence cs, char[] searchChars) {
             return true;
         }
         int csLen = cs.length();
+        int csLast = csLen - 1;
         int searchLen = searchChars.length;
+        int searchLast = searchLen - 1;
         for (int i = 0; i < csLen; i++) {
             char ch = cs.charAt(i);
             for (int j = 0; j < searchLen; j++) {
                 if (searchChars[j] == ch) {
+                    if (Character.isHighSurrogate(ch)) {
+                        if (j == searchLast) {
                             // missing low surrogate, fine, like String.indexOf(String)
+                            return false;
+                        }
+                        if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {
+                            return false;
+                        }
+                    } else {
                         // ch is in the Basic Multilingual Plane
                         return false;
+                    }
                 }
             }
         }
"
188,"junit.framework.ComparisonFailure","/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java","@@ -60,7 +60,13 @@ public int translate(CharSequence input, int index, Writer out) throws IOExcepti
                 return 0;
             }
 
+            if(entityValue > 0xFFFF) {
+                char[] chrs = Character.toChars(entityValue);
+                out.write(chrs[0]);
+                out.write(chrs[1]);
+            } else {
                 out.write(entityValue);
+            }
             return 2 + (end - start) + (isHex ? 1 : 0) + 1;
         }
         return 0;
","@@ -60,7 +60,13 @@ public int translate(CharSequence input, int index, Writer out) throws IOExcepti
                 return 0;
             }
 
+            if(entityValue > 0xFFFF) {
+                char[] chrs = Character.toChars(entityValue);
+                out.write(chrs[0]);
+                out.write(chrs[1]);
+            } else {
                 out.write(entityValue);
+            }
             return 2 + (end - start) + (isHex ? 1 : 0) + 1;
         }
         return 0;
"
189,"java.lang.StringIndexOutOfBoundsException","/src/main/java/org/apache/commons/lang3/math/NumberUtils.java","@@ -476,7 +476,7 @@ public static Number createNumber(String str) throws NumberFormatException {
         if (decPos > -1) {
 
             if (expPos > -1) {
+                if (expPos < decPos || expPos > str.length()) {
                     throw new NumberFormatException(str + "" is not a valid number."");
                 }
                 dec = str.substring(decPos + 1, expPos);
@@ -486,6 +486,9 @@ public static Number createNumber(String str) throws NumberFormatException {
             mant = str.substring(0, decPos);
         } else {
             if (expPos > -1) {
+                if (expPos > str.length()) {
+                    throw new NumberFormatException(str + "" is not a valid number."");
+                }
                 mant = str.substring(0, expPos);
             } else {
                 mant = str;
","@@ -476,7 +476,7 @@ public static Number createNumber(String str) throws NumberFormatException {
         if (decPos > -1) {
 
             if (expPos > -1) {
+                if (expPos < decPos || expPos > str.length()) {
                     throw new NumberFormatException(str + "" is not a valid number."");
                 }
                 dec = str.substring(decPos + 1, expPos);
@@ -486,6 +486,9 @@ public static Number createNumber(String str) throws NumberFormatException {
             mant = str.substring(0, decPos);
         } else {
             if (expPos > -1) {
+                if (expPos > str.length()) {
+                    throw new NumberFormatException(str + "" is not a valid number."");
+                }
                 mant = str.substring(0, expPos);
             } else {
                 mant = str;
"
190,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/StringUtils.java","@@ -1443,13 +1443,21 @@ public static boolean containsAny(CharSequence cs, char[] searchChars) {
 		}
 		int csLength = cs.length();
 		int searchLength = searchChars.length;
+		int csLastIndex = csLength - 1;
+		int searchLastIndex = searchLength - 1;
 		for (int i = 0; i < csLength; i++) {
 			char ch = cs.charAt(i);
 			for (int j = 0; j < searchLength; j++) {
 				if (searchChars[j] == ch) {
+					if (i < csLastIndex && j < searchLastIndex && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {
 						// ch is a supplementary character
+						if (searchChars[j + 1] == cs.charAt(i + 1)) {
+							return true;
+						}
+					} else {
 						// ch is in the Basic Multilingual Plane
 						return true;
+					}
 				}
 			}
 		}
","@@ -1443,13 +1443,21 @@ public static boolean containsAny(CharSequence cs, char[] searchChars) {
 		}
 		int csLength = cs.length();
 		int searchLength = searchChars.length;
+		int csLastIndex = csLength - 1;
+		int searchLastIndex = searchLength - 1;
 		for (int i = 0; i < csLength; i++) {
 			char ch = cs.charAt(i);
 			for (int j = 0; j < searchLength; j++) {
 				if (searchChars[j] == ch) {
+					if (i < csLastIndex && j < searchLastIndex && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {
 						// ch is a supplementary character
+						if (searchChars[j + 1] == cs.charAt(i + 1)) {
+							return true;
+						}
+					} else {
 						// ch is in the Basic Multilingual Plane
 						return true;
+					}
 				}
 			}
 		}
"
191,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java","@@ -101,12 +101,7 @@
      * 
      * @since 2.3
      */
+    private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>();
 
     /*
      * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()
@@ -149,7 +144,8 @@
      * @since 2.3
      */
     static boolean isRegistered(Object value) {
+        Set<IDKey> registry = getRegistry();
+        return registry != null && registry.contains(new IDKey(value));
     }
 
     /**
@@ -519,6 +515,11 @@ public static int reflectionHashCode(Object object, String[] excludeFields) {
      *            The object to register.
      */
     static void register(Object value) {
+        synchronized (HashCodeBuilder.class) {
+            if (getRegistry() == null) {
+                REGISTRY.set(new HashSet<IDKey>());
+            }
+        }
         getRegistry().add(new IDKey(value));
     }
 
@@ -535,7 +536,15 @@ static void register(Object value) {
      * @since 2.3
      */
     static void unregister(Object value) {
+        Set<IDKey> s = getRegistry();
+        if (s != null) {
+            s.remove(new IDKey(value));
+            synchronized (HashCodeBuilder.class) {
+                if (s.isEmpty()) {
+                    REGISTRY.remove();
+                }
+            }
+        }
     }
 
     /**
","@@ -101,12 +101,7 @@
      * 
      * @since 2.3
      */
+    private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>();
 
     /*
      * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()
@@ -149,7 +144,8 @@
      * @since 2.3
      */
     static boolean isRegistered(Object value) {
+        Set<IDKey> registry = getRegistry();
+        return registry != null && registry.contains(new IDKey(value));
     }
 
     /**
@@ -519,6 +515,11 @@ public static int reflectionHashCode(Object object, String[] excludeFields) {
      *            The object to register.
      */
     static void register(Object value) {
+        synchronized (HashCodeBuilder.class) {
+            if (getRegistry() == null) {
+                REGISTRY.set(new HashSet<IDKey>());
+            }
+        }
         getRegistry().add(new IDKey(value));
     }
 
@@ -535,7 +536,15 @@ static void register(Object value) {
      * @since 2.3
      */
     static void unregister(Object value) {
+        Set<IDKey> s = getRegistry();
+        if (s != null) {
+            s.remove(new IDKey(value));
+            synchronized (HashCodeBuilder.class) {
+                if (s.isEmpty()) {
+                    REGISTRY.remove();
+                }
+            }
+        }
     }
 
     /**
"
192,"java.lang.NullPointerException","/src/main/java/org/apache/commons/lang3/ClassUtils.java","@@ -907,7 +907,7 @@ private static String toCanonicalName(String className) {
         }
         Class<?>[] classes = new Class[array.length];
         for (int i = 0; i < array.length; i++) {
+            classes[i] = array[i] == null ? null : array[i].getClass();
         }
         return classes;
     }
","@@ -907,7 +907,7 @@ private static String toCanonicalName(String className) {
         }
         Class<?>[] classes = new Class[array.length];
         for (int i = 0; i < array.length; i++) {
+            classes[i] = array[i] == null ? null : array[i].getClass();
         }
         return classes;
     }
"
193,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java","@@ -145,7 +145,7 @@
      * @return Set the registry of objects being traversed
      */
     static Map<Object, Object> getRegistry() {
+        return REGISTRY.get();
     }
 
     /**
@@ -161,7 +161,7 @@
      */
     static boolean isRegistered(Object value) {
         Map<Object, Object> m = getRegistry();
+        return m != null && m.containsKey(value);
     }
 
     /**
","@@ -145,7 +145,7 @@
      * @return Set the registry of objects being traversed
      */
     static Map<Object, Object> getRegistry() {
+        return REGISTRY.get();
     }
 
     /**
@@ -161,7 +161,7 @@
      */
     static boolean isRegistered(Object value) {
         Map<Object, Object> m = getRegistry();
+        return m != null && m.containsKey(value);
     }
 
     /**
"
194,"java.lang.ArrayStoreException","/src/java/org/apache/commons/lang3/ArrayUtils.java","@@ -2959,8 +2959,16 @@ public static boolean isEmpty(boolean[] array) {
         final Class<?> type1 = array1.getClass().getComponentType();
         T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);
         System.arraycopy(array1, 0, joinedArray, 0, array1.length);
+        try {
             System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
+        } catch (ArrayStoreException ase) {
             // Check if problem is incompatible types
+            final Class<?> type2 = array2.getClass().getComponentType();
+            if (!type1.isAssignableFrom(type2)){
+                throw new IllegalArgumentException(""Cannot store ""+type2.getName()+"" in an array of ""+type1.getName());
+            }
+            throw ase; // No, so rethrow original
+        }
         return joinedArray;
     }
 
","@@ -2959,8 +2959,16 @@ public static boolean isEmpty(boolean[] array) {
         final Class<?> type1 = array1.getClass().getComponentType();
         T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);
         System.arraycopy(array1, 0, joinedArray, 0, array1.length);
+        try {
             System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
+        } catch (ArrayStoreException ase) {
             // Check if problem is incompatible types
+            final Class<?> type2 = array2.getClass().getComponentType();
+            if (!type1.isAssignableFrom(type2)){
+                throw new IllegalArgumentException(""Cannot store ""+type2.getName()+"" in an array of ""+type1.getName());
+            }
+            throw ase; // No, so rethrow original
+        }
         return joinedArray;
     }
 
"
195,"java.lang.ClassCastException","/src/main/java/org/apache/commons/lang3/ArrayUtils.java","@@ -3292,7 +3292,7 @@ public static boolean isEmpty(boolean[] array) {
         } else if (element != null) {
             type = element.getClass();
         } else {
+            throw new IllegalArgumentException(""Arguments cannot both be null"");            
         }
         @SuppressWarnings(""unchecked"") // type must be T
         T[] newArray = (T[]) copyArrayGrow1(array, type);
@@ -3571,7 +3571,7 @@ private static Object copyArrayGrow1(Object array, Class<?> newArrayComponentTyp
         } else if (element != null) {
             clss = element.getClass();
         } else {
+            throw new IllegalArgumentException(""Array and element cannot both be null"");            
         }
         @SuppressWarnings(""unchecked"") // the add method creates an array of type clss, which is type T
         final T[] newArray = (T[]) add(array, index, element, clss);
","@@ -3292,7 +3292,7 @@ public static boolean isEmpty(boolean[] array) {
         } else if (element != null) {
             type = element.getClass();
         } else {
+            throw new IllegalArgumentException(""Arguments cannot both be null"");            
         }
         @SuppressWarnings(""unchecked"") // type must be T
         T[] newArray = (T[]) copyArrayGrow1(array, type);
@@ -3571,7 +3571,7 @@ private static Object copyArrayGrow1(Object array, Class<?> newArrayComponentTyp
         } else if (element != null) {
             clss = element.getClass();
         } else {
+            throw new IllegalArgumentException(""Array and element cannot both be null"");            
         }
         @SuppressWarnings(""unchecked"") // the add method creates an array of type clss, which is type T
         final T[] newArray = (T[]) add(array, index, element, clss);
"
196,"junit.framework.ComparisonFailure","/src/java/org/apache/commons/lang3/time/FastDateFormat.java","@@ -869,6 +869,7 @@ public StringBuffer format(Date date, StringBuffer buf) {
      */
     public StringBuffer format(Calendar calendar, StringBuffer buf) {
         if (mTimeZoneForced) {
+            calendar.getTime(); /// LANG-538
             calendar = (Calendar) calendar.clone();
             calendar.setTimeZone(mTimeZone);
         }
","@@ -869,6 +869,7 @@ public StringBuffer format(Date date, StringBuffer buf) {
      */
     public StringBuffer format(Calendar calendar, StringBuffer buf) {
         if (mTimeZoneForced) {
+            calendar.getTime(); /// LANG-538
             calendar = (Calendar) calendar.clone();
             calendar.setTimeZone(mTimeZone);
         }
"
197,"junit.framework.ComparisonFailure","/src/java/org/apache/commons/lang/Entities.java","@@ -825,10 +825,15 @@ public String escape(String str) {
     public void escape(Writer writer, String str) throws IOException {
         int len = str.length();
         for (int i = 0; i < len; i++) {
+            int c = Character.codePointAt(str, i); 
             String entityName = this.entityName(c);
             if (entityName == null) {
+                if (c >= 0x010000 && i < len - 1) {
+                    writer.write(""&#"");
+                    writer.write(Integer.toString(c, 10));
+                    writer.write(';');
+                    i++;
+                } else if (c > 0x7F) { 
                     writer.write(""&#"");
                     writer.write(Integer.toString(c, 10));
                     writer.write(';');
","@@ -825,10 +825,15 @@ public String escape(String str) {
     public void escape(Writer writer, String str) throws IOException {
         int len = str.length();
         for (int i = 0; i < len; i++) {
+            int c = Character.codePointAt(str, i); 
             String entityName = this.entityName(c);
             if (entityName == null) {
+                if (c >= 0x010000 && i < len - 1) {
+                    writer.write(""&#"");
+                    writer.write(Integer.toString(c, 10));
+                    writer.write(';');
+                    i++;
+                } else if (c > 0x7F) { 
                     writer.write(""&#"");
                     writer.write(Integer.toString(c, 10));
                     writer.write(';');
"
198,"java.lang.OutOfMemoryError","/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java","@@ -419,6 +419,7 @@ private StringBuffer appendQuotedString(String pattern, ParsePosition pos,
         int start = pos.getIndex();
         char[] c = pattern.toCharArray();
         if (escapingOn && c[start] == QUOTE) {
+            next(pos);
             return appendTo == null ? null : appendTo.append(QUOTE);
         }
         int lastHold = start;
","@@ -419,6 +419,7 @@ private StringBuffer appendQuotedString(String pattern, ParsePosition pos,
         int start = pos.getIndex();
         char[] c = pattern.toCharArray();
         if (escapingOn && c[start] == QUOTE) {
+            next(pos);
             return appendTo == null ? null : appendTo.append(QUOTE);
         }
         int lastHold = start;
"
199,"java.lang.NumberFormatException","/src/java/org/apache/commons/lang3/math/NumberUtils.java","@@ -488,7 +488,7 @@ public static Number createNumber(String str) throws NumberFormatException {
             }
             dec = null;
         }
+        if (!Character.isDigit(lastChar) && lastChar != '.') {
             if (expPos > -1 && expPos < str.length() - 1) {
                 exp = str.substring(expPos + 1, str.length() - 1);
             } else {
@@ -1385,6 +1385,14 @@ public static boolean isNumber(String str) {
                 // can't have an E at the last byte
                 return false;
             }
+            if (chars[i] == '.') {
+                if (hasDecPoint || hasExp) {
+                    // two decimal points or dec in exponent
+                    return false;
+                }
+                // single trailing decimal point after non-exponent is ok
+                return foundDigit;
+            }
             if (!allowSigns
                 && (chars[i] == 'd'
                     || chars[i] == 'D'
","@@ -488,7 +488,7 @@ public static Number createNumber(String str) throws NumberFormatException {
             }
             dec = null;
         }
+        if (!Character.isDigit(lastChar) && lastChar != '.') {
             if (expPos > -1 && expPos < str.length() - 1) {
                 exp = str.substring(expPos + 1, str.length() - 1);
             } else {
@@ -1385,6 +1385,14 @@ public static boolean isNumber(String str) {
                 // can't have an E at the last byte
                 return false;
             }
+            if (chars[i] == '.') {
+                if (hasDecPoint || hasExp) {
+                    // two decimal points or dec in exponent
+                    return false;
+                }
+                // single trailing decimal point after non-exponent is ok
+                return foundDigit;
+            }
             if (!allowSigns
                 && (chars[i] == 'd'
                     || chars[i] == 'D'
"
200,"java.lang.NullPointerException","/src/java/org/apache/commons/lang3/StringUtils.java","@@ -3673,6 +3673,9 @@ private static String replaceEach(String text, String[] searchList, String[] rep
 
         // count the replacement text elements that are larger than their corresponding text being replaced
         for (int i = 0; i < searchList.length; i++) {
+            if (searchList[i] == null || replacementList[i] == null) {
+                continue;
+            }
             int greater = replacementList[i].length() - searchList[i].length();
             if (greater > 0) {
                 increase += 3 * greater; // assume 3 matches
","@@ -3673,6 +3673,9 @@ private static String replaceEach(String text, String[] searchList, String[] rep
 
         // count the replacement text elements that are larger than their corresponding text being replaced
         for (int i = 0; i < searchList.length; i++) {
+            if (searchList[i] == null || replacementList[i] == null) {
+                continue;
+            }
             int greater = replacementList[i].length() - searchList[i].length();
             if (greater > 0) {
                 increase += 3 * greater; // assume 3 matches
"
201,"junit.framework.ComparisonFailure","/src/java/org/apache/commons/lang/ClassUtils.java","@@ -188,10 +188,23 @@ public static String getShortClassName(String className) {
             return StringUtils.EMPTY;
         }
 
+        StringBuffer arrayPrefix = new StringBuffer();
 
         // Handle array encoding
+        if (className.startsWith(""["")) {
+            while (className.charAt(0) == '[') {
+                className = className.substring(1);
+                arrayPrefix.append(""[]"");
+            }
             // Strip Object type encoding
+            if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {
+                className = className.substring(1, className.length() - 1);
+            }
+        }
 
+        if (reverseAbbreviationMap.containsKey(className)) {
+            className = reverseAbbreviationMap.get(className);
+        }
 
         int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
         int innerIdx = className.indexOf(
@@ -200,7 +213,7 @@ public static String getShortClassName(String className) {
         if (innerIdx != -1) {
             out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
         }
+        return out + arrayPrefix;
     }
 
     // Package name
@@ -242,12 +255,18 @@ public static String getPackageName(Class<?> cls) {
      * @return the package name or an empty string
      */
     public static String getPackageName(String className) {
+        if (className == null || className.length() == 0) {
             return StringUtils.EMPTY;
         }
 
         // Strip array encoding
+        while (className.charAt(0) == '[') {
+            className = className.substring(1);
+        }
         // Strip Object type encoding
+        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {
+            className = className.substring(1);
+        }
 
         int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
         if (i == -1) {
","@@ -188,10 +188,23 @@ public static String getShortClassName(String className) {
             return StringUtils.EMPTY;
         }
 
+        StringBuffer arrayPrefix = new StringBuffer();
 
         // Handle array encoding
+        if (className.startsWith(""["")) {
+            while (className.charAt(0) == '[') {
+                className = className.substring(1);
+                arrayPrefix.append(""[]"");
+            }
             // Strip Object type encoding
+            if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {
+                className = className.substring(1, className.length() - 1);
+            }
+        }
 
+        if (reverseAbbreviationMap.containsKey(className)) {
+            className = reverseAbbreviationMap.get(className);
+        }
 
         int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
         int innerIdx = className.indexOf(
@@ -200,7 +213,7 @@ public static String getShortClassName(String className) {
         if (innerIdx != -1) {
             out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
         }
+        return out + arrayPrefix;
     }
 
     // Package name
@@ -242,12 +255,18 @@ public static String getPackageName(Class<?> cls) {
      * @return the package name or an empty string
      */
     public static String getPackageName(String className) {
+        if (className == null || className.length() == 0) {
             return StringUtils.EMPTY;
         }
 
         // Strip array encoding
+        while (className.charAt(0) == '[') {
+            className = className.substring(1);
+        }
         // Strip Object type encoding
+        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {
+            className = className.substring(1);
+        }
 
         int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
         if (i == -1) {
"
202,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/lang/StringUtils.java","@@ -1045,7 +1045,14 @@ public static boolean containsIgnoreCase(String str, String searchStr) {
         if (str == null || searchStr == null) {
             return false;
         }
+        int len = searchStr.length();
+        int max = str.length() - len;
+        for (int i = 0; i <= max; i++) {
+            if (str.regionMatches(true, i, searchStr, 0, len)) {
+                return true;
+            }
+        }
+        return false;
     }
 
     // IndexOfAny chars
","@@ -1045,7 +1045,14 @@ public static boolean containsIgnoreCase(String str, String searchStr) {
         if (str == null || searchStr == null) {
             return false;
         }
+        int len = searchStr.length();
+        int max = str.length() - len;
+        for (int i = 0; i <= max; i++) {
+            if (str.regionMatches(true, i, searchStr, 0, len)) {
+                return true;
+            }
+        }
+        return false;
     }
 
     // IndexOfAny chars
"
203,"java.lang.StringIndexOutOfBoundsException","/src/java/org/apache/commons/lang/NumberUtils.java","@@ -142,6 +142,9 @@ public static Number createNumber(String val) throws NumberFormatException {
         if (val.length() == 0) {
             throw new NumberFormatException(""\""\"" is not a valid number."");
         }
+        if (val.length() == 1 && !Character.isDigit(val.charAt(0))) {
+            throw new NumberFormatException(val + "" is not a valid number."");
+        }
         if (val.startsWith(""--"")) {
             // this is protection for poorness in java.lang.BigDecimal.
             // it accepts this as a legal value, but it does not appear 
","@@ -142,6 +142,9 @@ public static Number createNumber(String val) throws NumberFormatException {
         if (val.length() == 0) {
             throw new NumberFormatException(""\""\"" is not a valid number."");
         }
+        if (val.length() == 1 && !Character.isDigit(val.charAt(0))) {
+            throw new NumberFormatException(val + "" is not a valid number."");
+        }
         if (val.startsWith(""--"")) {
             // this is protection for poorness in java.lang.BigDecimal.
             // it accepts this as a legal value, but it does not appear 
"
204,"java.lang.StringIndexOutOfBoundsException","/src/java/org/apache/commons/lang/WordUtils.java","@@ -613,6 +613,9 @@ public static String abbreviate(String str, int lower, int upper, String appendT
 
         // if the lower value is greater than the length of the string,
         // set to the length of the string
+        if (lower > str.length()) {
+            lower = str.length();    
+        }
         // if the upper value is -1 (i.e. no limit) or is greater
         // than the length of the string, set to the length of the string
         if (upper == -1 || upper > str.length()) {
","@@ -613,6 +613,9 @@ public static String abbreviate(String str, int lower, int upper, String appendT
 
         // if the lower value is greater than the length of the string,
         // set to the length of the string
+        if (lower > str.length()) {
+            lower = str.length();    
+        }
         // if the upper value is -1 (i.e. no limit) or is greater
         // than the length of the string, set to the length of the string
         if (upper == -1 || upper > str.length()) {
"
205,"java.lang.NullPointerException","/src/java/org/apache/commons/lang/text/StrBuilder.java","@@ -1183,6 +1183,9 @@ public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {
         if (width > 0) {
             ensureCapacity(size + width);
             String str = (obj == null ? getNullText() : obj.toString());
+            if (str == null) {
+                str = """";
+            }
             int strLen = str.length();
             if (strLen >= width) {
                 str.getChars(strLen - width, strLen, buffer, size);
@@ -1227,6 +1230,9 @@ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar)
         if (width > 0) {
             ensureCapacity(size + width);
             String str = (obj == null ? getNullText() : obj.toString());
+            if (str == null) {
+                str = """";
+            }
             int strLen = str.length();
             if (strLen >= width) {
                 str.getChars(0, width, buffer, size);
","@@ -1183,6 +1183,9 @@ public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {
         if (width > 0) {
             ensureCapacity(size + width);
             String str = (obj == null ? getNullText() : obj.toString());
+            if (str == null) {
+                str = """";
+            }
             int strLen = str.length();
             if (strLen >= width) {
                 str.getChars(strLen - width, strLen, buffer, size);
@@ -1227,6 +1230,9 @@ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar)
         if (width > 0) {
             ensureCapacity(size + width);
             String str = (obj == null ? getNullText() : obj.toString());
+            if (str == null) {
+                str = """";
+            }
             int strLen = str.length();
             if (strLen >= width) {
                 str.getChars(0, width, buffer, size);
"
206,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/lang/builder/EqualsBuilder.java","@@ -377,8 +377,12 @@ public EqualsBuilder append(Object lhs, Object rhs) {
         }
         Class lhsClass = lhs.getClass();
         if (!lhsClass.isArray()) {
+            if (lhs instanceof java.math.BigDecimal) {
+                isEquals = (((java.math.BigDecimal)lhs).compareTo(rhs) == 0);
+            } else {
                 // The simple case, not an array, just test the element
                 isEquals = lhs.equals(rhs);
+            }
         } else if (lhs.getClass() != rhs.getClass()) {
             // Here when we compare different dimensions, for example: a boolean[][] to a boolean[] 
             this.setEquals(false);
","@@ -377,8 +377,12 @@ public EqualsBuilder append(Object lhs, Object rhs) {
         }
         Class lhsClass = lhs.getClass();
         if (!lhsClass.isArray()) {
+            if (lhs instanceof java.math.BigDecimal) {
+                isEquals = (((java.math.BigDecimal)lhs).compareTo(rhs) == 0);
+            } else {
                 // The simple case, not an array, just test the element
                 isEquals = lhs.equals(rhs);
+            }
         } else if (lhs.getClass() != rhs.getClass()) {
             // Here when we compare different dimensions, for example: a boolean[][] to a boolean[] 
             this.setEquals(false);
"
207,"junit.framework.ComparisonFailure","/src/java/org/apache/commons/lang/StringEscapeUtils.java","@@ -233,6 +233,10 @@ private static void escapeJavaStyleString(Writer out, String str, boolean escape
                         out.write('\\');
                         out.write('\\');
                         break;
+                    case '/':
+                        out.write('\\');
+                        out.write('/');
+                        break;
                     default :
                         out.write(ch);
                         break;
","@@ -233,6 +233,10 @@ private static void escapeJavaStyleString(Writer out, String str, boolean escape
                         out.write('\\');
                         out.write('\\');
                         break;
+                    case '/':
+                        out.write('\\');
+                        out.write('/');
+                        break;
                     default :
                         out.write(ch);
                         break;
"
208,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/lang/time/DateUtils.java","@@ -640,18 +640,18 @@ private static void modify(Calendar val, int field, boolean round) {
         int millisecs = val.get(Calendar.MILLISECOND);
         if (!round || millisecs < 500) {
             time = time - millisecs;
+        }
         if (field == Calendar.SECOND) {
             done = true;
         }
 
         // truncate seconds
         int seconds = val.get(Calendar.SECOND);
         if (!done && (!round || seconds < 30)) {
             time = time - (seconds * 1000L);
+        }
         if (field == Calendar.MINUTE) {
             done = true;
         }
 
         // truncate minutes
","@@ -640,18 +640,18 @@ private static void modify(Calendar val, int field, boolean round) {
         int millisecs = val.get(Calendar.MILLISECOND);
         if (!round || millisecs < 500) {
             time = time - millisecs;
+        }
         if (field == Calendar.SECOND) {
             done = true;
         }
 
         // truncate seconds
         int seconds = val.get(Calendar.SECOND);
         if (!done && (!round || seconds < 30)) {
             time = time - (seconds * 1000L);
+        }
         if (field == Calendar.MINUTE) {
             done = true;
         }
 
         // truncate minutes
"
209,"junit.framework.ComparisonFailure","/src/java/org/apache/commons/lang/StringEscapeUtils.java","@@ -83,7 +83,7 @@ public StringEscapeUtils() {
      * @return String with escaped values, <code>null</code> if null string input
      */
     public static String escapeJava(String str) {
+        return escapeJavaStyleString(str, false, false);
     }
 
     /**
@@ -99,7 +99,7 @@ public static String escapeJava(String str) {
      * @throws IOException if error occurs on underlying Writer
      */
     public static void escapeJava(Writer out, String str) throws IOException {
+        escapeJavaStyleString(out, str, false, false);
     }
 
     /**
@@ -124,7 +124,7 @@ public static void escapeJava(Writer out, String str) throws IOException {
      * @return String with escaped values, <code>null</code> if null string input
      */
     public static String escapeJavaScript(String str) {
+        return escapeJavaStyleString(str, true, true);
     }
 
     /**
@@ -140,7 +140,7 @@ public static String escapeJavaScript(String str) {
      * @throws IOException if error occurs on underlying Writer
      **/
     public static void escapeJavaScript(Writer out, String str) throws IOException {
+        escapeJavaStyleString(out, str, true, true);
     }
 
     /**
@@ -151,13 +151,13 @@ public static void escapeJavaScript(Writer out, String str) throws IOException {
      * @param escapeForwardSlash TODO
      * @return the escaped string
      */
+    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes, boolean escapeForwardSlash) {
         if (str == null) {
             return null;
         }
         try {
             StringWriter writer = new StringWriter(str.length() * 2);
+            escapeJavaStyleString(writer, str, escapeSingleQuotes, escapeForwardSlash);
             return writer.toString();
         } catch (IOException ioe) {
             // this should never ever happen while writing to a StringWriter
@@ -175,7 +175,8 @@ private static String escapeJavaStyleString(String str, boolean escapeSingleQuot
      * @param escapeForwardSlash TODO
      * @throws IOException if an IOException occurs
      */
+    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote,
+            boolean escapeForwardSlash) throws IOException {
         if (out == null) {
             throw new IllegalArgumentException(""The Writer must not be null"");
         }
@@ -241,7 +242,9 @@ private static void escapeJavaStyleString(Writer out, String str, boolean escape
                         out.write('\\');
                         break;
                     case '/' :
+                        if (escapeForwardSlash) {
                             out.write('\\');
+                        }
                         out.write('/');
                         break;
                     default :
","@@ -83,7 +83,7 @@ public StringEscapeUtils() {
      * @return String with escaped values, <code>null</code> if null string input
      */
     public static String escapeJava(String str) {
+        return escapeJavaStyleString(str, false, false);
     }
 
     /**
@@ -99,7 +99,7 @@ public static String escapeJava(String str) {
      * @throws IOException if error occurs on underlying Writer
      */
     public static void escapeJava(Writer out, String str) throws IOException {
+        escapeJavaStyleString(out, str, false, false);
     }
 
     /**
@@ -124,7 +124,7 @@ public static void escapeJava(Writer out, String str) throws IOException {
      * @return String with escaped values, <code>null</code> if null string input
      */
     public static String escapeJavaScript(String str) {
+        return escapeJavaStyleString(str, true, true);
     }
 
     /**
@@ -140,7 +140,7 @@ public static String escapeJavaScript(String str) {
      * @throws IOException if error occurs on underlying Writer
      **/
     public static void escapeJavaScript(Writer out, String str) throws IOException {
+        escapeJavaStyleString(out, str, true, true);
     }
 
     /**
@@ -151,13 +151,13 @@ public static void escapeJavaScript(Writer out, String str) throws IOException {
      * @param escapeForwardSlash TODO
      * @return the escaped string
      */
+    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes, boolean escapeForwardSlash) {
         if (str == null) {
             return null;
         }
         try {
             StringWriter writer = new StringWriter(str.length() * 2);
+            escapeJavaStyleString(writer, str, escapeSingleQuotes, escapeForwardSlash);
             return writer.toString();
         } catch (IOException ioe) {
             // this should never ever happen while writing to a StringWriter
@@ -175,7 +175,8 @@ private static String escapeJavaStyleString(String str, boolean escapeSingleQuot
      * @param escapeForwardSlash TODO
      * @throws IOException if an IOException occurs
      */
+    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote,
+            boolean escapeForwardSlash) throws IOException {
         if (out == null) {
             throw new IllegalArgumentException(""The Writer must not be null"");
         }
@@ -241,7 +242,9 @@ private static void escapeJavaStyleString(Writer out, String str, boolean escape
                         out.write('\\');
                         break;
                     case '/' :
+                        if (escapeForwardSlash) {
                             out.write('\\');
+                        }
                         out.write('/');
                         break;
                     default :
"
210,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/lang/time/FastDateFormat.java","@@ -282,16 +282,14 @@ public static synchronized FastDateFormat getDateInstance(int style, TimeZone ti
             key = new Pair(key, timeZone);
         }
 
+        if (locale == null) {
+            locale = Locale.getDefault();
         }
 
+        key = new Pair(key, locale);
 
         FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);
         if (format == null) {
             try {
                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);
                 String pattern = formatter.toPattern();
@@ -462,15 +460,13 @@ public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int
         if (timeZone != null) {
             key = new Pair(key, timeZone);
         }
+        if (locale == null) {
+            locale = Locale.getDefault();
         }
+        key = new Pair(key, locale);
 
         FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);
         if (format == null) {
             try {
                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle,
                         locale);
","@@ -282,16 +282,14 @@ public static synchronized FastDateFormat getDateInstance(int style, TimeZone ti
             key = new Pair(key, timeZone);
         }
 
+        if (locale == null) {
+            locale = Locale.getDefault();
         }
 
+        key = new Pair(key, locale);
 
         FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);
         if (format == null) {
             try {
                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);
                 String pattern = formatter.toPattern();
@@ -462,15 +460,13 @@ public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int
         if (timeZone != null) {
             key = new Pair(key, timeZone);
         }
+        if (locale == null) {
+            locale = Locale.getDefault();
         }
+        key = new Pair(key, locale);
 
         FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);
         if (format == null) {
             try {
                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle,
                         locale);
"
211,"java.lang.StringIndexOutOfBoundsException","/src/java/org/apache/commons/lang/BooleanUtils.java","@@ -679,6 +679,7 @@ public static boolean toBoolean(String str) {
                         (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&
                         (str.charAt(2) == 'S' || str.charAt(2) == 's');
                 }
+                return false;
             }
             case 4: {
                 char ch = str.charAt(0);
","@@ -679,6 +679,7 @@ public static boolean toBoolean(String str) {
                         (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&
                         (str.charAt(2) == 'S' || str.charAt(2) == 's');
                 }
+                return false;
             }
             case 4: {
                 char ch = str.charAt(0);
"
212,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/lang/math/Fraction.java","@@ -463,6 +463,9 @@ public double doubleValue() {
      * @return a new reduced fraction instance, or this if no simplification possible
      */
     public Fraction reduce() {
+        if (numerator == 0) {
+            return equals(ZERO) ? this : ZERO;
+        }
         int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);
         if (gcd == 1) {
             return this;
","@@ -463,6 +463,9 @@ public double doubleValue() {
      * @return a new reduced fraction instance, or this if no simplification possible
      */
     public Fraction reduce() {
+        if (numerator == 0) {
+            return equals(ZERO) ? this : ZERO;
+        }
         int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);
         if (gcd == 1) {
             return this;
"
213,"java.lang.IllegalArgumentException","/src/java/org/apache/commons/lang/LocaleUtils.java","@@ -111,6 +111,9 @@ public static Locale toLocale(String str) {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
             }
             char ch3 = str.charAt(3);
+            if (ch3 == '_') {
+                return new Locale(str.substring(0, 2), """", str.substring(4));
+            }
             char ch4 = str.charAt(4);
             if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
","@@ -111,6 +111,9 @@ public static Locale toLocale(String str) {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
             }
             char ch3 = str.charAt(3);
+            if (ch3 == '_') {
+                return new Locale(str.substring(0, 2), """", str.substring(4));
+            }
             char ch4 = str.charAt(4);
             if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
"
214,"java.lang.NullPointerException","/src/java/org/apache/commons/lang/LocaleUtils.java","@@ -220,7 +220,7 @@ public static Set availableLocaleSet() {
      * @return true if the locale is a known locale
      */
     public static boolean isAvailableLocale(Locale locale) {
+        return availableLocaleList().contains(locale);
     }
 
     //-----------------------------------------------------------------------
","@@ -220,7 +220,7 @@ public static Set availableLocaleSet() {
      * @return true if the locale is a known locale
      */
     public static boolean isAvailableLocale(Locale locale) {
+        return availableLocaleList().contains(locale);
     }
 
     //-----------------------------------------------------------------------
"
215,"java.lang.NumberFormatException","/src/java/org/apache/commons/lang/math/NumberUtils.java","@@ -451,8 +451,7 @@ public static Number createNumber(String str) throws NumberFormatException {
                 case 'L' :
                     if (dec == null
                         && exp == null
+                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                         try {
                             return createLong(numeric);
                         } catch (NumberFormatException nfe) {
","@@ -451,8 +451,7 @@ public static Number createNumber(String str) throws NumberFormatException {
                 case 'L' :
                     if (dec == null
                         && exp == null
+                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                         try {
                             return createLong(numeric);
                         } catch (NumberFormatException nfe) {
"
216,"org.apache.commons.lang.SerializationException","/src/java/org/apache/commons/lang/time/FastDateFormat.java","@@ -1,152 +1,152 @@
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the ""License""); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an ""AS IS"" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package org.apache.commons.lang.time;
 
 import java.io.IOException;
 import java.io.ObjectInputStream;
 
 import java.text.DateFormat;
 import java.text.DateFormatSymbols;
 import java.text.FieldPosition;
 import java.text.Format;
 import java.text.ParsePosition;
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.GregorianCalendar;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 import java.util.TimeZone;
 
 import org.apache.commons.lang.Validate;
 
 /**
  * <p>FastDateFormat is a fast and thread-safe version of
  * {@link java.text.SimpleDateFormat}.</p>
  * 
  * <p>This class can be used as a direct replacement to
  * <code>SimpleDateFormat</code> in most formatting situations.
  * This class is especially useful in multi-threaded server environments.
  * <code>SimpleDateFormat</code> is not thread-safe in any JDK version,
  * nor will it be as Sun have closed the bug/RFE.
  * </p>
  *
  * <p>Only formatting is supported, but all patterns are compatible with
  * SimpleDateFormat (except time zones - see below).</p>
  *
  * <p>Java 1.4 introduced a new pattern letter, <code>'Z'</code>, to represent
  * time zones in RFC822 format (eg. <code>+0800</code> or <code>-1100</code>).
  * This pattern letter can be used here (on all JDK versions).</p>
  *
  * <p>In addition, the pattern <code>'ZZ'</code> has been made to represent
  * ISO8601 full format time zones (eg. <code>+08:00</code> or <code>-11:00</code>).
  * This introduces a minor incompatibility with Java 1.4, but at a gain of
  * useful functionality.</p>
  *
  * @author TeaTrove project
  * @author Brian S O'Neill
  * @author Sean Schofield
  * @author Gary Gregory
  * @author Stephen Colebourne
  * @author Nikolay Metchev
  * @since 2.0
  * @version $Id$
  */
 public class FastDateFormat extends Format {
     // A lot of the speed in this class comes from caching, but some comes
     // from the special int to StringBuffer conversion.
     //
     // The following produces a padded 2 digit number:
     //   buffer.append((char)(value / 10 + '0'));
     //   buffer.append((char)(value % 10 + '0'));
     //
     // Note that the fastest append to StringBuffer is a single char (used here).
     // Note that Integer.toString() is not called, the conversion is simply
     // taking the value and adding (mathematically) the ASCII value for '0'.
     // So, don't change this code! It works and is very fast.
     
     /**
      * Required for serialization support.
      * 
      * @see java.io.Serializable
      */
     private static final long serialVersionUID = 1L;
 
     /**
      * FULL locale dependent date or time style.
      */
     public static final int FULL = DateFormat.FULL;
     /**
      * LONG locale dependent date or time style.
      */
     public static final int LONG = DateFormat.LONG;
     /**
      * MEDIUM locale dependent date or time style.
      */
     public static final int MEDIUM = DateFormat.MEDIUM;
     /**
      * SHORT locale dependent date or time style.
      */
     public static final int SHORT = DateFormat.SHORT;
     
     private static String cDefaultPattern;
 
     private static Map cInstanceCache = new HashMap(7);
     private static Map cDateInstanceCache = new HashMap(7);
     private static Map cTimeInstanceCache = new HashMap(7);
     private static Map cDateTimeInstanceCache = new HashMap(7);
     private static Map cTimeZoneDisplayCache = new HashMap(7);
 
     /**
      * The pattern.
      */
     private final String mPattern;
     /**
      * The time zone.
      */
     private final TimeZone mTimeZone;
     /**
      * Whether the time zone overrides any on Calendars.
      */
     private final boolean mTimeZoneForced;
     /**
      * The locale.
      */
     private final Locale mLocale;
     /**
      * Whether the locale overrides the default.
      */
     private final boolean mLocaleForced;
     /**
      * The parsed rules.
      */
+    private transient Rule[] mRules;
     /**
      * The estimated maximum length.
      */
+    private transient int mMaxLengthEstimate;
 
     //-----------------------------------------------------------------------
     /**
      * <p>Gets a formatter instance using the default pattern in the
      * default locale.</p>
      * 
      * @return a date/time formatter
      */
@@ -1016,37 +1016,41 @@ public int hashCode() {
     public String toString() {
         return ""FastDateFormat["" + mPattern + ""]"";
     }
 
     // Serializing
     //-----------------------------------------------------------------------
+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
+        in.defaultReadObject();
+        init();
+    }
     
     // Rules
     //-----------------------------------------------------------------------
     /**
      * <p>Inner class defining a rule.</p>
      */
     private interface Rule {
         /**
          * Returns the estimated lentgh of the result.
          * 
          * @return the estimated length
          */
         int estimateLength();
         
         /**
          * Appends the value of the specified calendar to the output buffer based on the rule implementation.
          * 
          * @param buffer the output buffer
          * @param calendar calendar to be appended
          */
         void appendTo(StringBuffer buffer, Calendar calendar);
     }
 
     /**
      * <p>Inner class defining a numeric rule.</p>
      */
     private interface NumberRule extends Rule {
         /**
          * Appends the specified value to the output buffer based on the rule implementation.
          * 
          * @param buffer the output buffer
","@@ -1,152 +1,152 @@
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the ""License""); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an ""AS IS"" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package org.apache.commons.lang.time;
 
 import java.io.IOException;
 import java.io.ObjectInputStream;
 
 import java.text.DateFormat;
 import java.text.DateFormatSymbols;
 import java.text.FieldPosition;
 import java.text.Format;
 import java.text.ParsePosition;
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.GregorianCalendar;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 import java.util.TimeZone;
 
 import org.apache.commons.lang.Validate;
 
 /**
  * <p>FastDateFormat is a fast and thread-safe version of
  * {@link java.text.SimpleDateFormat}.</p>
  * 
  * <p>This class can be used as a direct replacement to
  * <code>SimpleDateFormat</code> in most formatting situations.
  * This class is especially useful in multi-threaded server environments.
  * <code>SimpleDateFormat</code> is not thread-safe in any JDK version,
  * nor will it be as Sun have closed the bug/RFE.
  * </p>
  *
  * <p>Only formatting is supported, but all patterns are compatible with
  * SimpleDateFormat (except time zones - see below).</p>
  *
  * <p>Java 1.4 introduced a new pattern letter, <code>'Z'</code>, to represent
  * time zones in RFC822 format (eg. <code>+0800</code> or <code>-1100</code>).
  * This pattern letter can be used here (on all JDK versions).</p>
  *
  * <p>In addition, the pattern <code>'ZZ'</code> has been made to represent
  * ISO8601 full format time zones (eg. <code>+08:00</code> or <code>-11:00</code>).
  * This introduces a minor incompatibility with Java 1.4, but at a gain of
  * useful functionality.</p>
  *
  * @author TeaTrove project
  * @author Brian S O'Neill
  * @author Sean Schofield
  * @author Gary Gregory
  * @author Stephen Colebourne
  * @author Nikolay Metchev
  * @since 2.0
  * @version $Id$
  */
 public class FastDateFormat extends Format {
     // A lot of the speed in this class comes from caching, but some comes
     // from the special int to StringBuffer conversion.
     //
     // The following produces a padded 2 digit number:
     //   buffer.append((char)(value / 10 + '0'));
     //   buffer.append((char)(value % 10 + '0'));
     //
     // Note that the fastest append to StringBuffer is a single char (used here).
     // Note that Integer.toString() is not called, the conversion is simply
     // taking the value and adding (mathematically) the ASCII value for '0'.
     // So, don't change this code! It works and is very fast.
     
     /**
      * Required for serialization support.
      * 
      * @see java.io.Serializable
      */
     private static final long serialVersionUID = 1L;
 
     /**
      * FULL locale dependent date or time style.
      */
     public static final int FULL = DateFormat.FULL;
     /**
      * LONG locale dependent date or time style.
      */
     public static final int LONG = DateFormat.LONG;
     /**
      * MEDIUM locale dependent date or time style.
      */
     public static final int MEDIUM = DateFormat.MEDIUM;
     /**
      * SHORT locale dependent date or time style.
      */
     public static final int SHORT = DateFormat.SHORT;
     
     private static String cDefaultPattern;
 
     private static Map cInstanceCache = new HashMap(7);
     private static Map cDateInstanceCache = new HashMap(7);
     private static Map cTimeInstanceCache = new HashMap(7);
     private static Map cDateTimeInstanceCache = new HashMap(7);
     private static Map cTimeZoneDisplayCache = new HashMap(7);
 
     /**
      * The pattern.
      */
     private final String mPattern;
     /**
      * The time zone.
      */
     private final TimeZone mTimeZone;
     /**
      * Whether the time zone overrides any on Calendars.
      */
     private final boolean mTimeZoneForced;
     /**
      * The locale.
      */
     private final Locale mLocale;
     /**
      * Whether the locale overrides the default.
      */
     private final boolean mLocaleForced;
     /**
      * The parsed rules.
      */
+    private transient Rule[] mRules;
     /**
      * The estimated maximum length.
      */
+    private transient int mMaxLengthEstimate;
 
     //-----------------------------------------------------------------------
     /**
      * <p>Gets a formatter instance using the default pattern in the
      * default locale.</p>
      * 
      * @return a date/time formatter
      */
@@ -1016,37 +1016,41 @@ public int hashCode() {
     public String toString() {
         return ""FastDateFormat["" + mPattern + ""]"";
     }
 
     // Serializing
     //-----------------------------------------------------------------------
+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
+        in.defaultReadObject();
+        init();
+    }
     
     // Rules
     //-----------------------------------------------------------------------
     /**
      * <p>Inner class defining a rule.</p>
      */
     private interface Rule {
         /**
          * Returns the estimated lentgh of the result.
          * 
          * @return the estimated length
          */
         int estimateLength();
         
         /**
          * Appends the value of the specified calendar to the output buffer based on the rule implementation.
          * 
          * @param buffer the output buffer
          * @param calendar calendar to be appended
          */
         void appendTo(StringBuffer buffer, Calendar calendar);
     }
 
     /**
      * <p>Inner class defining a numeric rule.</p>
      */
     private interface NumberRule extends Rule {
         /**
          * Appends the specified value to the output buffer based on the rule implementation.
          * 
          * @param buffer the output buffer
"
217,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/lang/enums/ValuedEnum.java","@@ -180,6 +180,16 @@ public final int getValue() {
      * @throws NullPointerException if other is <code>null</code>
      */
     public int compareTo(Object other) {
+        if (other == this) {
+            return 0;
+        }
+        if (other.getClass() != this.getClass()) {
+            if (other.getClass().getName().equals(this.getClass().getName())) {
+                return iValue - getValueInOtherClassLoader(other);
+            }
+            throw new ClassCastException(
+                    ""Different enum class '"" + ClassUtils.getShortClassName(other.getClass()) + ""'"");
+        }
         return iValue - ((ValuedEnum) other).iValue;
     }
 
@@ -189,9 +199,20 @@ public int compareTo(Object other) {
      * @param other  the object to determine the value for
      * @return the value
      */
+    private int getValueInOtherClassLoader(Object other) {
+        try {
+            Method mth = other.getClass().getMethod(""getValue"", null);
+            Integer value = (Integer) mth.invoke(other, null);
+            return value.intValue();
+        } catch (NoSuchMethodException e) {
             // ignore - should never happen
+        } catch (IllegalAccessException e) {
             // ignore - should never happen
+        } catch (InvocationTargetException e) {
             // ignore - should never happen
+        }
+        throw new IllegalStateException(""This should not happen"");
+    }
 
     /**
      * <p>Human readable description of this <code>Enum</code> item.</p>
","@@ -180,6 +180,16 @@ public final int getValue() {
      * @throws NullPointerException if other is <code>null</code>
      */
     public int compareTo(Object other) {
+        if (other == this) {
+            return 0;
+        }
+        if (other.getClass() != this.getClass()) {
+            if (other.getClass().getName().equals(this.getClass().getName())) {
+                return iValue - getValueInOtherClassLoader(other);
+            }
+            throw new ClassCastException(
+                    ""Different enum class '"" + ClassUtils.getShortClassName(other.getClass()) + ""'"");
+        }
         return iValue - ((ValuedEnum) other).iValue;
     }
 
@@ -189,9 +199,20 @@ public int compareTo(Object other) {
      * @param other  the object to determine the value for
      * @return the value
      */
+    private int getValueInOtherClassLoader(Object other) {
+        try {
+            Method mth = other.getClass().getMethod(""getValue"", null);
+            Integer value = (Integer) mth.invoke(other, null);
+            return value.intValue();
+        } catch (NoSuchMethodException e) {
             // ignore - should never happen
+        } catch (IllegalAccessException e) {
             // ignore - should never happen
+        } catch (InvocationTargetException e) {
             // ignore - should never happen
+        }
+        throw new IllegalStateException(""This should not happen"");
+    }
 
     /**
      * <p>Human readable description of this <code>Enum</code> item.</p>
"
218,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/lang/time/StopWatch.java","@@ -115,7 +115,9 @@ public void stop() {
         if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {
             throw new IllegalStateException(""Stopwatch is not running. "");
         }
+        if(this.runningState == STATE_RUNNING) {
             stopTime = System.currentTimeMillis();
+        }
         this.runningState = STATE_STOPPED;
     }
 
","@@ -115,7 +115,9 @@ public void stop() {
         if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {
             throw new IllegalStateException(""Stopwatch is not running. "");
         }
+        if(this.runningState == STATE_RUNNING) {
             stopTime = System.currentTimeMillis();
+        }
         this.runningState = STATE_STOPPED;
     }
 
"
219,"java.lang.ArrayIndexOutOfBoundsException","/src/java/org/apache/commons/lang/text/StrBuilder.java","@@ -881,7 +881,7 @@ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar)
             String str = (obj == null ? getNullText() : obj.toString());
             int strLen = str.length();
             if (strLen >= width) {
+                str.getChars(0, width, buffer, size);
             } else {
                 int padLen = width - strLen;
                 str.getChars(0, strLen, buffer, size);
","@@ -881,7 +881,7 @@ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar)
             String str = (obj == null ? getNullText() : obj.toString());
             int strLen = str.length();
             if (strLen >= width) {
+                str.getChars(0, width, buffer, size);
             } else {
                 int padLen = width - strLen;
                 str.getChars(0, strLen, buffer, size);
"
220,"junit.framework.ComparisonFailure","/src/java/org/apache/commons/lang/Entities.java","@@ -847,6 +847,9 @@ public String unescape(String str) {
                             } else {
                                 entityValue = Integer.parseInt(entityName.substring(1));
                             }
+                            if (entityValue > 0xFFFF) {
+                                entityValue = -1;
+                            }
                         } catch (NumberFormatException ex) {
                             entityValue = -1;
                         }
@@ -917,12 +920,17 @@ public void unescape(Writer writer, String string) throws IOException {
                                     case 'X' :
                                     case 'x' : {
                                         entityValue = Integer.parseInt(entityContent.substring(2), 16);
+                                        break;
                                     }
                                     default : {
                                         entityValue = Integer.parseInt(entityContent.substring(1), 10);
                                     }
                                 }
+                                if (entityValue > 0xFFFF) {
+                                    entityValue = -1;
+                                }
                             } catch (NumberFormatException e) {
+                                entityValue = -1;
                             }
                         }
                     } else { //escaped value content is an entity name
","@@ -847,6 +847,9 @@ public String unescape(String str) {
                             } else {
                                 entityValue = Integer.parseInt(entityName.substring(1));
                             }
+                            if (entityValue > 0xFFFF) {
+                                entityValue = -1;
+                            }
                         } catch (NumberFormatException ex) {
                             entityValue = -1;
                         }
@@ -917,12 +920,17 @@ public void unescape(Writer writer, String string) throws IOException {
                                     case 'X' :
                                     case 'x' : {
                                         entityValue = Integer.parseInt(entityContent.substring(2), 16);
+                                        break;
                                     }
                                     default : {
                                         entityValue = Integer.parseInt(entityContent.substring(1), 10);
                                     }
                                 }
+                                if (entityValue > 0xFFFF) {
+                                    entityValue = -1;
+                                }
                             } catch (NumberFormatException e) {
+                                entityValue = -1;
                             }
                         }
                     } else { //escaped value content is an entity name
"
221,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/lang/text/StrBuilder.java","@@ -1670,7 +1670,7 @@ public String midString(int index, int length) {
      */
     public boolean contains(char ch) {
         char[] thisBuf = buffer;
+        for (int i = 0; i < this.size; i++) {
             if (thisBuf[i] == ch) {
                 return true;
             }
@@ -1727,7 +1727,7 @@ public int indexOf(char ch, int startIndex) {
             return -1;
         }
         char[] thisBuf = buffer;
+        for (int i = startIndex; i < size; i++) {
             if (thisBuf[i] == ch) {
                 return i;
             }
","@@ -1670,7 +1670,7 @@ public String midString(int index, int length) {
      */
     public boolean contains(char ch) {
         char[] thisBuf = buffer;
+        for (int i = 0; i < this.size; i++) {
             if (thisBuf[i] == ch) {
                 return true;
             }
@@ -1727,7 +1727,7 @@ public int indexOf(char ch, int startIndex) {
             return -1;
         }
         char[] thisBuf = buffer;
+        for (int i = startIndex; i < size; i++) {
             if (thisBuf[i] == ch) {
                 return i;
             }
"
222,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/lang/text/StrBuilder.java","@@ -1773,7 +1773,7 @@ public int indexOf(String str, int startIndex) {
             return -1;
         }
         char[] thisBuf = buffer;
+        int len = size - strLen + 1;
         outer:
         for (int i = startIndex; i < len; i++) {
             for (int j = 0; j < strLen; j++) {
","@@ -1773,7 +1773,7 @@ public int indexOf(String str, int startIndex) {
             return -1;
         }
         char[] thisBuf = buffer;
+        int len = size - strLen + 1;
         outer:
         for (int i = startIndex; i < len; i++) {
             for (int j = 0; j < strLen; j++) {
"
223,"junit.framework.ComparisonFailure","/src/java/org/apache/commons/lang/time/DurationFormatUtils.java","@@ -303,25 +303,20 @@ public static String formatPeriod(long startMillis, long endMillis, String forma
             days -= 1;
         }
         while (days < 0) {
+            end.add(Calendar.MONTH, -1);
+            days += end.getActualMaximum(Calendar.DAY_OF_MONTH);
 //days += 31; // TODO: Need tests to show this is bad and the new code is good.
 // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is 
 // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.
 // Also it's contextual - if asked for no M in the format then I should probably 
 // be doing no calculating here.
             months -= 1;
+            end.add(Calendar.MONTH, 1);
         }
         while (months < 0) {
             months += 12;
             years -= 1;
         }
 
         // This next block of code adds in values that 
         // aren't requested. This allows the user to ask for the 
@@ -429,18 +424,6 @@ static String format(Token[] tokens, int years, int months, int days, int hours,
         }
         return buffer.toString();
     }
 
     static final Object y = ""y"";
     static final Object M = ""M"";
","@@ -303,25 +303,20 @@ public static String formatPeriod(long startMillis, long endMillis, String forma
             days -= 1;
         }
         while (days < 0) {
+            end.add(Calendar.MONTH, -1);
+            days += end.getActualMaximum(Calendar.DAY_OF_MONTH);
 //days += 31; // TODO: Need tests to show this is bad and the new code is good.
 // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is 
 // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.
 // Also it's contextual - if asked for no M in the format then I should probably 
 // be doing no calculating here.
             months -= 1;
+            end.add(Calendar.MONTH, 1);
         }
         while (months < 0) {
             months += 12;
             years -= 1;
         }
 
         // This next block of code adds in values that 
         // aren't requested. This allows the user to ask for the 
@@ -429,18 +424,6 @@ static String format(Token[] tokens, int years, int months, int days, int hours,
         }
         return buffer.toString();
     }
 
     static final Object y = ""y"";
     static final Object M = ""M"";
"
224,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/lang/time/DateUtils.java","@@ -621,6 +621,9 @@ private static void modify(Calendar val, int field, boolean round) {
             throw new ArithmeticException(""Calendar value too large for accurate calculations"");
         }
         
+        if (field == Calendar.MILLISECOND) {
+            return;
+        }
 
         // ----------------- Fix for LANG-59 ---------------------- START ---------------
         // see http://issues.apache.org/jira/browse/LANG-59
@@ -628,14 +631,39 @@ private static void modify(Calendar val, int field, boolean round) {
         // Manually truncate milliseconds, seconds and minutes, rather than using
         // Calendar methods.
 
+        Date date = val.getTime();
+        long time = date.getTime();
+        boolean done = false;
 
         // truncate milliseconds
+        int millisecs = val.get(Calendar.MILLISECOND);
+        if (!round || millisecs < 500) {
+            time = time - millisecs;
+            if (field == Calendar.SECOND) {
+                done = true;
+            }
+        }
 
         // truncate seconds
+        int seconds = val.get(Calendar.SECOND);
+        if (!done && (!round || seconds < 30)) {
+            time = time - (seconds * 1000L);
+            if (field == Calendar.MINUTE) {
+                done = true;
+            }
+        }
 
         // truncate minutes
+        int minutes = val.get(Calendar.MINUTE);
+        if (!done && (!round || minutes < 30)) {
+            time = time - (minutes * 60000L);
+        }
 
         // reset time
+        if (date.getTime() != time) {
+            date.setTime(time);
+            val.setTime(date);
+        }
         // ----------------- Fix for LANG-59 ----------------------- END ----------------
 
         boolean roundUp = false;
@@ -706,7 +734,9 @@ private static void modify(Calendar val, int field, boolean round) {
                 roundUp = offset > ((max - min) / 2);
             }
             //We need to remove this field
+            if (offset != 0) {
                 val.set(fields[i][0], val.get(fields[i][0]) - offset);
+            }
         }
         throw new IllegalArgumentException(""The field "" + field + "" is not supported"");
 
","@@ -621,6 +621,9 @@ private static void modify(Calendar val, int field, boolean round) {
             throw new ArithmeticException(""Calendar value too large for accurate calculations"");
         }
         
+        if (field == Calendar.MILLISECOND) {
+            return;
+        }
 
         // ----------------- Fix for LANG-59 ---------------------- START ---------------
         // see http://issues.apache.org/jira/browse/LANG-59
@@ -628,14 +631,39 @@ private static void modify(Calendar val, int field, boolean round) {
         // Manually truncate milliseconds, seconds and minutes, rather than using
         // Calendar methods.
 
+        Date date = val.getTime();
+        long time = date.getTime();
+        boolean done = false;
 
         // truncate milliseconds
+        int millisecs = val.get(Calendar.MILLISECOND);
+        if (!round || millisecs < 500) {
+            time = time - millisecs;
+            if (field == Calendar.SECOND) {
+                done = true;
+            }
+        }
 
         // truncate seconds
+        int seconds = val.get(Calendar.SECOND);
+        if (!done && (!round || seconds < 30)) {
+            time = time - (seconds * 1000L);
+            if (field == Calendar.MINUTE) {
+                done = true;
+            }
+        }
 
         // truncate minutes
+        int minutes = val.get(Calendar.MINUTE);
+        if (!done && (!round || minutes < 30)) {
+            time = time - (minutes * 60000L);
+        }
 
         // reset time
+        if (date.getTime() != time) {
+            date.setTime(time);
+            val.setTime(date);
+        }
         // ----------------- Fix for LANG-59 ----------------------- END ----------------
 
         boolean roundUp = false;
@@ -706,7 +734,9 @@ private static void modify(Calendar val, int field, boolean round) {
                 roundUp = offset > ((max - min) / 2);
             }
             //We need to remove this field
+            if (offset != 0) {
                 val.set(fields[i][0], val.get(fields[i][0]) - offset);
+            }
         }
         throw new IllegalArgumentException(""The field "" + field + "" is not supported"");
 
"
225,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java","@@ -265,7 +265,7 @@ private double innerCumulativeProbability(int x0, int x1, int dx) {
      * size {@code n}, the mean is {@code n * m / N}.
      */
     public double getNumericalMean() {
+        return getSampleSize() * (getNumberOfSuccesses() / (double) getPopulationSize());
     }
 
     /**
","@@ -265,7 +265,7 @@ private double innerCumulativeProbability(int x0, int x1, int dx) {
      * size {@code n}, the mean is {@code n * m / N}.
      */
     public double getNumericalMean() {
+        return getSampleSize() * (getNumberOfSuccesses() / (double) getPopulationSize());
     }
 
     /**
"
226,"org.apache.commons.math3.fraction.FractionConversionException","/src/main/java/org/apache/commons/math3/fraction/BigFraction.java","@@ -303,6 +303,9 @@ private BigFraction(final double value, final double epsilon,
             if ((p2 > overflow) || (q2 > overflow)) {
                 // in maxDenominator mode, if the last fraction was very close to the actual value
                 // q2 may overflow in the next iteration; in this case return the last one.
+                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) {
+                    break;
+                }
                 throw new FractionConversionException(value, p2, q2);
             }
 
/src/main/java/org/apache/commons/math3/fraction/Fraction.java @@ -212,6 +212,9 @@ private Fraction(double value, double epsilon, int maxDenominator, int maxIterat
             if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {
                 // in maxDenominator mode, if the last fraction was very close to the actual value
                 // q2 may overflow in the next iteration; in this case return the last one.
+                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) {
+                    break;
+                }
                 throw new FractionConversionException(value, p2, q2);
             }
 
","@@ -303,6 +303,9 @@ private BigFraction(final double value, final double epsilon,
             if ((p2 > overflow) || (q2 > overflow)) {
                 // in maxDenominator mode, if the last fraction was very close to the actual value
                 // q2 may overflow in the next iteration; in this case return the last one.
+                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) {
+                    break;
+                }
                 throw new FractionConversionException(value, p2, q2);
             }
 
/src/main/java/org/apache/commons/math3/fraction/Fraction.java @@ -212,6 +212,9 @@ private Fraction(double value, double epsilon, int maxDenominator, int maxIterat
             if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {
                 // in maxDenominator mode, if the last fraction was very close to the actual value
                 // q2 may overflow in the next iteration; in this case return the last one.
+                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) {
+                    break;
+                }
                 throw new FractionConversionException(value, p2, q2);
             }
 
"
227,"java.lang.ArrayIndexOutOfBoundsException","/src/main/java/org/apache/commons/math3/util/MathArrays.java","@@ -818,7 +818,10 @@ public static double linearCombination(final double[] a, final double[] b)
             throw new DimensionMismatchException(len, b.length);
         }
 
+        if (len == 1) {
             // Revert to scalar multiplication.
+            return a[0] * b[0];
+        }
 
         final double[] prodHigh = new double[len];
         double prodLowSum = 0;
","@@ -818,7 +818,10 @@ public static double linearCombination(final double[] a, final double[] b)
             throw new DimensionMismatchException(len, b.length);
         }
 
+        if (len == 1) {
             // Revert to scalar multiplication.
+            return a[0] * b[0];
+        }
 
         final double[] prodHigh = new double[len];
         double prodLowSum = 0;
"
228,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/complex/Complex.java","@@ -302,7 +302,7 @@ public Complex reciprocal() {
         }
 
         if (real == 0.0 && imaginary == 0.0) {
+            return INF;
         }
 
         if (isInfinite) {
","@@ -302,7 +302,7 @@ public Complex reciprocal() {
         }
 
         if (real == 0.0 && imaginary == 0.0) {
+            return INF;
         }
 
         if (isInfinite) {
"
229,"java.lang.ArrayStoreException","/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java","@@ -178,13 +178,13 @@ public T sample() {
      * @throws NotStrictlyPositiveException if {@code sampleSize} is not
      * positive.
      */
+    public Object[] sample(int sampleSize) throws NotStrictlyPositiveException {
         if (sampleSize <= 0) {
             throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,
                     sampleSize);
         }
 
+        final Object[] out = new Object[sampleSize];
 
         for (int i = 0; i < sampleSize; i++) {
             out[i] = sample();
","@@ -178,13 +178,13 @@ public T sample() {
      * @throws NotStrictlyPositiveException if {@code sampleSize} is not
      * positive.
      */
+    public Object[] sample(int sampleSize) throws NotStrictlyPositiveException {
         if (sampleSize <= 0) {
             throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,
                     sampleSize);
         }
 
+        final Object[] out = new Object[sampleSize];
 
         for (int i = 0; i < sampleSize; i++) {
             out[i] = sample();
"
230,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java","@@ -180,7 +180,7 @@ public double density(final double[] vals) throws DimensionMismatchException {
             throw new DimensionMismatchException(vals.length, dim);
         }
 
+        return FastMath.pow(2 * FastMath.PI, -0.5 * dim) *
             FastMath.pow(covarianceMatrixDeterminant, -0.5) *
             getExponentTerm(vals);
     }
","@@ -180,7 +180,7 @@ public double density(final double[] vals) throws DimensionMismatchException {
             throw new DimensionMismatchException(vals.length, dim);
         }
 
+        return FastMath.pow(2 * FastMath.PI, -0.5 * dim) *
             FastMath.pow(covarianceMatrixDeterminant, -0.5) *
             getExponentTerm(vals);
     }
"
231,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java","@@ -48,7 +48,7 @@ protected BaseOptimizer(ConvergenceChecker<PAIR> checker) {
         this.checker = checker;
 
         evaluations = new Incrementor(0, new MaxEvalCallback());
+        iterations = new Incrementor(Integer.MAX_VALUE, new MaxIterCallback());
     }
 
     /**
/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java @@ -211,16 +211,15 @@ protected PointValuePair doOptimize() {
         }
 
         PointValuePair current = null;
         int maxEval = getMaxEvaluations();
         while (true) {
+            incrementIterationCount();
 
             final double objective = computeObjectiveValue(point);
             PointValuePair previous = current;
             current = new PointValuePair(point, objective);
             if (previous != null) {
+                if (checker.converged(getIterations(), previous, current)) {
                     // We have found an optimum.
                     return current;
                 }
@@ -274,7 +273,7 @@ protected PointValuePair doOptimize() {
             steepestDescent = newSteepestDescent;
 
             // Compute conjugate search direction.
+            if (getIterations() % n == 0 ||
                 beta < 0) {
                 // Break conjugation: reset search direction.
                 searchDirection = steepestDescent.clone();
/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java @@ -385,6 +385,7 @@ protected PointValuePair doOptimize() {
 
         generationLoop:
         for (iterations = 1; iterations <= maxIterations; iterations++) {
+            incrementIterationCount();
 
             // Generate and evaluate lambda offspring
             final RealMatrix arz = randn1(dimension, lambda);
/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java @@ -188,9 +188,8 @@ protected PointValuePair doOptimize() {
         double[] x = guess;
         double fVal = computeObjectiveValue(x);
         double[] x1 = x.clone();
         while (true) {
+            incrementIterationCount();
 
             double fX = fVal;
             double fX2 = 0;
@@ -224,7 +223,7 @@ protected PointValuePair doOptimize() {
             final PointValuePair current = new PointValuePair(x, fVal);
             if (!stop) { // User-defined stopping criteria.
                 if (checker != null) {
+                    stop = checker.converged(getIterations(), previous, current);
                 }
             }
             if (stop) {
/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java @@ -155,7 +155,7 @@ public int compare(final PointValuePair o1,
         int iteration = 0;
         final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
         while (true) {
+            if (getIterations() > 0) {
                 boolean converged = true;
                 for (int i = 0; i < simplex.getSize(); i++) {
                     PointValuePair prev = previous[i];
@@ -172,7 +172,7 @@ public int compare(final PointValuePair o1,
             previous = simplex.getPoints();
             simplex.iterate(evalFunc, comparator);
 
+            incrementIterationCount();
         }
     }
 
/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java @@ -103,9 +103,8 @@ public PointVectorValuePair doOptimize() {
 
         // iterate until convergence is reached
         PointVectorValuePair current = null;
         for (boolean converged = false; !converged;) {
+            incrementIterationCount();
 
             // evaluate the objective function and its jacobian
             PointVectorValuePair previous = current;
@@ -157,7 +156,7 @@ public PointVectorValuePair doOptimize() {
 
             // Check convergence.
             if (previous != null) {
+                converged = checker.converged(getIterations(), previous, current);
                 if (converged) {
                     setCost(computeCost(currentResiduals));
                     return current;
/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java @@ -319,10 +319,10 @@ protected PointVectorValuePair doOptimize() {
         // Outer loop.
         lmPar = 0;
         boolean firstIteration = true;
         final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();
         while (true) {
+            incrementIterationCount();
+
             final PointVectorValuePair previous = current;
 
             // QR decomposition of the jacobian matrix
@@ -486,7 +486,7 @@ protected PointVectorValuePair doOptimize() {
                     // tests for convergence.
                     if (checker != null) {
                         // we use the vectorial convergence checker
+                        if (checker.converged(getIterations(), previous, current)) {
                             setCost(currentCost);
                             return current;
                         }
","@@ -48,7 +48,7 @@ protected BaseOptimizer(ConvergenceChecker<PAIR> checker) {
         this.checker = checker;
 
         evaluations = new Incrementor(0, new MaxEvalCallback());
+        iterations = new Incrementor(Integer.MAX_VALUE, new MaxIterCallback());
     }
 
     /**
/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java @@ -211,16 +211,15 @@ protected PointValuePair doOptimize() {
         }
 
         PointValuePair current = null;
         int maxEval = getMaxEvaluations();
         while (true) {
+            incrementIterationCount();
 
             final double objective = computeObjectiveValue(point);
             PointValuePair previous = current;
             current = new PointValuePair(point, objective);
             if (previous != null) {
+                if (checker.converged(getIterations(), previous, current)) {
                     // We have found an optimum.
                     return current;
                 }
@@ -274,7 +273,7 @@ protected PointValuePair doOptimize() {
             steepestDescent = newSteepestDescent;
 
             // Compute conjugate search direction.
+            if (getIterations() % n == 0 ||
                 beta < 0) {
                 // Break conjugation: reset search direction.
                 searchDirection = steepestDescent.clone();
/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java @@ -385,6 +385,7 @@ protected PointValuePair doOptimize() {
 
         generationLoop:
         for (iterations = 1; iterations <= maxIterations; iterations++) {
+            incrementIterationCount();
 
             // Generate and evaluate lambda offspring
             final RealMatrix arz = randn1(dimension, lambda);
/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java @@ -188,9 +188,8 @@ protected PointValuePair doOptimize() {
         double[] x = guess;
         double fVal = computeObjectiveValue(x);
         double[] x1 = x.clone();
         while (true) {
+            incrementIterationCount();
 
             double fX = fVal;
             double fX2 = 0;
@@ -224,7 +223,7 @@ protected PointValuePair doOptimize() {
             final PointValuePair current = new PointValuePair(x, fVal);
             if (!stop) { // User-defined stopping criteria.
                 if (checker != null) {
+                    stop = checker.converged(getIterations(), previous, current);
                 }
             }
             if (stop) {
/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java @@ -155,7 +155,7 @@ public int compare(final PointValuePair o1,
         int iteration = 0;
         final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
         while (true) {
+            if (getIterations() > 0) {
                 boolean converged = true;
                 for (int i = 0; i < simplex.getSize(); i++) {
                     PointValuePair prev = previous[i];
@@ -172,7 +172,7 @@ public int compare(final PointValuePair o1,
             previous = simplex.getPoints();
             simplex.iterate(evalFunc, comparator);
 
+            incrementIterationCount();
         }
     }
 
/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java @@ -103,9 +103,8 @@ public PointVectorValuePair doOptimize() {
 
         // iterate until convergence is reached
         PointVectorValuePair current = null;
         for (boolean converged = false; !converged;) {
+            incrementIterationCount();
 
             // evaluate the objective function and its jacobian
             PointVectorValuePair previous = current;
@@ -157,7 +156,7 @@ public PointVectorValuePair doOptimize() {
 
             // Check convergence.
             if (previous != null) {
+                converged = checker.converged(getIterations(), previous, current);
                 if (converged) {
                     setCost(computeCost(currentResiduals));
                     return current;
/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java @@ -319,10 +319,10 @@ protected PointVectorValuePair doOptimize() {
         // Outer loop.
         lmPar = 0;
         boolean firstIteration = true;
         final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();
         while (true) {
+            incrementIterationCount();
+
             final PointVectorValuePair previous = current;
 
             // QR decomposition of the jacobian matrix
@@ -486,7 +486,7 @@ protected PointVectorValuePair doOptimize() {
                     // tests for convergence.
                     if (checker != null) {
                         // we use the vectorial convergence checker
+                        if (checker.converged(getIterations(), previous, current)) {
                             setCost(currentCost);
                             return current;
                         }
"
232,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java","@@ -1416,6 +1416,7 @@ public void atan2(final double[] y, final int yOffset,
         }
 
         // fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly
+        result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset]);
 
     }
 
","@@ -1416,6 +1416,7 @@ public void atan2(final double[] y, final int yOffset,
         }
 
         // fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly
+        result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset]);
 
     }
 
"
233,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java","@@ -343,8 +343,10 @@ public int compare(EventState es0, EventState es1) {
                 final double[] eventY = interpolator.getInterpolatedState().clone();
 
                 // advance all event states to current time
+                for (final EventState state : eventsStates) {
+                    state.stepAccepted(eventT, eventY);
+                    isLastStep = isLastStep || state.stop();
+                }
 
                 // handle the first part of the step, up to the event
                 for (final StepHandler handler : stepHandlers) {
@@ -354,22 +356,19 @@ public int compare(EventState es0, EventState es1) {
                 if (isLastStep) {
                     // the event asked to stop integration
                     System.arraycopy(eventY, 0, y, 0, y.length);
                     return eventT;
                 }
 
+                boolean needReset = false;
+                for (final EventState state : eventsStates) {
+                    needReset =  needReset || state.reset(eventT, eventY);
+                }
                 if (needReset) {
                     // some event handler has triggered changes that
                     // invalidate the derivatives, we need to recompute them
                     System.arraycopy(eventY, 0, y, 0, y.length);
                     computeDerivatives(eventT, y, yDot);
                     resetOccurred = true;
                     return eventT;
                 }
 
","@@ -343,8 +343,10 @@ public int compare(EventState es0, EventState es1) {
                 final double[] eventY = interpolator.getInterpolatedState().clone();
 
                 // advance all event states to current time
+                for (final EventState state : eventsStates) {
+                    state.stepAccepted(eventT, eventY);
+                    isLastStep = isLastStep || state.stop();
+                }
 
                 // handle the first part of the step, up to the event
                 for (final StepHandler handler : stepHandlers) {
@@ -354,22 +356,19 @@ public int compare(EventState es0, EventState es1) {
                 if (isLastStep) {
                     // the event asked to stop integration
                     System.arraycopy(eventY, 0, y, 0, y.length);
                     return eventT;
                 }
 
+                boolean needReset = false;
+                for (final EventState state : eventsStates) {
+                    needReset =  needReset || state.reset(eventT, eventY);
+                }
                 if (needReset) {
                     // some event handler has triggered changes that
                     // invalidate the derivatives, we need to recompute them
                     System.arraycopy(eventY, 0, y, 0, y.length);
                     computeDerivatives(eventT, y, yDot);
                     resetOccurred = true;
                     return eventT;
                 }
 
"
234,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java","@@ -16,6 +16,7 @@
  */
 package org.apache.commons.math3.random;
 
+import java.io.Serializable;
 
 import org.apache.commons.math3.exception.NotStrictlyPositiveException;
 import org.apache.commons.math3.util.FastMath;
@@ -26,8 +27,10 @@
  * @since 2.0
  */
 public abstract class BitsStreamGenerator
+    implements RandomGenerator,
+               Serializable {
     /** Serializable version identifier */
+    private static final long serialVersionUID = 20130104L;
     /** Next gaussian. */
     private double nextGaussian;
 
","@@ -16,6 +16,7 @@
  */
 package org.apache.commons.math3.random;
 
+import java.io.Serializable;
 
 import org.apache.commons.math3.exception.NotStrictlyPositiveException;
 import org.apache.commons.math3.util.FastMath;
@@ -26,8 +27,10 @@
  * @since 2.0
  */
 public abstract class BitsStreamGenerator
+    implements RandomGenerator,
+               Serializable {
     /** Serializable version identifier */
+    private static final long serialVersionUID = 20130104L;
     /** Next gaussian. */
     private double nextGaussian;
 
"
235,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java","@@ -84,7 +84,8 @@ public void reset(final Vector3D p1, final Vector3D p2) throws MathIllegalArgume
      * @return a new instance, with reversed direction
      */
     public Line revert() {
+        final Line reverted = new Line(this);
+        reverted.direction = reverted.direction.negate();
         return reverted;
     }
 
","@@ -84,7 +84,8 @@ public void reset(final Vector3D p1, final Vector3D p2) throws MathIllegalArgume
      * @return a new instance, with reversed direction
      */
     public Line revert() {
+        final Line reverted = new Line(this);
+        reverted.direction = reverted.direction.negate();
         return reverted;
     }
 
"
236,"java.lang.NullPointerException","/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java","@@ -111,6 +111,9 @@ public Vector3D intersection(final SubLine subLine, final boolean includeEndPoin
 
         // compute the intersection on infinite line
         Vector3D v1D = line.intersection(subLine.line);
+        if (v1D == null) {
+            return null;
+        }
 
         // check location of point with respect to first sub-line
         Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));
/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java @@ -115,6 +115,9 @@ public Vector2D intersection(final SubLine subLine, final boolean includeEndPoin
 
         // compute the intersection on infinite line
         Vector2D v2D = line1.intersection(line2);
+        if (v2D == null) {
+            return null;
+        }
 
         // check location of point with respect to first sub-line
         Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));
","@@ -111,6 +111,9 @@ public Vector3D intersection(final SubLine subLine, final boolean includeEndPoin
 
         // compute the intersection on infinite line
         Vector3D v1D = line.intersection(subLine.line);
+        if (v1D == null) {
+            return null;
+        }
 
         // check location of point with respect to first sub-line
         Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));
/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java @@ -115,6 +115,9 @@ public Vector2D intersection(final SubLine subLine, final boolean includeEndPoin
 
         // compute the intersection on infinite line
         Vector2D v2D = line1.intersection(line2);
+        if (v2D == null) {
+            return null;
+        }
 
         // check location of point with respect to first sub-line
         Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));
"
237,"java.lang.OutOfMemoryError","/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java","@@ -559,7 +559,16 @@ protected void setUp() {
      * @return the square-root of the weight matrix.
      */
     private RealMatrix squareRoot(RealMatrix m) {
+        if (m instanceof DiagonalMatrix) {
+            final int dim = m.getRowDimension();
+            final RealMatrix sqrtM = new DiagonalMatrix(dim);
+            for (int i = 0; i < dim; i++) {
+               sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));
+            }
+            return sqrtM;
+        } else {
             final EigenDecomposition dec = new EigenDecomposition(m);
             return dec.getSquareRoot();
+        }
     }
 }
","@@ -559,7 +559,16 @@ protected void setUp() {
      * @return the square-root of the weight matrix.
      */
     private RealMatrix squareRoot(RealMatrix m) {
+        if (m instanceof DiagonalMatrix) {
+            final int dim = m.getRowDimension();
+            final RealMatrix sqrtM = new DiagonalMatrix(dim);
+            for (int i = 0; i < dim; i++) {
+               sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));
+            }
+            return sqrtM;
+        } else {
             final EigenDecomposition dec = new EigenDecomposition(m);
             return dec.getSquareRoot();
+        }
     }
 }
"
238,"java.lang.OutOfMemoryError","/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/Weight.java","@@ -40,10 +40,7 @@
      */
     public Weight(double[] weight) {
         final int dim = weight.length;
+        weightMatrix = new DiagonalMatrix(weight);
     }
 
     /**
/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java @@ -264,7 +264,16 @@ private void parseOptimizationData(OptimizationData... optData) {
      * @return the square-root of the weight matrix.
      */
     private RealMatrix squareRoot(RealMatrix m) {
+        if (m instanceof DiagonalMatrix) {
+            final int dim = m.getRowDimension();
+            final RealMatrix sqrtM = new DiagonalMatrix(dim);
+            for (int i = 0; i < dim; i++) {
+                sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));
+            }
+            return sqrtM;
+        } else {
             final EigenDecomposition dec = new EigenDecomposition(m);
             return dec.getSquareRoot();
+        }
     }
 }
","@@ -40,10 +40,7 @@
      */
     public Weight(double[] weight) {
         final int dim = weight.length;
+        weightMatrix = new DiagonalMatrix(weight);
     }
 
     /**
/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java @@ -264,7 +264,16 @@ private void parseOptimizationData(OptimizationData... optData) {
      * @return the square-root of the weight matrix.
      */
     private RealMatrix squareRoot(RealMatrix m) {
+        if (m instanceof DiagonalMatrix) {
+            final int dim = m.getRowDimension();
+            final RealMatrix sqrtM = new DiagonalMatrix(dim);
+            for (int i = 0; i < dim; i++) {
+                sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));
+            }
+            return sqrtM;
+        } else {
             final EigenDecomposition dec = new EigenDecomposition(m);
             return dec.getSquareRoot();
+        }
     }
 }
"
239,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/util/FastMath.java","@@ -310,6 +310,7 @@
     /** 2^52 - double numbers this large must be integral (no fraction) or NaN or Infinite */
     private static final double TWO_POWER_52 = 4503599627370496.0;
     /** 2^53 - double numbers this large must be even. */
+    private static final double TWO_POWER_53 = 2 * TWO_POWER_52;
 
     /** Constant: {@value}. */
     private static final double F_1_3 = 1d / 3d;
@@ -1538,7 +1539,7 @@ public static double pow(double x, double y) {
         /* Handle special case x<0 */
         if (x < 0) {
             // y is an even integer in this case
+            if (y >= TWO_POWER_53 || y <= -TWO_POWER_53) {
                 return pow(-x, y);
             }
 
","@@ -310,6 +310,7 @@
     /** 2^52 - double numbers this large must be integral (no fraction) or NaN or Infinite */
     private static final double TWO_POWER_52 = 4503599627370496.0;
     /** 2^53 - double numbers this large must be even. */
+    private static final double TWO_POWER_53 = 2 * TWO_POWER_52;
 
     /** Constant: {@value}. */
     private static final double F_1_3 = 1d / 3d;
@@ -1538,7 +1539,7 @@ public static double pow(double x, double y) {
         /* Handle special case x<0 */
         if (x < 0) {
             // y is an even integer in this case
+            if (y >= TWO_POWER_53 || y <= -TWO_POWER_53) {
                 return pow(-x, y);
             }
 
"
240,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/dfp/Dfp.java","@@ -1600,7 +1600,11 @@ public Dfp multiply(final Dfp x) {
      * @return product of this and x
      */
     public Dfp multiply(final int x) {
+        if (x >= 0 && x < RADIX) {
             return multiplyFast(x);
+        } else {
+            return multiply(newInstance(x));
+        }
     }
 
     /** Multiply this by a single digit 0&lt;=x&lt;radix.
","@@ -1600,7 +1600,11 @@ public Dfp multiply(final Dfp x) {
      * @return product of this and x
      */
     public Dfp multiply(final int x) {
+        if (x >= 0 && x < RADIX) {
             return multiplyFast(x);
+        } else {
+            return multiply(newInstance(x));
+        }
     }
 
     /** Multiply this by a single digit 0&lt;=x&lt;radix.
"
241,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/distribution/FDistribution.java","@@ -272,7 +272,7 @@ public double getSupportUpperBound() {
 
     /** {@inheritDoc} */
     public boolean isSupportLowerBoundInclusive() {
+        return false;
     }
 
     /** {@inheritDoc} */
/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java @@ -181,7 +181,7 @@ public boolean isSupportLowerBoundInclusive() {
 
     /** {@inheritDoc} */
     public boolean isSupportUpperBoundInclusive() {
+        return true;
     }
 
     /**
","@@ -272,7 +272,7 @@ public double getSupportUpperBound() {
 
     /** {@inheritDoc} */
     public boolean isSupportLowerBoundInclusive() {
+        return false;
     }
 
     /** {@inheritDoc} */
/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java @@ -181,7 +181,7 @@ public boolean isSupportLowerBoundInclusive() {
 
     /** {@inheritDoc} */
     public boolean isSupportUpperBoundInclusive() {
+        return true;
     }
 
     /**
"
242,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/util/FastMath.java","@@ -79,6 +79,7 @@
  */
 public class FastMath {
     /** StrictMath.log(Double.MAX_VALUE): {@value} */
+    private static final double LOG_MAX_VALUE = StrictMath.log(Double.MAX_VALUE);
 
     /** Archimede's constant PI, ratio of circle circumference to diameter. */
     public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;
@@ -391,12 +392,21 @@ public static double cosh(double x) {
       // exp(-z) can be ignored in comparison with exp(z)
 
       if (x > 20) {
+          if (x >= LOG_MAX_VALUE) {
               // Avoid overflow (MATH-905).
+              final double t = exp(0.5 * x);
+              return (0.5 * t) * t;
+          } else {
               return 0.5 * exp(x);
           }
+      } else if (x < -20) {
+          if (x <= -LOG_MAX_VALUE) {
               // Avoid overflow (MATH-905).
+              final double t = exp(-0.5 * x);
+              return (0.5 * t) * t;
+          } else {
               return 0.5 * exp(-x);
+          }
       }
 
       final double hiPrec[] = new double[2];
@@ -452,12 +462,21 @@ public static double sinh(double x) {
       // exp(-z) can be ignored in comparison with exp(z)
 
       if (x > 20) {
+          if (x >= LOG_MAX_VALUE) {
               // Avoid overflow (MATH-905).
+              final double t = exp(0.5 * x);
+              return (0.5 * t) * t;
+          } else {
               return 0.5 * exp(x);
           }
+      } else if (x < -20) {
+          if (x <= -LOG_MAX_VALUE) {
               // Avoid overflow (MATH-905).
+              final double t = exp(-0.5 * x);
+              return (-0.5 * t) * t;
+          } else {
               return -0.5 * exp(-x);
+          }
       }
 
       if (x == 0) {
","@@ -79,6 +79,7 @@
  */
 public class FastMath {
     /** StrictMath.log(Double.MAX_VALUE): {@value} */
+    private static final double LOG_MAX_VALUE = StrictMath.log(Double.MAX_VALUE);
 
     /** Archimede's constant PI, ratio of circle circumference to diameter. */
     public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;
@@ -391,12 +392,21 @@ public static double cosh(double x) {
       // exp(-z) can be ignored in comparison with exp(z)
 
       if (x > 20) {
+          if (x >= LOG_MAX_VALUE) {
               // Avoid overflow (MATH-905).
+              final double t = exp(0.5 * x);
+              return (0.5 * t) * t;
+          } else {
               return 0.5 * exp(x);
           }
+      } else if (x < -20) {
+          if (x <= -LOG_MAX_VALUE) {
               // Avoid overflow (MATH-905).
+              final double t = exp(-0.5 * x);
+              return (0.5 * t) * t;
+          } else {
               return 0.5 * exp(-x);
+          }
       }
 
       final double hiPrec[] = new double[2];
@@ -452,12 +462,21 @@ public static double sinh(double x) {
       // exp(-z) can be ignored in comparison with exp(z)
 
       if (x > 20) {
+          if (x >= LOG_MAX_VALUE) {
               // Avoid overflow (MATH-905).
+              final double t = exp(0.5 * x);
+              return (0.5 * t) * t;
+          } else {
               return 0.5 * exp(x);
           }
+      } else if (x < -20) {
+          if (x <= -LOG_MAX_VALUE) {
               // Avoid overflow (MATH-905).
+              final double t = exp(-0.5 * x);
+              return (-0.5 * t) * t;
+          } else {
               return -0.5 * exp(-x);
+          }
       }
 
       if (x == 0) {
"
243,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java","@@ -929,7 +929,7 @@ public FitnessFunction() {
             double[] res = new double[x.length];
             for (int i = 0; i < x.length; i++) {
                 double diff = boundaries[1][i] - boundaries[0][i];
+                res[i] = x[i] / diff;
             }
             return res;
         }
@@ -955,7 +955,7 @@ public FitnessFunction() {
             double[] res = new double[x.length];
             for (int i = 0; i < x.length; i++) {
                 double diff = boundaries[1][i] - boundaries[0][i];
+                res[i] = diff * x[i];
             }
             return res;
         }
@@ -987,12 +987,14 @@ public boolean isFeasible(final double[] x) {
                 return true;
             }
 
+            final double[] bLoEnc = encode(boundaries[0]);
+            final double[] bHiEnc = encode(boundaries[1]);
 
             for (int i = 0; i < x.length; i++) {
+                if (x[i] < bLoEnc[i]) {
                     return false;
                 }
+                if (x[i] > bHiEnc[i]) {
                     return false;
                 }
             }
","@@ -929,7 +929,7 @@ public FitnessFunction() {
             double[] res = new double[x.length];
             for (int i = 0; i < x.length; i++) {
                 double diff = boundaries[1][i] - boundaries[0][i];
+                res[i] = x[i] / diff;
             }
             return res;
         }
@@ -955,7 +955,7 @@ public FitnessFunction() {
             double[] res = new double[x.length];
             for (int i = 0; i < x.length; i++) {
                 double diff = boundaries[1][i] - boundaries[0][i];
+                res[i] = diff * x[i];
             }
             return res;
         }
@@ -987,12 +987,14 @@ public boolean isFeasible(final double[] x) {
                 return true;
             }
 
+            final double[] bLoEnc = encode(boundaries[0]);
+            final double[] bHiEnc = encode(boundaries[1]);
 
             for (int i = 0; i < x.length; i++) {
+                if (x[i] < bLoEnc[i]) {
                     return false;
                 }
+                if (x[i] > bHiEnc[i]) {
                     return false;
                 }
             }
"
244,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java","@@ -918,7 +918,8 @@ public FitnessFunction() {
          * @return the original objective variables, possibly repaired.
          */
         public double[] repairAndDecode(final double[] x) {
+            return boundaries != null && isRepairMode ?
+                decode(repair(x)) :
                 decode(x);
         }
 
","@@ -918,7 +918,8 @@ public FitnessFunction() {
          * @return the original objective variables, possibly repaired.
          */
         public double[] repairAndDecode(final double[] x) {
+            return boundaries != null && isRepairMode ?
+                decode(repair(x)) :
                 decode(x);
         }
 
"
245,"java.lang.Exception","/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java","@@ -537,6 +537,19 @@ private void checkParameters() {
                 boundaries[1] = uB;
 
                 // Abort early if the normalization will overflow (cf. ""encode"" method).
+                for (int i = 0; i < lB.length; i++) {
+                    if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {
+                        final double max = Double.MAX_VALUE + boundaries[0][i];
+                        final NumberIsTooLargeException e
+                            = new NumberIsTooLargeException(boundaries[1][i],
+                                                            max,
+                                                            true);
+                        e.getContext().addMessage(LocalizedFormats.OVERFLOW);
+                        e.getContext().addMessage(LocalizedFormats.INDEX, i);
+
+                        throw e;
+                    }
+                }
             }
         } else {
             // Convert API to internal handling of boundaries.
","@@ -537,6 +537,19 @@ private void checkParameters() {
                 boundaries[1] = uB;
 
                 // Abort early if the normalization will overflow (cf. ""encode"" method).
+                for (int i = 0; i < lB.length; i++) {
+                    if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {
+                        final double max = Double.MAX_VALUE + boundaries[0][i];
+                        final NumberIsTooLargeException e
+                            = new NumberIsTooLargeException(boundaries[1][i],
+                                                            max,
+                                                            true);
+                        e.getContext().addMessage(LocalizedFormats.OVERFLOW);
+                        e.getContext().addMessage(LocalizedFormats.INDEX, i);
+
+                        throw e;
+                    }
+                }
             }
         } else {
             // Convert API to internal handling of boundaries.
"
246,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java","@@ -148,6 +148,7 @@ protected UnivariatePointValuePair doOptimize() {
         UnivariatePointValuePair current
             = new UnivariatePointValuePair(x, isMinim ? fx : -fx);
         // Best point encountered so far (which is the initial guess).
+        UnivariatePointValuePair best = current;
 
         int iter = 0;
         while (true) {
@@ -231,10 +232,15 @@ protected UnivariatePointValuePair doOptimize() {
                 // User-defined convergence checker.
                 previous = current;
                 current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);
+                best = best(best,
+                            best(current,
+                                 previous,
+                                 isMinim),
+                            isMinim);
 
                 if (checker != null) {
                     if (checker.converged(iter, previous, current)) {
+                        return best;
                     }
                 }
 
@@ -271,9 +277,10 @@ protected UnivariatePointValuePair doOptimize() {
                     }
                 }
             } else { // Default termination (Brent's criterion).
+                return best(best,
                             best(current,
                                  previous,
+                                 isMinim),
                             isMinim);
             }
             ++iter;
","@@ -148,6 +148,7 @@ protected UnivariatePointValuePair doOptimize() {
         UnivariatePointValuePair current
             = new UnivariatePointValuePair(x, isMinim ? fx : -fx);
         // Best point encountered so far (which is the initial guess).
+        UnivariatePointValuePair best = current;
 
         int iter = 0;
         while (true) {
@@ -231,10 +232,15 @@ protected UnivariatePointValuePair doOptimize() {
                 // User-defined convergence checker.
                 previous = current;
                 current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);
+                best = best(best,
+                            best(current,
+                                 previous,
+                                 isMinim),
+                            isMinim);
 
                 if (checker != null) {
                     if (checker.converged(iter, previous, current)) {
+                        return best;
                     }
                 }
 
@@ -271,9 +277,10 @@ protected UnivariatePointValuePair doOptimize() {
                     }
                 }
             } else { // Default termination (Brent's criterion).
+                return best(best,
                             best(current,
                                  previous,
+                                 isMinim),
                             isMinim);
             }
             ++iter;
"
247,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java","@@ -66,7 +66,6 @@ public RectangularCholeskyDecomposition(RealMatrix matrix, double small)
         final double[][] c = matrix.getData();
         final double[][] b = new double[order][order];
 
         int[] index = new int[order];
         for (int i = 0; i < order; ++i) {
             index[i] = i;
@@ -76,21 +75,24 @@ public RectangularCholeskyDecomposition(RealMatrix matrix, double small)
         for (boolean loop = true; loop;) {
 
             // find maximal diagonal element
+            int swapR = r;
             for (int i = r + 1; i < order; ++i) {
                 int ii  = index[i];
+                int isr = index[swapR];
+                if (c[ii][ii] > c[isr][isr]) {
+                    swapR = i;
                 }
             }
 
 
             // swap elements
+            if (swapR != r) {
+                final int tmpIndex    = index[r];
+                index[r]              = index[swapR];
+                index[swapR]          = tmpIndex;
+                final double[] tmpRow = b[r];
+                b[r]                  = b[swapR];
+                b[swapR]              = tmpRow;
             }
 
             // check diagonal element
@@ -121,11 +123,12 @@ public RectangularCholeskyDecomposition(RealMatrix matrix, double small)
                 final double sqrt = FastMath.sqrt(c[ir][ir]);
                 b[r][r] = sqrt;
                 final double inverse  = 1 / sqrt;
+                final double inverse2 = 1 / c[ir][ir];
                 for (int i = r + 1; i < order; ++i) {
                     final int ii = index[i];
                     final double e = inverse * c[ii][ir];
                     b[i][r] = e;
+                    c[ii][ii] -= c[ii][ir] * c[ii][ir] * inverse2;
                     for (int j = r + 1; j < i; ++j) {
                         final int ij = index[j];
                         final double f = c[ii][ij] - e * b[j][r];
","@@ -66,7 +66,6 @@ public RectangularCholeskyDecomposition(RealMatrix matrix, double small)
         final double[][] c = matrix.getData();
         final double[][] b = new double[order][order];
 
         int[] index = new int[order];
         for (int i = 0; i < order; ++i) {
             index[i] = i;
@@ -76,21 +75,24 @@ public RectangularCholeskyDecomposition(RealMatrix matrix, double small)
         for (boolean loop = true; loop;) {
 
             // find maximal diagonal element
+            int swapR = r;
             for (int i = r + 1; i < order; ++i) {
                 int ii  = index[i];
+                int isr = index[swapR];
+                if (c[ii][ii] > c[isr][isr]) {
+                    swapR = i;
                 }
             }
 
 
             // swap elements
+            if (swapR != r) {
+                final int tmpIndex    = index[r];
+                index[r]              = index[swapR];
+                index[swapR]          = tmpIndex;
+                final double[] tmpRow = b[r];
+                b[r]                  = b[swapR];
+                b[swapR]              = tmpRow;
             }
 
             // check diagonal element
@@ -121,11 +123,12 @@ public RectangularCholeskyDecomposition(RealMatrix matrix, double small)
                 final double sqrt = FastMath.sqrt(c[ir][ir]);
                 b[r][r] = sqrt;
                 final double inverse  = 1 / sqrt;
+                final double inverse2 = 1 / c[ir][ir];
                 for (int i = r + 1; i < order; ++i) {
                     final int ii = index[i];
                     final double e = inverse * c[ii][ir];
                     b[i][r] = e;
+                    c[ii][ii] -= c[ii][ir] * c[ii][ir] * inverse2;
                     for (int j = r + 1; j < i; ++j) {
                         final int ij = index[j];
                         final double f = c[ii][ij] - e * b[j][r];
"
248,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java","@@ -227,7 +227,7 @@ protected UnivariatePointValuePair doOptimize() {
 
                 if (checker != null) {
                     if (checker.converged(iter, previous, current)) {
+                        return best(current, previous, isMinim);
                     }
                 }
 
@@ -264,7 +264,7 @@ protected UnivariatePointValuePair doOptimize() {
                     }
                 }
             } else { // Default termination (Brent's criterion).
+                return best(current, previous, isMinim);
             }
             ++iter;
         }
","@@ -227,7 +227,7 @@ protected UnivariatePointValuePair doOptimize() {
 
                 if (checker != null) {
                     if (checker.converged(iter, previous, current)) {
+                        return best(current, previous, isMinim);
                     }
                 }
 
@@ -264,7 +264,7 @@ protected UnivariatePointValuePair doOptimize() {
                     }
                 }
             } else { // Default termination (Brent's criterion).
+                return best(current, previous, isMinim);
             }
             ++iter;
         }
"
249,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java","@@ -170,7 +170,7 @@ private double calculateAsymptoticPValue(final double Umin,
                                              final int n2)
         throws ConvergenceException, MaxCountExceededException {
 
+        final double n1n2prod = n1 * n2;
 
         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation
         final double EU = n1n2prod / 2.0;
","@@ -170,7 +170,7 @@ private double calculateAsymptoticPValue(final double Umin,
                                              final int n2)
         throws ConvergenceException, MaxCountExceededException {
 
+        final double n1n2prod = n1 * n2;
 
         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation
         final double EU = n1n2prod / 2.0;
"
250,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java","@@ -320,8 +320,11 @@ private void guessAOmega() {
                 }
                 a = 0.5 * (yMax - yMin);
             } else {
+                if (c2 == 0) {
                     // In some ill-conditioned cases (cf. MATH-844), the guesser
                     // procedure cannot produce sensible results.
+                    throw new MathIllegalStateException(LocalizedFormats.ZERO_DENOMINATOR);
+                }
 
                 a = FastMath.sqrt(c1 / c2);
                 omega = FastMath.sqrt(c2 / c3);
","@@ -320,8 +320,11 @@ private void guessAOmega() {
                 }
                 a = 0.5 * (yMax - yMin);
             } else {
+                if (c2 == 0) {
                     // In some ill-conditioned cases (cf. MATH-844), the guesser
                     // procedure cannot produce sensible results.
+                    throw new MathIllegalStateException(LocalizedFormats.ZERO_DENOMINATOR);
+                }
 
                 a = FastMath.sqrt(c1 / c2);
                 omega = FastMath.sqrt(c2 / c3);
"
251,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/fraction/Fraction.java","@@ -178,7 +178,7 @@ private Fraction(double value, double epsilon, int maxDenominator, int maxIterat
         long overflow = Integer.MAX_VALUE;
         double r0 = value;
         long a0 = (long)FastMath.floor(r0);
+        if (FastMath.abs(a0) > overflow) {
             throw new FractionConversionException(value, a0, 1l);
         }
 
@@ -206,7 +206,7 @@ private Fraction(double value, double epsilon, int maxDenominator, int maxIterat
             long a1 = (long)FastMath.floor(r1);
             p2 = (a1 * p1) + p0;
             q2 = (a1 * q1) + q0;
+            if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {
                 throw new FractionConversionException(value, p2, q2);
             }
 
","@@ -178,7 +178,7 @@ private Fraction(double value, double epsilon, int maxDenominator, int maxIterat
         long overflow = Integer.MAX_VALUE;
         double r0 = value;
         long a0 = (long)FastMath.floor(r0);
+        if (FastMath.abs(a0) > overflow) {
             throw new FractionConversionException(value, a0, 1l);
         }
 
@@ -206,7 +206,7 @@ private Fraction(double value, double epsilon, int maxDenominator, int maxIterat
             long a1 = (long)FastMath.floor(r1);
             p2 = (a1 * p1) + p0;
             q2 = (a1 * q1) + q0;
+            if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {
                 throw new FractionConversionException(value, p2, q2);
             }
 
"
252,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/fraction/Fraction.java","@@ -594,7 +594,7 @@ public Fraction divide(final int i) {
      * @return the fraction percentage as a <tt>double</tt>.
      */
     public double percentageValue() {
+        return 100 * doubleValue();
     }
 
     /**
","@@ -594,7 +594,7 @@ public Fraction divide(final int i) {
      * @return the fraction percentage as a <tt>double</tt>.
      */
     public double percentageValue() {
+        return 100 * doubleValue();
     }
 
     /**
"
253,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java","@@ -346,10 +346,9 @@ public OpenMapRealVector ebeDivide(RealVector v) {
          * this only. Indeed, if this[i] = 0d and v[i] = 0d, then
          * this[i] / v[i] = NaN, and not 0d.
          */
+        final int n = getDimension();
+        for (int i = 0; i < n; i++) {
+            res.setEntry(i, this.getEntry(i) / v.getEntry(i));
         }
         return res;
     }
@@ -371,6 +370,18 @@ public OpenMapRealVector ebeMultiply(RealVector v) {
          *
          * These special cases are handled below.
          */
+        if (v.isNaN() || v.isInfinite()) {
+            final int n = getDimension();
+            for (int i = 0; i < n; i++) {
+                final double y = v.getEntry(i);
+                if (Double.isNaN(y)) {
+                    res.setEntry(i, Double.NaN);
+                } else if (Double.isInfinite(y)) {
+                    final double x = this.getEntry(i);
+                    res.setEntry(i, x * y);
+                }
+            }
+        }
         return res;
     }
 
","@@ -346,10 +346,9 @@ public OpenMapRealVector ebeDivide(RealVector v) {
          * this only. Indeed, if this[i] = 0d and v[i] = 0d, then
          * this[i] / v[i] = NaN, and not 0d.
          */
+        final int n = getDimension();
+        for (int i = 0; i < n; i++) {
+            res.setEntry(i, this.getEntry(i) / v.getEntry(i));
         }
         return res;
     }
@@ -371,6 +370,18 @@ public OpenMapRealVector ebeMultiply(RealVector v) {
          *
          * These special cases are handled below.
          */
+        if (v.isNaN() || v.isInfinite()) {
+            final int n = getDimension();
+            for (int i = 0; i < n; i++) {
+                final double y = v.getEntry(i);
+                if (Double.isNaN(y)) {
+                    res.setEntry(i, Double.NaN);
+                } else if (Double.isInfinite(y)) {
+                    final double x = this.getEntry(i);
+                    res.setEntry(i, x * y);
+                }
+            }
+        }
         return res;
     }
 
"
254,"org.apache.commons.math3.exception.MaxCountExceededException","/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java","@@ -116,6 +116,7 @@ private Integer getPivotRow(SimplexTableau tableau, final int col) {
             // there's a degeneracy as indicated by a tie in the minimum ratio test
 
             // 1. check if there's an artificial variable that can be forced out of the basis
+            if (tableau.getNumArtificialVariables() > 0) {
                 for (Integer row : minRatioPositions) {
                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {
                         int column = i + tableau.getArtificialVariableOffset();
@@ -125,6 +126,7 @@ private Integer getPivotRow(SimplexTableau tableau, final int col) {
                         }
                     }
                 }
+            }
 
             // 2. apply Bland's rule to prevent cycling:
             //    take the row for which the corresponding basic variable has the smallest index
@@ -135,6 +137,7 @@ private Integer getPivotRow(SimplexTableau tableau, final int col) {
             // Additional heuristic: if we did not get a solution after half of maxIterations
             //                       revert to the simple case of just returning the top-most row
             // This heuristic is based on empirical data gathered while investigating MATH-828.
+            if (getIterations() < getMaxIterations() / 2) {
                 Integer minRow = null;
                 int minIndex = tableau.getWidth();
                 for (Integer row : minRatioPositions) {
@@ -149,6 +152,7 @@ private Integer getPivotRow(SimplexTableau tableau, final int col) {
                     }
                 }
                 return minRow;
+            }
         }
         return minRatioPositions.get(0);
     }
","@@ -116,6 +116,7 @@ private Integer getPivotRow(SimplexTableau tableau, final int col) {
             // there's a degeneracy as indicated by a tie in the minimum ratio test
 
             // 1. check if there's an artificial variable that can be forced out of the basis
+            if (tableau.getNumArtificialVariables() > 0) {
                 for (Integer row : minRatioPositions) {
                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {
                         int column = i + tableau.getArtificialVariableOffset();
@@ -125,6 +126,7 @@ private Integer getPivotRow(SimplexTableau tableau, final int col) {
                         }
                     }
                 }
+            }
 
             // 2. apply Bland's rule to prevent cycling:
             //    take the row for which the corresponding basic variable has the smallest index
@@ -135,6 +137,7 @@ private Integer getPivotRow(SimplexTableau tableau, final int col) {
             // Additional heuristic: if we did not get a solution after half of maxIterations
             //                       revert to the simple case of just returning the top-most row
             // This heuristic is based on empirical data gathered while investigating MATH-828.
+            if (getIterations() < getMaxIterations() / 2) {
                 Integer minRow = null;
                 int minIndex = tableau.getWidth();
                 for (Integer row : minRatioPositions) {
@@ -149,6 +152,7 @@ private Integer getPivotRow(SimplexTableau tableau, final int col) {
                     }
                 }
                 return minRow;
+            }
         }
         return minRatioPositions.get(0);
     }
"
255,"org.apache.commons.math3.exception.ConvergenceException","/src/main/java/org/apache/commons/math3/util/ContinuedFraction.java","@@ -131,8 +131,6 @@ public double evaluate(double x, double epsilon, int maxIterations) {
 
         int n = 1;
         double dPrev = 0.0;
         double cPrev = hPrev;
         double hN = hPrev;
 
@@ -140,34 +138,18 @@ public double evaluate(double x, double epsilon, int maxIterations) {
             final double a = getA(n, x);
             final double b = getB(n, x);
 
+            double dN = a + b * dPrev;
+            if (Precision.equals(dN, 0.0, small)) {
+                dN = small;
+            }
+            double cN = a + b / cPrev;
+            if (Precision.equals(cN, 0.0, small)) {
+                cN = small;
             }
 
+            dN = 1 / dN;
+            final double deltaN = cN * dN;
+            hN = hPrev * deltaN;
 
             if (Double.isInfinite(hN)) {
                 throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,
@@ -182,11 +164,9 @@ public double evaluate(double x, double epsilon, int maxIterations) {
                 break;
             }
 
+            dPrev = dN;
+            cPrev = cN;
+            hPrev = hN;
             n++;
         }
 
","@@ -131,8 +131,6 @@ public double evaluate(double x, double epsilon, int maxIterations) {
 
         int n = 1;
         double dPrev = 0.0;
         double cPrev = hPrev;
         double hN = hPrev;
 
@@ -140,34 +138,18 @@ public double evaluate(double x, double epsilon, int maxIterations) {
             final double a = getA(n, x);
             final double b = getB(n, x);
 
+            double dN = a + b * dPrev;
+            if (Precision.equals(dN, 0.0, small)) {
+                dN = small;
+            }
+            double cN = a + b / cPrev;
+            if (Precision.equals(cN, 0.0, small)) {
+                cN = small;
             }
 
+            dN = 1 / dN;
+            final double deltaN = cN * dN;
+            hN = hPrev * deltaN;
 
             if (Double.isInfinite(hN)) {
                 throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,
@@ -182,11 +164,9 @@ public double evaluate(double x, double epsilon, int maxIterations) {
                 break;
             }
 
+            dPrev = dN;
+            cPrev = cN;
+            hPrev = hN;
             n++;
         }
 
"
256,"java.lang.ClassCastException","/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java","@@ -133,7 +133,7 @@ protected void computeGeometricalProperties() {
 
         if (v.length == 0) {
             final BSPTree<Euclidean2D> tree = getTree(false);
+            if (tree.getCut() == null && (Boolean) tree.getAttribute()) {
                 // the instance covers the whole space
                 setSize(Double.POSITIVE_INFINITY);
                 setBarycenter(Vector2D.NaN);
","@@ -133,7 +133,7 @@ protected void computeGeometricalProperties() {
 
         if (v.length == 0) {
             final BSPTree<Euclidean2D> tree = getTree(false);
+            if (tree.getCut() == null && (Boolean) tree.getAttribute()) {
                 // the instance covers the whole space
                 setSize(Double.POSITIVE_INFINITY);
                 setBarycenter(Vector2D.NaN);
"
257,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java","@@ -48,7 +48,7 @@ public ElitisticListPopulation(final List<Chromosome> chromosomes,
                                    final int populationLimit,
                                    final double elitismRate) {
         super(chromosomes, populationLimit);
+        setElitismRate(elitismRate);
     }
 
     /**
@@ -62,7 +62,7 @@ public ElitisticListPopulation(final List<Chromosome> chromosomes,
      */
     public ElitisticListPopulation(final int populationLimit, final double elitismRate) {
         super(populationLimit);
+        setElitismRate(elitismRate);
     }
 
     /**
","@@ -48,7 +48,7 @@ public ElitisticListPopulation(final List<Chromosome> chromosomes,
                                    final int populationLimit,
                                    final double elitismRate) {
         super(chromosomes, populationLimit);
+        setElitismRate(elitismRate);
     }
 
     /**
@@ -62,7 +62,7 @@ public ElitisticListPopulation(final List<Chromosome> chromosomes,
      */
     public ElitisticListPopulation(final int populationLimit, final double elitismRate) {
         super(populationLimit);
+        setElitismRate(elitismRate);
     }
 
     /**
"
258,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java","@@ -335,7 +335,7 @@ protected void dropPhase1Objective() {
         // positive cost non-artificial variables
         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {
             final double entry = tableau.getEntry(0, i);
+            if (Precision.compareTo(entry, 0d, epsilon) > 0) {
                 columnsToDrop.add(i);
             }
         }
","@@ -335,7 +335,7 @@ protected void dropPhase1Objective() {
         // positive cost non-artificial variables
         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {
             final double entry = tableau.getEntry(0, i);
+            if (Precision.compareTo(entry, 0d, epsilon) > 0) {
                 columnsToDrop.add(i);
             }
         }
"
259,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/complex/Complex.java","@@ -1015,9 +1015,15 @@ public Complex sqrt1z() {
      * @since 1.2
      */
     public Complex tan() {
+        if (isNaN || Double.isInfinite(real)) {
             return NaN;
         }
+        if (imaginary > 20.0) {
+            return createComplex(0.0, 1.0);
+        }
+        if (imaginary < -20.0) {
+            return createComplex(0.0, -1.0);
+        }
 
         double real2 = 2.0 * real;
         double imaginary2 = 2.0 * imaginary;
@@ -1060,9 +1066,15 @@ public Complex tan() {
      * @since 1.2
      */
     public Complex tanh() {
+        if (isNaN || Double.isInfinite(imaginary)) {
             return NaN;
         }
+        if (real > 20.0) {
+            return createComplex(1.0, 0.0);
+        }
+        if (real < -20.0) {
+            return createComplex(-1.0, 0.0);
+        }
         double real2 = 2.0 * real;
         double imaginary2 = 2.0 * imaginary;
         double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);
","@@ -1015,9 +1015,15 @@ public Complex sqrt1z() {
      * @since 1.2
      */
     public Complex tan() {
+        if (isNaN || Double.isInfinite(real)) {
             return NaN;
         }
+        if (imaginary > 20.0) {
+            return createComplex(0.0, 1.0);
+        }
+        if (imaginary < -20.0) {
+            return createComplex(0.0, -1.0);
+        }
 
         double real2 = 2.0 * real;
         double imaginary2 = 2.0 * imaginary;
@@ -1060,9 +1066,15 @@ public Complex tan() {
      * @since 1.2
      */
     public Complex tanh() {
+        if (isNaN || Double.isInfinite(imaginary)) {
             return NaN;
         }
+        if (real > 20.0) {
+            return createComplex(1.0, 0.0);
+        }
+        if (real < -20.0) {
+            return createComplex(-1.0, 0.0);
+        }
         double real2 = 2.0 * real;
         double imaginary2 = 2.0 * imaginary;
         double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);
"
260,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java","@@ -206,6 +206,6 @@ public String toString() {
      * @return chromosome iterator
      */
     public Iterator<Chromosome> iterator() {
+        return getChromosomes().iterator();
     }
 }
","@@ -206,6 +206,6 @@ public String toString() {
      * @return chromosome iterator
      */
     public Iterator<Chromosome> iterator() {
+        return getChromosomes().iterator();
     }
 }
"
261,"org.apache.commons.math.exception.TooManyEvaluationsException","/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java","@@ -232,10 +232,16 @@ protected double doSolve() {
             double targetY;
             if (agingA >= MAXIMAL_AGING) {
                 // we keep updating the high bracket, try to compensate this
+                final int p = agingA - MAXIMAL_AGING;
+                final double weightA = (1 << p) - 1;
+                final double weightB = p + 1;
+                targetY = (weightA * yA - weightB * REDUCTION_FACTOR * yB) / (weightA + weightB);
             } else if (agingB >= MAXIMAL_AGING) {
                 // we keep updating the low bracket, try to compensate this
+                final int p = agingB - MAXIMAL_AGING;
+                final double weightA = p + 1;
+                final double weightB = (1 << p) - 1;
+                targetY = (weightB * yB - weightA * REDUCTION_FACTOR * yA) / (weightA + weightB);
             } else {
                 // bracketing is balanced, try to find the root itself
                 targetY = 0;
","@@ -232,10 +232,16 @@ protected double doSolve() {
             double targetY;
             if (agingA >= MAXIMAL_AGING) {
                 // we keep updating the high bracket, try to compensate this
+                final int p = agingA - MAXIMAL_AGING;
+                final double weightA = (1 << p) - 1;
+                final double weightB = p + 1;
+                targetY = (weightA * yA - weightB * REDUCTION_FACTOR * yB) / (weightA + weightB);
             } else if (agingB >= MAXIMAL_AGING) {
                 // we keep updating the low bracket, try to compensate this
+                final int p = agingB - MAXIMAL_AGING;
+                final double weightA = p + 1;
+                final double weightB = (1 << p) - 1;
+                targetY = (weightB * yB - weightA * REDUCTION_FACTOR * yA) / (weightA + weightB);
             } else {
                 // bracketing is balanced, try to find the root itself
                 targetY = 0;
"
262,"org.apache.commons.math.optimization.direct.BOBYQAOptimizer$PathIsExploredException","/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java","@@ -1657,10 +1657,10 @@ private void prelim(double[] lowerBound,
                     final int tmp2 = jpt;
                     jpt = ipt - n;
                     ipt = tmp2;
+//                     throw new PathIsExploredException(); // XXX
                 }
+                final int iptMinus1 = ipt - 1;
+                final int jptMinus1 = jpt - 1;
                 interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));
                 interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));
             }
@@ -1749,7 +1749,7 @@ private void prelim(double[] lowerBound,
                 final int ih = ipt * (ipt - 1) / 2 + jpt - 1;
                 final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);
                 modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);
+//                 throw new PathIsExploredException(); // XXX
             }
         } while (getEvaluations() < npt);
     } // prelim
","@@ -1657,10 +1657,10 @@ private void prelim(double[] lowerBound,
                     final int tmp2 = jpt;
                     jpt = ipt - n;
                     ipt = tmp2;
+//                     throw new PathIsExploredException(); // XXX
                 }
+                final int iptMinus1 = ipt - 1;
+                final int jptMinus1 = jpt - 1;
                 interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));
                 interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));
             }
@@ -1749,7 +1749,7 @@ private void prelim(double[] lowerBound,
                 final int ih = ipt * (ipt - 1) / 2 + jpt - 1;
                 final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);
                 modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);
+//                 throw new PathIsExploredException(); // XXX
             }
         } while (getEvaluations() < npt);
     } // prelim
"
263,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java","@@ -247,6 +247,15 @@ public void integrate(final ExpandableStatefulODE equations, final double t)
         }
 
         stepSize = hNew;
+        if (forward) {
+            if (stepStart + stepSize >= t) {
+                stepSize = t - stepStart;
+            }
+        } else {
+            if (stepStart + stepSize <= t) {
+                stepSize = t - stepStart;
+            }
+        }
 
         // next stages
         for (int k = 1; k < stages; ++k) {
","@@ -247,6 +247,15 @@ public void integrate(final ExpandableStatefulODE equations, final double t)
         }
 
         stepSize = hNew;
+        if (forward) {
+            if (stepStart + stepSize >= t) {
+                stepSize = t - stepStart;
+            }
+        } else {
+            if (stepStart + stepSize <= t) {
+                stepSize = t - stepStart;
+            }
+        }
 
         // next stages
         for (int k = 1; k < stages; ++k) {
"
264,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/fraction/BigFraction.java","@@ -683,8 +683,14 @@ public BigFraction divide(final BigFraction fraction) {
     @Override
     public double doubleValue() {
         double result = numerator.doubleValue() / denominator.doubleValue();
+        if (Double.isNaN(result)) {
             // Numerator and/or denominator must be out of range:
             // Calculate how far to shift them to put them in range.
+            int shift = Math.max(numerator.bitLength(),
+                                 denominator.bitLength()) - Double.MAX_EXPONENT;
+            result = numerator.shiftRight(shift).doubleValue() /
+                denominator.shiftRight(shift).doubleValue();
+        }
         return result;
     }
 
@@ -730,8 +736,14 @@ public boolean equals(final Object other) {
     @Override
     public float floatValue() {
         float result = numerator.floatValue() / denominator.floatValue();
+        if (Double.isNaN(result)) {
             // Numerator and/or denominator must be out of range:
             // Calculate how far to shift them to put them in range.
+            int shift = Math.max(numerator.bitLength(),
+                                 denominator.bitLength()) - Float.MAX_EXPONENT;
+            result = numerator.shiftRight(shift).floatValue() /
+                denominator.shiftRight(shift).floatValue();
+        }
         return result;
     }
 
","@@ -683,8 +683,14 @@ public BigFraction divide(final BigFraction fraction) {
     @Override
     public double doubleValue() {
         double result = numerator.doubleValue() / denominator.doubleValue();
+        if (Double.isNaN(result)) {
             // Numerator and/or denominator must be out of range:
             // Calculate how far to shift them to put them in range.
+            int shift = Math.max(numerator.bitLength(),
+                                 denominator.bitLength()) - Double.MAX_EXPONENT;
+            result = numerator.shiftRight(shift).doubleValue() /
+                denominator.shiftRight(shift).doubleValue();
+        }
         return result;
     }
 
@@ -730,8 +736,14 @@ public boolean equals(final Object other) {
     @Override
     public float floatValue() {
         float result = numerator.floatValue() / denominator.floatValue();
+        if (Double.isNaN(result)) {
             // Numerator and/or denominator must be out of range:
             // Calculate how far to shift them to put them in range.
+            int shift = Math.max(numerator.bitLength(),
+                                 denominator.bitLength()) - Float.MAX_EXPONENT;
+            result = numerator.shiftRight(shift).floatValue() /
+                denominator.shiftRight(shift).floatValue();
+        }
         return result;
     }
 
"
265,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java","@@ -407,10 +407,12 @@ protected RealPointValuePair getSolution() {
             continue;
           }
           Integer basicRow = getBasicRow(colIndex);
+          if (basicRow != null && basicRow == 0) {
               // if the basic row is found to be the objective function row
               // set the coefficient to 0 -> this case handles unconstrained 
               // variables that are still part of the objective function
+              coefficients[i] = 0;
+          } else if (basicRows.contains(basicRow)) {
               // if multiple variables can take a given value
               // then we choose the first and set the rest equal to 0
               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);
","@@ -407,10 +407,12 @@ protected RealPointValuePair getSolution() {
             continue;
           }
           Integer basicRow = getBasicRow(colIndex);
+          if (basicRow != null && basicRow == 0) {
               // if the basic row is found to be the objective function row
               // set the coefficient to 0 -> this case handles unconstrained 
               // variables that are still part of the objective function
+              coefficients[i] = 0;
+          } else if (basicRows.contains(basicRow)) {
               // if multiple variables can take a given value
               // then we choose the first and set the rest equal to 0
               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);
"
266,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java","@@ -517,7 +517,7 @@ public double evaluate(final double[] values, final double[] weights,
                 }
 
                 double sumWts = 0;
+                for (int i = begin; i < begin + length; i++) {
                     sumWts += weights[i];
                 }
 
","@@ -517,7 +517,7 @@ public double evaluate(final double[] values, final double[] weights,
                 }
 
                 double sumWts = 0;
+                for (int i = begin; i < begin + length; i++) {
                     sumWts += weights[i];
                 }
 
"
267,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java","@@ -277,7 +277,6 @@ protected double acceptStep(final AbstractStepInterpolator interpolator,
 
             double previousT = interpolator.getGlobalPreviousTime();
             final double currentT = interpolator.getGlobalCurrentTime();
 
             // initialize the events states if needed
             if (! statesInitialized) {
@@ -331,6 +330,9 @@ public int compare(EventState es0, EventState es1) {
                 if (isLastStep) {
                     // the event asked to stop integration
                     System.arraycopy(eventY, 0, y, 0, y.length);
+                    for (final EventState remaining : occuringEvents) {
+                        remaining.stepAccepted(eventT, eventY);
+                    }
                     return eventT;
                 }
 
@@ -340,6 +342,9 @@ public int compare(EventState es0, EventState es1) {
                     System.arraycopy(eventY, 0, y, 0, y.length);
                     computeDerivatives(eventT, y, yDot);
                     resetOccurred = true;
+                    for (final EventState remaining : occuringEvents) {
+                        remaining.stepAccepted(eventT, eventY);
+                    }
                     return eventT;
                 }
 
","@@ -277,7 +277,6 @@ protected double acceptStep(final AbstractStepInterpolator interpolator,
 
             double previousT = interpolator.getGlobalPreviousTime();
             final double currentT = interpolator.getGlobalCurrentTime();
 
             // initialize the events states if needed
             if (! statesInitialized) {
@@ -331,6 +330,9 @@ public int compare(EventState es0, EventState es1) {
                 if (isLastStep) {
                     // the event asked to stop integration
                     System.arraycopy(eventY, 0, y, 0, y.length);
+                    for (final EventState remaining : occuringEvents) {
+                        remaining.stepAccepted(eventT, eventY);
+                    }
                     return eventT;
                 }
 
@@ -340,6 +342,9 @@ public int compare(EventState es0, EventState es1) {
                     System.arraycopy(eventY, 0, y, 0, y.length);
                     computeDerivatives(eventT, y, yDot);
                     resetOccurred = true;
+                    for (final EventState remaining : occuringEvents) {
+                        remaining.stepAccepted(eventT, eventY);
+                    }
                     return eventT;
                 }
 
"
268,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java","@@ -155,13 +155,13 @@ public void addValue(double value) {
         secondMoment.increment(value);
         // If mean, variance or geomean have been overridden,
         // need to increment these
+        if (meanImpl != mean) {
             meanImpl.increment(value);
         }
+        if (varianceImpl != variance) {
             varianceImpl.increment(value);
         }
+        if (geoMeanImpl != geoMean) {
             geoMeanImpl.increment(value);
         }
         n++;
","@@ -155,13 +155,13 @@ public void addValue(double value) {
         secondMoment.increment(value);
         // If mean, variance or geomean have been overridden,
         // need to increment these
+        if (meanImpl != mean) {
             meanImpl.increment(value);
         }
+        if (varianceImpl != variance) {
             varianceImpl.increment(value);
         }
+        if (geoMeanImpl != geoMean) {
             geoMeanImpl.increment(value);
         }
         n++;
"
269,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/complex/Complex.java","@@ -1,87 +1,88 @@
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the ""License""); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an ""AS IS"" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package org.apache.commons.math.complex;
 
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.List;
 
 import org.apache.commons.math.FieldElement;
 import org.apache.commons.math.exception.NullArgumentException;
 import org.apache.commons.math.exception.NotPositiveException;
 import org.apache.commons.math.exception.util.LocalizedFormats;
 import org.apache.commons.math.util.MathUtils;
 import org.apache.commons.math.util.FastMath;
 
 /**
  * Representation of a Complex number, i.e. a number which has both a
  * real and imaginary part.
  * <br/>
  * Implementations of arithmetic operations handle {@code NaN} and
  * infinite values according to the rules for {@link java.lang.Double}, i.e.
  * {@link #equals} is an equivalence relation for all instances that have
  * a {@code NaN} in either real or imaginary part, e.g. the following are
  * considered equal:
  * <ul>
  *  <li>{@code 1 + NaNi}</li>
  *  <li>{@code NaN + i}</li>
  *  <li>{@code NaN + NaNi}</li>
  * </ul>
  * Note that this is in contradiction with the IEEE-754 standard for floating
  * point numbers (according to which the test {@code x == x} must fail if
  * {@code x} is {@code NaN}). The method
  * {@link MathUtils#equals(double,double,int) equals for primitive double} in
  * {@link MathUtils} conforms with IEEE-754 while this class conforms with
  * the standard behavior for Java object types.
  * <br/>
  * Implements Serializable since 2.0
  *
  * @version $Id$
  */
 public class Complex implements FieldElement<Complex>, Serializable  {
     /** The square root of -1. A number representing ""0.0 + 1.0i"" */
     public static final Complex I = new Complex(0.0, 1.0);
     // CHECKSTYLE: stop ConstantName
     /** A complex number representing ""NaN + NaNi"" */
     public static final Complex NaN = new Complex(Double.NaN, Double.NaN);
     // CHECKSTYLE: resume ConstantName
     /** A complex number representing ""+INF + INFi"" */
     public static final Complex INF = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);
     /** A complex number representing ""1.0 + 0.0i"" */
     public static final Complex ONE = new Complex(1.0, 0.0);
     /** A complex number representing ""0.0 + 0.0i"" */
     public static final Complex ZERO = new Complex(0.0, 0.0);
 
     /** Serializable version identifier */
     private static final long serialVersionUID = -6195664516687396620L;
 
     /** The imaginary part. */
     private final double imaginary;
     /** The real part. */
     private final double real;
     /** Record whether this complex number is equal to NaN. */
     private final transient boolean isNaN;
     /** Record whether this complex number is infinite. */
     private final transient boolean isInfinite;
     /** Record whether this complex number is zero. */
+    private final transient boolean isZero;
 
     /**
      * Create a complex number given only the real part.
      *
      * @param real Real part.
      */
@@ -98,17 +99,18 @@ public Complex(double real) {
     public Complex(double real, double imaginary) {
         this.real = real;
         this.imaginary = imaginary;
 
         isNaN = Double.isNaN(real) || Double.isNaN(imaginary);
         isInfinite = !isNaN &&
             (Double.isInfinite(real) || Double.isInfinite(imaginary));
+        isZero = real == 0 && imaginary == 0;
     }
 
     /**
      * Return the absolute value of this complex number.
      * Returns {@code NaN} if either real or imaginary part is {@code NaN}
      * and {@code Double.POSITIVE_INFINITY} if neither part is {@code NaN},
      * but at least one part is infinite.
      *
      * @return the absolute value.
      */
@@ -249,60 +251,60 @@ public Complex conjugate() {
     public Complex divide(Complex divisor)
         throws NullArgumentException {
         MathUtils.checkNotNull(divisor);
         if (isNaN || divisor.isNaN) {
             return NaN;
         }
 
+        if (divisor.isZero) {
+            return isZero ? NaN : INF;
         }
 
         if (divisor.isInfinite() && !isInfinite()) {
             return ZERO;
         }
 
         final double c = divisor.getReal();
         final double d = divisor.getImaginary();
 
         if (FastMath.abs(c) < FastMath.abs(d)) {
             double q = c / d;
             double denominator = c * q + d;
             return createComplex((real * q + imaginary) / denominator,
                 (imaginary * q - real) / denominator);
         } else {
             double q = d / c;
             double denominator = d * q + c;
             return createComplex((imaginary * q + real) / denominator,
                 (imaginary - real * q) / denominator);
         }
     }
 
     /**
      * Returns a {@code Complex} whose value is {@code (this / divisor)},
      * with {@code divisor} interpreted as a real number.
      *
      * @param  divisor Value by which this {@code Complex} is to be divided.
      * @return {@code this / divisor}.
      * @see #divide(Complex)
      */
     public Complex divide(double divisor) {
         if (isNaN || Double.isNaN(divisor)) {
             return NaN;
         }
         if (divisor == 0d) {
+            return isZero ? NaN : INF;
         }
         if (Double.isInfinite(divisor)) {
             return !isInfinite() ? ZERO : NaN;
         }
         return createComplex(real / divisor,
                              imaginary  / divisor);
     }
 
     /**
      * Test for the equality of two Complex objects.
      * If both the real and imaginary parts of two complex numbers
      * are exactly the same, and neither is {@code Double.NaN}, the two
      * Complex objects are considered to be equal.
      * All {@code NaN} values are considered to be equal - i.e, if either
      * (or both) real and imaginary parts of the complex number are equal
","@@ -1,87 +1,88 @@
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the ""License""); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an ""AS IS"" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package org.apache.commons.math.complex;
 
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.List;
 
 import org.apache.commons.math.FieldElement;
 import org.apache.commons.math.exception.NullArgumentException;
 import org.apache.commons.math.exception.NotPositiveException;
 import org.apache.commons.math.exception.util.LocalizedFormats;
 import org.apache.commons.math.util.MathUtils;
 import org.apache.commons.math.util.FastMath;
 
 /**
  * Representation of a Complex number, i.e. a number which has both a
  * real and imaginary part.
  * <br/>
  * Implementations of arithmetic operations handle {@code NaN} and
  * infinite values according to the rules for {@link java.lang.Double}, i.e.
  * {@link #equals} is an equivalence relation for all instances that have
  * a {@code NaN} in either real or imaginary part, e.g. the following are
  * considered equal:
  * <ul>
  *  <li>{@code 1 + NaNi}</li>
  *  <li>{@code NaN + i}</li>
  *  <li>{@code NaN + NaNi}</li>
  * </ul>
  * Note that this is in contradiction with the IEEE-754 standard for floating
  * point numbers (according to which the test {@code x == x} must fail if
  * {@code x} is {@code NaN}). The method
  * {@link MathUtils#equals(double,double,int) equals for primitive double} in
  * {@link MathUtils} conforms with IEEE-754 while this class conforms with
  * the standard behavior for Java object types.
  * <br/>
  * Implements Serializable since 2.0
  *
  * @version $Id$
  */
 public class Complex implements FieldElement<Complex>, Serializable  {
     /** The square root of -1. A number representing ""0.0 + 1.0i"" */
     public static final Complex I = new Complex(0.0, 1.0);
     // CHECKSTYLE: stop ConstantName
     /** A complex number representing ""NaN + NaNi"" */
     public static final Complex NaN = new Complex(Double.NaN, Double.NaN);
     // CHECKSTYLE: resume ConstantName
     /** A complex number representing ""+INF + INFi"" */
     public static final Complex INF = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);
     /** A complex number representing ""1.0 + 0.0i"" */
     public static final Complex ONE = new Complex(1.0, 0.0);
     /** A complex number representing ""0.0 + 0.0i"" */
     public static final Complex ZERO = new Complex(0.0, 0.0);
 
     /** Serializable version identifier */
     private static final long serialVersionUID = -6195664516687396620L;
 
     /** The imaginary part. */
     private final double imaginary;
     /** The real part. */
     private final double real;
     /** Record whether this complex number is equal to NaN. */
     private final transient boolean isNaN;
     /** Record whether this complex number is infinite. */
     private final transient boolean isInfinite;
     /** Record whether this complex number is zero. */
+    private final transient boolean isZero;
 
     /**
      * Create a complex number given only the real part.
      *
      * @param real Real part.
      */
@@ -98,17 +99,18 @@ public Complex(double real) {
     public Complex(double real, double imaginary) {
         this.real = real;
         this.imaginary = imaginary;
 
         isNaN = Double.isNaN(real) || Double.isNaN(imaginary);
         isInfinite = !isNaN &&
             (Double.isInfinite(real) || Double.isInfinite(imaginary));
+        isZero = real == 0 && imaginary == 0;
     }
 
     /**
      * Return the absolute value of this complex number.
      * Returns {@code NaN} if either real or imaginary part is {@code NaN}
      * and {@code Double.POSITIVE_INFINITY} if neither part is {@code NaN},
      * but at least one part is infinite.
      *
      * @return the absolute value.
      */
@@ -249,60 +251,60 @@ public Complex conjugate() {
     public Complex divide(Complex divisor)
         throws NullArgumentException {
         MathUtils.checkNotNull(divisor);
         if (isNaN || divisor.isNaN) {
             return NaN;
         }
 
+        if (divisor.isZero) {
+            return isZero ? NaN : INF;
         }
 
         if (divisor.isInfinite() && !isInfinite()) {
             return ZERO;
         }
 
         final double c = divisor.getReal();
         final double d = divisor.getImaginary();
 
         if (FastMath.abs(c) < FastMath.abs(d)) {
             double q = c / d;
             double denominator = c * q + d;
             return createComplex((real * q + imaginary) / denominator,
                 (imaginary * q - real) / denominator);
         } else {
             double q = d / c;
             double denominator = d * q + c;
             return createComplex((imaginary * q + real) / denominator,
                 (imaginary - real * q) / denominator);
         }
     }
 
     /**
      * Returns a {@code Complex} whose value is {@code (this / divisor)},
      * with {@code divisor} interpreted as a real number.
      *
      * @param  divisor Value by which this {@code Complex} is to be divided.
      * @return {@code this / divisor}.
      * @see #divide(Complex)
      */
     public Complex divide(double divisor) {
         if (isNaN || Double.isNaN(divisor)) {
             return NaN;
         }
         if (divisor == 0d) {
+            return isZero ? NaN : INF;
         }
         if (Double.isInfinite(divisor)) {
             return !isInfinite() ? ZERO : NaN;
         }
         return createComplex(real / divisor,
                              imaginary  / divisor);
     }
 
     /**
      * Test for the equality of two Complex objects.
      * If both the real and imaginary parts of two complex numbers
      * are exactly the same, and neither is {@code Double.NaN}, the two
      * Complex objects are considered to be equal.
      * All {@code NaN} values are considered to be equal - i.e, if either
      * (or both) real and imaginary parts of the complex number are equal
"
270,"java.lang.Exception","/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java","@@ -186,6 +186,9 @@ protected final double doSolve() {
                 case REGULA_FALSI:
                     // Detect early that algorithm is stuck, instead of waiting
                     // for the maximum number of iterations to be exceeded.
+                    if (x == x1) {
+                        throw new ConvergenceException();
+                    }
                     break;
                 default:
                     // Should never happen.
","@@ -186,6 +186,9 @@ protected final double doSolve() {
                 case REGULA_FALSI:
                     // Detect early that algorithm is stuck, instead of waiting
                     // for the maximum number of iterations to be exceeded.
+                    if (x == x1) {
+                        throw new ConvergenceException();
+                    }
                     break;
                 default:
                     // Should never happen.
"
271,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java","@@ -184,10 +184,6 @@ protected final double doSolve() {
                     break;
                 case REGULA_FALSI:
                     // Nothing.
                     break;
                 default:
                     // Should never happen.
","@@ -184,10 +184,6 @@ protected final double doSolve() {
                     break;
                 case REGULA_FALSI:
                     // Nothing.
                     break;
                 default:
                     // Should never happen.
"
272,"org.apache.commons.math.MathRuntimeException$6","/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java","@@ -342,7 +342,7 @@ public double dotProduct(RealVector v) {
     public OpenMapRealVector ebeDivide(RealVector v) {
         checkVectorDimensions(v.getDimension());
         OpenMapRealVector res = new OpenMapRealVector(this);
+        Iterator iter = entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));
@@ -355,7 +355,7 @@ public OpenMapRealVector ebeDivide(RealVector v) {
     public OpenMapRealVector ebeDivide(double[] v) {
         checkVectorDimensions(v.length);
         OpenMapRealVector res = new OpenMapRealVector(this);
+        Iterator iter = entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             res.setEntry(iter.key(), iter.value() / v[iter.key()]);
@@ -367,7 +367,7 @@ public OpenMapRealVector ebeDivide(double[] v) {
     public OpenMapRealVector ebeMultiply(RealVector v) {
         checkVectorDimensions(v.getDimension());
         OpenMapRealVector res = new OpenMapRealVector(this);
+        Iterator iter = entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));
@@ -380,7 +380,7 @@ public OpenMapRealVector ebeMultiply(RealVector v) {
     public OpenMapRealVector ebeMultiply(double[] v) {
         checkVectorDimensions(v.length);
         OpenMapRealVector res = new OpenMapRealVector(this);
+        Iterator iter = entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             res.setEntry(iter.key(), iter.value() * v[iter.key()]);
","@@ -342,7 +342,7 @@ public double dotProduct(RealVector v) {
     public OpenMapRealVector ebeDivide(RealVector v) {
         checkVectorDimensions(v.getDimension());
         OpenMapRealVector res = new OpenMapRealVector(this);
+        Iterator iter = entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));
@@ -355,7 +355,7 @@ public OpenMapRealVector ebeDivide(RealVector v) {
     public OpenMapRealVector ebeDivide(double[] v) {
         checkVectorDimensions(v.length);
         OpenMapRealVector res = new OpenMapRealVector(this);
+        Iterator iter = entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             res.setEntry(iter.key(), iter.value() / v[iter.key()]);
@@ -367,7 +367,7 @@ public OpenMapRealVector ebeDivide(double[] v) {
     public OpenMapRealVector ebeMultiply(RealVector v) {
         checkVectorDimensions(v.getDimension());
         OpenMapRealVector res = new OpenMapRealVector(this);
+        Iterator iter = entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));
@@ -380,7 +380,7 @@ public OpenMapRealVector ebeMultiply(RealVector v) {
     public OpenMapRealVector ebeMultiply(double[] v) {
         checkVectorDimensions(v.length);
         OpenMapRealVector res = new OpenMapRealVector(this);
+        Iterator iter = entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             res.setEntry(iter.key(), iter.value() * v[iter.key()]);
"
273,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/complex/Complex.java","@@ -257,7 +257,7 @@ public Complex divide(Complex divisor)
 
         if (divisor.isZero) {
             // return isZero ? NaN : INF; // See MATH-657
+            return NaN;
         }
 
         if (divisor.isInfinite() && !isInfinite()) {
@@ -294,7 +294,7 @@ public Complex divide(double divisor) {
         }
         if (divisor == 0d) {
             // return isZero ? NaN : INF; // See MATH-657
+            return NaN;
         }
         if (Double.isInfinite(divisor)) {
             return !isInfinite() ? ZERO : NaN;
","@@ -257,7 +257,7 @@ public Complex divide(Complex divisor)
 
         if (divisor.isZero) {
             // return isZero ? NaN : INF; // See MATH-657
+            return NaN;
         }
 
         if (divisor.isInfinite() && !isInfinite()) {
@@ -294,7 +294,7 @@ public Complex divide(double divisor) {
         }
         if (divisor == 0d) {
             // return isZero ? NaN : INF; // See MATH-657
+            return NaN;
         }
         if (Double.isInfinite(divisor)) {
             return !isInfinite() ? ZERO : NaN;
"
274,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java","@@ -47,6 +47,11 @@
      */
     public OpenMapRealMatrix(int rowDimension, int columnDimension) {
         super(rowDimension, columnDimension);
+        long lRow = (long) rowDimension;
+        long lCol = (long) columnDimension;
+        if (lRow * lCol >= (long) Integer.MAX_VALUE) {
+            throw new NumberIsTooLargeException(lRow * lCol, Integer.MAX_VALUE, false);
+        }
         this.rows = rowDimension;
         this.columns = columnDimension;
         this.entries = new OpenIntToDoubleHashMap(0.0);
","@@ -47,6 +47,11 @@
      */
     public OpenMapRealMatrix(int rowDimension, int columnDimension) {
         super(rowDimension, columnDimension);
+        long lRow = (long) rowDimension;
+        long lCol = (long) columnDimension;
+        if (lRow * lCol >= (long) Integer.MAX_VALUE) {
+            throw new NumberIsTooLargeException(lRow * lCol, Integer.MAX_VALUE, false);
+        }
         this.rows = rowDimension;
         this.columns = columnDimension;
         this.entries = new OpenIntToDoubleHashMap(0.0);
"
275,"org.apache.commons.math.exception.TooManyEvaluationsException","/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java","@@ -182,10 +182,19 @@ protected final double doSolve() {
                 case PEGASUS:
                     f0 *= f1 / (f1 + fx);
                     break;
+                case REGULA_FALSI:
+                    if (x == x1) {
+                        final double delta = FastMath.max(rtol * FastMath.abs(x1),
+                                                          atol);
                         // Update formula cannot make any progress: Update the
                         // search interval.
+                        x0 = 0.5 * (x0 + x1 - delta);
+                        f0 = computeObjectiveValue(x0);
+                    }
+                    break;
                 default:
                     // Should never happen.
+                    throw new MathInternalError();
                 }
             }
             // Update from [x0, x1] to [x0, x].
","@@ -182,10 +182,19 @@ protected final double doSolve() {
                 case PEGASUS:
                     f0 *= f1 / (f1 + fx);
                     break;
+                case REGULA_FALSI:
+                    if (x == x1) {
+                        final double delta = FastMath.max(rtol * FastMath.abs(x1),
+                                                          atol);
                         // Update formula cannot make any progress: Update the
                         // search interval.
+                        x0 = 0.5 * (x0 + x1 - delta);
+                        f0 = computeObjectiveValue(x0);
+                    }
+                    break;
                 default:
                     // Should never happen.
+                    throw new MathInternalError();
                 }
             }
             // Update from [x0, x1] to [x0, x].
"
276,"org.apache.commons.math.exception.NotStrictlyPositiveException","/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java","@@ -118,7 +118,7 @@ public double value(double x, double[] p) {
      */
     public double[] fit() {
         final double[] guess = (new ParameterGuesser(getObservations())).guess();
+        return fit(guess);
     }
 
     /**
","@@ -118,7 +118,7 @@ public double value(double x, double[] p) {
      */
     public double[] fit() {
         final double[] guess = (new ParameterGuesser(getObservations())).guess();
+        return fit(guess);
     }
 
     /**
"
277,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/util/FastMath.java","@@ -3479,7 +3479,7 @@ public static long max(final long a, final long b) {
      * @return b if a is lesser or equal to b, a otherwise
      */
     public static float max(final float a, final float b) {
+        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a);
     }
 
     /** Compute the maximum of two values
","@@ -3479,7 +3479,7 @@ public static long max(final long a, final long b) {
      * @return b if a is lesser or equal to b, a otherwise
      */
     public static float max(final float a, final float b) {
+        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a);
     }
 
     /** Compute the maximum of two values
"
278,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java","@@ -172,7 +172,7 @@ public KMeansPlusPlusClusterer(final Random random, final EmptyClusterStrategy e
         while (resultSet.size() < k) {
             // For each data point x, compute D(x), the distance between x and
             // the nearest center that has already been chosen.
+            double sum = 0;
             for (int i = 0; i < pointSet.size(); i++) {
                 final T p = pointSet.get(i);
                 final Cluster<T> nearest = getNearestCluster(resultSet, p);
","@@ -172,7 +172,7 @@ public KMeansPlusPlusClusterer(final Random random, final EmptyClusterStrategy e
         while (resultSet.size() < k) {
             // For each data point x, compute D(x), the distance between x and
             // the nearest center that has already been chosen.
+            double sum = 0;
             for (int i = 0; i < pointSet.size(); i++) {
                 final T p = pointSet.get(i);
                 final Cluster<T> nearest = getNearestCluster(resultSet, p);
"
279,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/complex/Complex.java","@@ -150,6 +150,9 @@ public double abs() {
     public Complex add(Complex rhs)
         throws NullArgumentException {
         MathUtils.checkNotNull(rhs);
+        if (isNaN || rhs.isNaN) {
+            return NaN;
+        }
         return createComplex(real + rhs.getReal(),
             imaginary + rhs.getImaginary());
     }
","@@ -150,6 +150,9 @@ public double abs() {
     public Complex add(Complex rhs)
         throws NullArgumentException {
         MathUtils.checkNotNull(rhs);
+        if (isNaN || rhs.isNaN) {
+            return NaN;
+        }
         return createComplex(real + rhs.getReal(),
             imaginary + rhs.getImaginary());
     }
"
280,"org.apache.commons.math.MathRuntimeException$4","/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java","@@ -19,7 +19,7 @@
 import java.io.Serializable;
 
 import org.apache.commons.math.MathException;
-import org.apache.commons.math.MathRuntimeException;
+import org.apache.commons.math.exception.NotStrictlyPositiveException;
 import org.apache.commons.math.exception.util.LocalizedFormats;
 import org.apache.commons.math.special.Gamma;
 import org.apache.commons.math.util.MathUtils;
@@ -91,7 +91,7 @@ public PoissonDistributionImpl(double p) {
      */
     public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {
         if (p <= 0) {
+            throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, p);
         }
         mean = p;
         normal = new NormalDistributionImpl(p, FastMath.sqrt(p));
","@@ -19,7 +19,7 @@
 import java.io.Serializable;
 
 import org.apache.commons.math.MathException;
-import org.apache.commons.math.MathRuntimeException;
+import org.apache.commons.math.exception.NotStrictlyPositiveException;
 import org.apache.commons.math.exception.util.LocalizedFormats;
 import org.apache.commons.math.special.Gamma;
 import org.apache.commons.math.util.MathUtils;
@@ -91,7 +91,7 @@ public PoissonDistributionImpl(double p) {
      */
     public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {
         if (p <= 0) {
+            throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, p);
         }
         mean = p;
         normal = new NormalDistributionImpl(p, FastMath.sqrt(p));
"
281,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/geometry/Vector3D.java","@@ -456,9 +456,21 @@ public static double dotProduct(Vector3D v1, Vector3D v2) {
    */
   public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {
 
+      final double n1 = v1.getNormSq();
+      final double n2 = v2.getNormSq();
+      if ((n1 * n2) < MathUtils.SAFE_MIN) {
+          return ZERO;
+      }
 
       // rescale both vectors without losing precision,
       // to ensure their norm are the same order of magnitude
+      final int deltaExp = (FastMath.getExponent(n1) - FastMath.getExponent(n2)) / 4;
+      final double x1    = FastMath.scalb(v1.x, -deltaExp);
+      final double y1    = FastMath.scalb(v1.y, -deltaExp);
+      final double z1    = FastMath.scalb(v1.z, -deltaExp);
+      final double x2    = FastMath.scalb(v2.x,  deltaExp);
+      final double y2    = FastMath.scalb(v2.y,  deltaExp);
+      final double z2    = FastMath.scalb(v2.z,  deltaExp);
 
       // we reduce cancellation errors by preconditioning,
       // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute
@@ -467,10 +479,15 @@ public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {
       // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf
 
       // compute rho as an 8 bits approximation of v1.v2 / v2.v2
+      final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp);
+      final double rho   = FastMath.rint(256 * ratio) / 256;
 
+      final double x3 = x1 - rho * x2;
+      final double y3 = y1 - rho * y2;
+      final double z3 = z1 - rho * z2;
 
       // compute cross product from v3 and v2 instead of v1 and v2
+      return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2);
 
   }
 
","@@ -456,9 +456,21 @@ public static double dotProduct(Vector3D v1, Vector3D v2) {
    */
   public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {
 
+      final double n1 = v1.getNormSq();
+      final double n2 = v2.getNormSq();
+      if ((n1 * n2) < MathUtils.SAFE_MIN) {
+          return ZERO;
+      }
 
       // rescale both vectors without losing precision,
       // to ensure their norm are the same order of magnitude
+      final int deltaExp = (FastMath.getExponent(n1) - FastMath.getExponent(n2)) / 4;
+      final double x1    = FastMath.scalb(v1.x, -deltaExp);
+      final double y1    = FastMath.scalb(v1.y, -deltaExp);
+      final double z1    = FastMath.scalb(v1.z, -deltaExp);
+      final double x2    = FastMath.scalb(v2.x,  deltaExp);
+      final double y2    = FastMath.scalb(v2.y,  deltaExp);
+      final double z2    = FastMath.scalb(v2.z,  deltaExp);
 
       // we reduce cancellation errors by preconditioning,
       // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute
@@ -467,10 +479,15 @@ public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {
       // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf
 
       // compute rho as an 8 bits approximation of v1.v2 / v2.v2
+      final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp);
+      final double rho   = FastMath.rint(256 * ratio) / 256;
 
+      final double x3 = x1 - rho * x2;
+      final double y3 = y1 - rho * y2;
+      final double z3 = z1 - rho * z2;
 
       // compute cross product from v3 and v2 instead of v1 and v2
+      return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2);
 
   }
 
"
282,"org.apache.commons.math.ConvergenceException","/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java","@@ -123,18 +123,11 @@ public double density(double x) {
      */
     public double cumulativeProbability(double x) throws MathException {
         final double dev = x - mean;
+        if (FastMath.abs(dev) > 40 * standardDeviation) { 
+            return dev < 0 ? 0.0d : 1.0d;
+        }
         return 0.5 * (1.0 + Erf.erf((dev) /
                     (standardDeviation * FastMath.sqrt(2.0))));
     }
 
     /**
","@@ -123,18 +123,11 @@ public double density(double x) {
      */
     public double cumulativeProbability(double x) throws MathException {
         final double dev = x - mean;
+        if (FastMath.abs(dev) > 40 * standardDeviation) { 
+            return dev < 0 ? 0.0d : 1.0d;
+        }
         return 0.5 * (1.0 + Erf.erf((dev) /
                     (standardDeviation * FastMath.sqrt(2.0))));
     }
 
     /**
"
283,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/dfp/Dfp.java","@@ -270,6 +270,9 @@ protected Dfp(final DfpField field, double x) {
             // Zero or sub-normal
             if (x == 0) {
                 // make sure 0 has the right sign
+                if ((bits & 0x8000000000000000L) != 0) {
+                    sign = -1;
+                }
                 return;
             }
 
@@ -2316,7 +2319,10 @@ public double toDouble() {
 
         Dfp y = this;
         boolean negate = false;
+        int cmp0 = compare(this, getZero());
+        if (cmp0 == 0) {
+            return sign < 0 ? -0.0 : +0.0;
+        } else if (cmp0 < 0) {
             y = negate();
             negate = true;
         }
","@@ -270,6 +270,9 @@ protected Dfp(final DfpField field, double x) {
             // Zero or sub-normal
             if (x == 0) {
                 // make sure 0 has the right sign
+                if ((bits & 0x8000000000000000L) != 0) {
+                    sign = -1;
+                }
                 return;
             }
 
@@ -2316,7 +2319,10 @@ public double toDouble() {
 
         Dfp y = this;
         boolean negate = false;
+        int cmp0 = compare(this, getZero());
+        if (cmp0 == 0) {
+            return sign < 0 ? -0.0 : +0.0;
+        } else if (cmp0 < 0) {
             y = negate();
             negate = true;
         }
"
284,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java","@@ -234,13 +234,7 @@ public int getDimension() {
             indices[i] = idx;
         }
 
+        indices[last] = index - count;
 
         return indices;
     }
","@@ -234,13 +234,7 @@ public int getDimension() {
             indices[i] = idx;
         }
 
+        indices[last] = index - count;
 
         return indices;
     }
"
285,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java","@@ -341,7 +341,8 @@ public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {
   Vector3D k     = v1Su1.crossProduct(v2Su2);
   Vector3D u3    = u1.crossProduct(u2);
   double c       = k.dotProduct(u3);
+  final double inPlaneThreshold = 0.001;
+  if (c <= inPlaneThreshold * k.getNorm() * u3.getNorm()) {
     // the (q1, q2, q3) vector is close to the (u1, u2) plane
     // we try other vectors
     Vector3D v3 = Vector3D.crossProduct(v1, v2);
@@ -350,13 +351,13 @@ public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {
     Vector3D u2Prime = u1.crossProduct(u3);
     c = k.dotProduct(u2Prime);
 
+    if (c <= inPlaneThreshold * k.getNorm() * u2Prime.getNorm()) {
       // the (q1, q2, q3) vector is also close to the (u1, u3) plane,
       // it is almost aligned with u1: we try (u2, u3) and (v2, v3)
       k = v2Su2.crossProduct(v3Su3);;
       c = k.dotProduct(u2.crossProduct(u3));;
 
+      if (c <= 0) {
         // the (q1, q2, q3) vector is aligned with everything
         // this is really the identity rotation
         q0 = 1.0;
","@@ -341,7 +341,8 @@ public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {
   Vector3D k     = v1Su1.crossProduct(v2Su2);
   Vector3D u3    = u1.crossProduct(u2);
   double c       = k.dotProduct(u3);
+  final double inPlaneThreshold = 0.001;
+  if (c <= inPlaneThreshold * k.getNorm() * u3.getNorm()) {
     // the (q1, q2, q3) vector is close to the (u1, u2) plane
     // we try other vectors
     Vector3D v3 = Vector3D.crossProduct(v1, v2);
@@ -350,13 +351,13 @@ public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {
     Vector3D u2Prime = u1.crossProduct(u3);
     c = k.dotProduct(u2Prime);
 
+    if (c <= inPlaneThreshold * k.getNorm() * u2Prime.getNorm()) {
       // the (q1, q2, q3) vector is also close to the (u1, u3) plane,
       // it is almost aligned with u1: we try (u2, u3) and (v2, v3)
       k = v2Su2.crossProduct(v3Su3);;
       c = k.dotProduct(u2.crossProduct(u3));;
 
+      if (c <= 0) {
         // the (q1, q2, q3) vector is aligned with everything
         // this is really the identity rotation
         q0 = 1.0;
"
286,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/util/MathUtils.java","@@ -414,7 +414,7 @@ public static double cosh(double x) {
      * @return {@code true} if the values are equal.
      */
     public static boolean equals(double x, double y) {
+        return equals(x, y, 1);
     }
 
     /**
","@@ -414,7 +414,7 @@ public static double cosh(double x) {
      * @return {@code true} if the values are equal.
      */
     public static boolean equals(double x, double y) {
+        return equals(x, y, 1);
     }
 
     /**
"
287,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java","@@ -143,7 +143,7 @@ public UnivariateRealPointValuePair optimize(final FUNC f,
                                                  final GoalType goal,
                                                  final double min, final double max)
         throws FunctionEvaluationException {
+        return optimize(f, goal, min, max, min + 0.5 * (max - min));
     }
 
     /** {@inheritDoc} */
@@ -157,9 +157,8 @@ public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal,
         // Multi-start loop.
         for (int i = 0; i < starts; ++i) {
             try {
+                final double s = (i == 0) ? startValue : min + generator.nextDouble() * (max - min);
+                optima[i] = optimizer.optimize(f, goal, min, max, s);
             } catch (FunctionEvaluationException fee) {
                 optima[i] = null;
             } catch (ConvergenceException ce) {
","@@ -143,7 +143,7 @@ public UnivariateRealPointValuePair optimize(final FUNC f,
                                                  final GoalType goal,
                                                  final double min, final double max)
         throws FunctionEvaluationException {
+        return optimize(f, goal, min, max, min + 0.5 * (max - min));
     }
 
     /** {@inheritDoc} */
@@ -157,9 +157,8 @@ public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal,
         // Multi-start loop.
         for (int i = 0; i < starts; ++i) {
             try {
+                final double s = (i == 0) ? startValue : min + generator.nextDouble() * (max - min);
+                optima[i] = optimizer.optimize(f, goal, min, max, s);
             } catch (FunctionEvaluationException fee) {
                 optima[i] = null;
             } catch (ConvergenceException ce) {
"
288,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java","@@ -41,10 +41,10 @@
      * Construct a solver.
      */
     public BrentOptimizer() {
+        setMaxEvaluations(1000);
         setMaximalIterationCount(100);
+        setAbsoluteAccuracy(1e-11);
+        setRelativeAccuracy(1e-9);
     }
 
     /**
@@ -54,17 +54,10 @@ public BrentOptimizer() {
      */
     protected double doOptimize()
         throws MaxIterationsExceededException, FunctionEvaluationException {
         return localMin(getGoalType() == GoalType.MINIMIZE,
+                        getMin(), getStartValue(), getMax(),
                         getRelativeAccuracy(), getAbsoluteAccuracy());
     }
 
     /**
      * Find the minimum of the function within the interval {@code (lo, hi)}.
@@ -91,8 +84,6 @@ public double optimize(final UnivariateRealFunction f, final GoalType goalType,
      * the function.
      */
     private double localMin(boolean isMinim,
                             double lo, double mid, double hi,
                             double eps, double t)
         throws MaxIterationsExceededException, FunctionEvaluationException {
@@ -116,15 +107,14 @@ private double localMin(boolean isMinim,
         double w = x;
         double d = 0;
         double e = 0;
+        double fx = computeObjectiveValue(x);
+        if (!isMinim) {
             fx = -fx;
         }
         double fv = fx;
         double fw = fx;
 
+        while (true) {
             double m = 0.5 * (a + b);
             final double tol1 = eps * Math.abs(x) + t;
             final double tol2 = 2 * tol1;
@@ -197,8 +187,8 @@ private double localMin(boolean isMinim,
                     u = x + d;
                 }
 
+                double fu = computeObjectiveValue(u);
+                if (!isMinim) {
                     fu = -fu;
                 }
 
@@ -235,11 +225,10 @@ private double localMin(boolean isMinim,
                     }
                 }
             } else { // termination
+                setFunctionValue(isMinim ? fx : -fx);
                 return x;
             }
+            incrementIterationsCounter();
         }
     }
 }
","@@ -41,10 +41,10 @@
      * Construct a solver.
      */
     public BrentOptimizer() {
+        setMaxEvaluations(1000);
         setMaximalIterationCount(100);
+        setAbsoluteAccuracy(1e-11);
+        setRelativeAccuracy(1e-9);
     }
 
     /**
@@ -54,17 +54,10 @@ public BrentOptimizer() {
      */
     protected double doOptimize()
         throws MaxIterationsExceededException, FunctionEvaluationException {
         return localMin(getGoalType() == GoalType.MINIMIZE,
+                        getMin(), getStartValue(), getMax(),
                         getRelativeAccuracy(), getAbsoluteAccuracy());
     }
 
     /**
      * Find the minimum of the function within the interval {@code (lo, hi)}.
@@ -91,8 +84,6 @@ public double optimize(final UnivariateRealFunction f, final GoalType goalType,
      * the function.
      */
     private double localMin(boolean isMinim,
                             double lo, double mid, double hi,
                             double eps, double t)
         throws MaxIterationsExceededException, FunctionEvaluationException {
@@ -116,15 +107,14 @@ private double localMin(boolean isMinim,
         double w = x;
         double d = 0;
         double e = 0;
+        double fx = computeObjectiveValue(x);
+        if (!isMinim) {
             fx = -fx;
         }
         double fv = fx;
         double fw = fx;
 
+        while (true) {
             double m = 0.5 * (a + b);
             final double tol1 = eps * Math.abs(x) + t;
             final double tol2 = 2 * tol1;
@@ -197,8 +187,8 @@ private double localMin(boolean isMinim,
                     u = x + d;
                 }
 
+                double fu = computeObjectiveValue(u);
+                if (!isMinim) {
                     fu = -fu;
                 }
 
@@ -235,11 +225,10 @@ private double localMin(boolean isMinim,
                     }
                 }
             } else { // termination
+                setFunctionValue(isMinim ? fx : -fx);
                 return x;
             }
+            incrementIterationsCounter();
         }
     }
 }
"
289,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java","@@ -239,30 +239,25 @@ protected void updateResidualsAndCost()
     public double getRMS() {
+        return Math.sqrt(getChiSquare() / rows);
     }
 
     /**
      * Get a Chi-Square-like value assuming the N residuals follow N
      * distinct normal distributions centered on 0 and whose variances are
      * the reciprocal of the weights.
      * @return chi-square value
      */
     public double getChiSquare() {
         double chiSquare = 0;
         for (int i = 0; i < rows; ++i) {
             final double residual = residuals[i];
+            chiSquare += residual * residual * residualsWeights[i];
         }
         return chiSquare;
     }
 
     /**
      * Get the covariance matrix of optimized parameters.
      * @return covariance matrix
      * @exception FunctionEvaluationException if the function jacobian cannot
      * be evaluated
      * @exception OptimizationException if the covariance matrix
","@@ -239,30 +239,25 @@ protected void updateResidualsAndCost()
     public double getRMS() {
+        return Math.sqrt(getChiSquare() / rows);
     }
 
     /**
      * Get a Chi-Square-like value assuming the N residuals follow N
      * distinct normal distributions centered on 0 and whose variances are
      * the reciprocal of the weights.
      * @return chi-square value
      */
     public double getChiSquare() {
         double chiSquare = 0;
         for (int i = 0; i < rows; ++i) {
             final double residual = residuals[i];
+            chiSquare += residual * residual * residualsWeights[i];
         }
         return chiSquare;
     }
 
     /**
      * Get the covariance matrix of optimized parameters.
      * @return covariance matrix
      * @exception FunctionEvaluationException if the function jacobian cannot
      * be evaluated
      * @exception OptimizationException if the covariance matrix
"
290,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java","@@ -255,6 +255,8 @@ protected VectorialPointValuePair doOptimize()
         double[] diag    = new double[cols];
         double[] oldX    = new double[cols];
         double[] oldRes  = new double[rows];
+        double[] oldObj  = new double[rows];
+        double[] qtf     = new double[rows];
         double[] work1   = new double[cols];
         double[] work2   = new double[cols];
         double[] work3   = new double[cols];
@@ -267,6 +269,9 @@ protected VectorialPointValuePair doOptimize()
         boolean firstIteration = true;
         VectorialPointValuePair current = new VectorialPointValuePair(point, objective);
         while (true) {
+            for (int i=0;i<rows;i++) {
+                qtf[i]=residuals[i];
+            }
             incrementIterationsCounter();
 
             // compute the Q.R. decomposition of the jacobian matrix
@@ -275,7 +280,7 @@ protected VectorialPointValuePair doOptimize()
             qrDecomposition();
 
             // compute Qt.res
+            qTy(qtf);
             // now we don't need Q anymore,
             // so let jacobian contain the R matrix with its diagonal elements
             for (int k = 0; k < solvedCols; ++k) {
@@ -313,7 +318,7 @@ protected VectorialPointValuePair doOptimize()
                     if (s != 0) {
                         double sum = 0;
                         for (int i = 0; i <= j; ++i) {
+                            sum += jacobian[i][pj] * qtf[i];
                         }
                         maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
                     }
@@ -321,6 +326,8 @@ protected VectorialPointValuePair doOptimize()
             }
             if (maxCosine <= orthoTolerance) {
                 // convergence has been reached
+            	updateResidualsAndCost();
+            	current = new VectorialPointValuePair(point, objective);
                 return current;
             }
 
@@ -341,9 +348,12 @@ protected VectorialPointValuePair doOptimize()
                 double[] tmpVec = residuals;
                 residuals = oldRes;
                 oldRes    = tmpVec;
+                tmpVec    = objective;
+                objective = oldObj;
+                oldObj    = tmpVec;
 
                 // determine the Levenberg-Marquardt parameter
+                determineLMParameter(qtf, delta, diag, work1, work2, work3);
 
                 // compute the new point and the norm of the evolution direction
                 double lmNorm = 0;
@@ -362,7 +372,6 @@ protected VectorialPointValuePair doOptimize()
 
                 // evaluate the function at x + p and calculate its norm
                 updateResidualsAndCost();
 
                 // compute the scaled actual reduction
                 double actRed = -1.0;
@@ -418,9 +427,15 @@ protected VectorialPointValuePair doOptimize()
                         xNorm    += xK * xK;
                     }
                     xNorm = Math.sqrt(xNorm);
+                    current = new VectorialPointValuePair(point, objective);
 
                     // tests for convergence.
+                    if (checker != null) {
                     // we use the vectorial convergence checker
+                    	if (checker.converged(getIterations(), previous, current)) {
+                    		return current;
+                    	}
+                    }
                 } else {
                     // failed iteration, reset the previous values
                     cost = previousCost;
@@ -431,6 +446,9 @@ protected VectorialPointValuePair doOptimize()
                     tmpVec    = residuals;
                     residuals = oldRes;
                     oldRes    = tmpVec;
+                    tmpVec    = objective;
+                    objective = oldObj;
+                    oldObj    = tmpVec;
                 }
                 if (checker==null) {
                 	if (((Math.abs(actRed) <= costRelativeTolerance) &&
@@ -439,10 +457,6 @@ protected VectorialPointValuePair doOptimize()
                        (delta <= parRelativeTolerance * xNorm)) {
                        return current;
                    }
                 }
                 // tests for termination and stringent tolerances
                 // (2.2204e-16 is the machine epsilon for IEEE754)
","@@ -255,6 +255,8 @@ protected VectorialPointValuePair doOptimize()
         double[] diag    = new double[cols];
         double[] oldX    = new double[cols];
         double[] oldRes  = new double[rows];
+        double[] oldObj  = new double[rows];
+        double[] qtf     = new double[rows];
         double[] work1   = new double[cols];
         double[] work2   = new double[cols];
         double[] work3   = new double[cols];
@@ -267,6 +269,9 @@ protected VectorialPointValuePair doOptimize()
         boolean firstIteration = true;
         VectorialPointValuePair current = new VectorialPointValuePair(point, objective);
         while (true) {
+            for (int i=0;i<rows;i++) {
+                qtf[i]=residuals[i];
+            }
             incrementIterationsCounter();
 
             // compute the Q.R. decomposition of the jacobian matrix
@@ -275,7 +280,7 @@ protected VectorialPointValuePair doOptimize()
             qrDecomposition();
 
             // compute Qt.res
+            qTy(qtf);
             // now we don't need Q anymore,
             // so let jacobian contain the R matrix with its diagonal elements
             for (int k = 0; k < solvedCols; ++k) {
@@ -313,7 +318,7 @@ protected VectorialPointValuePair doOptimize()
                     if (s != 0) {
                         double sum = 0;
                         for (int i = 0; i <= j; ++i) {
+                            sum += jacobian[i][pj] * qtf[i];
                         }
                         maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
                     }
@@ -321,6 +326,8 @@ protected VectorialPointValuePair doOptimize()
             }
             if (maxCosine <= orthoTolerance) {
                 // convergence has been reached
+            	updateResidualsAndCost();
+            	current = new VectorialPointValuePair(point, objective);
                 return current;
             }
 
@@ -341,9 +348,12 @@ protected VectorialPointValuePair doOptimize()
                 double[] tmpVec = residuals;
                 residuals = oldRes;
                 oldRes    = tmpVec;
+                tmpVec    = objective;
+                objective = oldObj;
+                oldObj    = tmpVec;
 
                 // determine the Levenberg-Marquardt parameter
+                determineLMParameter(qtf, delta, diag, work1, work2, work3);
 
                 // compute the new point and the norm of the evolution direction
                 double lmNorm = 0;
@@ -362,7 +372,6 @@ protected VectorialPointValuePair doOptimize()
 
                 // evaluate the function at x + p and calculate its norm
                 updateResidualsAndCost();
 
                 // compute the scaled actual reduction
                 double actRed = -1.0;
@@ -418,9 +427,15 @@ protected VectorialPointValuePair doOptimize()
                         xNorm    += xK * xK;
                     }
                     xNorm = Math.sqrt(xNorm);
+                    current = new VectorialPointValuePair(point, objective);
 
                     // tests for convergence.
+                    if (checker != null) {
                     // we use the vectorial convergence checker
+                    	if (checker.converged(getIterations(), previous, current)) {
+                    		return current;
+                    	}
+                    }
                 } else {
                     // failed iteration, reset the previous values
                     cost = previousCost;
@@ -431,6 +446,9 @@ protected VectorialPointValuePair doOptimize()
                     tmpVec    = residuals;
                     residuals = oldRes;
                     oldRes    = tmpVec;
+                    tmpVec    = objective;
+                    objective = oldObj;
+                    oldObj    = tmpVec;
                 }
                 if (checker==null) {
                 	if (((Math.abs(actRed) <= costRelativeTolerance) &&
@@ -439,10 +457,6 @@ protected VectorialPointValuePair doOptimize()
                        (delta <= parRelativeTolerance * xNorm)) {
                        return current;
                    }
                 }
                 // tests for termination and stringent tolerances
                 // (2.2204e-16 is the machine epsilon for IEEE754)
"
291,"java.lang.NullPointerException","/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java","@@ -69,7 +69,7 @@ public double solve(double min, double max)
     /** {@inheritDoc} */
     public double solve(final UnivariateRealFunction f, double min, double max, double initial)
         throws MaxIterationsExceededException, FunctionEvaluationException {
+        return solve(f, min, max);
     }
 
     /** {@inheritDoc} */
","@@ -69,7 +69,7 @@ public double solve(double min, double max)
     /** {@inheritDoc} */
     public double solve(final UnivariateRealFunction f, double min, double max, double initial)
         throws MaxIterationsExceededException, FunctionEvaluationException {
+        return solve(f, min, max);
     }
 
     /** {@inheritDoc} */
"
292,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java","@@ -163,6 +163,7 @@ public LevenbergMarquardtOptimizer() {
         setMaxIterations(1000);
 
         // default values for the tuning parameters
+        setConvergenceChecker(null);
         setInitialStepBoundFactor(100.0);
         setCostRelativeTolerance(1.0e-10);
         setParRelativeTolerance(1.0e-10);
@@ -244,11 +245,13 @@ protected VectorialPointValuePair doOptimize()
         // outer loop
         lmPar = 0;
         boolean firstIteration = true;
+        VectorialPointValuePair current = new VectorialPointValuePair(point, objective);
         while (true) {
 
             incrementIterationsCounter();
 
             // compute the Q.R. decomposition of the jacobian matrix
+            VectorialPointValuePair previous = current;
             updateJacobian();
             qrDecomposition();
 
@@ -300,7 +303,7 @@ protected VectorialPointValuePair doOptimize()
             }
             if (maxCosine <= orthoTolerance) {
                 // convergence has been reached
+                return current;
             }
 
             // rescale if necessary
@@ -342,6 +345,7 @@ protected VectorialPointValuePair doOptimize()
 
                 // evaluate the function at x + p and calculate its norm
                 updateResidualsAndCost();
+                current = new VectorialPointValuePair(point, objective);
 
                 // compute the scaled actual reduction
                 double actRed = -1.0;
@@ -410,14 +414,20 @@ protected VectorialPointValuePair doOptimize()
                 }
 
                 // tests for convergence.
+                if (checker != null) {
                     // we use the vectorial convergence checker
+                    if (checker.converged(getIterations(), previous, current)) {
+                        return current;                        
+                    }
+                } else {
                     // we use the Levenberg-Marquardt specific convergence parameters
                     if (((Math.abs(actRed) <= costRelativeTolerance) &&
                          (preRed <= costRelativeTolerance) &&
                          (ratio <= 2.0)) ||
                         (delta <= parRelativeTolerance * xNorm)) {
+                        return current;
                     }
+                }
 
                 // tests for termination and stringent tolerances
                 // (2.2204e-16 is the machine epsilon for IEEE754)
","@@ -163,6 +163,7 @@ public LevenbergMarquardtOptimizer() {
         setMaxIterations(1000);
 
         // default values for the tuning parameters
+        setConvergenceChecker(null);
         setInitialStepBoundFactor(100.0);
         setCostRelativeTolerance(1.0e-10);
         setParRelativeTolerance(1.0e-10);
@@ -244,11 +245,13 @@ protected VectorialPointValuePair doOptimize()
         // outer loop
         lmPar = 0;
         boolean firstIteration = true;
+        VectorialPointValuePair current = new VectorialPointValuePair(point, objective);
         while (true) {
 
             incrementIterationsCounter();
 
             // compute the Q.R. decomposition of the jacobian matrix
+            VectorialPointValuePair previous = current;
             updateJacobian();
             qrDecomposition();
 
@@ -300,7 +303,7 @@ protected VectorialPointValuePair doOptimize()
             }
             if (maxCosine <= orthoTolerance) {
                 // convergence has been reached
+                return current;
             }
 
             // rescale if necessary
@@ -342,6 +345,7 @@ protected VectorialPointValuePair doOptimize()
 
                 // evaluate the function at x + p and calculate its norm
                 updateResidualsAndCost();
+                current = new VectorialPointValuePair(point, objective);
 
                 // compute the scaled actual reduction
                 double actRed = -1.0;
@@ -410,14 +414,20 @@ protected VectorialPointValuePair doOptimize()
                 }
 
                 // tests for convergence.
+                if (checker != null) {
                     // we use the vectorial convergence checker
+                    if (checker.converged(getIterations(), previous, current)) {
+                        return current;                        
+                    }
+                } else {
                     // we use the Levenberg-Marquardt specific convergence parameters
                     if (((Math.abs(actRed) <= costRelativeTolerance) &&
                          (preRed <= costRelativeTolerance) &&
                          (ratio <= 2.0)) ||
                         (delta <= parRelativeTolerance * xNorm)) {
+                        return current;
                     }
+                }
 
                 // tests for termination and stringent tolerances
                 // (2.2204e-16 is the machine epsilon for IEEE754)
"
293,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java","@@ -168,7 +168,7 @@ public RealMatrix getCorrelationPValues() throws MathException {
                 } else {
                     double r = correlationMatrix.getEntry(i, j);
                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));
+                    out[i][j] = 2 * tDistribution.cumulativeProbability(-t);
                 }
             }
         }
","@@ -168,7 +168,7 @@ public RealMatrix getCorrelationPValues() throws MathException {
                 } else {
                     double r = correlationMatrix.getEntry(i, j);
                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));
+                    out[i][j] = 2 * tDistribution.cumulativeProbability(-t);
                 }
             }
         }
"
294,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java","@@ -297,6 +297,10 @@ public double integrate(final FirstOrderDifferentialEquations equations,
                   // it is so small (much probably exactly 0 due to limited accuracy)
                   // that the code above would fail handling it.
                   // So we set up an artificial 0 size step by copying states
+                  interpolator.storeTime(stepStart);
+                  System.arraycopy(y, 0, yTmp, 0, y0.length);
+                  hNew     = 0;
+                  stepSize = 0;
                   loop     = false;
               } else {
                   // reject the step to match exactly the next switch time
/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java @@ -177,6 +177,9 @@ public double integrate(final FirstOrderDifferentialEquations equations,
                 // it is so small (much probably exactly 0 due to limited accuracy)
                 // that the code above would fail handling it.
                 // So we set up an artificial 0 size step by copying states
+                interpolator.storeTime(stepStart);
+                System.arraycopy(y, 0, yTmp, 0, y0.length);
+                stepSize = 0;
                 loop     = false;
             } else {
                 // reject the step to match exactly the next switch time
","@@ -297,6 +297,10 @@ public double integrate(final FirstOrderDifferentialEquations equations,
                   // it is so small (much probably exactly 0 due to limited accuracy)
                   // that the code above would fail handling it.
                   // So we set up an artificial 0 size step by copying states
+                  interpolator.storeTime(stepStart);
+                  System.arraycopy(y, 0, yTmp, 0, y0.length);
+                  hNew     = 0;
+                  stepSize = 0;
                   loop     = false;
               } else {
                   // reject the step to match exactly the next switch time
/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java @@ -177,6 +177,9 @@ public double integrate(final FirstOrderDifferentialEquations equations,
                 // it is so small (much probably exactly 0 due to limited accuracy)
                 // that the code above would fail handling it.
                 // So we set up an artificial 0 size step by copying states
+                interpolator.storeTime(stepStart);
+                System.arraycopy(y, 0, yTmp, 0, y0.length);
+                stepSize = 0;
                 loop     = false;
             } else {
                 // reject the step to match exactly the next switch time
"
295,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java","@@ -112,7 +112,7 @@ public double solve(final UnivariateRealFunction f,
         // return the first endpoint if it is good enough
         double yMin = f.value(min);
         if (Math.abs(yMin) <= functionValueAccuracy) {
+            setResult(min, 0);
             return result;
         }
 
@@ -124,7 +124,7 @@ public double solve(final UnivariateRealFunction f,
         // return the second endpoint if it is good enough
         double yMax = f.value(max);
         if (Math.abs(yMax) <= functionValueAccuracy) {
+            setResult(max, 0);
             return result;
         }
 
","@@ -112,7 +112,7 @@ public double solve(final UnivariateRealFunction f,
         // return the first endpoint if it is good enough
         double yMin = f.value(min);
         if (Math.abs(yMin) <= functionValueAccuracy) {
+            setResult(min, 0);
             return result;
         }
 
@@ -124,7 +124,7 @@ public double solve(final UnivariateRealFunction f,
         // return the second endpoint if it is good enough
         double yMax = f.value(max);
         if (Math.abs(yMax) <= functionValueAccuracy) {
+            setResult(max, 0);
             return result;
         }
 
"
296,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java","@@ -89,12 +89,12 @@ public MultiStartUnivariateRealOptimizer(final UnivariateRealOptimizer optimizer
 
     /** {@inheritDoc} */
     public double getFunctionValue() {
+        return optimaValues[0];
     }
 
     /** {@inheritDoc} */
     public double getResult() {
+        return optima[0];
     }
 
     /** {@inheritDoc} */
","@@ -89,12 +89,12 @@ public MultiStartUnivariateRealOptimizer(final UnivariateRealOptimizer optimizer
 
     /** {@inheritDoc} */
     public double getFunctionValue() {
+        return optimaValues[0];
     }
 
     /** {@inheritDoc} */
     public double getResult() {
+        return optima[0];
     }
 
     /** {@inheritDoc} */
"
297,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java","@@ -133,6 +133,10 @@ public double solve(final UnivariateRealFunction f,
             return solve(f, initial, yInitial, max, yMax, initial, yInitial);
         }
 
+        if (yMin * yMax > 0) {
+            throw MathRuntimeException.createIllegalArgumentException(
+                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);
+        }
 
         // full Brent algorithm starting with provided initial guess
         return solve(f, min, yMin, max, yMax, initial, yInitial);
","@@ -133,6 +133,10 @@ public double solve(final UnivariateRealFunction f,
             return solve(f, initial, yInitial, max, yMax, initial, yInitial);
         }
 
+        if (yMin * yMax > 0) {
+            throw MathRuntimeException.createIllegalArgumentException(
+                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);
+        }
 
         // full Brent algorithm starting with provided initial guess
         return solve(f, min, yMin, max, yMax, initial, yInitial);
"
298,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java","@@ -242,12 +242,15 @@ public double integrate(final FirstOrderDifferentialEquations equations,
         }
 
         if (firstTime) {
+          final double[] scale = new double[y0.length];
           if (vecAbsoluteTolerance == null) {
+              for (int i = 0; i < scale.length; ++i) {
+                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);
+              }
             } else {
+              for (int i = 0; i < scale.length; ++i) {
+                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);
+              }
             }
           hNew = initializeStep(equations, forward, getOrder(), scale,
                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);
","@@ -242,12 +242,15 @@ public double integrate(final FirstOrderDifferentialEquations equations,
         }
 
         if (firstTime) {
+          final double[] scale = new double[y0.length];
           if (vecAbsoluteTolerance == null) {
+              for (int i = 0; i < scale.length; ++i) {
+                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);
+              }
             } else {
+              for (int i = 0; i < scale.length; ++i) {
+                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);
+              }
             }
           hNew = initializeStep(equations, forward, getOrder(), scale,
                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);
"
299,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/stat/Frequency.java","@@ -300,7 +300,7 @@ public long getCount(char v) {
      */
     @Deprecated
     public double getPct(Object v) {
+        return getPct((Comparable<?>) v);
     }
 
     /**
","@@ -300,7 +300,7 @@ public long getCount(char v) {
      */
     @Deprecated
     public double getPct(Object v) {
+        return getPct((Comparable<?>) v);
     }
 
     /**
"
300,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java","@@ -718,7 +718,7 @@ public double getL1Norm() {
     public double getLInfNorm() {
         double max = 0;
         for (double a : data) {
+            max = Math.max(max, Math.abs(a));
         }
         return max;
     }
/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java @@ -495,15 +495,6 @@ public double getL1Distance(double[] v) throws IllegalArgumentException {
         return max;
     }
 
     /**
      * Optimized method to compute LInfDistance.
      * @param v The vector to compute from
","@@ -718,7 +718,7 @@ public double getL1Norm() {
     public double getLInfNorm() {
         double max = 0;
         for (double a : data) {
+            max = Math.max(max, Math.abs(a));
         }
         return max;
     }
/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java @@ -495,15 +495,6 @@ public double getL1Distance(double[] v) throws IllegalArgumentException {
         return max;
     }
 
     /**
      * Optimized method to compute LInfDistance.
      * @param v The vector to compute from
"
301,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java","@@ -79,7 +79,7 @@ private Integer getPivotRow(final int col, final SimplexTableau tableau) {
         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
             final double entry = tableau.getEntry(i, col);
+            if (MathUtils.compareTo(entry, 0, epsilon) > 0) {
                 final double ratio = rhs / entry;
                 if (ratio < minRatio) {
                     minRatio = ratio;
","@@ -79,7 +79,7 @@ private Integer getPivotRow(final int col, final SimplexTableau tableau) {
         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
             final double entry = tableau.getEntry(i, col);
+            if (MathUtils.compareTo(entry, 0, epsilon) > 0) {
                 final double ratio = rhs / entry;
                 if (ratio < minRatio) {
                     minRatio = ratio;
"
302,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java","@@ -159,24 +159,27 @@ public RealMatrix getU()
             if (m >= n) {
                 // the tridiagonal matrix is Bt.B, where B is upper bidiagonal
                 final RealMatrix e =
+                    eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);
                 final double[][] eData = e.getData();
                 final double[][] wData = new double[m][p];
                 double[] ei1 = eData[0];
+                for (int i = 0; i < p; ++i) {
                     // compute W = B.E.S^(-1) where E is the eigenvectors matrix
                     final double mi = mainBidiagonal[i];
                     final double[] ei0 = ei1;
                     final double[] wi  = wData[i];
+                    if (i < n - 1) {
                         ei1 = eData[i + 1];
                         final double si = secondaryBidiagonal[i];
                         for (int j = 0; j < p; ++j) {
                             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
                         }
+                    } else {
                         for (int j = 0; j < p; ++j) {
+                            wi[j] = mi * ei0[j] / singularValues[j];
                         }
+                    }
+                }
 
                 for (int i = p; i < m; ++i) {
                     wData[i] = new double[p];
@@ -245,23 +248,26 @@ public RealMatrix getV()
                 // the tridiagonal matrix is B.Bt, where B is lower bidiagonal
                 // compute W = Bt.E.S^(-1) where E is the eigenvectors matrix
                 final RealMatrix e =
+                    eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);
                 final double[][] eData = e.getData();
                 final double[][] wData = new double[n][p];
                 double[] ei1 = eData[0];
+                for (int i = 0; i < p; ++i) {
                     final double mi = mainBidiagonal[i];
                     final double[] ei0 = ei1;
                     final double[] wi  = wData[i];
+                    if (i < m - 1) {
                         ei1 = eData[i + 1];
                         final double si = secondaryBidiagonal[i];
                         for (int j = 0; j < p; ++j) {
                             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
                         }
+                    } else {
                         for (int j = 0; j < p; ++j) {
+                            wi[j] = mi * ei0[j] / singularValues[j];
                         }
+                    }
+                }
                 for (int i = p; i < n; ++i) {
                     wData[i] = new double[p];
                 }
","@@ -159,24 +159,27 @@ public RealMatrix getU()
             if (m >= n) {
                 // the tridiagonal matrix is Bt.B, where B is upper bidiagonal
                 final RealMatrix e =
+                    eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);
                 final double[][] eData = e.getData();
                 final double[][] wData = new double[m][p];
                 double[] ei1 = eData[0];
+                for (int i = 0; i < p; ++i) {
                     // compute W = B.E.S^(-1) where E is the eigenvectors matrix
                     final double mi = mainBidiagonal[i];
                     final double[] ei0 = ei1;
                     final double[] wi  = wData[i];
+                    if (i < n - 1) {
                         ei1 = eData[i + 1];
                         final double si = secondaryBidiagonal[i];
                         for (int j = 0; j < p; ++j) {
                             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
                         }
+                    } else {
                         for (int j = 0; j < p; ++j) {
+                            wi[j] = mi * ei0[j] / singularValues[j];
                         }
+                    }
+                }
 
                 for (int i = p; i < m; ++i) {
                     wData[i] = new double[p];
@@ -245,23 +248,26 @@ public RealMatrix getV()
                 // the tridiagonal matrix is B.Bt, where B is lower bidiagonal
                 // compute W = Bt.E.S^(-1) where E is the eigenvectors matrix
                 final RealMatrix e =
+                    eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);
                 final double[][] eData = e.getData();
                 final double[][] wData = new double[n][p];
                 double[] ei1 = eData[0];
+                for (int i = 0; i < p; ++i) {
                     final double mi = mainBidiagonal[i];
                     final double[] ei0 = ei1;
                     final double[] wi  = wData[i];
+                    if (i < m - 1) {
                         ei1 = eData[i + 1];
                         final double si = secondaryBidiagonal[i];
                         for (int j = 0; j < p; ++j) {
                             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
                         }
+                    } else {
                         for (int j = 0; j < p; ++j) {
+                            wi[j] = mi * ei0[j] / singularValues[j];
                         }
+                    }
+                }
                 for (int i = p; i < n; ++i) {
                     wData[i] = new double[p];
                 }
"
303,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java","@@ -61,6 +61,7 @@ public MultiDirectional(final double khi, final double gamma) {
     protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)
         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
 
+        final RealConvergenceChecker checker = getConvergenceChecker();
         while (true) {
 
             incrementIterationsCounter();
@@ -89,8 +90,16 @@ protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)
             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);
             if (comparator.compare(contracted, best) < 0) {
                 // accept the contracted simplex
+                return;
+            }
 
             // check convergence
+            final int iter = getIterations();
+            boolean converged = true;
+            for (int i = 0; i < simplex.length; ++i) {
+                converged &= checker.converged(iter, original[i], simplex[i]);
+            }
+            if (converged) {
                 return;
             }
 
","@@ -61,6 +61,7 @@ public MultiDirectional(final double khi, final double gamma) {
     protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)
         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
 
+        final RealConvergenceChecker checker = getConvergenceChecker();
         while (true) {
 
             incrementIterationsCounter();
@@ -89,8 +90,16 @@ protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)
             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);
             if (comparator.compare(contracted, best) < 0) {
                 // accept the contracted simplex
+                return;
+            }
 
             // check convergence
+            final int iter = getIterations();
+            boolean converged = true;
+            for (int i = 0; i < simplex.length; ++i) {
+                converged &= checker.converged(iter, original[i], simplex[i]);
+            }
+            if (converged) {
                 return;
             }
 
"
304,"java.lang.ArrayIndexOutOfBoundsException","/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java","@@ -600,6 +600,7 @@ private void computeGershgorinCircles() {
         lowerSpectra = Math.min(lowerSpectra, lower);
         final double upper = dCurrent + eCurrent;
         work[upperStart + m - 1] = upper;
+        upperSpectra = Math.max(upperSpectra, upper);
         minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);
 
     }
@@ -902,8 +903,8 @@ private void processGeneralBlock(final int n)
                     diagMax    = work[4 * i0];
                     offDiagMin = work[4 * i0 + 2];
                     double previousEMin = work[4 * i0 + 3];
+                    for (int i = 4 * i0; i < 4 * n0 - 16; i += 4) {
+                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) ||
                             (work[i + 2] <= TOLERANCE_2 * sigma)) {
                             // insert a split
                             work[i + 2]  = -sigma;
@@ -1540,7 +1541,7 @@ private void computeShiftIncrement(final int start, final int end, final int def
                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);
 
                 // approximate contribution to norm squared from i < nn-2.
+                if (end - start > 3) {
                     b2 = work[nn - 13] / work[nn - 15];
                     a2 = a2 + b2;
                     for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
","@@ -600,6 +600,7 @@ private void computeGershgorinCircles() {
         lowerSpectra = Math.min(lowerSpectra, lower);
         final double upper = dCurrent + eCurrent;
         work[upperStart + m - 1] = upper;
+        upperSpectra = Math.max(upperSpectra, upper);
         minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);
 
     }
@@ -902,8 +903,8 @@ private void processGeneralBlock(final int n)
                     diagMax    = work[4 * i0];
                     offDiagMin = work[4 * i0 + 2];
                     double previousEMin = work[4 * i0 + 3];
+                    for (int i = 4 * i0; i < 4 * n0 - 16; i += 4) {
+                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) ||
                             (work[i + 2] <= TOLERANCE_2 * sigma)) {
                             // insert a split
                             work[i + 2]  = -sigma;
@@ -1540,7 +1541,7 @@ private void computeShiftIncrement(final int start, final int end, final int def
                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);
 
                 // approximate contribution to norm squared from i < nn-2.
+                if (end - start > 3) {
                     b2 = work[nn - 13] / work[nn - 15];
                     a2 = a2 + b2;
                     for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
"
305,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java","@@ -1132,7 +1132,7 @@ private int goodStep(final int start, final int end) {
     private boolean flipIfWarranted(final int n, final int step) {
         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {
             // flip array
+            int j = 4 * (n - 1);
             for (int i = 0; i < j; i += 4) {
                 for (int k = 0; k < 4; k += step) {
                     final double tmp = work[i + k];
","@@ -1132,7 +1132,7 @@ private int goodStep(final int start, final int end) {
     private boolean flipIfWarranted(final int n, final int step) {
         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {
             // flip array
+            int j = 4 * (n - 1);
             for (int i = 0; i < j; i += 4) {
                 for (int k = 0; k < 4; k += step) {
                     final double tmp = work[i + k];
"
306,"org.apache.commons.math.MathRuntimeException$4","/src/main/java/org/apache/commons/math/ode/events/EventState.java","@@ -188,6 +188,7 @@ public boolean evaluateStep(final StepInterpolator interpolator)
                 if (g0Positive ^ (gb >= 0)) {
                     // there is a sign change: an event is expected during this step
 
+                    if (ga * gb > 0) {
                         // this is a corner case:
                         // - there was an event near ta,
                         // - there is another event between ta and tb
@@ -195,7 +196,17 @@ public boolean evaluateStep(final StepInterpolator interpolator)
                         // this implies that the real sign of ga is the same as gb, so we need to slightly
                         // shift ta to make sure ga and gb get opposite signs and the solver won't complain
                         // about bracketing
+                        final double epsilon = (forward ? 0.25 : -0.25) * convergence;
+                        for (int k = 0; (k < 4) && (ga * gb > 0); ++k) {
+                            ta += epsilon;
+                            interpolator.setInterpolatedTime(ta);
+                            ga = handler.g(ta, interpolator.getInterpolatedState());
+                        }
+                        if (ga * gb > 0) {
                             // this should never happen
+                            throw MathRuntimeException.createInternalError(null);
+                        }
+                    }
                          
                     // variation direction, with respect to the integration direction
                     increasing = gb >= ga;
","@@ -188,6 +188,7 @@ public boolean evaluateStep(final StepInterpolator interpolator)
                 if (g0Positive ^ (gb >= 0)) {
                     // there is a sign change: an event is expected during this step
 
+                    if (ga * gb > 0) {
                         // this is a corner case:
                         // - there was an event near ta,
                         // - there is another event between ta and tb
@@ -195,7 +196,17 @@ public boolean evaluateStep(final StepInterpolator interpolator)
                         // this implies that the real sign of ga is the same as gb, so we need to slightly
                         // shift ta to make sure ga and gb get opposite signs and the solver won't complain
                         // about bracketing
+                        final double epsilon = (forward ? 0.25 : -0.25) * convergence;
+                        for (int k = 0; (k < 4) && (ga * gb > 0); ++k) {
+                            ta += epsilon;
+                            interpolator.setInterpolatedTime(ta);
+                            ga = handler.g(ta, interpolator.getInterpolatedState());
+                        }
+                        if (ga * gb > 0) {
                             // this should never happen
+                            throw MathRuntimeException.createInternalError(null);
+                        }
+                    }
                          
                     // variation direction, with respect to the integration direction
                     increasing = gb >= ga;
"
307,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java","@@ -289,7 +289,7 @@ private Integer getBasicRowForSolution(final int col) {
      */
     private Integer getBasicRow(final int col, boolean ignoreObjectiveRows) {
         Integer row = null;
+        int start = ignoreObjectiveRows ? getNumObjectiveFunctions() : 0;
         for (int i = start; i < getHeight(); i++) {
             if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {
                 row = i;
@@ -338,11 +338,11 @@ private void copyArray(final double[] src, final double[] dest,
      */
     protected RealPointValuePair getSolution() {
       double[] coefficients = new double[getOriginalNumDecisionVariables()];
+      Integer negativeVarBasicRow = getBasicRowForSolution(getNegativeDecisionVariableOffset());
       double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());
       Set<Integer> basicRows = new HashSet<Integer>();
       for (int i = 0; i < coefficients.length; i++) {
+          Integer basicRow = getBasicRowForSolution(getNumObjectiveFunctions() + i);
           if (basicRows.contains(basicRow)) {
               // if multiple variables can take a given value 
               // then we choose the first and set the rest equal to 0
","@@ -289,7 +289,7 @@ private Integer getBasicRowForSolution(final int col) {
      */
     private Integer getBasicRow(final int col, boolean ignoreObjectiveRows) {
         Integer row = null;
+        int start = ignoreObjectiveRows ? getNumObjectiveFunctions() : 0;
         for (int i = start; i < getHeight(); i++) {
             if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {
                 row = i;
@@ -338,11 +338,11 @@ private void copyArray(final double[] src, final double[] dest,
      */
     protected RealPointValuePair getSolution() {
       double[] coefficients = new double[getOriginalNumDecisionVariables()];
+      Integer negativeVarBasicRow = getBasicRowForSolution(getNegativeDecisionVariableOffset());
       double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());
       Set<Integer> basicRows = new HashSet<Integer>();
       for (int i = 0; i < coefficients.length; i++) {
+          Integer basicRow = getBasicRowForSolution(getNumObjectiveFunctions() + i);
           if (basicRows.contains(basicRow)) {
               // if multiple variables can take a given value 
               // then we choose the first and set the rest equal to 0
"
308,"java.lang.NullPointerException","/src/main/java/org/apache/commons/math/util/MathUtils.java","@@ -1621,9 +1621,9 @@ public static double distance(double[] p1, double[] p2) {
      * @return the L<sub>2</sub> distance between the two points
      */
     public static double distance(int[] p1, int[] p2) {
+      double sum = 0;
       for (int i = 0; i < p1.length; i++) {
+          final double dp = p1[i] - p2[i];
           sum += dp * dp;
       }
       return Math.sqrt(sum);
","@@ -1621,9 +1621,9 @@ public static double distance(double[] p1, double[] p2) {
      * @return the L<sub>2</sub> distance between the two points
      */
     public static double distance(int[] p1, int[] p2) {
+      double sum = 0;
       for (int i = 0; i < p1.length; i++) {
+          final double dp = p1[i] - p2[i];
           sum += dp * dp;
       }
       return Math.sqrt(sum);
"
309,"org.apache.commons.math.MathException","/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java","@@ -195,7 +195,7 @@ public static double solve(UnivariateRealFunction f, double x0, double x1,
         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && 
                 ((a > lowerBound) || (b < upperBound)));
    
+        if (fa * fb > 0.0 ) {
             throw new ConvergenceException(
                       ""number of iterations={0}, maximum iterations={1}, "" +
                       ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +
","@@ -195,7 +195,7 @@ public static double solve(UnivariateRealFunction f, double x0, double x1,
         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && 
                 ((a > lowerBound) || (b < upperBound)));
    
+        if (fa * fb > 0.0 ) {
             throw new ConvergenceException(
                       ""number of iterations={0}, maximum iterations={1}, "" +
                       ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +
"
310,"java.lang.ClassCastException","/src/java/org/apache/commons/math/stat/Frequency.java","@@ -107,7 +107,11 @@ public String toString() {
      */
     @Deprecated
     public void addValue(Object v) {
+        if (v instanceof Comparable<?>){
             addValue((Comparable<?>) v);            
+        } else {
+            throw new IllegalArgumentException(""Object must implement Comparable"");
+        }
     }
     
     /**
","@@ -107,7 +107,11 @@ public String toString() {
      */
     @Deprecated
     public void addValue(Object v) {
+        if (v instanceof Comparable<?>){
             addValue((Comparable<?>) v);            
+        } else {
+            throw new IllegalArgumentException(""Object must implement Comparable"");
+        }
     }
     
     /**
"
311,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java","@@ -272,12 +272,10 @@ protected static double getInvertedCoeffiecientSum(final RealVector coefficients
     private Integer getBasicRow(final int col) {
         Integer row = null;
         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {
+            if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {
                 row = i;
+            } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {
                 return null;
             }
         }
         return row;
","@@ -272,12 +272,10 @@ protected static double getInvertedCoeffiecientSum(final RealVector coefficients
     private Integer getBasicRow(final int col) {
         Integer row = null;
         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {
+            if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {
                 row = i;
+            } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {
                 return null;
             }
         }
         return row;
"
312,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java","@@ -111,9 +111,6 @@ public CholeskyDecompositionImpl(final RealMatrix matrix,
 
             final double[] lI = lTData[i];
 
             // check off-diagonal elements (and reset them to 0)
             for (int j = i + 1; j < order; ++j) {
                 final double[] lJ = lTData[j];
@@ -134,6 +131,9 @@ public CholeskyDecompositionImpl(final RealMatrix matrix,
             final double[] ltI = lTData[i];
 
             // check diagonal element
+            if (ltI[i] < absolutePositivityThreshold) {
+                throw new NotPositiveDefiniteMatrixException();
+            }
 
             ltI[i] = Math.sqrt(ltI[i]);
             final double inverse = 1.0 / ltI[i];
","@@ -111,9 +111,6 @@ public CholeskyDecompositionImpl(final RealMatrix matrix,
 
             final double[] lI = lTData[i];
 
             // check off-diagonal elements (and reset them to 0)
             for (int j = i + 1; j < order; ++j) {
                 final double[] lJ = lTData[j];
@@ -134,6 +131,9 @@ public CholeskyDecompositionImpl(final RealMatrix matrix,
             final double[] ltI = lTData[i];
 
             // check diagonal element
+            if (ltI[i] < absolutePositivityThreshold) {
+                throw new NotPositiveDefiniteMatrixException();
+            }
 
             ltI[i] = Math.sqrt(ltI[i]);
             final double inverse = 1.0 / ltI[i];
"
313,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java","@@ -326,19 +326,18 @@ protected RealPointValuePair getSolution() {
         Integer basicRow =
             getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());
         double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());
+        Set<Integer> basicRows = new HashSet<Integer>();
         for (int i = 0; i < coefficients.length; i++) {
             basicRow = getBasicRow(getNumObjectiveFunctions() + i);
+            if (basicRows.contains(basicRow)) {
                 // if multiple variables can take a given value 
                 // then we choose the first and set the rest equal to 0
+                coefficients[i] = 0;
+            } else {
+                basicRows.add(basicRow);
                 coefficients[i] =
                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
                     (restrictToNonNegative ? 0 : mostNegative);
             }
         }
         return new RealPointValuePair(coefficients, f.getValue(coefficients));
","@@ -326,19 +326,18 @@ protected RealPointValuePair getSolution() {
         Integer basicRow =
             getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());
         double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());
+        Set<Integer> basicRows = new HashSet<Integer>();
         for (int i = 0; i < coefficients.length; i++) {
             basicRow = getBasicRow(getNumObjectiveFunctions() + i);
+            if (basicRows.contains(basicRow)) {
                 // if multiple variables can take a given value 
                 // then we choose the first and set the rest equal to 0
+                coefficients[i] = 0;
+            } else {
+                basicRows.add(basicRow);
                 coefficients[i] =
                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
                     (restrictToNonNegative ? 0 : mostNegative);
             }
         }
         return new RealPointValuePair(coefficients, f.getValue(coefficients));
"
314,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/math/fraction/Fraction.java","@@ -256,8 +256,8 @@ public Fraction abs() {
      *         than <tt>object</tt>, 0 if they are equal.
      */
     public int compareTo(Fraction object) {
+        long nOd = ((long) numerator) * object.denominator;
+        long dOn = ((long) denominator) * object.numerator;
         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);
     }
     
","@@ -256,8 +256,8 @@ public Fraction abs() {
      *         than <tt>object</tt>, 0 if they are equal.
      */
     public int compareTo(Fraction object) {
+        long nOd = ((long) numerator) * object.denominator;
+        long dOn = ((long) denominator) * object.numerator;
         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);
     }
     
"
315,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/math/util/MathUtils.java","@@ -342,8 +342,10 @@ public static boolean equals(double[] x, double[] y) {
      * @throws IllegalArgumentException if n < 0
      */
     public static long factorial(final int n) {
+        if (n < 0) {
+            throw new IllegalArgumentException(""must have n >= 0 for n!"");
+        }
+        if (n > 20) {
             throw new ArithmeticException(
                     ""factorial value is too large to fit in a long"");
         }
@@ -374,6 +376,9 @@ public static double factorialDouble(final int n) {
         if (n < 0) {
             throw new IllegalArgumentException(""must have n >= 0 for n!"");
         }
+        if (n < 21) {
+            return factorial(n);
+        }
         return Math.floor(Math.exp(factorialLog(n)) + 0.5);
     }
 
@@ -394,6 +399,9 @@ public static double factorialLog(final int n) {
         if (n < 0) {
             throw new IllegalArgumentException(""must have n > 0 for n!"");
         }
+        if (n < 21) {
+            return Math.log(factorial(n));
+        }
         double logSum = 0;
         for (int i = 2; i <= n; i++) {
             logSum += Math.log((double)i);
","@@ -342,8 +342,10 @@ public static boolean equals(double[] x, double[] y) {
      * @throws IllegalArgumentException if n < 0
      */
     public static long factorial(final int n) {
+        if (n < 0) {
+            throw new IllegalArgumentException(""must have n >= 0 for n!"");
+        }
+        if (n > 20) {
             throw new ArithmeticException(
                     ""factorial value is too large to fit in a long"");
         }
@@ -374,6 +376,9 @@ public static double factorialDouble(final int n) {
         if (n < 0) {
             throw new IllegalArgumentException(""must have n >= 0 for n!"");
         }
+        if (n < 21) {
+            return factorial(n);
+        }
         return Math.floor(Math.exp(factorialLog(n)) + 0.5);
     }
 
@@ -394,6 +399,9 @@ public static double factorialLog(final int n) {
         if (n < 0) {
             throw new IllegalArgumentException(""must have n > 0 for n!"");
         }
+        if (n < 21) {
+            return Math.log(factorial(n));
+        }
         double logSum = 0;
         for (int i = 2; i <= n; i++) {
             logSum += Math.log((double)i);
"
316,"java.lang.IllegalArgumentException","/src/java/org/apache/commons/math/distribution/FDistributionImpl.java","@@ -141,10 +141,12 @@ protected double getDomainUpperBound(double p) {
      * @return initial domain value
      */
     protected double getInitialDomain(double p) {
+        double ret = 1.0;
         double d = getDenominatorDegreesOfFreedom();
+        if (d > 2.0) {
             // use mean
             ret = d / (d - 2.0);
+        }
         return ret;
     }
     
","@@ -141,10 +141,12 @@ protected double getDomainUpperBound(double p) {
      * @return initial domain value
      */
     protected double getInitialDomain(double p) {
+        double ret = 1.0;
         double d = getDenominatorDegreesOfFreedom();
+        if (d > 2.0) {
             // use mean
             ret = d / (d - 2.0);
+        }
         return ret;
     }
     
"
317,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/math/util/MathUtils.java","@@ -409,7 +409,7 @@ public static double factorialLog(final int n) {
      * @since 1.1
      */
     public static int gcd(int u, int v) {
+        if ((u == 0) || (v == 0)) {
             return (Math.abs(u) + Math.abs(v));
         }
         // keep u and v negative, as negative integers range down to
","@@ -409,7 +409,7 @@ public static double factorialLog(final int n) {
      * @since 1.1
      */
     public static int gcd(int u, int v) {
+        if ((u == 0) || (v == 0)) {
             return (Math.abs(u) + Math.abs(v));
         }
         // keep u and v negative, as negative integers range down to
"
318,"java.lang.IllegalArgumentException","/src/java/org/apache/commons/math/stat/Frequency.java","@@ -107,6 +107,8 @@ public String toString() {
      */
     @Deprecated
     public void addValue(Object v) {
+        addValue((Comparable<?>) v);
+    }
     
     /**
      * Adds 1 to the frequency count for v.
@@ -118,6 +120,7 @@ public void addValue(Object v) {
      * @param v the value to add.
      * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries
      */
+    public void addValue(Comparable<?>v){
         Object obj = v;
         if (v instanceof Integer) {
            obj = Long.valueOf(((Integer) v).longValue());
","@@ -107,6 +107,8 @@ public String toString() {
      */
     @Deprecated
     public void addValue(Object v) {
+        addValue((Comparable<?>) v);
+    }
     
     /**
      * Adds 1 to the frequency count for v.
@@ -118,6 +120,7 @@ public void addValue(Object v) {
      * @param v the value to add.
      * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries
      */
+    public void addValue(Comparable<?>v){
         Object obj = v;
         if (v instanceof Integer) {
            obj = Long.valueOf(((Integer) v).longValue());
"
319,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/math/complex/Complex.java","@@ -255,7 +255,7 @@ public boolean equals(Object other) {
                 if (rhs.isNaN()) {
                     ret = this.isNaN();
                 } else {
+                    ret = (real == rhs.real) && (imaginary == rhs.imaginary); 
                 }
             } catch (ClassCastException ex) {
                 // ignore exception
","@@ -255,7 +255,7 @@ public boolean equals(Object other) {
                 if (rhs.isNaN()) {
                     ret = this.isNaN();
                 } else {
+                    ret = (real == rhs.real) && (imaginary == rhs.imaginary); 
                 }
             } catch (ClassCastException ex) {
                 // ignore exception
"
320,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/math/util/MathUtils.java","@@ -181,30 +181,43 @@ public static long binomialCoefficient(final int n, final int k) {
         if ((k == 1) || (k == n - 1)) {
             return n;
         }
         // Use symmetry for large k
+        if (k > n / 2)
+            return binomialCoefficient(n, n - k);
         
         // We use the formula
         // (n choose k) = n! / (n-k)! / k!
         // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
         // which could be written
         // (n choose k) == (n-1 choose k-1) * n / k
+        long result = 1;
+        if (n <= 61) {
             // For n <= 61, the naive implementation cannot overflow.
+            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
+                result = result * i / j;
+            }
+        } else if (n <= 66) {
             // For n > 61 but n <= 66, the result cannot overflow,
             // but we must take care not to overflow intermediate values.
+            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
                 // We know that (result * i) is divisible by j,
                 // but (result * i) may overflow, so we split j:
                 // Filter out the gcd, d, so j/d and i/d are integer.
                 // result is divisible by (j/d) because (j/d)
                 // is relative prime to (i/d) and is a divisor of
                 // result * (i/d).
+                long d = gcd(i, j);
+                result = (result / (j / d)) * (i / d);
+            }
+        } else {
             // For n > 66, a result overflow might occur, so we check
             // the multiplication, taking care to not overflow
             // unnecessary.
+            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
+                long d = gcd(i, j);
+                result = mulAndCheck((result / (j / d)), (i / d));
+            }
+        }
         return result;
     }
 
@@ -231,9 +244,33 @@ public static long binomialCoefficient(final int n, final int k) {
      * @throws IllegalArgumentException if preconditions are not met.
      */
     public static double binomialCoefficientDouble(final int n, final int k) {
+        if (n < k) {
+            throw new IllegalArgumentException(
+                ""must have n >= k for binomial coefficient (n,k)"");
+        }
+        if (n < 0) {
+            throw new IllegalArgumentException(
+                ""must have n >= 0 for binomial coefficient (n,k)"");
+        }
+        if ((n == k) || (k == 0)) {
+            return 1d;
+        }
+        if ((k == 1) || (k == n - 1)) {
+            return n;
+        }
+        if (k > n/2) {
+            return binomialCoefficientDouble(n, n - k);
+        }
+        if (n < 67) {
+            return binomialCoefficient(n,k);
+        }
         
+        double result = 1d;
+        for (int i = 1; i <= k; i++) {
+             result *= (double)(n - k + i) / (double)i;
+        }
   
+        return Math.floor(result + 0.5);
     }
     
     /**
@@ -274,11 +311,17 @@ public static double binomialCoefficientLog(final int n, final int k) {
          * For values small enough to do exact integer computation,
          * return the log of the exact value 
          */
+        if (n < 67) {  
+            return Math.log(binomialCoefficient(n,k));
+        }
         
         /*
          * Return the log of binomialCoefficientDouble for values that will not
          * overflow binomialCoefficientDouble
          */
+        if (n < 1030) { 
+            return Math.log(binomialCoefficientDouble(n, k));
+        } 
         
         /*
          * Sum logs for values that could overflow
","@@ -181,30 +181,43 @@ public static long binomialCoefficient(final int n, final int k) {
         if ((k == 1) || (k == n - 1)) {
             return n;
         }
         // Use symmetry for large k
+        if (k > n / 2)
+            return binomialCoefficient(n, n - k);
         
         // We use the formula
         // (n choose k) = n! / (n-k)! / k!
         // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
         // which could be written
         // (n choose k) == (n-1 choose k-1) * n / k
+        long result = 1;
+        if (n <= 61) {
             // For n <= 61, the naive implementation cannot overflow.
+            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
+                result = result * i / j;
+            }
+        } else if (n <= 66) {
             // For n > 61 but n <= 66, the result cannot overflow,
             // but we must take care not to overflow intermediate values.
+            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
                 // We know that (result * i) is divisible by j,
                 // but (result * i) may overflow, so we split j:
                 // Filter out the gcd, d, so j/d and i/d are integer.
                 // result is divisible by (j/d) because (j/d)
                 // is relative prime to (i/d) and is a divisor of
                 // result * (i/d).
+                long d = gcd(i, j);
+                result = (result / (j / d)) * (i / d);
+            }
+        } else {
             // For n > 66, a result overflow might occur, so we check
             // the multiplication, taking care to not overflow
             // unnecessary.
+            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
+                long d = gcd(i, j);
+                result = mulAndCheck((result / (j / d)), (i / d));
+            }
+        }
         return result;
     }
 
@@ -231,9 +244,33 @@ public static long binomialCoefficient(final int n, final int k) {
      * @throws IllegalArgumentException if preconditions are not met.
      */
     public static double binomialCoefficientDouble(final int n, final int k) {
+        if (n < k) {
+            throw new IllegalArgumentException(
+                ""must have n >= k for binomial coefficient (n,k)"");
+        }
+        if (n < 0) {
+            throw new IllegalArgumentException(
+                ""must have n >= 0 for binomial coefficient (n,k)"");
+        }
+        if ((n == k) || (k == 0)) {
+            return 1d;
+        }
+        if ((k == 1) || (k == n - 1)) {
+            return n;
+        }
+        if (k > n/2) {
+            return binomialCoefficientDouble(n, n - k);
+        }
+        if (n < 67) {
+            return binomialCoefficient(n,k);
+        }
         
+        double result = 1d;
+        for (int i = 1; i <= k; i++) {
+             result *= (double)(n - k + i) / (double)i;
+        }
   
+        return Math.floor(result + 0.5);
     }
     
     /**
@@ -274,11 +311,17 @@ public static double binomialCoefficientLog(final int n, final int k) {
          * For values small enough to do exact integer computation,
          * return the log of the exact value 
          */
+        if (n < 67) {  
+            return Math.log(binomialCoefficient(n,k));
+        }
         
         /*
          * Return the log of binomialCoefficientDouble for values that will not
          * overflow binomialCoefficientDouble
          */
+        if (n < 1030) { 
+            return Math.log(binomialCoefficientDouble(n, k));
+        } 
         
         /*
          * Sum logs for values that could overflow
"
321,"java.lang.ArrayIndexOutOfBoundsException","/src/java/org/apache/commons/math/linear/BigMatrixImpl.java","@@ -988,7 +988,7 @@ public BigDecimal getTrace() throws IllegalArgumentException {
         }
         final int nRows = this.getRowDimension();
         final int nCols = this.getColumnDimension();
+        final BigDecimal[] out = new BigDecimal[nRows];
         for (int row = 0; row < nRows; row++) {
             BigDecimal sum = ZERO;
             for (int i = 0; i < nCols; i++) {
/src/java/org/apache/commons/math/linear/RealMatrixImpl.java @@ -776,7 +776,7 @@ public double getTrace() throws IllegalArgumentException {
         if (v.length != nCols) {
             throw new IllegalArgumentException(""vector has wrong length"");
         }
+        final double[] out = new double[nRows];
         for (int row = 0; row < nRows; row++) {
             final double[] dataRow = data[row];
             double sum = 0;
","@@ -988,7 +988,7 @@ public BigDecimal getTrace() throws IllegalArgumentException {
         }
         final int nRows = this.getRowDimension();
         final int nCols = this.getColumnDimension();
+        final BigDecimal[] out = new BigDecimal[nRows];
         for (int row = 0; row < nRows; row++) {
             BigDecimal sum = ZERO;
             for (int i = 0; i < nCols; i++) {
/src/java/org/apache/commons/math/linear/RealMatrixImpl.java @@ -776,7 +776,7 @@ public double getTrace() throws IllegalArgumentException {
         if (v.length != nCols) {
             throw new IllegalArgumentException(""vector has wrong length"");
         }
+        final double[] out = new double[nRows];
         for (int row = 0; row < nRows; row++) {
             final double[] dataRow = data[row];
             double sum = 0;
"
322,"java.lang.StringIndexOutOfBoundsException","/src/java/org/apache/commons/math/complex/ComplexFormat.java","@@ -374,7 +374,8 @@ public Complex parse(String source, ParsePosition pos) {
         int n = getImaginaryCharacter().length();
         startIndex = pos.getIndex();
         int endIndex = startIndex + n;
+        if ((startIndex >= source.length()) ||
+            (endIndex > source.length()) ||
             source.substring(startIndex, endIndex).compareTo(
             getImaginaryCharacter()) != 0) {
             // set index back to initial, error index should be the start index
","@@ -374,7 +374,8 @@ public Complex parse(String source, ParsePosition pos) {
         int n = getImaginaryCharacter().length();
         startIndex = pos.getIndex();
         int endIndex = startIndex + n;
+        if ((startIndex >= source.length()) ||
+            (endIndex > source.length()) ||
             source.substring(startIndex, endIndex).compareTo(
             getImaginaryCharacter()) != 0) {
             // set index back to initial, error index should be the start index
"
323,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java","@@ -261,7 +261,7 @@ public double getSlope() {
      * @return sum of squared errors associated with the regression model
      */
     public double getSumSquaredErrors() {
+        return Math.max(0d, sumYY - sumXY * sumXY / sumXX);
     }
 
     /**
","@@ -261,7 +261,7 @@ public double getSlope() {
      * @return sum of squared errors associated with the regression model
      */
     public double getSumSquaredErrors() {
+        return Math.max(0d, sumYY - sumXY * sumXY / sumXX);
     }
 
     /**
"
324,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/math/special/Gamma.java","@@ -34,7 +34,7 @@
     private static final long serialVersionUID = -6587513359895466954L;
 
     /** Maximum allowed numerical error. */
+    private static final double DEFAULT_EPSILON = 10e-15;
 
     /** Lanczos coefficients */
     private static double[] lanczos =
","@@ -34,7 +34,7 @@
     private static final long serialVersionUID = -6587513359895466954L;
 
     /** Maximum allowed numerical error. */
+    private static final double DEFAULT_EPSILON = 10e-15;
 
     /** Lanczos coefficients */
     private static double[] lanczos =
"
325,"java.lang.IllegalArgumentException","/src/java/org/apache/commons/math/analysis/BrentSolver.java","@@ -135,17 +135,31 @@ public double solve(double min, double max) throws MaxIterationsExceededExceptio
         
         // Verify bracketing
         double sign = yMin * yMax;
+        if (sign > 0) {
             // check if either value is close to a zero
+            if (Math.abs(yMin) <= functionValueAccuracy) {
+                setResult(min, 0);
+                ret = min;
+            } else if (Math.abs(yMax) <= functionValueAccuracy) {
+                setResult(max, 0);
+                ret = max;
+            } else {
                 // neither value is close to zero and min and max do not bracket root.
                 throw new IllegalArgumentException
                 (""Function values at endpoints do not have different signs."" +
                         ""  Endpoints: ["" + min + "","" + max + ""]"" + 
                         ""  Values: ["" + yMin + "","" + yMax + ""]"");
+            }
+        } else if (sign < 0){
             // solve using only the first endpoint as initial guess
             ret = solve(min, yMin, max, yMax, min, yMin);
+        } else {
             // either min or max is a root
+            if (yMin == 0.0) {
+                ret = min;
+            } else {
+                ret = max;
+            }
         }
 
         return ret;
","@@ -135,17 +135,31 @@ public double solve(double min, double max) throws MaxIterationsExceededExceptio
         
         // Verify bracketing
         double sign = yMin * yMax;
+        if (sign > 0) {
             // check if either value is close to a zero
+            if (Math.abs(yMin) <= functionValueAccuracy) {
+                setResult(min, 0);
+                ret = min;
+            } else if (Math.abs(yMax) <= functionValueAccuracy) {
+                setResult(max, 0);
+                ret = max;
+            } else {
                 // neither value is close to zero and min and max do not bracket root.
                 throw new IllegalArgumentException
                 (""Function values at endpoints do not have different signs."" +
                         ""  Endpoints: ["" + min + "","" + max + ""]"" + 
                         ""  Values: ["" + yMin + "","" + yMax + ""]"");
+            }
+        } else if (sign < 0){
             // solve using only the first endpoint as initial guess
             ret = solve(min, yMin, max, yMax, min, yMin);
+        } else {
             // either min or max is a root
+            if (yMin == 0.0) {
+                ret = min;
+            } else {
+                ret = max;
+            }
         }
 
         return ret;
"
326,"java.lang.ArrayIndexOutOfBoundsException","/src/java/org/apache/commons/math/estimation/AbstractEstimator.java","@@ -163,7 +163,7 @@ public double getChiSquare(EstimationProblem problem) {
 
         // compute transpose(J).J, avoiding building big intermediate matrices
         final int rows = problem.getMeasurements().length;
+        final int cols = problem.getUnboundParameters().length;
         final int max  = cols * rows;
         double[][] jTj = new double[cols][cols];
         for (int i = 0; i < cols; ++i) {
@@ -199,12 +199,12 @@ public double getChiSquare(EstimationProblem problem) {
     public double[] guessParametersErrors(EstimationProblem problem)
       throws EstimationException {
         int m = problem.getMeasurements().length;
+        int p = problem.getUnboundParameters().length;
         if (m <= p) {
             throw new EstimationException(""no degrees of freedom ({0} measurements, {1} parameters)"",
                                           new Object[] { new Integer(m), new Integer(p)});
         }
+        double[] errors = new double[problem.getUnboundParameters().length];
         final double c = Math.sqrt(getChiSquare(problem) / (m - p));
         double[][] covar = getCovariances(problem);
         for (int i = 0; i < errors.length; ++i) {
","@@ -163,7 +163,7 @@ public double getChiSquare(EstimationProblem problem) {
 
         // compute transpose(J).J, avoiding building big intermediate matrices
         final int rows = problem.getMeasurements().length;
+        final int cols = problem.getUnboundParameters().length;
         final int max  = cols * rows;
         double[][] jTj = new double[cols][cols];
         for (int i = 0; i < cols; ++i) {
@@ -199,12 +199,12 @@ public double getChiSquare(EstimationProblem problem) {
     public double[] guessParametersErrors(EstimationProblem problem)
       throws EstimationException {
         int m = problem.getMeasurements().length;
+        int p = problem.getUnboundParameters().length;
         if (m <= p) {
             throw new EstimationException(""no degrees of freedom ({0} measurements, {1} parameters)"",
                                           new Object[] { new Integer(m), new Integer(p)});
         }
+        double[] errors = new double[problem.getUnboundParameters().length];
         final double c = Math.sqrt(getChiSquare(problem) / (m - p));
         double[][] covar = getCovariances(problem);
         for (int i = 0; i < errors.length; ++i) {
"
327,"org.apache.commons.math.MaxIterationsExceededException","/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java","@@ -106,8 +106,18 @@ public void setStandardDeviation(double sd) {
      * convergence exception is caught and 0 or 1 is returned.
      */
     public double cumulativeProbability(double x) throws MathException {
+        try {
             return 0.5 * (1.0 + Erf.erf((x - mean) /
                     (standardDeviation * Math.sqrt(2.0))));
+        } catch (MaxIterationsExceededException ex) {
+            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38
+                return 0.0d;
+            } else if (x > (mean + 20 * standardDeviation)) {
+                return 1.0d;
+            } else {
+                throw ex;
+            }
+        }
     }
     
     /**
","@@ -106,8 +106,18 @@ public void setStandardDeviation(double sd) {
      * convergence exception is caught and 0 or 1 is returned.
      */
     public double cumulativeProbability(double x) throws MathException {
+        try {
             return 0.5 * (1.0 + Erf.erf((x - mean) /
                     (standardDeviation * Math.sqrt(2.0))));
+        } catch (MaxIterationsExceededException ex) {
+            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38
+                return 0.0d;
+            } else if (x > (mean + 20 * standardDeviation)) {
+                return 1.0d;
+            } else {
+                throw ex;
+            }
+        }
     }
     
     /**
"
328,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java","@@ -71,11 +71,28 @@ public double chiSquare(double[] expected, long[] observed)
             throw new IllegalArgumentException(
                 ""observed counts must be non-negative and expected counts must be postive"");
         }
+        double sumExpected = 0d;
+        double sumObserved = 0d;
+        for (int i = 0; i < observed.length; i++) {
+            sumExpected += expected[i];
+            sumObserved += observed[i];
+        }
+        double ratio = 1.0d;
+        boolean rescale = false;
+        if (Math.abs(sumExpected - sumObserved) > 10E-6) {
+            ratio = sumObserved / sumExpected;
+            rescale = true;
+        }
         double sumSq = 0.0d;
         double dev = 0.0d;
         for (int i = 0; i < observed.length; i++) {
+            if (rescale) {
+                dev = ((double) observed[i] - ratio * expected[i]);
+                sumSq += dev * dev / (ratio * expected[i]);
+            } else {
                 dev = ((double) observed[i] - expected[i]);
                 sumSq += dev * dev / expected[i];
+            }
         }
         return sumSq;
     }
","@@ -71,11 +71,28 @@ public double chiSquare(double[] expected, long[] observed)
             throw new IllegalArgumentException(
                 ""observed counts must be non-negative and expected counts must be postive"");
         }
+        double sumExpected = 0d;
+        double sumObserved = 0d;
+        for (int i = 0; i < observed.length; i++) {
+            sumExpected += expected[i];
+            sumObserved += observed[i];
+        }
+        double ratio = 1.0d;
+        boolean rescale = false;
+        if (Math.abs(sumExpected - sumObserved) > 10E-6) {
+            ratio = sumObserved / sumExpected;
+            rescale = true;
+        }
         double sumSq = 0.0d;
         double dev = 0.0d;
         for (int i = 0; i < observed.length; i++) {
+            if (rescale) {
+                dev = ((double) observed[i] - ratio * expected[i]);
+                sumSq += dev * dev / (ratio * expected[i]);
+            } else {
                 dev = ((double) observed[i] - expected[i]);
                 sumSq += dev * dev / expected[i];
+            }
         }
         return sumSq;
     }
"
329,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/math/util/MathUtils.java","@@ -540,6 +540,11 @@ public static int gcd(final int p, final int q) {
         int u = p;
         int v = q;
         if ((u == 0) || (v == 0)) {
+            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {
+                throw MathRuntimeException.createArithmeticException(
+                        ""overflow: gcd({0}, {1}) is 2^31"",
+                        new Object[] { p, q });
+            }
             return (Math.abs(u) + Math.abs(v));
         }
         // keep u and v negative, as negative integers range down to
@@ -711,6 +716,9 @@ public static int lcm(int a, int b) {
             return 0;
         }
         int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));
+        if (lcm == Integer.MIN_VALUE){
+            throw new ArithmeticException(""overflow: lcm is 2^31"");
+        }
         return lcm;
     }
 
","@@ -540,6 +540,11 @@ public static int gcd(final int p, final int q) {
         int u = p;
         int v = q;
         if ((u == 0) || (v == 0)) {
+            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {
+                throw MathRuntimeException.createArithmeticException(
+                        ""overflow: gcd({0}, {1}) is 2^31"",
+                        new Object[] { p, q });
+            }
             return (Math.abs(u) + Math.abs(v));
         }
         // keep u and v negative, as negative integers range down to
@@ -711,6 +716,9 @@ public static int lcm(int a, int b) {
             return 0;
         }
         int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));
+        if (lcm == Integer.MIN_VALUE){
+            throw new ArithmeticException(""overflow: lcm is 2^31"");
+        }
         return lcm;
     }
 
"
330,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/math/fraction/ProperFractionFormat.java","@@ -162,7 +162,11 @@ public Fraction parse(String source, ParsePosition pos) {
             return null;
         }
         
+        if (num.intValue() < 0) {
             // minus signs should be leading, invalid expression
+            pos.setIndex(initialIndex);
+            return null;
+        }
 
         // parse '/'
         int startIndex = pos.getIndex();
@@ -197,7 +201,11 @@ public Fraction parse(String source, ParsePosition pos) {
             return null;
         }
         
+        if (den.intValue() < 0) {
             // minus signs must be leading, invalid
+            pos.setIndex(initialIndex);
+            return null;
+        }
 
         int w = whole.intValue();
         int n = num.intValue();
","@@ -162,7 +162,11 @@ public Fraction parse(String source, ParsePosition pos) {
             return null;
         }
         
+        if (num.intValue() < 0) {
             // minus signs should be leading, invalid expression
+            pos.setIndex(initialIndex);
+            return null;
+        }
 
         // parse '/'
         int startIndex = pos.getIndex();
@@ -197,7 +201,11 @@ public Fraction parse(String source, ParsePosition pos) {
             return null;
         }
         
+        if (den.intValue() < 0) {
             // minus signs must be leading, invalid
+            pos.setIndex(initialIndex);
+            return null;
+        }
 
         int w = whole.intValue();
         int n = num.intValue();
"
331,"junit.framework.AssertionFailedError","/src/org/mockito/internal/invocation/InvocationMatcher.java","@@ -124,10 +124,12 @@ public void captureArgumentsFrom(Invocation invocation) {
                     ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));
                 }
             }
+            for (Matcher m : uniqueMatcherSet(indexOfVararg)) {
                 if (m instanceof CapturesArguments) {
+                    Object rawArgument = invocation.getRawArguments()[indexOfVararg];
+                    for (int i = 0; i < Array.getLength(rawArgument); i++) {
+                        ((CapturesArguments) m).captureFrom(Array.get(rawArgument, i));
+                    }
                 }
             }
         } else {
@@ -140,6 +142,18 @@ public void captureArgumentsFrom(Invocation invocation) {
         }
     }
 
+    private Set<Matcher> uniqueMatcherSet(int indexOfVararg) {
+        HashSet<Matcher> set = new HashSet<Matcher>();
+        for (int position = indexOfVararg; position < matchers.size(); position++) {
+            Matcher matcher = matchers.get(position);
+            if(matcher instanceof MatcherDecorator) {
+                set.add(((MatcherDecorator) matcher).getActualMatcher());
+            } else {
+                set.add(matcher);
+            }
+        }
+        return set;
+    }
 
     public static List<InvocationMatcher> createFrom(List<Invocation> invocations) {
         LinkedList<InvocationMatcher> out = new LinkedList<InvocationMatcher>();
","@@ -124,10 +124,12 @@ public void captureArgumentsFrom(Invocation invocation) {
                     ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));
                 }
             }
+            for (Matcher m : uniqueMatcherSet(indexOfVararg)) {
                 if (m instanceof CapturesArguments) {
+                    Object rawArgument = invocation.getRawArguments()[indexOfVararg];
+                    for (int i = 0; i < Array.getLength(rawArgument); i++) {
+                        ((CapturesArguments) m).captureFrom(Array.get(rawArgument, i));
+                    }
                 }
             }
         } else {
@@ -140,6 +142,18 @@ public void captureArgumentsFrom(Invocation invocation) {
         }
     }
 
+    private Set<Matcher> uniqueMatcherSet(int indexOfVararg) {
+        HashSet<Matcher> set = new HashSet<Matcher>();
+        for (int position = indexOfVararg; position < matchers.size(); position++) {
+            Matcher matcher = matchers.get(position);
+            if(matcher instanceof MatcherDecorator) {
+                set.add(((MatcherDecorator) matcher).getActualMatcher());
+            } else {
+                set.add(matcher);
+            }
+        }
+        return set;
+    }
 
     public static List<InvocationMatcher> createFrom(List<Invocation> invocations) {
         LinkedList<InvocationMatcher> out = new LinkedList<InvocationMatcher>();
"
332,"junit.framework.AssertionFailedError","/src/org/mockito/internal/util/Timer.java","@@ -1,5 +1,6 @@
 package org.mockito.internal.util;
 
+import org.mockito.exceptions.Reporter;
 
 public class Timer {
 
@@ -7,6 +8,7 @@
     private long startTime = -1;
 
     public Timer(long durationMillis) {
+        validateInput(durationMillis);
         this.durationMillis = durationMillis;
     }
 
@@ -25,4 +27,9 @@ public void start() {
         startTime = System.currentTimeMillis();
     }
 
+    private void validateInput(long durationMillis) {
+        if (durationMillis < 0) {
+            new Reporter().cannotCreateTimerWithNegativeDurationTime(durationMillis);
+        }
+    }
 }
","@@ -1,5 +1,6 @@
 package org.mockito.internal.util;
 
+import org.mockito.exceptions.Reporter;
 
 public class Timer {
 
@@ -7,6 +8,7 @@
     private long startTime = -1;
 
     public Timer(long durationMillis) {
+        validateInput(durationMillis);
         this.durationMillis = durationMillis;
     }
 
@@ -25,4 +27,9 @@ public void start() {
         startTime = System.currentTimeMillis();
     }
 
+    private void validateInput(long durationMillis) {
+        if (durationMillis < 0) {
+            new Reporter().cannotCreateTimerWithNegativeDurationTime(durationMillis);
+        }
+    }
 }
"
333,"java.lang.UnsupportedOperationException","/src/org/mockito/internal/invocation/InvocationMatcher.java","@@ -120,7 +120,18 @@ public Location getLocation() {
     public void captureArgumentsFrom(Invocation invocation) {
         if (invocation.getMethod().isVarArgs()) {
             int indexOfVararg = invocation.getRawArguments().length - 1;
+            for (int position = 0; position < indexOfVararg; position++) {
+                Matcher m = matchers.get(position);
+                if (m instanceof CapturesArguments) {
+                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));
+                }
+            }
+            for (int position = indexOfVararg; position < matchers.size(); position++) {
+                Matcher m = matchers.get(position);
+                if (m instanceof CapturesArguments) {
+                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);
+                }
+            }
 
         } else {
             for (int position = 0; position < matchers.size(); position++) {
","@@ -120,7 +120,18 @@ public Location getLocation() {
     public void captureArgumentsFrom(Invocation invocation) {
         if (invocation.getMethod().isVarArgs()) {
             int indexOfVararg = invocation.getRawArguments().length - 1;
+            for (int position = 0; position < indexOfVararg; position++) {
+                Matcher m = matchers.get(position);
+                if (m instanceof CapturesArguments) {
+                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));
+                }
+            }
+            for (int position = indexOfVararg; position < matchers.size(); position++) {
+                Matcher m = matchers.get(position);
+                if (m instanceof CapturesArguments) {
+                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);
+                }
+            }
 
         } else {
             for (int position = 0; position < matchers.size(); position++) {
"
334,"org.mockito.exceptions.base.MockitoException","/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java","@@ -376,6 +376,7 @@ private void readTypeVariables() {
             for (Type type : typeVariable.getBounds()) {
                 registerTypeVariablesOn(type);
             }
+            registerTypeParametersOn(new TypeVariable[] { typeVariable });
             registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));
         }
 
","@@ -376,6 +376,7 @@ private void readTypeVariables() {
             for (Type type : typeVariable.getBounds()) {
                 registerTypeVariablesOn(type);
             }
+            registerTypeParametersOn(new TypeVariable[] { typeVariable });
             registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));
         }
 
"
335,"java.lang.Exception","/src/org/mockito/exceptions/Reporter.java","@@ -421,7 +421,7 @@ public void noMoreInteractionsWanted(Invocation undesired, List<VerificationAwar
         throw new NoInteractionsWanted(join(
                 ""No interactions wanted here:"",
                 new LocationImpl(),
+                ""But found this interaction on mock '"" + safelyGetMockName(undesired.getMock()) + ""':"",
                 undesired.getLocation(),
                 scenario
         ));
@@ -431,7 +431,7 @@ public void noMoreInteractionsWantedInOrder(Invocation undesired) {
         throw new VerificationInOrderFailure(join(
                 ""No interactions wanted here:"",
                 new LocationImpl(),
+                ""But found this interaction on mock '"" + safelyGetMockName(undesired.getMock()) + ""':"",
                 undesired.getLocation()
         ));
     }
@@ -674,6 +674,9 @@ public void cannotInjectDependency(Field field, Object matchingMock, Exception d
     }
 
     private String exceptionCauseMessageIfAvailable(Exception details) {
+        if (details.getCause() == null) {
+            return details.getMessage();
+        }
         return details.getCause().getMessage();
     }
 
","@@ -421,7 +421,7 @@ public void noMoreInteractionsWanted(Invocation undesired, List<VerificationAwar
         throw new NoInteractionsWanted(join(
                 ""No interactions wanted here:"",
                 new LocationImpl(),
+                ""But found this interaction on mock '"" + safelyGetMockName(undesired.getMock()) + ""':"",
                 undesired.getLocation(),
                 scenario
         ));
@@ -431,7 +431,7 @@ public void noMoreInteractionsWantedInOrder(Invocation undesired) {
         throw new VerificationInOrderFailure(join(
                 ""No interactions wanted here:"",
                 new LocationImpl(),
+                ""But found this interaction on mock '"" + safelyGetMockName(undesired.getMock()) + ""':"",
                 undesired.getLocation()
         ));
     }
@@ -674,6 +674,9 @@ public void cannotInjectDependency(Field field, Object matchingMock, Exception d
     }
 
     private String exceptionCauseMessageIfAvailable(Exception details) {
+        if (details.getCause() == null) {
+            return details.getMessage();
+        }
         return details.getCause().getMessage();
     }
 
"
336,"junit.framework.AssertionFailedError","/src/org/mockito/internal/creation/DelegatingMethod.java","@@ -52,11 +52,19 @@ public boolean isAbstract() {
      */
     @Override
     public boolean equals(Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (o instanceof DelegatingMethod) {
+            DelegatingMethod that = (DelegatingMethod) o;
+            return method.equals(that.method);
+        } else {
             return method.equals(o);
+        }
     }
 
     @Override
     public int hashCode() {
+        return method.hashCode();
     }
 }
\ No newline at end of file
","@@ -52,11 +52,19 @@ public boolean isAbstract() {
      */
     @Override
     public boolean equals(Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (o instanceof DelegatingMethod) {
+            DelegatingMethod that = (DelegatingMethod) o;
+            return method.equals(that.method);
+        } else {
             return method.equals(o);
+        }
     }
 
     @Override
     public int hashCode() {
+        return method.hashCode();
     }
 }
\ No newline at end of file
"
337,"org.mockito.exceptions.base.MockitoException","/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java","@@ -14,6 +14,7 @@
 import org.mockito.internal.util.MockUtil;
 import org.mockito.internal.util.reflection.GenericMetadataSupport;
 import org.mockito.invocation.InvocationOnMock;
+import org.mockito.mock.MockCreationSettings;
 import org.mockito.stubbing.Answer;
 
 import java.io.IOException;
@@ -68,7 +69,7 @@ private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu
 
         // record deep stub answer
         return recordDeepStubAnswer(
+                newDeepStubMock(returnTypeGenericMetadata, invocation.getMock()),
                 container
         );
     }
@@ -84,22 +85,26 @@ private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu
      * @param parentMock The parent of the current deep stub mock.
      * @return The mock
      */
+    private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata, Object parentMock) {
+        MockCreationSettings parentMockSettings = new MockUtil().getMockSettings(parentMock);
         return mockitoCore().mock(
                 returnTypeGenericMetadata.rawType(),
+                withSettingsUsing(returnTypeGenericMetadata, parentMockSettings)
         );
     }
 
+    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata, MockCreationSettings parentMockSettings) {
         MockSettings mockSettings = returnTypeGenericMetadata.hasRawExtraInterfaces() ?
                 withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())
                 : withSettings();
 
+        return propagateSerializationSettings(mockSettings, parentMockSettings)
                 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));
     }
 
+    private MockSettings propagateSerializationSettings(MockSettings mockSettings, MockCreationSettings parentMockSettings) {
+        return mockSettings.serializable(parentMockSettings.getSerializableMode());
+    }
 
     private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {
         return new ReturnsDeepStubsSerializationFallback(returnTypeGenericMetadata);
","@@ -14,6 +14,7 @@
 import org.mockito.internal.util.MockUtil;
 import org.mockito.internal.util.reflection.GenericMetadataSupport;
 import org.mockito.invocation.InvocationOnMock;
+import org.mockito.mock.MockCreationSettings;
 import org.mockito.stubbing.Answer;
 
 import java.io.IOException;
@@ -68,7 +69,7 @@ private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu
 
         // record deep stub answer
         return recordDeepStubAnswer(
+                newDeepStubMock(returnTypeGenericMetadata, invocation.getMock()),
                 container
         );
     }
@@ -84,22 +85,26 @@ private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu
      * @param parentMock The parent of the current deep stub mock.
      * @return The mock
      */
+    private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata, Object parentMock) {
+        MockCreationSettings parentMockSettings = new MockUtil().getMockSettings(parentMock);
         return mockitoCore().mock(
                 returnTypeGenericMetadata.rawType(),
+                withSettingsUsing(returnTypeGenericMetadata, parentMockSettings)
         );
     }
 
+    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata, MockCreationSettings parentMockSettings) {
         MockSettings mockSettings = returnTypeGenericMetadata.hasRawExtraInterfaces() ?
                 withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())
                 : withSettings();
 
+        return propagateSerializationSettings(mockSettings, parentMockSettings)
                 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));
     }
 
+    private MockSettings propagateSerializationSettings(MockSettings mockSettings, MockCreationSettings parentMockSettings) {
+        return mockSettings.serializable(parentMockSettings.getSerializableMode());
+    }
 
     private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {
         return new ReturnsDeepStubsSerializationFallback(returnTypeGenericMetadata);
"
338,"junit.framework.AssertionFailedError","/src/org/mockito/internal/verification/VerificationOverTimeImpl.java","@@ -88,7 +88,7 @@ public void verify(VerificationData data) {
             } catch (MockitoAssertionError e) {
                 error = handleVerifyException(e);
             }
+            catch (AssertionError e) {
                 error = handleVerifyException(e);
             }
         }
","@@ -88,7 +88,7 @@ public void verify(VerificationData data) {
             } catch (MockitoAssertionError e) {
                 error = handleVerifyException(e);
             }
+            catch (AssertionError e) {
                 error = handleVerifyException(e);
             }
         }
"
339,"junit.framework.ComparisonFailure","/src/org/mockito/Matchers.java","@@ -119,7 +119,7 @@
      * @return <code>false</code>.
      */
     public static boolean anyBoolean() {
+        return reportMatcher(new InstanceOf(Boolean.class)).returnFalse();
     }
 
     /**
@@ -134,7 +134,7 @@ public static boolean anyBoolean() {
      * @return <code>0</code>.
      */
     public static byte anyByte() {
+        return reportMatcher(new InstanceOf(Byte.class)).returnZero();
     }
 
     /**
@@ -149,7 +149,7 @@ public static byte anyByte() {
      * @return <code>0</code>.
      */
     public static char anyChar() {
+        return reportMatcher(new InstanceOf(Character.class)).returnChar();
     }
 
     /**
@@ -164,7 +164,7 @@ public static char anyChar() {
      * @return <code>0</code>.
      */
     public static int anyInt() {
+        return reportMatcher(new InstanceOf(Integer.class)).returnZero();
     }
 
     /**
@@ -179,7 +179,7 @@ public static int anyInt() {
      * @return <code>0</code>.
      */
     public static long anyLong() {
+        return reportMatcher(new InstanceOf(Long.class)).returnZero();
     }
 
     /**
@@ -194,7 +194,7 @@ public static long anyLong() {
      * @return <code>0</code>.
      */
     public static float anyFloat() {
+        return reportMatcher(new InstanceOf(Float.class)).returnZero();
     }
 
     /**
@@ -209,7 +209,7 @@ public static float anyFloat() {
      * @return <code>0</code>.
      */
     public static double anyDouble() {
+        return reportMatcher(new InstanceOf(Double.class)).returnZero();
     }
 
     /**
@@ -224,7 +224,7 @@ public static double anyDouble() {
      * @return <code>0</code>.
      */
     public static short anyShort() {
+        return reportMatcher(new InstanceOf(Short.class)).returnZero();
     }
 
     /**
@@ -241,7 +241,7 @@ public static short anyShort() {
      * @return <code>null</code>.
      */
     public static <T> T anyObject() {
+        return (T) reportMatcher(new InstanceOf(Object.class)).returnNull();
     }
 
     /**
@@ -289,7 +289,7 @@ public static short anyShort() {
      * @return <code>null</code>.
      */
     public static <T> T any(Class<T> clazz) {
+        return (T) reportMatcher(new InstanceOf(clazz)).returnFor(clazz);
     }
     
     /**
@@ -306,7 +306,7 @@ public static short anyShort() {
      * @return <code>null</code>.
      */
     public static <T> T any() {
+        return (T) reportMatcher(Any.ANY).returnNull();
     }
 
     /**
@@ -321,7 +321,7 @@ public static short anyShort() {
      * @return empty String ("""")
      */
     public static String anyString() {
+        return reportMatcher(new InstanceOf(String.class)).returnString();
     }
     
     /**
@@ -336,7 +336,7 @@ public static String anyString() {
      * @return empty List.
      */
     public static List anyList() {
+        return reportMatcher(new InstanceOf(List.class)).returnList();
     }    
     
     /**
@@ -355,7 +355,7 @@ public static List anyList() {
      * @return empty List.
      */
     public static <T> List<T> anyListOf(Class<T> clazz) {
+        return anyList();
     }    
     
     /**
@@ -370,7 +370,7 @@ public static List anyList() {
      * @return empty Set
      */
     public static Set anySet() {
+        return reportMatcher(new InstanceOf(Set.class)).returnSet();
     }
     
     /**
@@ -389,7 +389,7 @@ public static Set anySet() {
      * @return empty Set
      */
     public static <T> Set<T> anySetOf(Class<T> clazz) {
+        return anySet();
     }
 
     /**
@@ -404,7 +404,7 @@ public static Set anySet() {
      * @return empty Map.
      */
     public static Map anyMap() {
+        return reportMatcher(new InstanceOf(Map.class)).returnMap();
     }
 
     /**
@@ -424,7 +424,7 @@ public static Map anyMap() {
      * @return empty Map.
      */
     public static <K, V>  Map<K, V> anyMapOf(Class<K> keyClazz, Class<V> valueClazz) {
+        return anyMap();
     }
     
     /**
@@ -439,7 +439,7 @@ public static Map anyMap() {
      * @return empty Collection.
      */
     public static Collection anyCollection() {
+        return reportMatcher(new InstanceOf(Collection.class)).returnList();
     }    
     
     /**
@@ -458,7 +458,7 @@ public static Collection anyCollection() {
      * @return empty Collection.
      */
     public static <T> Collection<T> anyCollectionOf(Class<T> clazz) {
+        return anyCollection();
     }    
 
     /**
","@@ -119,7 +119,7 @@
      * @return <code>false</code>.
      */
     public static boolean anyBoolean() {
+        return reportMatcher(new InstanceOf(Boolean.class)).returnFalse();
     }
 
     /**
@@ -134,7 +134,7 @@ public static boolean anyBoolean() {
      * @return <code>0</code>.
      */
     public static byte anyByte() {
+        return reportMatcher(new InstanceOf(Byte.class)).returnZero();
     }
 
     /**
@@ -149,7 +149,7 @@ public static byte anyByte() {
      * @return <code>0</code>.
      */
     public static char anyChar() {
+        return reportMatcher(new InstanceOf(Character.class)).returnChar();
     }
 
     /**
@@ -164,7 +164,7 @@ public static char anyChar() {
      * @return <code>0</code>.
      */
     public static int anyInt() {
+        return reportMatcher(new InstanceOf(Integer.class)).returnZero();
     }
 
     /**
@@ -179,7 +179,7 @@ public static int anyInt() {
      * @return <code>0</code>.
      */
     public static long anyLong() {
+        return reportMatcher(new InstanceOf(Long.class)).returnZero();
     }
 
     /**
@@ -194,7 +194,7 @@ public static long anyLong() {
      * @return <code>0</code>.
      */
     public static float anyFloat() {
+        return reportMatcher(new InstanceOf(Float.class)).returnZero();
     }
 
     /**
@@ -209,7 +209,7 @@ public static float anyFloat() {
      * @return <code>0</code>.
      */
     public static double anyDouble() {
+        return reportMatcher(new InstanceOf(Double.class)).returnZero();
     }
 
     /**
@@ -224,7 +224,7 @@ public static double anyDouble() {
      * @return <code>0</code>.
      */
     public static short anyShort() {
+        return reportMatcher(new InstanceOf(Short.class)).returnZero();
     }
 
     /**
@@ -241,7 +241,7 @@ public static short anyShort() {
      * @return <code>null</code>.
      */
     public static <T> T anyObject() {
+        return (T) reportMatcher(new InstanceOf(Object.class)).returnNull();
     }
 
     /**
@@ -289,7 +289,7 @@ public static short anyShort() {
      * @return <code>null</code>.
      */
     public static <T> T any(Class<T> clazz) {
+        return (T) reportMatcher(new InstanceOf(clazz)).returnFor(clazz);
     }
     
     /**
@@ -306,7 +306,7 @@ public static short anyShort() {
      * @return <code>null</code>.
      */
     public static <T> T any() {
+        return (T) reportMatcher(Any.ANY).returnNull();
     }
 
     /**
@@ -321,7 +321,7 @@ public static short anyShort() {
      * @return empty String ("""")
      */
     public static String anyString() {
+        return reportMatcher(new InstanceOf(String.class)).returnString();
     }
     
     /**
@@ -336,7 +336,7 @@ public static String anyString() {
      * @return empty List.
      */
     public static List anyList() {
+        return reportMatcher(new InstanceOf(List.class)).returnList();
     }    
     
     /**
@@ -355,7 +355,7 @@ public static List anyList() {
      * @return empty List.
      */
     public static <T> List<T> anyListOf(Class<T> clazz) {
+        return anyList();
     }    
     
     /**
@@ -370,7 +370,7 @@ public static List anyList() {
      * @return empty Set
      */
     public static Set anySet() {
+        return reportMatcher(new InstanceOf(Set.class)).returnSet();
     }
     
     /**
@@ -389,7 +389,7 @@ public static Set anySet() {
      * @return empty Set
      */
     public static <T> Set<T> anySetOf(Class<T> clazz) {
+        return anySet();
     }
 
     /**
@@ -404,7 +404,7 @@ public static Set anySet() {
      * @return empty Map.
      */
     public static Map anyMap() {
+        return reportMatcher(new InstanceOf(Map.class)).returnMap();
     }
 
     /**
@@ -424,7 +424,7 @@ public static Map anyMap() {
      * @return empty Map.
      */
     public static <K, V>  Map<K, V> anyMapOf(Class<K> keyClazz, Class<V> valueClazz) {
+        return anyMap();
     }
     
     /**
@@ -439,7 +439,7 @@ public static Map anyMap() {
      * @return empty Collection.
      */
     public static Collection anyCollection() {
+        return reportMatcher(new InstanceOf(Collection.class)).returnList();
     }    
     
     /**
@@ -458,7 +458,7 @@ public static Collection anyCollection() {
      * @return empty Collection.
      */
     public static <T> Collection<T> anyCollectionOf(Class<T> clazz) {
+        return anyCollection();
     }    
 
     /**
"
340,"org.mockito.exceptions.base.MockitoException","/src/org/mockito/internal/stubbing/answers/CallsRealMethods.java","@@ -5,7 +5,9 @@
 package org.mockito.internal.stubbing.answers;
 
 import java.io.Serializable;
+import java.lang.reflect.Modifier;
 
+import org.mockito.internal.stubbing.defaultanswers.GloballyConfiguredAnswer;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 
@@ -33,6 +35,9 @@
     private static final long serialVersionUID = 9057165148930624087L;
 
     public Object answer(InvocationOnMock invocation) throws Throwable {
+    	if (Modifier.isAbstract(invocation.getMethod().getModifiers())) {
+    		return new GloballyConfiguredAnswer().answer(invocation);
+    	}
         return invocation.callRealMethod();
     }
 }
\ No newline at end of file
","@@ -5,7 +5,9 @@
 package org.mockito.internal.stubbing.answers;
 
 import java.io.Serializable;
+import java.lang.reflect.Modifier;
 
+import org.mockito.internal.stubbing.defaultanswers.GloballyConfiguredAnswer;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 
@@ -33,6 +35,9 @@
     private static final long serialVersionUID = 9057165148930624087L;
 
     public Object answer(InvocationOnMock invocation) throws Throwable {
+    	if (Modifier.isAbstract(invocation.getMethod().getModifiers())) {
+    		return new GloballyConfiguredAnswer().answer(invocation);
+    	}
         return invocation.callRealMethod();
     }
 }
\ No newline at end of file
"
341,"java.lang.StackOverflowError","/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java","@@ -76,7 +76,7 @@ protected void registerTypeVariablesOn(Type classType) {
 
             if (actualTypeArgument instanceof WildcardType) {
                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));
+            } else if (typeParameter != actualTypeArgument) {
                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);
             }
             // logger.log(""For '"" + parameterizedType + ""' found type variable : { '"" + typeParameter + ""("" + System.identityHashCode(typeParameter) + "")"" + ""' : '"" + actualTypeArgument + ""("" + System.identityHashCode(typeParameter) + "")"" + ""' }"");
","@@ -76,7 +76,7 @@ protected void registerTypeVariablesOn(Type classType) {
 
             if (actualTypeArgument instanceof WildcardType) {
                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));
+            } else if (typeParameter != actualTypeArgument) {
                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);
             }
             // logger.log(""For '"" + parameterizedType + ""' found type variable : { '"" + typeParameter + ""("" + System.identityHashCode(typeParameter) + "")"" + ""' : '"" + actualTypeArgument + ""("" + System.identityHashCode(typeParameter) + "")"" + ""' }"");
"
342,"org.mockito.exceptions.misusing.MissingMethodInvocationException","/src/org/mockito/Mockito.java","@@ -1,921 +1,921 @@
 /*
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
 package org.mockito;
 
 import org.mockito.internal.MockitoCore;
 import org.mockito.internal.creation.MockSettingsImpl;
 import org.mockito.internal.debugging.MockitoDebuggerImpl;
 import org.mockito.internal.stubbing.answers.*;
 import org.mockito.internal.stubbing.defaultanswers.*;
 import org.mockito.internal.verification.VerificationModeFactory;
 import org.mockito.internal.verification.api.VerificationMode;
 import org.mockito.runners.MockitoJUnitRunner;
 import org.mockito.stubbing.*;
 
 /**
  * <p align=""left""><img src=""logo.jpg""/></p>
  * Mockito library enables mocks creation, verification and stubbing.
  * <p>
  * This javadoc content is also available on the <a href=""http://mockito.org"">http://mockito.org</a> web page. 
  * All documentation is kept in javadocs because it guarantees consistency between what's on the web and what's in the source code.
  * Also, it makes possible to access documentation straight from the IDE even if you work offline.   
  * 
  * <h1>Contents</h1>
  * 
  * <b> 
  *      <a href=""#1"">1. Let's verify some behaviour! </a><br/> 
  *      <a href=""#2"">2. How about some stubbing? </a><br/>
  *      <a href=""#3"">3. Argument matchers </a><br/>
  *      <a href=""#4"">4. Verifying exact number of invocations / at least once / never </a><br/> 
  *      <a href=""#5"">5. Stubbing void methods with exceptions </a><br/> 
  *      <a href=""#6"">6. Verification in order </a><br/> 
  *      <a href=""#7"">7. Making sure interaction(s) never happened on mock </a><br/> 
  *      <a href=""#8"">8. Finding redundant invocations </a><br/> 
  *      <a href=""#9"">9. Shorthand for mocks creation - &#064;Mock annotation </a><br/> 
  *      <a href=""#10"">10. Stubbing consecutive calls (iterator-style stubbing) </a><br/> 
  *      <a href=""#11"">11. Stubbing with callbacks </a><br/>
  *      <a href=""#12"">12. doThrow()|doAnswer()|doNothing()|doReturn() family of methods mostly for stubbing voids </a><br/>
  *      <a href=""#13"">13. Spying on real objects </a><br/>
  *      <a href=""#14"">14. Changing default return values of unstubbed invocations (Since 1.7) </a><br/>
  *      <a href=""#15"">15. Capturing arguments for further assertions (Since 1.8.0) </a><br/>
  *      <a href=""#16"">16. Real partial mocks (Since 1.8.0) </a><br/>
  *      <a href=""#17"">17. Resetting mocks (Since 1.8.0) </a><br/>
  *      <a href=""#18"">18. Troubleshooting & validating framework usage (Since 1.8.0) </a><br/>
  *      <a href=""#19"">19. Aliases for behavior driven development (Since 1.8.0) </a><br/>
  *      <a href=""#20"">20. (**New**) Serializable mocks (Since 1.8.1) </a><br/>
  * </b>
  * 
  * <p>
  * Following examples mock a List, because everyone knows its interface (methods
  * like add(), get(), clear() will be used). <br>
  * You probably wouldn't mock List class 'in real'.
  * 
  * <h3 id=""1"">1. Let's verify some behaviour!</h3>
  * 
  * <pre>
  * //Let's import Mockito statically so that the code looks clearer
  * import static org.mockito.Mockito.*;
  * 
  * //mock creation
  * List mockedList = mock(List.class);
  *
  * //using mock object
  * mockedList.add(""one"");
  * mockedList.clear();
  *
  * //verification
  * verify(mockedList).add(""one"");
  * verify(mockedList).clear();
  * </pre>
  * 
  * <p>
  * Once created, mock will remember all interactions. Then you can selectively
  * verify whatever interaction you are interested in.
  * 
  * <h3 id=""2"">2. How about some stubbing?</h3>
  * 
  * <pre>
  * //You can mock concrete classes, not only interfaces
  * LinkedList mockedList = mock(LinkedList.class);
  * 
  * //stubbing
  * when(mockedList.get(0)).thenReturn(""first"");
  * when(mockedList.get(1)).thenThrow(new RuntimeException());
  * 
  * //following prints ""first""
  * System.out.println(mockedList.get(0));
  * 
  * //following throws runtime exception
  * System.out.println(mockedList.get(1));
  * 
  * //following prints ""null"" because get(999) was not stubbed
  * System.out.println(mockedList.get(999));
  *  
  * //Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>
  * //If your code cares what get(0) returns then something else breaks (often before even verify() gets executed).
  * //If your code doesn't care what get(0) returns then it should not be stubbed. Not convinced? See <a href=""http://monkeyisland.pl/2008/04/26/asking-and-telling"">here</a>.
  * verify(mockedList).get(0);
  * </pre>
  * 
  * <ul>
  * <li> By default, for all methods that return value, mock returns null, an
  * empty collection or appropriate primitive/primitive wrapper value (e.g: 0,
  * false, ... for int/Integer, boolean/Boolean, ...). </li>
  * 
  * <li> Stubbing can be overridden: for example common stubbing can go to
  * fixture setup but the test methods can override it.
  * Please note that overridding stubbing is a potential code smell that points out too much stubbing</li>
  * 
  * <li> Once stubbed, the method will always return stubbed value regardless
  * of how many times it is called. </li>
  * 
  * <li> Last stubbing is more important - when you stubbed the same method with
  * the same arguments many times. </li>
  * 
  * </ul>
  * 
  * <h3 id=""3"">3. Argument matchers</h3>
  * 
  * Mockito verifies argument values in natural java style: by using an equals() method.
  * Sometimes, when extra flexibility is required then you might use argument matchers:  
  * 
  * <pre>
  * //stubbing using built-in anyInt() argument matcher
  * when(mockedList.get(anyInt())).thenReturn(""element"");
  * 
  * //stubbing using hamcrest (let's say isValid() returns your own hamcrest matcher):
  * when(mockedList.contains(argThat(isValid()))).thenReturn(""element"");
  * 
  * //following prints ""element""
  * System.out.println(mockedList.get(999));
  * 
  * //<b>you can also verify using an argument matcher</b>
  * verify(mockedList).get(anyInt());
  * </pre>
  * 
  * <p>
  * Argument matchers allow flexible verification or stubbing. 
  * {@link Matchers Click here to see} more built-in matchers 
  * and examples of <b>custom argument matchers / hamcrest matchers</b>.
  * <p>
  * For information solely on <b>custom argument matchers</b> check out javadoc for {@link ArgumentMatcher} class.
  * <p>
  * Be reasonable with using complicated argument matching.
  * The natural matching style using equals() with occasional anyX() matchers tend to give clean & simple tests.
  * Sometimes it's just better to refactor the code to allow equals() matching or even implement equals() method to help out with testing.
  * <p>
  * Also, read <a href=""#15"">section 15</a> or javadoc for {@link ArgumentCaptor} class.
  * {@link ArgumentCaptor} is a special implementation of an argument matcher that captures argument values for further assertions.  
  * <p>
  * <b>Warning on argument matchers:</b>
  * <p>
  * If you are using argument matchers, <b>all arguments</b> have to be provided
  * by matchers.
  * <p>
  * E.g: (example shows verification but the same applies to stubbing):
  * 
  * <pre>
  *   verify(mock).someMethod(anyInt(), anyString(), <b>eq(""third argument"")</b>);
  *   //above is correct - eq() is also an argument matcher
  *   
  *   verify(mock).someMethod(anyInt(), anyString(), <b>""third argument""</b>);
  *   //above is incorrect - exception will be thrown because third argument is given without an argument matcher.
  * </pre>
  * 
  * <h3 id=""4"">4. Verifying exact number of invocations / at least x / never</h3>
  * 
  * <pre>
  * //using mock 
  * mockedList.add(""once"");
  * 
  * mockedList.add(""twice"");
  * mockedList.add(""twice"");
  * 
  * mockedList.add(""three times"");
  * mockedList.add(""three times"");
  * mockedList.add(""three times"");
  * 
  * //following two verifications work exactly the same - times(1) is used by default
  * verify(mockedList).add(""once"");
  * verify(mockedList, times(1)).add(""once"");
  * 
  * //exact number of invocations verification
  * verify(mockedList, times(2)).add(""twice"");
  * verify(mockedList, times(3)).add(""three times"");
  * 
  * //verification using never(). never() is an alias to times(0)
  * verify(mockedList, never()).add(""never happened"");
  * 
  * //verification using atLeast()/atMost()
  * verify(mockedList, atLeastOnce()).add(""three times"");
  * verify(mockedList, atLeast(2)).add(""five times"");
  * verify(mockedList, atMost(5)).add(""three times"");
  * 
  * </pre>
  * 
  * <p>
  * <b>times(1) is the default.</b> Therefore using times(1) explicitly can be
  * omitted.
  * 
  * <h3 id=""5"">5. Stubbing void methods with exceptions</h3>
  * 
  * <pre>
  *   doThrow(new RuntimeException()).when(mockedList).clear();
  *   
  *   //following throws RuntimeException:
  *   mockedList.clear();
  * </pre>
  * 
  * Read more about doThrow|doAnswer family of methods in paragraph 12.
  * <p>
  * Initially, {@link Mockito#stubVoid(Object)} was used for stubbing voids.
  * Currently stubVoid() is deprecated in favor of {@link Mockito#doThrow(Throwable)}.
  * This is because of improved readability and consistency with the family of {@link Mockito#doAnswer(Answer)} methods. 
  * 
  * <h3 id=""6"">6. Verification in order</h3>
  * 
  * <pre>
  * List firstMock = mock(List.class);
  * List secondMock = mock(List.class);
  * 
  * //using mocks
  * firstMock.add(""was called first"");
  * secondMock.add(""was called second"");
  * 
  * //create inOrder object passing any mocks that need to be verified in order
  * InOrder inOrder = inOrder(firstMock, secondMock);
  * 
  * //following will make sure that firstMock was called before secondMock
  * inOrder.verify(firstMock).add(""was called first"");
  * inOrder.verify(secondMock).add(""was called second"");
  * </pre>
  * 
  * Verification in order is flexible - <b>you don't have to verify all
  * interactions</b> one-by-one but only those that you are interested in
  * testing in order.
  * <p>
  * Also, you can create InOrder object passing only mocks that are relevant for
  * in-order verification.
  * 
  * <h3 id=""7"">7. Making sure interaction(s) never happened on mock</h3>
  * 
  * <pre>
  * //using mocks - only mockOne is interacted
  * mockOne.add(""one"");
  * 
  * //ordinary verification
  * verify(mockOne).add(""one"");
  * 
  * //verify that method was never called on a mock
  * verify(mockOne, never()).add(""two"");
  * 
  * //verify that other mocks were not interacted
  * verifyZeroInteractions(mockTwo, mockThree);
  * 
  * </pre>
  * 
  * <h3 id=""8"">8. Finding redundant invocations</h3>
  * 
  * <pre>
  * //using mocks
  * mockedList.add(""one"");
  * mockedList.add(""two"");
  * 
  * verify(mockedList).add(""one"");
  * 
  * //following verification will fail 
  * verifyNoMoreInteractions(mockedList);
  * </pre>
  * 
  * A word of <b>warning</b>: 
  * Some users who did a lot of classic, expect-run-verify mocking tend to use verifyNoMoreInteractions() very often, even in every test method. 
  * verifyNoMoreInteractions() is not recommended to use in every test method. 
  * verifyNoMoreInteractions() is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.
  * Abusing it leads to overspecified, less maintainable tests. You can find further reading 
  * <a href=""http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/"">here</a>.
  * 
  * <p>   
  * See also {@link Mockito#never()} - it is more explicit and
  * communicates the intent well.
  * <p>
  * 
  * <h3 id=""9"">9. Shorthand for mocks creation - &#064;Mock annotation</h3>
  * 
  * <ul>
  * <li>Minimizes repetitive mock creation code.</li>
  * <li>Makes the test class more readable.</li>
  * <li>Makes the verification error easier to read because the <b>field name</b>
  * is used to identify the mock.</li>
  * </ul>
  * 
  * <pre>
  *   public class ArticleManagerTest { 
  *     
  *       &#064;Mock private ArticleCalculator calculator;
  *       &#064;Mock private ArticleDatabase database;
  *       &#064;Mock private UserProvider userProvider;
  *     
  *       private ArticleManager manager;
  * </pre>
  * 
  * <b>Important!</b> This needs to be somewhere in the base class or a test
  * runner:
  * 
  * <pre>
  * MockitoAnnotations.initMocks(testClass);
  * </pre>
  * 
  * You can use built-in runner: {@link MockitoJUnitRunner}.
  * <p>
  * Read more here: {@link MockitoAnnotations}
  * 
  * <h3 id=""10""> 10. Stubbing consecutive calls (iterator-style stubbing)</h3>
  * 
  * Sometimes we need to stub with different return value/exception for the same
  * method call. Typical use case could be mocking iterators. 
  * Original version of Mockito did not have this feature to promote simple mocking. 
  * For example, instead of iterators one could use {@link Iterable} or simply
  * collections. Those offer natural ways of stubbing (e.g. using real
  * collections). In rare scenarios stubbing consecutive calls could be useful,
  * though:
  * <p>
  * 
  * <pre>
  * when(mock.someMethod(""some arg""))
  *   .thenThrow(new RuntimeException())
  *   .thenReturn(""foo"");
  * 
  * //First call: throws runtime exception:
  * mock.someMethod(""some arg"");
  * 
  * //Second call: prints ""foo""
  * System.out.println(mock.someMethod(""some arg""));
  * 
  * //Any consecutive call: prints ""foo"" as well (last stubbing wins). 
  * System.out.println(mock.someMethod(""some arg""));
  * </pre>
  * 
  * Alternative, shorter version of consecutive stubbing:
  * 
  * <pre>
  * when(mock.someMethod(""some arg""))
  *   .thenReturn(""one"", ""two"", ""three"");
  * </pre>
  * 
  * <h3 id=""11""> 11. Stubbing with callbacks</h3>
  * 
  * Allows stubbing with generic {@link Answer} interface.
 *  <p>
  * Yet another controversial feature which was not included in Mockito
  * originally. We recommend using simple stubbing with thenReturn() or
  * thenThrow() only. Those two should be <b>just enough</b> to test/test-drive
  * any clean & simple code.
  * 
  * <pre>
  * when(mock.someMethod(anyString())).thenAnswer(new Answer() {
  *     Object answer(InvocationOnMock invocation) {
  *         Object[] args = invocation.getArguments();
  *         Object mock = invocation.getMock();
  *         return ""called with arguments: "" + args;
  *     }
  * });
  * 
  * //Following prints ""called with arguments: foo""
  * System.out.println(mock.someMethod(""foo""));
  * </pre>
  * 
  * <h3 id=""12""> 12. doThrow()|doAnswer()|doNothing()|doReturn() family of methods for stubbing voids (mostly)</h3>
  * 
  * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...
  * <p>
  * {@link Mockito#doThrow(Throwable)} replaces the {@link Mockito#stubVoid(Object)} method for stubbing voids. 
  * The main reason is improved readability and consistency with the family of doAnswer() methods.
  * <p>
  * Use doThrow() when you want to stub a void method with an exception:
  * <pre>
  *   doThrow(new RuntimeException()).when(mockedList).clear();
  *   
  *   //following throws RuntimeException:
  *   mockedList.clear();
  * </pre>
  * 
  * Read more about other methods:
  * <p>
  * {@link Mockito#doThrow(Throwable)}
  * <p>
  * {@link Mockito#doAnswer(Answer)}
  * <p>
  * {@link Mockito#doNothing()}
  * <p>
  * {@link Mockito#doReturn(Object)}
  * 
  * <h3 id=""13""> 13. Spying on real objects</h3>
  * 
  * You can create spies of real objects. When you use the spy then the <b>real</b> methods are called (unless a method was stubbed).
  * <p>
  * Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.
  * 
  * <p>
  * Spying on real objects can be associated with ""partial mocking"" concept. 
  * <b>Before the release 1.8</b>, Mockito spies were not real partial mocks. 
  * The reason was we thought partial mock is a code smell. 
  * At some point we found legitimate use cases for partial mocks 
  * (3rd party interfaces, interim refactoring of legacy code, the full article is <a href=
  * ""http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring""
  * >here</a>)
  * <p>
  *
  * <pre>
  *   List list = new LinkedList();
  *   List spy = spy(list);
  * 
  *   //optionally, you can stub out some methods:
  *   when(spy.size()).thenReturn(100);
  * 
  *   //using the spy calls <b>real</b> methods
  *   spy.add(""one"");
  *   spy.add(""two"");
  * 
  *   //prints ""one"" - the first element of a list
  *   System.out.println(spy.get(0));
  * 
  *   //size() method was stubbed - 100 is printed
  *   System.out.println(spy.size());
  * 
  *   //optionally, you can verify
  *   verify(spy).add(""one"");
  *   verify(spy).add(""two"");
  * </pre>
  * 
  * <h4>Important gotcha on spying real objects!</h4>
  * 
  * 1. Sometimes it's impossible to use {@link Mockito#when(Object)} for stubbing spies. Example:
  * 
  * <pre>
  *   List list = new LinkedList();
  *   List spy = spy(list);
  *   
  *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)
  *   when(spy.get(0)).thenReturn(""foo"");
  *   
  *   //You have to use doReturn() for stubbing
  *   doReturn(""foo"").when(spy).get(0);
  * </pre>
  * 
  * 2. Watch out for final methods. 
  * Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.
  * What will happen is the real method will be called *on mock* but *not on the real instance* you passed to the spy() method.
  * Typically you may get a NullPointerException because mock instances don't have fields initiated.
  * 
  * <h3 id=""14"">14. Changing default return values of unstubbed invocations (Since 1.7) </h3>
  * 
  * You can create a mock with specified strategy for its return values.
  * It's quite advanced feature and typically you don't need it to write decent tests.
  * However, it can be helpful for working with <b>legacy systems</b>.
  * <p>
  * It is the default answer so it will be used <b>only when you don't</b> stub the method call.
  * 
  * <pre>
  *   Foo mock = mock(Foo.class, Mockito.RETURNS_SMART_NULLS);
  *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer()); 
  * </pre>
  * 
  * <p>
  * Read more about this interesting implementation of <i>Answer</i>: {@link Mockito#RETURNS_SMART_NULLS}
  * 
  * <h3 id=""15"">15. Capturing arguments for further assertions (Since 1.8.0) </h3>
  * 
  * Mockito verifies argument values in natural java style: by using an equals() method.
  * This is also the recommended way of matching arguments because it makes tests clean & simple.
  * In some situations though, it is helpful to assert on certain arguments after the actual verification.
  * For example:
  * <pre>
  *   ArgumentCaptor&lt;Person&gt; argument = ArgumentCaptor.forClass(Person.class);
  *   verify(mock).doSomething(argument.capture());
  *   assertEquals(""John"", argument.getValue().getName());
  * </pre>
  * 
  * <b>Warning:</b> it is recommended to use ArgumentCaptor with verification <b>but not</b> with stubbing.
  * Using ArgumentCaptor with stubbing may decrease test readability because captor is created outside of assert (aka verify or 'then') block.
  * Also it may reduce defect localization because if stubbed method was not called then no argument is captured.
  * <p>
  * In a way ArgumentCaptor is related to custom argument matchers (see javadoc for {@link ArgumentMatcher} class).
  * Both techniques can be used for making sure certain arguments where passed to mocks. 
  * However, ArgumentCaptor may be a better fit if:
  * <ul>  
  * <li>custom argument matcher is not likely to be reused</li>
  * <li>you just need it to assert on argument values to complete verification</li>
  * </ul>
  * Custom argument matchers via {@link ArgumentMatcher} are usually better for stubbing.
  * 
  * <h3 id=""16"">16. Real partial mocks (Since 1.8.0) </h3>
  *  
  *  Finally, after many internal debates & discussions on the mailing list, partial mock support was added to Mockito.
  *  Previously we considered partial mocks as code smells. However, we found a legitimate use case for partial mocks - more reading:
  *  <a href=""http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring"">here</a>
  *  <p>
  *  <b>Before release 1.8</b> spy() was not producing real partial mocks and it was confusing for some users.
  *  Read more about spying: <a href=""#13"">here</a> or in javadoc for {@link Mockito#spy(Object)} method. 
  *  <p>
  *  <pre>
  *    //you can create partial mock with spy() method:    
  *    List list = spy(new LinkedList());
  *    
  *    //you can enable partial mock capabilities selectively on mocks:
  *    Foo mock = mock(Foo.class);
  *    //Be sure the real implementation is 'safe'.
  *    //If real implementation throws exceptions or depends on specific state of the object then you're in trouble.
  *    when(mock.someMethod()).thenCallRealMethod();
  *  </pre>
  *  
  * As usual you are going to read <b>the partial mock warning</b>:
  * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.
  * How does partial mock fit into this paradigm? Well, it just doesn't... 
  * Partial mock usually means that the complexity has been moved to a different method on the same object.
  * In most cases, this is not the way you want to design your application.
  * <p>
  * However, there are rare cases when partial mocks come handy: 
  * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
  * However, I wouldn't use partial mocks for new, test-driven & well-designed code.
  *  
  * <h3 id=""17"">17. Resetting mocks (Since 1.8.0) </h3>
  *  
  * Smart Mockito users hardly use this feature because they know it could be a sign of poor tests.
  * Normally, you don't need to reset your mocks, just create new mocks for each test method. 
  * <p>
  * Instead of reset() please consider writing simple, small and focused test methods over lengthy, over-specified tests.
  * <b>First potential code smell is reset() in the middle of the test method.</b> This probably means you're testing too much.
  * Follow the whisper of your test methods: ""Please keep us small & focused on single behavior"". 
  * There are several threads about it on mockito mailing list.
  * <p>
  * The only reason we added reset() method is to
  * make it possible to work with container-injected mocks.
  * See issue 55 (<a href=""http://code.google.com/p/mockito/issues/detail?id=55"">here</a>)
  * or FAQ (<a href=""http://code.google.com/p/mockito/wiki/FAQ"">here</a>).
  * <p>
  * <b>Don't harm yourself.</b> reset() in the middle of the test method is a code smell (you're probably testing too much). 
  * <pre>
  *   List mock = mock(List.class);
  *   when(mock.size()).thenReturn(10);
  *   mock.add(1);
  *   
  *   reset(mock);
  *   //at this point the mock forgot any interactions & stubbing
  * </pre>
  *  
  * <h3 id=""18"">18. Troubleshooting & validating framework usage (Since 1.8.0) </h3>
  * 
  * First of all, in case of any trouble, I encourage you to read the Mockito FAQ: 
  * <a href=""http://code.google.com/p/mockito/wiki/FAQ"">http://code.google.com/p/mockito/wiki/FAQ</a>
  * <p>
  * In case of questions you may also post to mockito mailing list: 
  * <a href=""http://groups.google.com/group/mockito"">http://groups.google.com/group/mockito</a>
  * <p>
  * Next, you should know that Mockito validates if you use it correctly <b>all the time</b>. 
  * However, there's a gotcha so please read the javadoc for {@link Mockito#validateMockitoUsage()}
  * 
  * <h3 id=""19"">19. Aliases for behavior driven development (Since 1.8.0) </h3>
  * 
  * Behavior Driven Development style of writing tests uses <b>//given //when //then</b> comments as fundamental parts of your test methods.
  * This is exactly how we write our tests and we warmly encourage you to do so!
  * <p>
  * Start learning about BDD here: <a href=""http://en.wikipedia.org/wiki/Behavior_Driven_Development"">http://en.wikipedia.org/wiki/Behavior_Driven_Development</a>
  * <p>
  * The problem is that current stubbing api with canonical role of <b>when</b> word does not integrate nicely with <b>//given //when //then</b> comments.
  * It's because stubbing belongs to <b>given</b> component of the test and not to the <b>when</b> component of the test. 
  * Hence {@link BDDMockito} class introduces an alias so that you stub method calls with {@link BDDMockito#given(Object)} method. 
  * Now it really nicely integrates with the <b>given</b> component of a BDD style test!  
  * <p>
  * Here is how the test might look like: 
  * <pre>
  * import static org.mockito.BDDMockito.*;
  * 
  * Seller seller = mock(Seller.class);
  * Shop shop = new Shop(seller);
  * 
  * public void shouldBuyBread() throws Exception {
  *   //given  
  *   given(seller.askForBread()).willReturn(new Bread());
  *   
  *   //when
  *   Goods goods = shop.buyBread();
  *   
  *   //then
  *   assertThat(goods, containBread());
  * }  
  * </pre>
  * 
  * <h3 id=""20"">20. (**New**) Serializable mocks (Since 1.8.1) </h3>
  * 
  * Mocks can be made serializable. With this feature you can use a mock in a place that requires dependencies to be serializable.
  * <p>
  * WARNING: This should be rarely used in unit testing. 
  * <p>
  * The behaviour was implemented for a specific use case of a BDD spec that had an unreliable external dependency.  This
  * was in a web environment and the objects from the external dependency were being serialized to pass between layers. 
  * <p>
  * To create serializable mock use {@link MockSettings#serializable()}:
  * <pre>
  *   List serializableMock = mock(List.class, withSettings().serializable());
  * </pre>
  * <p>
  * The mock can be serialized assuming all the normal <a href='http://java.sun.com/j2se/1.5.0/docs/api/java/io/Serializable.html'>
  * serialization requirements</a> are met by the class.
  * <p>
  * Making a real object spy serializable is a bit more effort as the spy(...) method does not have an overloaded version 
  * which accepts MockSettings. No worries, you will hardly ever use it.
  * 
  * <pre>
  * List<Object> list = new ArrayList<Object>();
  * List<Object> spy = mock(ArrayList.class, withSettings()
  *                 .spiedInstance(list)
  *                 .defaultAnswer(CALLS_REAL_METHODS)
  *                 .serializable());
  * </pre>
  */
 @SuppressWarnings(""unchecked"")
 public class Mockito extends Matchers {
     
     private static final MockitoCore MOCKITO_CORE = new MockitoCore();
     
     /**
      * The default Answer of every mock <b>if</b> the mock was not stubbed. 
      * Typically it just returns some empty value. 
      * <p>
      * {@link Answer} can be used to define the return values of unstubbed invocations. 
      * <p>
      * This implementation first tries the global configuration. 
      * If there is no global configuration then it uses {@link ReturnsEmptyValues} (returns zeros, empty collections, nulls, etc.)
      */
     public static final Answer<Object> RETURNS_DEFAULTS = new GloballyConfiguredAnswer();
     
     /**
      * Optional Answer to be used with {@link Mockito#mock(Class, Answer)}
      * <p>
      * {@link Answer} can be used to define the return values of unstubbed invocations.
      * <p>
      * This implementation can be helpful when working with legacy code.
      * Unstubbed methods often return null. If your code uses the object returned by an unstubbed call you get a NullPointerException.
      * This implementation of Answer <b>returns SmartNull instead of null</b>.
      * SmartNull gives nicer exception message than NPE because it points out the line where unstubbed method was called. You just click on the stack trace.
      * <p>
      * ReturnsSmartNulls first tries to return ordinary return values (see {@link ReturnsMoreEmptyValues})
      * then it tries to return SmartNull. If the return type is final then plain null is returned.
      * <p>
      * ReturnsSmartNulls will be probably the default return values strategy in Mockito 2.0
      * <p>
      * Example:
      * <pre>
      *   Foo mock = (Foo.class, RETURNS_SMART_NULLS);
      *   
      *   //calling unstubbed method here:
      *   Stuff stuff = mock.getStuff();
      *   
      *   //using object returned by unstubbed call:
      *   stuff.doSomething();
      *   
      *   //Above doesn't yield NullPointerException this time!
      *   //Instead, SmartNullPointerException is thrown. 
      *   //Exception's cause links to unstubbed <i>mock.getStuff()</i> - just click on the stack trace.  
      * </pre>
      */
     public static final Answer<Object> RETURNS_SMART_NULLS = new ReturnsSmartNulls();
     
     /**
      * Optional Answer to be used with {@link Mockito#mock(Class, Answer)}
      * <p>
      * {@link Answer} can be used to define the return values of unstubbed invocations.
      * <p>
      * This implementation can be helpful when working with legacy code. 
      * <p>
      * ReturnsMocks first tries to return ordinary return values (see {@link ReturnsMoreEmptyValues})
      * then it tries to return mocks. If the return type cannot be mocked (e.g. is final) then plain null is returned.
      * <p>
      */
     public static final Answer<Object> RETURNS_MOCKS = new ReturnsMocks();
 
     /**
      * Optional Answer to be used with {@link Mockito#mock(Class, Answer)}
      * <p>
      * {@link Answer} can be used to define the return values of unstubbed invocations.
      * <p>
      * This implementation can be helpful when working with legacy code.
      * When this implementation is used, unstubbed methods will delegate to the real implementation.
      * This is a way to create a partial mock object that calls real methods by default.
      * <p>
      * As usual you are going to read <b>the partial mock warning</b>:
      * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.
      * How does partial mock fit into this paradigm? Well, it just doesn't... 
      * Partial mock usually means that the complexity has been moved to a different method on the same object.
      * In most cases, this is not the way you want to design your application.
      * <p>
      * However, there are rare cases when partial mocks come handy: 
      * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
      * However, I wouldn't use partial mocks for new, test-driven & well-designed code.
      * <p>
      * Example:
      * <pre>
      * Foo mock = mock(Foo.class, CALLS_REAL_METHODS);
      *
      * // this calls the real implementation of Foo.getSomething()
      * value = mock.getSomething();
      *
      * when(mock.getSomething()).thenReturn(fakeValue);
      *
      * // now fakeValue is returned
      * value = mock.getSomething();
      * </pre>
      */
     public static final Answer<Object> CALLS_REAL_METHODS = new CallsRealMethods();
     
     /**
      * Creates mock object of given class or interface.
      * <p>
      * See examples in javadoc for {@link Mockito} class
      * 
      * @param classToMock class or interface to mock
      * @return mock object
      */
     public static <T> T mock(Class<T> classToMock) {
         return mock(classToMock, withSettings().defaultAnswer(RETURNS_DEFAULTS));
     }
     
     /**
      * Specifies mock name. Naming mocks can be helpful for debugging - the name is used in all verification errors. 
      * <p>
      * Beware that naming mocks is not a solution for complex code which uses too many mocks or collaborators. 
      * <b>If you have too many mocks then refactor the code</b> so that it's easy to test/debug without necessity of naming mocks.
      * <p>
      * <b>If you use &#064;Mock annotation then you've got naming mocks for free!</b> &#064;Mock uses field name as mock name. {@link Mock Read more.}
      * <p>
      * 
      * See examples in javadoc for {@link Mockito} class
      * 
      * @param classToMock class or interface to mock
      * @param name of the mock 
      * @return mock object
      */
     public static <T> T mock(Class<T> classToMock, String name) {
         return mock(classToMock, withSettings()
                 .name(name)
                 .defaultAnswer(RETURNS_DEFAULTS));
     }
     
     /**
      * @deprecated
      * <b>Please use mock(Foo.class, defaultAnswer);</b>
      * <p>
      * See {@link Mockito#mock(Class, Answer)}
      * <p>
      * Why it is deprecated? ReturnValues is being replaced by Answer
      * for better consistency & interoperability of the framework. 
      * Answer interface has been in Mockito for a while and it has the same responsibility as ReturnValues.
      * There's no point in mainting exactly the same interfaces.
      * <p>
      * Creates mock with a specified strategy for its return values. 
      * It's quite advanced feature and typically you don't need it to write decent tests.
      * However it can be helpful when working with legacy systems.
      * <p>
      * Obviously return values are used only when you don't stub the method call.
      *
      * <pre>
      *   Foo mock = mock(Foo.class, Mockito.RETURNS_SMART_NULLS);
      *   Foo mockTwo = mock(Foo.class, new YourOwnReturnValues()); 
      * </pre>
      * 
      * <p>See examples in javadoc for {@link Mockito} class</p>
      * 
      * @param classToMock class or interface to mock
      * @param returnValues default return values for unstubbed methods
      *
      * @return mock object
      */
     @Deprecated
     public static <T> T mock(Class<T> classToMock, ReturnValues returnValues) {
         return mock(classToMock, withSettings().defaultAnswer(new AnswerReturnValuesAdapter(returnValues)));
     }
     
     /**
      * Creates mock with a specified strategy for its answers to interactions. 
      * It's quite advanced feature and typically you don't need it to write decent tests.
      * However it can be helpful when working with legacy systems.
      * <p>
      * It is the default answer so it will be used <b>only when you don't</b> stub the method call.
      *
      * <pre>
      *   Foo mock = mock(Foo.class, RETURNS_SMART_NULLS);
      *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer()); 
      * </pre>
      * 
      * <p>See examples in javadoc for {@link Mockito} class</p>
      * 
      * @param classToMock class or interface to mock
      * @param defaultAnswer default answer for unstubbed methods
      *
      * @return mock object
      */
     public static <T> T mock(Class<T> classToMock, Answer defaultAnswer) {
         return mock(classToMock, withSettings().defaultAnswer(defaultAnswer));
     }
     
     /**
      * Creates a mock with some non-standard settings.
      * <p>
      * The number of configuration points for a mock grows 
      * so we need a fluent way to introduce new configuration without adding more and more overloaded Mockito.mock() methods. 
      * Hence {@link MockSettings}.
      * <pre>
      *   Listener mock = mock(Listener.class, withSettings()
      *     .name(""firstListner"").defaultBehavior(RETURNS_SMART_NULLS));
      *   );  
      * </pre>
      * <b>Use it carefully and occasionally</b>. What might be reason your test needs non-standard mocks? 
      * Is the code under test so complicated that it requires non-standard mocks? 
      * Wouldn't you prefer to refactor the code under test so it is testable in a simple way?
      * <p>
      * See also {@link Mockito#withSettings()}
      * <p>
      * See examples in javadoc for {@link Mockito} class
      * 
      * @param classToMock class or interface to mock
      * @param mockSettings additional mock settings
      * @return mock object
      */
     public static <T> T mock(Class<T> classToMock, MockSettings mockSettings) {
+        return MOCKITO_CORE.mock(classToMock, mockSettings, true);
     }
     
     /**
      * Creates a spy of the real object. The spy calls <b>real</b> methods unless they are stubbed.
      * <p>
      * Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.
      * <p>
      * As usual you are going to read <b>the partial mock warning</b>:
      * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.
      * How does partial mock fit into this paradigm? Well, it just doesn't... 
      * Partial mock usually means that the complexity has been moved to a different method on the same object.
      * In most cases, this is not the way you want to design your application.
      * <p>
      * However, there are rare cases when partial mocks come handy: 
      * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
      * However, I wouldn't use partial mocks for new, test-driven & well-designed code.
      * <p>
      * Example:
      * 
      * <pre>
      *   List list = new LinkedList();
      *   List spy = spy(list);
      * 
      *   //optionally, you can stub out some methods:
      *   when(spy.size()).thenReturn(100);
      * 
      *   //using the spy calls <b>real</b> methods
      *   spy.add(""one"");
      *   spy.add(""two"");
      * 
      *   //prints ""one"" - the first element of a list
      *   System.out.println(spy.get(0));
      * 
      *   //size() method was stubbed - 100 is printed
      *   System.out.println(spy.size());
      * 
      *   //optionally, you can verify
      *   verify(spy).add(""one"");
      *   verify(spy).add(""two"");
      * </pre>
      * 
      * <h4>Important gotcha on spying real objects!</h4>
      * 
      * 1. Sometimes it's impossible to use {@link Mockito#when(Object)} for stubbing spies. Example:
      * 
      * <pre>
      *   List list = new LinkedList();
      *   List spy = spy(list);
      *   
      *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)
      *   when(spy.get(0)).thenReturn(""foo"");
      *   
      *   //You have to use doReturn() for stubbing
      *   doReturn(""foo"").when(spy).get(0);
      * </pre>
      * 
      * 2. Watch out for final methods. 
      * Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.
      * What will happen is the real method will be called *on mock* but *not on the real instance* you passed to the spy() method.
      * Typically you may get a NullPointerException because mock instances don't have fields initiated.
      * 
      * <p>
      * See examples in javadoc for {@link Mockito} class
      * 
      * @param object
      *            to spy on
      * @return a spy of the real object
      */
     public static <T> T spy(T object) {
         return MOCKITO_CORE.mock((Class<T>) object.getClass(), withSettings()
                 .spiedInstance(object)
+                .defaultAnswer(CALLS_REAL_METHODS), true); 
     }
 
     /**
      * <pre>
      *   //Instead of:
      *   stub(mock.count()).toReturn(10);
      * 
      *   //Please do:
      *   when(mock.count()).thenReturn(10);
      * </pre> 
      * 
      * Many users found stub() confusing therefore stub() has been deprecated in favor of {@link Mockito#when(Object)} 
      * <p>
      * How to fix deprecation warnings? Typically it's just few minutes of search & replace job:
      * <pre>
      *   Mockito.stub;  <i>replace with:</i>  Mockito.when;
      *   stub(          <i>replace with:</i>  when(
      *   .toReturn(     <i>replace with:</i>  .thenReturn(
      *   .toThrow(      <i>replace with:</i>  .thenThrow(
      *   .toAnswer(     <i>replace with:</i>  .thenAnswer(
      * </pre>
      * If you're an existing user then sorry for making your code littered with deprecation warnings. 
/src/org/mockito/internal/MockitoCore.java @@ -1,38 +1,39 @@
 /*
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
 package org.mockito.internal;
 
 import org.mockito.InOrder;
 import org.mockito.MockSettings;
 import org.mockito.exceptions.Reporter;
 import org.mockito.exceptions.misusing.NotAMockException;
 import org.mockito.internal.creation.MockSettingsImpl;
 import org.mockito.internal.invocation.Invocation;
 import org.mockito.internal.progress.IOngoingStubbing;
 import org.mockito.internal.progress.MockingProgress;
 import org.mockito.internal.progress.ThreadSafeMockingProgress;
 import org.mockito.internal.stubbing.OngoingStubbingImpl;
 import org.mockito.internal.stubbing.StubberImpl;
 import org.mockito.internal.util.MockUtil;
 import org.mockito.internal.verification.api.VerificationMode;
 import org.mockito.stubbing.*;
 
 import java.util.Arrays;
 import java.util.List;
 
 @SuppressWarnings(""unchecked"")
 public class MockitoCore {
 
     private final Reporter reporter = new Reporter();
     private final MockUtil mockUtil = new MockUtil();
     private final MockingProgress mockingProgress = new ThreadSafeMockingProgress();
     
+    public <T> T mock(Class<T> classToMock, MockSettings mockSettings, boolean shouldResetOngoingStubbing) {
         mockingProgress.validateState();
+        if (shouldResetOngoingStubbing) {
             mockingProgress.resetOngoingStubbing();
+        }
         return mockUtil.createMock(classToMock, (MockSettingsImpl) mockSettings);
     }
     
","@@ -1,921 +1,921 @@
 /*
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
 package org.mockito;
 
 import org.mockito.internal.MockitoCore;
 import org.mockito.internal.creation.MockSettingsImpl;
 import org.mockito.internal.debugging.MockitoDebuggerImpl;
 import org.mockito.internal.stubbing.answers.*;
 import org.mockito.internal.stubbing.defaultanswers.*;
 import org.mockito.internal.verification.VerificationModeFactory;
 import org.mockito.internal.verification.api.VerificationMode;
 import org.mockito.runners.MockitoJUnitRunner;
 import org.mockito.stubbing.*;
 
 /**
  * <p align=""left""><img src=""logo.jpg""/></p>
  * Mockito library enables mocks creation, verification and stubbing.
  * <p>
  * This javadoc content is also available on the <a href=""http://mockito.org"">http://mockito.org</a> web page. 
  * All documentation is kept in javadocs because it guarantees consistency between what's on the web and what's in the source code.
  * Also, it makes possible to access documentation straight from the IDE even if you work offline.   
  * 
  * <h1>Contents</h1>
  * 
  * <b> 
  *      <a href=""#1"">1. Let's verify some behaviour! </a><br/> 
  *      <a href=""#2"">2. How about some stubbing? </a><br/>
  *      <a href=""#3"">3. Argument matchers </a><br/>
  *      <a href=""#4"">4. Verifying exact number of invocations / at least once / never </a><br/> 
  *      <a href=""#5"">5. Stubbing void methods with exceptions </a><br/> 
  *      <a href=""#6"">6. Verification in order </a><br/> 
  *      <a href=""#7"">7. Making sure interaction(s) never happened on mock </a><br/> 
  *      <a href=""#8"">8. Finding redundant invocations </a><br/> 
  *      <a href=""#9"">9. Shorthand for mocks creation - &#064;Mock annotation </a><br/> 
  *      <a href=""#10"">10. Stubbing consecutive calls (iterator-style stubbing) </a><br/> 
  *      <a href=""#11"">11. Stubbing with callbacks </a><br/>
  *      <a href=""#12"">12. doThrow()|doAnswer()|doNothing()|doReturn() family of methods mostly for stubbing voids </a><br/>
  *      <a href=""#13"">13. Spying on real objects </a><br/>
  *      <a href=""#14"">14. Changing default return values of unstubbed invocations (Since 1.7) </a><br/>
  *      <a href=""#15"">15. Capturing arguments for further assertions (Since 1.8.0) </a><br/>
  *      <a href=""#16"">16. Real partial mocks (Since 1.8.0) </a><br/>
  *      <a href=""#17"">17. Resetting mocks (Since 1.8.0) </a><br/>
  *      <a href=""#18"">18. Troubleshooting & validating framework usage (Since 1.8.0) </a><br/>
  *      <a href=""#19"">19. Aliases for behavior driven development (Since 1.8.0) </a><br/>
  *      <a href=""#20"">20. (**New**) Serializable mocks (Since 1.8.1) </a><br/>
  * </b>
  * 
  * <p>
  * Following examples mock a List, because everyone knows its interface (methods
  * like add(), get(), clear() will be used). <br>
  * You probably wouldn't mock List class 'in real'.
  * 
  * <h3 id=""1"">1. Let's verify some behaviour!</h3>
  * 
  * <pre>
  * //Let's import Mockito statically so that the code looks clearer
  * import static org.mockito.Mockito.*;
  * 
  * //mock creation
  * List mockedList = mock(List.class);
  *
  * //using mock object
  * mockedList.add(""one"");
  * mockedList.clear();
  *
  * //verification
  * verify(mockedList).add(""one"");
  * verify(mockedList).clear();
  * </pre>
  * 
  * <p>
  * Once created, mock will remember all interactions. Then you can selectively
  * verify whatever interaction you are interested in.
  * 
  * <h3 id=""2"">2. How about some stubbing?</h3>
  * 
  * <pre>
  * //You can mock concrete classes, not only interfaces
  * LinkedList mockedList = mock(LinkedList.class);
  * 
  * //stubbing
  * when(mockedList.get(0)).thenReturn(""first"");
  * when(mockedList.get(1)).thenThrow(new RuntimeException());
  * 
  * //following prints ""first""
  * System.out.println(mockedList.get(0));
  * 
  * //following throws runtime exception
  * System.out.println(mockedList.get(1));
  * 
  * //following prints ""null"" because get(999) was not stubbed
  * System.out.println(mockedList.get(999));
  *  
  * //Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>
  * //If your code cares what get(0) returns then something else breaks (often before even verify() gets executed).
  * //If your code doesn't care what get(0) returns then it should not be stubbed. Not convinced? See <a href=""http://monkeyisland.pl/2008/04/26/asking-and-telling"">here</a>.
  * verify(mockedList).get(0);
  * </pre>
  * 
  * <ul>
  * <li> By default, for all methods that return value, mock returns null, an
  * empty collection or appropriate primitive/primitive wrapper value (e.g: 0,
  * false, ... for int/Integer, boolean/Boolean, ...). </li>
  * 
  * <li> Stubbing can be overridden: for example common stubbing can go to
  * fixture setup but the test methods can override it.
  * Please note that overridding stubbing is a potential code smell that points out too much stubbing</li>
  * 
  * <li> Once stubbed, the method will always return stubbed value regardless
  * of how many times it is called. </li>
  * 
  * <li> Last stubbing is more important - when you stubbed the same method with
  * the same arguments many times. </li>
  * 
  * </ul>
  * 
  * <h3 id=""3"">3. Argument matchers</h3>
  * 
  * Mockito verifies argument values in natural java style: by using an equals() method.
  * Sometimes, when extra flexibility is required then you might use argument matchers:  
  * 
  * <pre>
  * //stubbing using built-in anyInt() argument matcher
  * when(mockedList.get(anyInt())).thenReturn(""element"");
  * 
  * //stubbing using hamcrest (let's say isValid() returns your own hamcrest matcher):
  * when(mockedList.contains(argThat(isValid()))).thenReturn(""element"");
  * 
  * //following prints ""element""
  * System.out.println(mockedList.get(999));
  * 
  * //<b>you can also verify using an argument matcher</b>
  * verify(mockedList).get(anyInt());
  * </pre>
  * 
  * <p>
  * Argument matchers allow flexible verification or stubbing. 
  * {@link Matchers Click here to see} more built-in matchers 
  * and examples of <b>custom argument matchers / hamcrest matchers</b>.
  * <p>
  * For information solely on <b>custom argument matchers</b> check out javadoc for {@link ArgumentMatcher} class.
  * <p>
  * Be reasonable with using complicated argument matching.
  * The natural matching style using equals() with occasional anyX() matchers tend to give clean & simple tests.
  * Sometimes it's just better to refactor the code to allow equals() matching or even implement equals() method to help out with testing.
  * <p>
  * Also, read <a href=""#15"">section 15</a> or javadoc for {@link ArgumentCaptor} class.
  * {@link ArgumentCaptor} is a special implementation of an argument matcher that captures argument values for further assertions.  
  * <p>
  * <b>Warning on argument matchers:</b>
  * <p>
  * If you are using argument matchers, <b>all arguments</b> have to be provided
  * by matchers.
  * <p>
  * E.g: (example shows verification but the same applies to stubbing):
  * 
  * <pre>
  *   verify(mock).someMethod(anyInt(), anyString(), <b>eq(""third argument"")</b>);
  *   //above is correct - eq() is also an argument matcher
  *   
  *   verify(mock).someMethod(anyInt(), anyString(), <b>""third argument""</b>);
  *   //above is incorrect - exception will be thrown because third argument is given without an argument matcher.
  * </pre>
  * 
  * <h3 id=""4"">4. Verifying exact number of invocations / at least x / never</h3>
  * 
  * <pre>
  * //using mock 
  * mockedList.add(""once"");
  * 
  * mockedList.add(""twice"");
  * mockedList.add(""twice"");
  * 
  * mockedList.add(""three times"");
  * mockedList.add(""three times"");
  * mockedList.add(""three times"");
  * 
  * //following two verifications work exactly the same - times(1) is used by default
  * verify(mockedList).add(""once"");
  * verify(mockedList, times(1)).add(""once"");
  * 
  * //exact number of invocations verification
  * verify(mockedList, times(2)).add(""twice"");
  * verify(mockedList, times(3)).add(""three times"");
  * 
  * //verification using never(). never() is an alias to times(0)
  * verify(mockedList, never()).add(""never happened"");
  * 
  * //verification using atLeast()/atMost()
  * verify(mockedList, atLeastOnce()).add(""three times"");
  * verify(mockedList, atLeast(2)).add(""five times"");
  * verify(mockedList, atMost(5)).add(""three times"");
  * 
  * </pre>
  * 
  * <p>
  * <b>times(1) is the default.</b> Therefore using times(1) explicitly can be
  * omitted.
  * 
  * <h3 id=""5"">5. Stubbing void methods with exceptions</h3>
  * 
  * <pre>
  *   doThrow(new RuntimeException()).when(mockedList).clear();
  *   
  *   //following throws RuntimeException:
  *   mockedList.clear();
  * </pre>
  * 
  * Read more about doThrow|doAnswer family of methods in paragraph 12.
  * <p>
  * Initially, {@link Mockito#stubVoid(Object)} was used for stubbing voids.
  * Currently stubVoid() is deprecated in favor of {@link Mockito#doThrow(Throwable)}.
  * This is because of improved readability and consistency with the family of {@link Mockito#doAnswer(Answer)} methods. 
  * 
  * <h3 id=""6"">6. Verification in order</h3>
  * 
  * <pre>
  * List firstMock = mock(List.class);
  * List secondMock = mock(List.class);
  * 
  * //using mocks
  * firstMock.add(""was called first"");
  * secondMock.add(""was called second"");
  * 
  * //create inOrder object passing any mocks that need to be verified in order
  * InOrder inOrder = inOrder(firstMock, secondMock);
  * 
  * //following will make sure that firstMock was called before secondMock
  * inOrder.verify(firstMock).add(""was called first"");
  * inOrder.verify(secondMock).add(""was called second"");
  * </pre>
  * 
  * Verification in order is flexible - <b>you don't have to verify all
  * interactions</b> one-by-one but only those that you are interested in
  * testing in order.
  * <p>
  * Also, you can create InOrder object passing only mocks that are relevant for
  * in-order verification.
  * 
  * <h3 id=""7"">7. Making sure interaction(s) never happened on mock</h3>
  * 
  * <pre>
  * //using mocks - only mockOne is interacted
  * mockOne.add(""one"");
  * 
  * //ordinary verification
  * verify(mockOne).add(""one"");
  * 
  * //verify that method was never called on a mock
  * verify(mockOne, never()).add(""two"");
  * 
  * //verify that other mocks were not interacted
  * verifyZeroInteractions(mockTwo, mockThree);
  * 
  * </pre>
  * 
  * <h3 id=""8"">8. Finding redundant invocations</h3>
  * 
  * <pre>
  * //using mocks
  * mockedList.add(""one"");
  * mockedList.add(""two"");
  * 
  * verify(mockedList).add(""one"");
  * 
  * //following verification will fail 
  * verifyNoMoreInteractions(mockedList);
  * </pre>
  * 
  * A word of <b>warning</b>: 
  * Some users who did a lot of classic, expect-run-verify mocking tend to use verifyNoMoreInteractions() very often, even in every test method. 
  * verifyNoMoreInteractions() is not recommended to use in every test method. 
  * verifyNoMoreInteractions() is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.
  * Abusing it leads to overspecified, less maintainable tests. You can find further reading 
  * <a href=""http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/"">here</a>.
  * 
  * <p>   
  * See also {@link Mockito#never()} - it is more explicit and
  * communicates the intent well.
  * <p>
  * 
  * <h3 id=""9"">9. Shorthand for mocks creation - &#064;Mock annotation</h3>
  * 
  * <ul>
  * <li>Minimizes repetitive mock creation code.</li>
  * <li>Makes the test class more readable.</li>
  * <li>Makes the verification error easier to read because the <b>field name</b>
  * is used to identify the mock.</li>
  * </ul>
  * 
  * <pre>
  *   public class ArticleManagerTest { 
  *     
  *       &#064;Mock private ArticleCalculator calculator;
  *       &#064;Mock private ArticleDatabase database;
  *       &#064;Mock private UserProvider userProvider;
  *     
  *       private ArticleManager manager;
  * </pre>
  * 
  * <b>Important!</b> This needs to be somewhere in the base class or a test
  * runner:
  * 
  * <pre>
  * MockitoAnnotations.initMocks(testClass);
  * </pre>
  * 
  * You can use built-in runner: {@link MockitoJUnitRunner}.
  * <p>
  * Read more here: {@link MockitoAnnotations}
  * 
  * <h3 id=""10""> 10. Stubbing consecutive calls (iterator-style stubbing)</h3>
  * 
  * Sometimes we need to stub with different return value/exception for the same
  * method call. Typical use case could be mocking iterators. 
  * Original version of Mockito did not have this feature to promote simple mocking. 
  * For example, instead of iterators one could use {@link Iterable} or simply
  * collections. Those offer natural ways of stubbing (e.g. using real
  * collections). In rare scenarios stubbing consecutive calls could be useful,
  * though:
  * <p>
  * 
  * <pre>
  * when(mock.someMethod(""some arg""))
  *   .thenThrow(new RuntimeException())
  *   .thenReturn(""foo"");
  * 
  * //First call: throws runtime exception:
  * mock.someMethod(""some arg"");
  * 
  * //Second call: prints ""foo""
  * System.out.println(mock.someMethod(""some arg""));
  * 
  * //Any consecutive call: prints ""foo"" as well (last stubbing wins). 
  * System.out.println(mock.someMethod(""some arg""));
  * </pre>
  * 
  * Alternative, shorter version of consecutive stubbing:
  * 
  * <pre>
  * when(mock.someMethod(""some arg""))
  *   .thenReturn(""one"", ""two"", ""three"");
  * </pre>
  * 
  * <h3 id=""11""> 11. Stubbing with callbacks</h3>
  * 
  * Allows stubbing with generic {@link Answer} interface.
 *  <p>
  * Yet another controversial feature which was not included in Mockito
  * originally. We recommend using simple stubbing with thenReturn() or
  * thenThrow() only. Those two should be <b>just enough</b> to test/test-drive
  * any clean & simple code.
  * 
  * <pre>
  * when(mock.someMethod(anyString())).thenAnswer(new Answer() {
  *     Object answer(InvocationOnMock invocation) {
  *         Object[] args = invocation.getArguments();
  *         Object mock = invocation.getMock();
  *         return ""called with arguments: "" + args;
  *     }
  * });
  * 
  * //Following prints ""called with arguments: foo""
  * System.out.println(mock.someMethod(""foo""));
  * </pre>
  * 
  * <h3 id=""12""> 12. doThrow()|doAnswer()|doNothing()|doReturn() family of methods for stubbing voids (mostly)</h3>
  * 
  * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...
  * <p>
  * {@link Mockito#doThrow(Throwable)} replaces the {@link Mockito#stubVoid(Object)} method for stubbing voids. 
  * The main reason is improved readability and consistency with the family of doAnswer() methods.
  * <p>
  * Use doThrow() when you want to stub a void method with an exception:
  * <pre>
  *   doThrow(new RuntimeException()).when(mockedList).clear();
  *   
  *   //following throws RuntimeException:
  *   mockedList.clear();
  * </pre>
  * 
  * Read more about other methods:
  * <p>
  * {@link Mockito#doThrow(Throwable)}
  * <p>
  * {@link Mockito#doAnswer(Answer)}
  * <p>
  * {@link Mockito#doNothing()}
  * <p>
  * {@link Mockito#doReturn(Object)}
  * 
  * <h3 id=""13""> 13. Spying on real objects</h3>
  * 
  * You can create spies of real objects. When you use the spy then the <b>real</b> methods are called (unless a method was stubbed).
  * <p>
  * Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.
  * 
  * <p>
  * Spying on real objects can be associated with ""partial mocking"" concept. 
  * <b>Before the release 1.8</b>, Mockito spies were not real partial mocks. 
  * The reason was we thought partial mock is a code smell. 
  * At some point we found legitimate use cases for partial mocks 
  * (3rd party interfaces, interim refactoring of legacy code, the full article is <a href=
  * ""http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring""
  * >here</a>)
  * <p>
  *
  * <pre>
  *   List list = new LinkedList();
  *   List spy = spy(list);
  * 
  *   //optionally, you can stub out some methods:
  *   when(spy.size()).thenReturn(100);
  * 
  *   //using the spy calls <b>real</b> methods
  *   spy.add(""one"");
  *   spy.add(""two"");
  * 
  *   //prints ""one"" - the first element of a list
  *   System.out.println(spy.get(0));
  * 
  *   //size() method was stubbed - 100 is printed
  *   System.out.println(spy.size());
  * 
  *   //optionally, you can verify
  *   verify(spy).add(""one"");
  *   verify(spy).add(""two"");
  * </pre>
  * 
  * <h4>Important gotcha on spying real objects!</h4>
  * 
  * 1. Sometimes it's impossible to use {@link Mockito#when(Object)} for stubbing spies. Example:
  * 
  * <pre>
  *   List list = new LinkedList();
  *   List spy = spy(list);
  *   
  *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)
  *   when(spy.get(0)).thenReturn(""foo"");
  *   
  *   //You have to use doReturn() for stubbing
  *   doReturn(""foo"").when(spy).get(0);
  * </pre>
  * 
  * 2. Watch out for final methods. 
  * Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.
  * What will happen is the real method will be called *on mock* but *not on the real instance* you passed to the spy() method.
  * Typically you may get a NullPointerException because mock instances don't have fields initiated.
  * 
  * <h3 id=""14"">14. Changing default return values of unstubbed invocations (Since 1.7) </h3>
  * 
  * You can create a mock with specified strategy for its return values.
  * It's quite advanced feature and typically you don't need it to write decent tests.
  * However, it can be helpful for working with <b>legacy systems</b>.
  * <p>
  * It is the default answer so it will be used <b>only when you don't</b> stub the method call.
  * 
  * <pre>
  *   Foo mock = mock(Foo.class, Mockito.RETURNS_SMART_NULLS);
  *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer()); 
  * </pre>
  * 
  * <p>
  * Read more about this interesting implementation of <i>Answer</i>: {@link Mockito#RETURNS_SMART_NULLS}
  * 
  * <h3 id=""15"">15. Capturing arguments for further assertions (Since 1.8.0) </h3>
  * 
  * Mockito verifies argument values in natural java style: by using an equals() method.
  * This is also the recommended way of matching arguments because it makes tests clean & simple.
  * In some situations though, it is helpful to assert on certain arguments after the actual verification.
  * For example:
  * <pre>
  *   ArgumentCaptor&lt;Person&gt; argument = ArgumentCaptor.forClass(Person.class);
  *   verify(mock).doSomething(argument.capture());
  *   assertEquals(""John"", argument.getValue().getName());
  * </pre>
  * 
  * <b>Warning:</b> it is recommended to use ArgumentCaptor with verification <b>but not</b> with stubbing.
  * Using ArgumentCaptor with stubbing may decrease test readability because captor is created outside of assert (aka verify or 'then') block.
  * Also it may reduce defect localization because if stubbed method was not called then no argument is captured.
  * <p>
  * In a way ArgumentCaptor is related to custom argument matchers (see javadoc for {@link ArgumentMatcher} class).
  * Both techniques can be used for making sure certain arguments where passed to mocks. 
  * However, ArgumentCaptor may be a better fit if:
  * <ul>  
  * <li>custom argument matcher is not likely to be reused</li>
  * <li>you just need it to assert on argument values to complete verification</li>
  * </ul>
  * Custom argument matchers via {@link ArgumentMatcher} are usually better for stubbing.
  * 
  * <h3 id=""16"">16. Real partial mocks (Since 1.8.0) </h3>
  *  
  *  Finally, after many internal debates & discussions on the mailing list, partial mock support was added to Mockito.
  *  Previously we considered partial mocks as code smells. However, we found a legitimate use case for partial mocks - more reading:
  *  <a href=""http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring"">here</a>
  *  <p>
  *  <b>Before release 1.8</b> spy() was not producing real partial mocks and it was confusing for some users.
  *  Read more about spying: <a href=""#13"">here</a> or in javadoc for {@link Mockito#spy(Object)} method. 
  *  <p>
  *  <pre>
  *    //you can create partial mock with spy() method:    
  *    List list = spy(new LinkedList());
  *    
  *    //you can enable partial mock capabilities selectively on mocks:
  *    Foo mock = mock(Foo.class);
  *    //Be sure the real implementation is 'safe'.
  *    //If real implementation throws exceptions or depends on specific state of the object then you're in trouble.
  *    when(mock.someMethod()).thenCallRealMethod();
  *  </pre>
  *  
  * As usual you are going to read <b>the partial mock warning</b>:
  * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.
  * How does partial mock fit into this paradigm? Well, it just doesn't... 
  * Partial mock usually means that the complexity has been moved to a different method on the same object.
  * In most cases, this is not the way you want to design your application.
  * <p>
  * However, there are rare cases when partial mocks come handy: 
  * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
  * However, I wouldn't use partial mocks for new, test-driven & well-designed code.
  *  
  * <h3 id=""17"">17. Resetting mocks (Since 1.8.0) </h3>
  *  
  * Smart Mockito users hardly use this feature because they know it could be a sign of poor tests.
  * Normally, you don't need to reset your mocks, just create new mocks for each test method. 
  * <p>
  * Instead of reset() please consider writing simple, small and focused test methods over lengthy, over-specified tests.
  * <b>First potential code smell is reset() in the middle of the test method.</b> This probably means you're testing too much.
  * Follow the whisper of your test methods: ""Please keep us small & focused on single behavior"". 
  * There are several threads about it on mockito mailing list.
  * <p>
  * The only reason we added reset() method is to
  * make it possible to work with container-injected mocks.
  * See issue 55 (<a href=""http://code.google.com/p/mockito/issues/detail?id=55"">here</a>)
  * or FAQ (<a href=""http://code.google.com/p/mockito/wiki/FAQ"">here</a>).
  * <p>
  * <b>Don't harm yourself.</b> reset() in the middle of the test method is a code smell (you're probably testing too much). 
  * <pre>
  *   List mock = mock(List.class);
  *   when(mock.size()).thenReturn(10);
  *   mock.add(1);
  *   
  *   reset(mock);
  *   //at this point the mock forgot any interactions & stubbing
  * </pre>
  *  
  * <h3 id=""18"">18. Troubleshooting & validating framework usage (Since 1.8.0) </h3>
  * 
  * First of all, in case of any trouble, I encourage you to read the Mockito FAQ: 
  * <a href=""http://code.google.com/p/mockito/wiki/FAQ"">http://code.google.com/p/mockito/wiki/FAQ</a>
  * <p>
  * In case of questions you may also post to mockito mailing list: 
  * <a href=""http://groups.google.com/group/mockito"">http://groups.google.com/group/mockito</a>
  * <p>
  * Next, you should know that Mockito validates if you use it correctly <b>all the time</b>. 
  * However, there's a gotcha so please read the javadoc for {@link Mockito#validateMockitoUsage()}
  * 
  * <h3 id=""19"">19. Aliases for behavior driven development (Since 1.8.0) </h3>
  * 
  * Behavior Driven Development style of writing tests uses <b>//given //when //then</b> comments as fundamental parts of your test methods.
  * This is exactly how we write our tests and we warmly encourage you to do so!
  * <p>
  * Start learning about BDD here: <a href=""http://en.wikipedia.org/wiki/Behavior_Driven_Development"">http://en.wikipedia.org/wiki/Behavior_Driven_Development</a>
  * <p>
  * The problem is that current stubbing api with canonical role of <b>when</b> word does not integrate nicely with <b>//given //when //then</b> comments.
  * It's because stubbing belongs to <b>given</b> component of the test and not to the <b>when</b> component of the test. 
  * Hence {@link BDDMockito} class introduces an alias so that you stub method calls with {@link BDDMockito#given(Object)} method. 
  * Now it really nicely integrates with the <b>given</b> component of a BDD style test!  
  * <p>
  * Here is how the test might look like: 
  * <pre>
  * import static org.mockito.BDDMockito.*;
  * 
  * Seller seller = mock(Seller.class);
  * Shop shop = new Shop(seller);
  * 
  * public void shouldBuyBread() throws Exception {
  *   //given  
  *   given(seller.askForBread()).willReturn(new Bread());
  *   
  *   //when
  *   Goods goods = shop.buyBread();
  *   
  *   //then
  *   assertThat(goods, containBread());
  * }  
  * </pre>
  * 
  * <h3 id=""20"">20. (**New**) Serializable mocks (Since 1.8.1) </h3>
  * 
  * Mocks can be made serializable. With this feature you can use a mock in a place that requires dependencies to be serializable.
  * <p>
  * WARNING: This should be rarely used in unit testing. 
  * <p>
  * The behaviour was implemented for a specific use case of a BDD spec that had an unreliable external dependency.  This
  * was in a web environment and the objects from the external dependency were being serialized to pass between layers. 
  * <p>
  * To create serializable mock use {@link MockSettings#serializable()}:
  * <pre>
  *   List serializableMock = mock(List.class, withSettings().serializable());
  * </pre>
  * <p>
  * The mock can be serialized assuming all the normal <a href='http://java.sun.com/j2se/1.5.0/docs/api/java/io/Serializable.html'>
  * serialization requirements</a> are met by the class.
  * <p>
  * Making a real object spy serializable is a bit more effort as the spy(...) method does not have an overloaded version 
  * which accepts MockSettings. No worries, you will hardly ever use it.
  * 
  * <pre>
  * List<Object> list = new ArrayList<Object>();
  * List<Object> spy = mock(ArrayList.class, withSettings()
  *                 .spiedInstance(list)
  *                 .defaultAnswer(CALLS_REAL_METHODS)
  *                 .serializable());
  * </pre>
  */
 @SuppressWarnings(""unchecked"")
 public class Mockito extends Matchers {
     
     private static final MockitoCore MOCKITO_CORE = new MockitoCore();
     
     /**
      * The default Answer of every mock <b>if</b> the mock was not stubbed. 
      * Typically it just returns some empty value. 
      * <p>
      * {@link Answer} can be used to define the return values of unstubbed invocations. 
      * <p>
      * This implementation first tries the global configuration. 
      * If there is no global configuration then it uses {@link ReturnsEmptyValues} (returns zeros, empty collections, nulls, etc.)
      */
     public static final Answer<Object> RETURNS_DEFAULTS = new GloballyConfiguredAnswer();
     
     /**
      * Optional Answer to be used with {@link Mockito#mock(Class, Answer)}
      * <p>
      * {@link Answer} can be used to define the return values of unstubbed invocations.
      * <p>
      * This implementation can be helpful when working with legacy code.
      * Unstubbed methods often return null. If your code uses the object returned by an unstubbed call you get a NullPointerException.
      * This implementation of Answer <b>returns SmartNull instead of null</b>.
      * SmartNull gives nicer exception message than NPE because it points out the line where unstubbed method was called. You just click on the stack trace.
      * <p>
      * ReturnsSmartNulls first tries to return ordinary return values (see {@link ReturnsMoreEmptyValues})
      * then it tries to return SmartNull. If the return type is final then plain null is returned.
      * <p>
      * ReturnsSmartNulls will be probably the default return values strategy in Mockito 2.0
      * <p>
      * Example:
      * <pre>
      *   Foo mock = (Foo.class, RETURNS_SMART_NULLS);
      *   
      *   //calling unstubbed method here:
      *   Stuff stuff = mock.getStuff();
      *   
      *   //using object returned by unstubbed call:
      *   stuff.doSomething();
      *   
      *   //Above doesn't yield NullPointerException this time!
      *   //Instead, SmartNullPointerException is thrown. 
      *   //Exception's cause links to unstubbed <i>mock.getStuff()</i> - just click on the stack trace.  
      * </pre>
      */
     public static final Answer<Object> RETURNS_SMART_NULLS = new ReturnsSmartNulls();
     
     /**
      * Optional Answer to be used with {@link Mockito#mock(Class, Answer)}
      * <p>
      * {@link Answer} can be used to define the return values of unstubbed invocations.
      * <p>
      * This implementation can be helpful when working with legacy code. 
      * <p>
      * ReturnsMocks first tries to return ordinary return values (see {@link ReturnsMoreEmptyValues})
      * then it tries to return mocks. If the return type cannot be mocked (e.g. is final) then plain null is returned.
      * <p>
      */
     public static final Answer<Object> RETURNS_MOCKS = new ReturnsMocks();
 
     /**
      * Optional Answer to be used with {@link Mockito#mock(Class, Answer)}
      * <p>
      * {@link Answer} can be used to define the return values of unstubbed invocations.
      * <p>
      * This implementation can be helpful when working with legacy code.
      * When this implementation is used, unstubbed methods will delegate to the real implementation.
      * This is a way to create a partial mock object that calls real methods by default.
      * <p>
      * As usual you are going to read <b>the partial mock warning</b>:
      * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.
      * How does partial mock fit into this paradigm? Well, it just doesn't... 
      * Partial mock usually means that the complexity has been moved to a different method on the same object.
      * In most cases, this is not the way you want to design your application.
      * <p>
      * However, there are rare cases when partial mocks come handy: 
      * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
      * However, I wouldn't use partial mocks for new, test-driven & well-designed code.
      * <p>
      * Example:
      * <pre>
      * Foo mock = mock(Foo.class, CALLS_REAL_METHODS);
      *
      * // this calls the real implementation of Foo.getSomething()
      * value = mock.getSomething();
      *
      * when(mock.getSomething()).thenReturn(fakeValue);
      *
      * // now fakeValue is returned
      * value = mock.getSomething();
      * </pre>
      */
     public static final Answer<Object> CALLS_REAL_METHODS = new CallsRealMethods();
     
     /**
      * Creates mock object of given class or interface.
      * <p>
      * See examples in javadoc for {@link Mockito} class
      * 
      * @param classToMock class or interface to mock
      * @return mock object
      */
     public static <T> T mock(Class<T> classToMock) {
         return mock(classToMock, withSettings().defaultAnswer(RETURNS_DEFAULTS));
     }
     
     /**
      * Specifies mock name. Naming mocks can be helpful for debugging - the name is used in all verification errors. 
      * <p>
      * Beware that naming mocks is not a solution for complex code which uses too many mocks or collaborators. 
      * <b>If you have too many mocks then refactor the code</b> so that it's easy to test/debug without necessity of naming mocks.
      * <p>
      * <b>If you use &#064;Mock annotation then you've got naming mocks for free!</b> &#064;Mock uses field name as mock name. {@link Mock Read more.}
      * <p>
      * 
      * See examples in javadoc for {@link Mockito} class
      * 
      * @param classToMock class or interface to mock
      * @param name of the mock 
      * @return mock object
      */
     public static <T> T mock(Class<T> classToMock, String name) {
         return mock(classToMock, withSettings()
                 .name(name)
                 .defaultAnswer(RETURNS_DEFAULTS));
     }
     
     /**
      * @deprecated
      * <b>Please use mock(Foo.class, defaultAnswer);</b>
      * <p>
      * See {@link Mockito#mock(Class, Answer)}
      * <p>
      * Why it is deprecated? ReturnValues is being replaced by Answer
      * for better consistency & interoperability of the framework. 
      * Answer interface has been in Mockito for a while and it has the same responsibility as ReturnValues.
      * There's no point in mainting exactly the same interfaces.
      * <p>
      * Creates mock with a specified strategy for its return values. 
      * It's quite advanced feature and typically you don't need it to write decent tests.
      * However it can be helpful when working with legacy systems.
      * <p>
      * Obviously return values are used only when you don't stub the method call.
      *
      * <pre>
      *   Foo mock = mock(Foo.class, Mockito.RETURNS_SMART_NULLS);
      *   Foo mockTwo = mock(Foo.class, new YourOwnReturnValues()); 
      * </pre>
      * 
      * <p>See examples in javadoc for {@link Mockito} class</p>
      * 
      * @param classToMock class or interface to mock
      * @param returnValues default return values for unstubbed methods
      *
      * @return mock object
      */
     @Deprecated
     public static <T> T mock(Class<T> classToMock, ReturnValues returnValues) {
         return mock(classToMock, withSettings().defaultAnswer(new AnswerReturnValuesAdapter(returnValues)));
     }
     
     /**
      * Creates mock with a specified strategy for its answers to interactions. 
      * It's quite advanced feature and typically you don't need it to write decent tests.
      * However it can be helpful when working with legacy systems.
      * <p>
      * It is the default answer so it will be used <b>only when you don't</b> stub the method call.
      *
      * <pre>
      *   Foo mock = mock(Foo.class, RETURNS_SMART_NULLS);
      *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer()); 
      * </pre>
      * 
      * <p>See examples in javadoc for {@link Mockito} class</p>
      * 
      * @param classToMock class or interface to mock
      * @param defaultAnswer default answer for unstubbed methods
      *
      * @return mock object
      */
     public static <T> T mock(Class<T> classToMock, Answer defaultAnswer) {
         return mock(classToMock, withSettings().defaultAnswer(defaultAnswer));
     }
     
     /**
      * Creates a mock with some non-standard settings.
      * <p>
      * The number of configuration points for a mock grows 
      * so we need a fluent way to introduce new configuration without adding more and more overloaded Mockito.mock() methods. 
      * Hence {@link MockSettings}.
      * <pre>
      *   Listener mock = mock(Listener.class, withSettings()
      *     .name(""firstListner"").defaultBehavior(RETURNS_SMART_NULLS));
      *   );  
      * </pre>
      * <b>Use it carefully and occasionally</b>. What might be reason your test needs non-standard mocks? 
      * Is the code under test so complicated that it requires non-standard mocks? 
      * Wouldn't you prefer to refactor the code under test so it is testable in a simple way?
      * <p>
      * See also {@link Mockito#withSettings()}
      * <p>
      * See examples in javadoc for {@link Mockito} class
      * 
      * @param classToMock class or interface to mock
      * @param mockSettings additional mock settings
      * @return mock object
      */
     public static <T> T mock(Class<T> classToMock, MockSettings mockSettings) {
+        return MOCKITO_CORE.mock(classToMock, mockSettings, true);
     }
     
     /**
      * Creates a spy of the real object. The spy calls <b>real</b> methods unless they are stubbed.
      * <p>
      * Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.
      * <p>
      * As usual you are going to read <b>the partial mock warning</b>:
      * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.
      * How does partial mock fit into this paradigm? Well, it just doesn't... 
      * Partial mock usually means that the complexity has been moved to a different method on the same object.
      * In most cases, this is not the way you want to design your application.
      * <p>
      * However, there are rare cases when partial mocks come handy: 
      * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
      * However, I wouldn't use partial mocks for new, test-driven & well-designed code.
      * <p>
      * Example:
      * 
      * <pre>
      *   List list = new LinkedList();
      *   List spy = spy(list);
      * 
      *   //optionally, you can stub out some methods:
      *   when(spy.size()).thenReturn(100);
      * 
      *   //using the spy calls <b>real</b> methods
      *   spy.add(""one"");
      *   spy.add(""two"");
      * 
      *   //prints ""one"" - the first element of a list
      *   System.out.println(spy.get(0));
      * 
      *   //size() method was stubbed - 100 is printed
      *   System.out.println(spy.size());
      * 
      *   //optionally, you can verify
      *   verify(spy).add(""one"");
      *   verify(spy).add(""two"");
      * </pre>
      * 
      * <h4>Important gotcha on spying real objects!</h4>
      * 
      * 1. Sometimes it's impossible to use {@link Mockito#when(Object)} for stubbing spies. Example:
      * 
      * <pre>
      *   List list = new LinkedList();
      *   List spy = spy(list);
      *   
      *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)
      *   when(spy.get(0)).thenReturn(""foo"");
      *   
      *   //You have to use doReturn() for stubbing
      *   doReturn(""foo"").when(spy).get(0);
      * </pre>
      * 
      * 2. Watch out for final methods. 
      * Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.
      * What will happen is the real method will be called *on mock* but *not on the real instance* you passed to the spy() method.
      * Typically you may get a NullPointerException because mock instances don't have fields initiated.
      * 
      * <p>
      * See examples in javadoc for {@link Mockito} class
      * 
      * @param object
      *            to spy on
      * @return a spy of the real object
      */
     public static <T> T spy(T object) {
         return MOCKITO_CORE.mock((Class<T>) object.getClass(), withSettings()
                 .spiedInstance(object)
+                .defaultAnswer(CALLS_REAL_METHODS), true); 
     }
 
     /**
      * <pre>
      *   //Instead of:
      *   stub(mock.count()).toReturn(10);
      * 
      *   //Please do:
      *   when(mock.count()).thenReturn(10);
      * </pre> 
      * 
      * Many users found stub() confusing therefore stub() has been deprecated in favor of {@link Mockito#when(Object)} 
      * <p>
      * How to fix deprecation warnings? Typically it's just few minutes of search & replace job:
      * <pre>
      *   Mockito.stub;  <i>replace with:</i>  Mockito.when;
      *   stub(          <i>replace with:</i>  when(
      *   .toReturn(     <i>replace with:</i>  .thenReturn(
      *   .toThrow(      <i>replace with:</i>  .thenThrow(
      *   .toAnswer(     <i>replace with:</i>  .thenAnswer(
      * </pre>
      * If you're an existing user then sorry for making your code littered with deprecation warnings. 
/src/org/mockito/internal/MockitoCore.java @@ -1,38 +1,39 @@
 /*
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
 package org.mockito.internal;
 
 import org.mockito.InOrder;
 import org.mockito.MockSettings;
 import org.mockito.exceptions.Reporter;
 import org.mockito.exceptions.misusing.NotAMockException;
 import org.mockito.internal.creation.MockSettingsImpl;
 import org.mockito.internal.invocation.Invocation;
 import org.mockito.internal.progress.IOngoingStubbing;
 import org.mockito.internal.progress.MockingProgress;
 import org.mockito.internal.progress.ThreadSafeMockingProgress;
 import org.mockito.internal.stubbing.OngoingStubbingImpl;
 import org.mockito.internal.stubbing.StubberImpl;
 import org.mockito.internal.util.MockUtil;
 import org.mockito.internal.verification.api.VerificationMode;
 import org.mockito.stubbing.*;
 
 import java.util.Arrays;
 import java.util.List;
 
 @SuppressWarnings(""unchecked"")
 public class MockitoCore {
 
     private final Reporter reporter = new Reporter();
     private final MockUtil mockUtil = new MockUtil();
     private final MockingProgress mockingProgress = new ThreadSafeMockingProgress();
     
+    public <T> T mock(Class<T> classToMock, MockSettings mockSettings, boolean shouldResetOngoingStubbing) {
         mockingProgress.validateState();
+        if (shouldResetOngoingStubbing) {
             mockingProgress.resetOngoingStubbing();
+        }
         return mockUtil.createMock(classToMock, (MockSettingsImpl) mockSettings);
     }
     
"
343,"junit.framework.AssertionFailedError","/src/org/mockito/internal/configuration/injection/FinalMockCandidateFilter.java","@@ -1,6 +1,7 @@
 package org.mockito.internal.configuration.injection;
 
 import org.mockito.exceptions.base.MockitoException;
+import org.mockito.internal.util.reflection.BeanPropertySetter;
 import org.mockito.internal.util.reflection.FieldSetter;
 
 import java.lang.reflect.Field;
@@ -22,7 +23,9 @@ public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Fie
             return new OngoingInjecter() {
                 public boolean thenInject() {
                     try {
+                        if (!new BeanPropertySetter(fieldInstance, field).set(matchingMock)) {
                             new FieldSetter(fieldInstance, field).set(matchingMock);
+                        }
                     } catch (Exception e) {
                         throw new MockitoException(""Problems injecting dependency in "" + field.getName(), e);
                     }
","@@ -1,6 +1,7 @@
 package org.mockito.internal.configuration.injection;
 
 import org.mockito.exceptions.base.MockitoException;
+import org.mockito.internal.util.reflection.BeanPropertySetter;
 import org.mockito.internal.util.reflection.FieldSetter;
 
 import java.lang.reflect.Field;
@@ -22,7 +23,9 @@ public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Fie
             return new OngoingInjecter() {
                 public boolean thenInject() {
                     try {
+                        if (!new BeanPropertySetter(fieldInstance, field).set(matchingMock)) {
                             new FieldSetter(fieldInstance, field).set(matchingMock);
+                        }
                     } catch (Exception e) {
                         throw new MockitoException(""Problems injecting dependency in "" + field.getName(), e);
                     }
"
344,"junit.framework.AssertionFailedError","/src/org/mockito/internal/MockHandler.java","@@ -17,6 +17,7 @@
 import org.mockito.internal.stubbing.OngoingStubbingImpl;
 import org.mockito.internal.stubbing.StubbedInvocationMatcher;
 import org.mockito.internal.stubbing.VoidMethodStubbableImpl;
+import org.mockito.internal.verification.MockAwareVerificationMode;
 import org.mockito.internal.verification.VerificationDataImpl;
 import org.mockito.stubbing.Answer;
 import org.mockito.stubbing.VoidMethodStubbable;
@@ -73,9 +74,11 @@ public Object handle(Invocation invocation) throws Throwable {
         if (verificationMode != null) {
             //We need to check if verification was started on the correct mock 
             // - see VerifyingWithAnExtraCallToADifferentMockTest
+            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {
                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl.getInvocations(), invocationMatcher);            
                 verificationMode.verify(data);
                 return null;
+            }
         }
         
         invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);
/src/org/mockito/internal/MockitoCore.java @@ -20,6 +20,7 @@
 import org.mockito.internal.stubbing.OngoingStubbingImpl;
 import org.mockito.internal.stubbing.StubberImpl;
 import org.mockito.internal.util.MockUtil;
+import org.mockito.internal.verification.MockAwareVerificationMode;
 import org.mockito.internal.verification.VerificationDataImpl;
 import org.mockito.internal.verification.VerificationModeFactory;
 import org.mockito.internal.verification.api.InOrderContext;
@@ -70,7 +71,7 @@ public IOngoingStubbing stub() {
         } else if (!mockUtil.isMock(mock)) {
             reporter.notAMockPassedToVerify();
         }
+        mockingProgress.verificationStarted(new MockAwareVerificationMode(mock, mode));
         return mock;
     }
     
","@@ -17,6 +17,7 @@
 import org.mockito.internal.stubbing.OngoingStubbingImpl;
 import org.mockito.internal.stubbing.StubbedInvocationMatcher;
 import org.mockito.internal.stubbing.VoidMethodStubbableImpl;
+import org.mockito.internal.verification.MockAwareVerificationMode;
 import org.mockito.internal.verification.VerificationDataImpl;
 import org.mockito.stubbing.Answer;
 import org.mockito.stubbing.VoidMethodStubbable;
@@ -73,9 +74,11 @@ public Object handle(Invocation invocation) throws Throwable {
         if (verificationMode != null) {
             //We need to check if verification was started on the correct mock 
             // - see VerifyingWithAnExtraCallToADifferentMockTest
+            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {
                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl.getInvocations(), invocationMatcher);            
                 verificationMode.verify(data);
                 return null;
+            }
         }
         
         invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);
/src/org/mockito/internal/MockitoCore.java @@ -20,6 +20,7 @@
 import org.mockito.internal.stubbing.OngoingStubbingImpl;
 import org.mockito.internal.stubbing.StubberImpl;
 import org.mockito.internal.util.MockUtil;
+import org.mockito.internal.verification.MockAwareVerificationMode;
 import org.mockito.internal.verification.VerificationDataImpl;
 import org.mockito.internal.verification.VerificationModeFactory;
 import org.mockito.internal.verification.api.InOrderContext;
@@ -70,7 +71,7 @@ public IOngoingStubbing stub() {
         } else if (!mockUtil.isMock(mock)) {
             reporter.notAMockPassedToVerify();
         }
+        mockingProgress.verificationStarted(new MockAwareVerificationMode(mock, mode));
         return mock;
     }
     
"
345,"java.lang.ClassCastException","/src/org/mockito/internal/util/reflection/GenericMaster.java","@@ -17,8 +17,12 @@ public Class getGenericType(Field field) {
         Type generic = field.getGenericType();
         if (generic != null && generic instanceof ParameterizedType) {
             Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];
+            if (actual instanceof Class) {
                 return (Class) actual;
+            } else if (actual instanceof ParameterizedType) {
                 //in case of nested generics we don't go deep
+                return (Class) ((ParameterizedType) actual).getRawType();
+            }
         }
         
         return Object.class;
","@@ -17,8 +17,12 @@ public Class getGenericType(Field field) {
         Type generic = field.getGenericType();
         if (generic != null && generic instanceof ParameterizedType) {
             Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];
+            if (actual instanceof Class) {
                 return (Class) actual;
+            } else if (actual instanceof ParameterizedType) {
                 //in case of nested generics we don't go deep
+                return (Class) ((ParameterizedType) actual).getRawType();
+            }
         }
         
         return Object.class;
"
346,"junit.framework.AssertionFailedError","/src/org/mockito/internal/MockHandler.java","@@ -74,12 +74,14 @@ public Object handle(Invocation invocation) throws Throwable {
         if (verificationMode != null) {
             //We need to check if verification was started on the correct mock 
             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
+            if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                
                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            
                 verificationMode.verify(data);
                 return null;
+            } else {
                 // this means there is an invocation on a different mock. Re-adding verification mode 
                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
+                mockingProgress.verificationStarted(verificationMode);
             }
         }
         
","@@ -74,12 +74,14 @@ public Object handle(Invocation invocation) throws Throwable {
         if (verificationMode != null) {
             //We need to check if verification was started on the correct mock 
             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
+            if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                
                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            
                 verificationMode.verify(data);
                 return null;
+            } else {
                 // this means there is an invocation on a different mock. Re-adding verification mode 
                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
+                mockingProgress.verificationStarted(verificationMode);
             }
         }
         
"
347,"java.io.NotSerializableException","/src/org/mockito/internal/creation/MockSettingsImpl.java","@@ -17,9 +17,11 @@
     private Object spiedInstance;
     private Answer<Object> defaultAnswer;
     private MockName mockName;
+    private boolean serializable;
 
     public MockSettings serializable() {
+        this.serializable = true;
+        return this;
     }
 
     public MockSettings extraInterfaces(Class<?>... extraInterfaces) {
@@ -71,7 +73,7 @@ public MockSettings defaultAnswer(Answer defaultAnswer) {
     }
 
     public boolean isSerializable() {
+        return serializable;
     }
 
     public void initiateMockName(Class classToMock) {
/src/org/mockito/internal/util/MockUtil.java @@ -16,6 +16,7 @@
 import org.mockito.internal.creation.jmock.ClassImposterizer;
 import org.mockito.internal.util.reflection.LenientCopyTool;
 
+import java.io.Serializable;
 
 @SuppressWarnings(""unchecked"")
 public class MockUtil {
@@ -42,7 +43,11 @@ public MockUtil() {
         Class<?>[] interfaces = settings.getExtraInterfaces();
 
         Class<?>[] ancillaryTypes;
+        if (settings.isSerializable()) {
+            ancillaryTypes = interfaces == null ? new Class<?>[] {Serializable.class} : new ArrayUtils().concat(interfaces, Serializable.class);
+        } else {
             ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;
+        }
 
         Object spiedInstance = settings.getSpiedInstance();
         
","@@ -17,9 +17,11 @@
     private Object spiedInstance;
     private Answer<Object> defaultAnswer;
     private MockName mockName;
+    private boolean serializable;
 
     public MockSettings serializable() {
+        this.serializable = true;
+        return this;
     }
 
     public MockSettings extraInterfaces(Class<?>... extraInterfaces) {
@@ -71,7 +73,7 @@ public MockSettings defaultAnswer(Answer defaultAnswer) {
     }
 
     public boolean isSerializable() {
+        return serializable;
     }
 
     public void initiateMockName(Class classToMock) {
/src/org/mockito/internal/util/MockUtil.java @@ -16,6 +16,7 @@
 import org.mockito.internal.creation.jmock.ClassImposterizer;
 import org.mockito.internal.util.reflection.LenientCopyTool;
 
+import java.io.Serializable;
 
 @SuppressWarnings(""unchecked"")
 public class MockUtil {
@@ -42,7 +43,11 @@ public MockUtil() {
         Class<?>[] interfaces = settings.getExtraInterfaces();
 
         Class<?>[] ancillaryTypes;
+        if (settings.isSerializable()) {
+            ancillaryTypes = interfaces == null ? new Class<?>[] {Serializable.class} : new ArrayUtils().concat(interfaces, Serializable.class);
+        } else {
             ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;
+        }
 
         Object spiedInstance = settings.getSpiedInstance();
         
"
348,"java.lang.NullPointerException","/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java","@@ -84,6 +84,8 @@ Object returnValueFor(Class<?> type) {
             return Primitives.defaultValueForPrimitiveOrWrapper(type);
             //new instances are used instead of Collections.emptyList(), etc.
             //to avoid UnsupportedOperationException if code under test modifies returned collection
+        } else if (type == Iterable.class) {
+            return new ArrayList<Object>(0);
         } else if (type == Collection.class) {
             return new LinkedList<Object>();
         } else if (type == Set.class) {
","@@ -84,6 +84,8 @@ Object returnValueFor(Class<?> type) {
             return Primitives.defaultValueForPrimitiveOrWrapper(type);
             //new instances are used instead of Collections.emptyList(), etc.
             //to avoid UnsupportedOperationException if code under test modifies returned collection
+        } else if (type == Iterable.class) {
+            return new ArrayList<Object>(0);
         } else if (type == Collection.class) {
             return new LinkedList<Object>();
         } else if (type == Set.class) {
"
349,"java.lang.RuntimeException","/src/org/mockito/internal/matchers/Equality.java","@@ -10,7 +10,9 @@
 public class Equality {
 
     public static boolean areEqual(Object o1, Object o2) {
+        if (o1 == o2 ) {
+            return true;
+	} else if (o1 == null || o2 == null) {
             return o1 == null && o2 == null;
         } else if (isArray(o1)) {
             return isArray(o2) && areArraysEqual(o1, o2);
","@@ -10,7 +10,9 @@
 public class Equality {
 
     public static boolean areEqual(Object o1, Object o2) {
+        if (o1 == o2 ) {
+            return true;
+	} else if (o1 == null || o2 == null) {
             return o1 == null && o2 == null;
         } else if (isArray(o1)) {
             return isArray(o2) && areArraysEqual(o1, o2);
"
350,"junit.framework.ComparisonFailure","/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java","@@ -29,9 +29,10 @@ public ByteBuddyMockMaker() {
                 settings.getTypeToMock(),
                 settings.getExtraInterfaces()
         );
+        Instantiator instantiator = new InstantiatorProvider().getInstantiator(settings);
         T mockInstance = null;
         try {
+            mockInstance = instantiator.newInstance(mockedProxyType);
             MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;
             mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));
 
@@ -42,7 +43,7 @@ public ByteBuddyMockMaker() {
                     ""  class to mock : "" + describeClass(mockedProxyType),
                     ""  created class : "" + describeClass(settings.getTypeToMock()),
                     ""  proxy instance class : "" + describeClass(mockInstance),
+                    ""  instance creation by : "" + instantiator.getClass().getSimpleName(),
                     """",
                     ""You might experience classloading issues, please ask the mockito mailing-list."",
                     """"
","@@ -29,9 +29,10 @@ public ByteBuddyMockMaker() {
                 settings.getTypeToMock(),
                 settings.getExtraInterfaces()
         );
+        Instantiator instantiator = new InstantiatorProvider().getInstantiator(settings);
         T mockInstance = null;
         try {
+            mockInstance = instantiator.newInstance(mockedProxyType);
             MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;
             mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));
 
@@ -42,7 +43,7 @@ public ByteBuddyMockMaker() {
                     ""  class to mock : "" + describeClass(mockedProxyType),
                     ""  created class : "" + describeClass(settings.getTypeToMock()),
                     ""  proxy instance class : "" + describeClass(mockInstance),
+                    ""  instance creation by : "" + instantiator.getClass().getSimpleName(),
                     """",
                     ""You might experience classloading issues, please ask the mockito mailing-list."",
                     """"
"
351,"junit.framework.AssertionFailedError","/src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java","@@ -111,7 +111,7 @@ private boolean injectMockCandidates(Class<?> awaitingInjectionClazz, Set<Object
     private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) {
         for (Iterator<Field> it = orderedInstanceFields.iterator(); it.hasNext(); ) {
             Field field = it.next();
+            Object injected = mockCandidateFilter.filterCandidate(mocks, field, orderedInstanceFields, instance).thenInject();
             if (injected != null) {
                 injectionOccurred |= true;
                 mocks.remove(injected);
/src/org/mockito/internal/configuration/injection/filter/FinalMockCandidateFilter.java @@ -10,6 +10,7 @@
 
 import java.lang.reflect.Field;
 import java.util.Collection;
+import java.util.List;
 
 /**
  * This node returns an actual injecter which will be either :
@@ -20,7 +21,7 @@
  * </ul>
  */
 public class FinalMockCandidateFilter implements MockCandidateFilter {
+    public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, List<Field> fields, final Object fieldInstance) {
         if(mocks.size() == 1) {
             final Object matchingMock = mocks.iterator().next();
 
/src/org/mockito/internal/configuration/injection/filter/MockCandidateFilter.java @@ -6,13 +6,14 @@
 
 import java.lang.reflect.Field;
 import java.util.Collection;
+import java.util.List;
 
 public interface MockCandidateFilter {
 
     OngoingInjecter filterCandidate(
             Collection<Object> mocks,
             Field fieldToBeInjected,
+            List<Field> fields, Object instance
     );
 
 }
/src/org/mockito/internal/configuration/injection/filter/NameBasedCandidateFilter.java @@ -20,7 +20,7 @@ public NameBasedCandidateFilter(MockCandidateFilter next) {
 	}
 
 	public OngoingInjecter filterCandidate(Collection<Object> mocks,
+			Field field, List<Field> fields, Object fieldInstance) {
 		List<Object> mockNameMatches = new ArrayList<Object>();
 		if (mocks.size() > 1) {
 			for (Object mock : mocks) {
@@ -28,7 +28,7 @@ public OngoingInjecter filterCandidate(Collection<Object> mocks,
 					mockNameMatches.add(mock);
 				}
 			}
+			return next.filterCandidate(mockNameMatches, field, fields,
 					fieldInstance);
 			/*
 			 * In this case we have to check whether we have conflicting naming
@@ -39,7 +39,23 @@ public OngoingInjecter filterCandidate(Collection<Object> mocks,
 			 * whenever we find a field that does match its name with the mock
 			 * name, we should take that field instead.
 			 */
+		} else if (mocks.size() == 1) {
+			String mockName = mockUtil.getMockName(mocks.iterator().next())
+					.toString();
+
+			for (Field otherField : fields) {
+				if (!otherField.equals(field)
+						&& otherField.getType().equals(field.getType())
+						&& otherField.getName().equals(mockName)) {
+
+					return new OngoingInjecter() {
+						public Object thenInject() {
+							return null;
+						}
+					};
+				}
+			}
 		}
+		return next.filterCandidate(mocks, field, fields, fieldInstance);
 	}
 }
/src/org/mockito/internal/configuration/injection/filter/TypeBasedCandidateFilter.java @@ -17,7 +17,7 @@ public TypeBasedCandidateFilter(MockCandidateFilter next) {
         this.next = next;
     }
 
+    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, List<Field> fields, Object fieldInstance) {
         List<Object> mockTypeMatches = new ArrayList<Object>();
         for (Object mock : mocks) {
             if (field.getType().isAssignableFrom(mock.getClass())) {
@@ -25,6 +25,6 @@ public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Ob
             }
         }
 
+        return next.filterCandidate(mockTypeMatches, field, fields, fieldInstance);
     }
 }
","@@ -111,7 +111,7 @@ private boolean injectMockCandidates(Class<?> awaitingInjectionClazz, Set<Object
     private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) {
         for (Iterator<Field> it = orderedInstanceFields.iterator(); it.hasNext(); ) {
             Field field = it.next();
+            Object injected = mockCandidateFilter.filterCandidate(mocks, field, orderedInstanceFields, instance).thenInject();
             if (injected != null) {
                 injectionOccurred |= true;
                 mocks.remove(injected);
/src/org/mockito/internal/configuration/injection/filter/FinalMockCandidateFilter.java @@ -10,6 +10,7 @@
 
 import java.lang.reflect.Field;
 import java.util.Collection;
+import java.util.List;
 
 /**
  * This node returns an actual injecter which will be either :
@@ -20,7 +21,7 @@
  * </ul>
  */
 public class FinalMockCandidateFilter implements MockCandidateFilter {
+    public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, List<Field> fields, final Object fieldInstance) {
         if(mocks.size() == 1) {
             final Object matchingMock = mocks.iterator().next();
 
/src/org/mockito/internal/configuration/injection/filter/MockCandidateFilter.java @@ -6,13 +6,14 @@
 
 import java.lang.reflect.Field;
 import java.util.Collection;
+import java.util.List;
 
 public interface MockCandidateFilter {
 
     OngoingInjecter filterCandidate(
             Collection<Object> mocks,
             Field fieldToBeInjected,
+            List<Field> fields, Object instance
     );
 
 }
/src/org/mockito/internal/configuration/injection/filter/NameBasedCandidateFilter.java @@ -20,7 +20,7 @@ public NameBasedCandidateFilter(MockCandidateFilter next) {
 	}
 
 	public OngoingInjecter filterCandidate(Collection<Object> mocks,
+			Field field, List<Field> fields, Object fieldInstance) {
 		List<Object> mockNameMatches = new ArrayList<Object>();
 		if (mocks.size() > 1) {
 			for (Object mock : mocks) {
@@ -28,7 +28,7 @@ public OngoingInjecter filterCandidate(Collection<Object> mocks,
 					mockNameMatches.add(mock);
 				}
 			}
+			return next.filterCandidate(mockNameMatches, field, fields,
 					fieldInstance);
 			/*
 			 * In this case we have to check whether we have conflicting naming
@@ -39,7 +39,23 @@ public OngoingInjecter filterCandidate(Collection<Object> mocks,
 			 * whenever we find a field that does match its name with the mock
 			 * name, we should take that field instead.
 			 */
+		} else if (mocks.size() == 1) {
+			String mockName = mockUtil.getMockName(mocks.iterator().next())
+					.toString();
+
+			for (Field otherField : fields) {
+				if (!otherField.equals(field)
+						&& otherField.getType().equals(field.getType())
+						&& otherField.getName().equals(mockName)) {
+
+					return new OngoingInjecter() {
+						public Object thenInject() {
+							return null;
+						}
+					};
+				}
+			}
 		}
+		return next.filterCandidate(mocks, field, fields, fieldInstance);
 	}
 }
/src/org/mockito/internal/configuration/injection/filter/TypeBasedCandidateFilter.java @@ -17,7 +17,7 @@ public TypeBasedCandidateFilter(MockCandidateFilter next) {
         this.next = next;
     }
 
+    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, List<Field> fields, Object fieldInstance) {
         List<Object> mockTypeMatches = new ArrayList<Object>();
         for (Object mock : mocks) {
             if (field.getType().isAssignableFrom(mock.getClass())) {
@@ -25,6 +25,6 @@ public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Ob
             }
         }
 
+        return next.filterCandidate(mockTypeMatches, field, fields, fieldInstance);
     }
 }
"
352,"org.mockito.internal.creation.instance.InstantationException","/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java","@@ -14,18 +14,23 @@ public ConstructorInstantiator(Object outerClassInstance) {
         if (outerClassInstance == null) {
             return noArgConstructor(cls);
         }
+        return withParams(cls, outerClassInstance);
     }
 
+    private static <T> T withParams(Class<T> cls, Object... params) {
         try {
             //this is kind of overengineered because we don't need to support more params
             //however, I know we will be needing it :)
+            for (Constructor<?> constructor : cls.getDeclaredConstructors()) {
+                Class<?>[] types = constructor.getParameterTypes();
+                if (paramsMatch(types, params)) {
+                    return (T) constructor.newInstance(params);
+                }
+            }
         } catch (Exception e) {
             throw paramsException(cls, e);
         }
+        throw paramsException(cls, null);
     }
 
     private static <T> InstantationException paramsException(Class<T> cls, Exception e) {
@@ -33,6 +38,17 @@ public ConstructorInstantiator(Object outerClassInstance) {
                 + cls.getSimpleName() + ""'.\nPlease ensure that the outer instance has correct type and that the target class has parameter-less constructor."", e);
     }
 
+    private static boolean paramsMatch(Class<?>[] types, Object[] params) {
+        if (params.length != types.length) {
+            return false;
+        }
+        for (int i = 0; i < params.length; i++) {
+            if (!types[i].isInstance(params[i])) {
+                return false;
+            }
+        }
+        return true;
+    }
 
     private static <T> T noArgConstructor(Class<T> cls) {
         try {
","@@ -14,18 +14,23 @@ public ConstructorInstantiator(Object outerClassInstance) {
         if (outerClassInstance == null) {
             return noArgConstructor(cls);
         }
+        return withParams(cls, outerClassInstance);
     }
 
+    private static <T> T withParams(Class<T> cls, Object... params) {
         try {
             //this is kind of overengineered because we don't need to support more params
             //however, I know we will be needing it :)
+            for (Constructor<?> constructor : cls.getDeclaredConstructors()) {
+                Class<?>[] types = constructor.getParameterTypes();
+                if (paramsMatch(types, params)) {
+                    return (T) constructor.newInstance(params);
+                }
+            }
         } catch (Exception e) {
             throw paramsException(cls, e);
         }
+        throw paramsException(cls, null);
     }
 
     private static <T> InstantationException paramsException(Class<T> cls, Exception e) {
@@ -33,6 +38,17 @@ public ConstructorInstantiator(Object outerClassInstance) {
                 + cls.getSimpleName() + ""'.\nPlease ensure that the outer instance has correct type and that the target class has parameter-less constructor."", e);
     }
 
+    private static boolean paramsMatch(Class<?>[] types, Object[] params) {
+        if (params.length != types.length) {
+            return false;
+        }
+        for (int i = 0; i < params.length; i++) {
+            if (!types[i].isInstance(params[i])) {
+                return false;
+            }
+        }
+        return true;
+    }
 
     private static <T> T noArgConstructor(Class<T> cls) {
         try {
"
353,"java.io.NotSerializableException","/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java","@@ -41,14 +41,16 @@
     
     private static final long serialVersionUID = -7105341425736035847L;
 
+    private transient MockitoCore mockitoCore;
+    private transient ReturnsEmptyValues delegate;
 
     public Object answer(InvocationOnMock invocation) throws Throwable {
         GenericMetadataSupport returnTypeGenericMetadata =
                 actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());
 
         Class<?> rawType = returnTypeGenericMetadata.rawType();
+        instantiateMockitoCoreIfNeeded();
+        instantiateDelegateIfNeeded();
         if (!mockitoCore.isTypeMockable(rawType)) {
             return delegate.returnValueFor(rawType);
         }
@@ -56,7 +58,17 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
         return getMock(invocation, returnTypeGenericMetadata);
     }
 
+    private synchronized void instantiateMockitoCoreIfNeeded() {
+        if (mockitoCore == null) {
+            mockitoCore = new MockitoCore();
+        }
+    }
 
+    private synchronized void instantiateDelegateIfNeeded() {
+        if (delegate == null) {
+            delegate = new ReturnsEmptyValues();
+        }
+    }
 
     private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {
     	InternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());
@@ -97,6 +109,7 @@ private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericM
                 : withSettings();
 
         return mockSettings
+		        .serializable()
                 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));
     }
 
@@ -111,7 +124,7 @@ protected GenericMetadataSupport actualParameterizedType(Object mock) {
 
     private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {
 
+        container.addAnswer(new SerializableAnswer() {
             public Object answer(InvocationOnMock invocation) throws Throwable {
                 return mock;
             }
@@ -120,7 +133,9 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
         return mock;
     }
 	
+	abstract class SerializableAnswer implements Answer<Object>, Serializable {
 		
+	}
 	
 
     protected GenericMetadataSupport actualParameterizedType(Object mock) {
","@@ -41,14 +41,16 @@
     
     private static final long serialVersionUID = -7105341425736035847L;
 
+    private transient MockitoCore mockitoCore;
+    private transient ReturnsEmptyValues delegate;
 
     public Object answer(InvocationOnMock invocation) throws Throwable {
         GenericMetadataSupport returnTypeGenericMetadata =
                 actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());
 
         Class<?> rawType = returnTypeGenericMetadata.rawType();
+        instantiateMockitoCoreIfNeeded();
+        instantiateDelegateIfNeeded();
         if (!mockitoCore.isTypeMockable(rawType)) {
             return delegate.returnValueFor(rawType);
         }
@@ -56,7 +58,17 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
         return getMock(invocation, returnTypeGenericMetadata);
     }
 
+    private synchronized void instantiateMockitoCoreIfNeeded() {
+        if (mockitoCore == null) {
+            mockitoCore = new MockitoCore();
+        }
+    }
 
+    private synchronized void instantiateDelegateIfNeeded() {
+        if (delegate == null) {
+            delegate = new ReturnsEmptyValues();
+        }
+    }
 
     private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {
     	InternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());
@@ -97,6 +109,7 @@ private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericM
                 : withSettings();
 
         return mockSettings
+		        .serializable()
                 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));
     }
 
@@ -111,7 +124,7 @@ protected GenericMetadataSupport actualParameterizedType(Object mock) {
 
     private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {
 
+        container.addAnswer(new SerializableAnswer() {
             public Object answer(InvocationOnMock invocation) throws Throwable {
                 return mock;
             }
@@ -120,7 +133,9 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
         return mock;
     }
 	
+	abstract class SerializableAnswer implements Answer<Object>, Serializable {
 		
+	}
 	
 
     protected GenericMetadataSupport actualParameterizedType(Object mock) {
"
354,"junit.framework.AssertionFailedError","/src/org/mockito/internal/configuration/DefaultInjectionEngine.java","@@ -90,7 +90,8 @@ public void injectMocksOnFields(Set<Field> injectMocksFields, Set<Object> mocks,
 
     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {
         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {
+            Object injected = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();
+            mocks.remove(injected);
         }
     }
 
","@@ -90,7 +90,8 @@ public void injectMocksOnFields(Set<Field> injectMocksFields, Set<Object> mocks,
 
     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {
         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {
+            Object injected = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();
+            mocks.remove(injected);
         }
     }
 
"
355,"junit.framework.AssertionFailedError","/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java","@@ -73,7 +73,7 @@ public Object answer(InvocationOnMock invocation) {
             //see issue 184.
             //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).
             //Only for compareTo() method by the Comparable interface
+            return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;
         }
         
         Class<?> returnType = invocation.getMethod().getReturnType();
","@@ -73,7 +73,7 @@ public Object answer(InvocationOnMock invocation) {
             //see issue 184.
             //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).
             //Only for compareTo() method by the Comparable interface
+            return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;
         }
         
         Class<?> returnType = invocation.getMethod().getReturnType();
"
356,"java.lang.Exception","/src/org/mockito/internal/matchers/Same.java","@@ -26,7 +26,7 @@ public boolean matches(Object actual) {
     public void describeTo(Description description) {
         description.appendText(""same("");
         appendQuoting(description);
+        description.appendText(wanted == null ? ""null"" : wanted.toString());
         appendQuoting(description);
         description.appendText("")"");
     }
","@@ -26,7 +26,7 @@ public boolean matches(Object actual) {
     public void describeTo(Description description) {
         description.appendText(""same("");
         appendQuoting(description);
+        description.appendText(wanted == null ? ""null"" : wanted.toString());
         appendQuoting(description);
         description.appendText("")"");
     }
"
357,"java.lang.ClassCastException","/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java","@@ -1,85 +1,108 @@
 /*
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
 package org.mockito.internal.stubbing.defaultanswers;
 
+import org.mockito.MockSettings;
 import org.mockito.internal.InternalMockHandler;
 import org.mockito.internal.creation.settings.CreationSettings;
 import org.mockito.internal.stubbing.InvocationContainerImpl;
 import org.mockito.internal.stubbing.StubbedInvocationMatcher;
 import org.mockito.internal.util.MockCreationValidator;
 import org.mockito.internal.util.MockUtil;
 import org.mockito.internal.util.reflection.GenericMetadataSupport;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 
 import java.io.Serializable;
 
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.withSettings;
 
 /**
  * Returning deep stub implementation.
  *
  * Will return previously created mock if the invocation matches.
  *
  * <p>Supports nested generic information, with this answer you can write code like this :
  *
  * <pre class=""code""><code class=""java"">
  *     interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; {}
  *
  *     GenericsNest&lt;?&gt; mock = mock(GenericsNest.class, new ReturnsGenericDeepStubs());
  *     Number number = mock.entrySet().iterator().next().getValue().iterator().next();
  * </code></pre>
  * </p>
  *
  * @see org.mockito.Mockito#RETURNS_DEEP_STUBS
  * @see org.mockito.Answers#RETURNS_DEEP_STUBS
  */
 public class ReturnsDeepStubs implements Answer<Object>, Serializable {
     
     private static final long serialVersionUID = -7105341425736035847L;
 
     private ReturnsEmptyValues delegate = new ReturnsEmptyValues();
 
     public Object answer(InvocationOnMock invocation) throws Throwable {
         GenericMetadataSupport returnTypeGenericMetadata =
                 actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());
 
         Class<?> rawType = returnTypeGenericMetadata.rawType();
         if (!new MockCreationValidator().isTypeMockable(rawType)) {
             return delegate.returnValueFor(rawType);
         }
 
+        return getMock(invocation, returnTypeGenericMetadata);
     }
 
+    private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {
     	InternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());
     	InvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();
 
         // matches invocation for verification
         for (StubbedInvocationMatcher stubbedInvocationMatcher : container.getStubbedInvocations()) {
     		if(container.getInvocationForStubbing().matches(stubbedInvocationMatcher.getInvocation())) {
     			return stubbedInvocationMatcher.answer(invocation);
     		}
 		}
 
         // deep stub
+        return recordDeepStubMock(createNewDeepStubMock(returnTypeGenericMetadata), container);
     }
 
     /**
      * Creates a mock using the Generics Metadata.
      *
      * @param returnTypeGenericMetadata The metadata to use to create the new mock.
      * @return The mock
      */
+    private Object createNewDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {
+        return mock(
+                returnTypeGenericMetadata.rawType(),
+                withSettingsUsing(returnTypeGenericMetadata)
+        );
+    }
 
+    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) {
+        MockSettings mockSettings =
+                returnTypeGenericMetadata.rawExtraInterfaces().length > 0 ?
+                withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())
+                : withSettings();
 
+        return mockSettings
+                .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));
+    }
 
+    private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {
+        return new ReturnsDeepStubs() {
+            @Override
+            protected GenericMetadataSupport actualParameterizedType(Object mock) {
+                return returnTypeGenericMetadata;
+            }
+        };
+    }
 
+    private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {
 
         container.addAnswer(new Answer<Object>() {
","@@ -1,85 +1,108 @@
 /*
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
 package org.mockito.internal.stubbing.defaultanswers;
 
+import org.mockito.MockSettings;
 import org.mockito.internal.InternalMockHandler;
 import org.mockito.internal.creation.settings.CreationSettings;
 import org.mockito.internal.stubbing.InvocationContainerImpl;
 import org.mockito.internal.stubbing.StubbedInvocationMatcher;
 import org.mockito.internal.util.MockCreationValidator;
 import org.mockito.internal.util.MockUtil;
 import org.mockito.internal.util.reflection.GenericMetadataSupport;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 
 import java.io.Serializable;
 
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.withSettings;
 
 /**
  * Returning deep stub implementation.
  *
  * Will return previously created mock if the invocation matches.
  *
  * <p>Supports nested generic information, with this answer you can write code like this :
  *
  * <pre class=""code""><code class=""java"">
  *     interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; {}
  *
  *     GenericsNest&lt;?&gt; mock = mock(GenericsNest.class, new ReturnsGenericDeepStubs());
  *     Number number = mock.entrySet().iterator().next().getValue().iterator().next();
  * </code></pre>
  * </p>
  *
  * @see org.mockito.Mockito#RETURNS_DEEP_STUBS
  * @see org.mockito.Answers#RETURNS_DEEP_STUBS
  */
 public class ReturnsDeepStubs implements Answer<Object>, Serializable {
     
     private static final long serialVersionUID = -7105341425736035847L;
 
     private ReturnsEmptyValues delegate = new ReturnsEmptyValues();
 
     public Object answer(InvocationOnMock invocation) throws Throwable {
         GenericMetadataSupport returnTypeGenericMetadata =
                 actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());
 
         Class<?> rawType = returnTypeGenericMetadata.rawType();
         if (!new MockCreationValidator().isTypeMockable(rawType)) {
             return delegate.returnValueFor(rawType);
         }
 
+        return getMock(invocation, returnTypeGenericMetadata);
     }
 
+    private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {
     	InternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());
     	InvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();
 
         // matches invocation for verification
         for (StubbedInvocationMatcher stubbedInvocationMatcher : container.getStubbedInvocations()) {
     		if(container.getInvocationForStubbing().matches(stubbedInvocationMatcher.getInvocation())) {
     			return stubbedInvocationMatcher.answer(invocation);
     		}
 		}
 
         // deep stub
+        return recordDeepStubMock(createNewDeepStubMock(returnTypeGenericMetadata), container);
     }
 
     /**
      * Creates a mock using the Generics Metadata.
      *
      * @param returnTypeGenericMetadata The metadata to use to create the new mock.
      * @return The mock
      */
+    private Object createNewDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {
+        return mock(
+                returnTypeGenericMetadata.rawType(),
+                withSettingsUsing(returnTypeGenericMetadata)
+        );
+    }
 
+    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) {
+        MockSettings mockSettings =
+                returnTypeGenericMetadata.rawExtraInterfaces().length > 0 ?
+                withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())
+                : withSettings();
 
+        return mockSettings
+                .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));
+    }
 
+    private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {
+        return new ReturnsDeepStubs() {
+            @Override
+            protected GenericMetadataSupport actualParameterizedType(Object mock) {
+                return returnTypeGenericMetadata;
+            }
+        };
+    }
 
+    private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {
 
         container.addAnswer(new Answer<Object>() {
"
358,"junit.framework.AssertionFailedError","/src/org/mockito/internal/util/MockUtil.java","@@ -61,8 +61,7 @@ public MockUtil() {
 
     public <T> void resetMock(T mock) {
         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);
+        MethodInterceptorFilter newFilter = newMethodInterceptorFilter(oldMockHandler.getMockSettings());
         ((Factory) mock).setCallback(0, newFilter);
     }
 
","@@ -61,8 +61,7 @@ public MockUtil() {
 
     public <T> void resetMock(T mock) {
         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);
+        MethodInterceptorFilter newFilter = newMethodInterceptorFilter(oldMockHandler.getMockSettings());
         ((Factory) mock).setCallback(0, newFilter);
     }
 
"
359,"java.lang.ClassCastException","/src/org/mockito/internal/util/Primitives.java","@@ -63,6 +63,6 @@ public static boolean isPrimitiveWrapper(Class<?> type) {
         primitiveValues.put(int.class, 0);
         primitiveValues.put(long.class, 0L);
         primitiveValues.put(float.class, 0F);
+        primitiveValues.put(double.class, 0D);
     }
 }
\ No newline at end of file
","@@ -63,6 +63,6 @@ public static boolean isPrimitiveWrapper(Class<?> type) {
         primitiveValues.put(int.class, 0);
         primitiveValues.put(long.class, 0L);
         primitiveValues.put(float.class, 0F);
+        primitiveValues.put(double.class, 0D);
     }
 }
\ No newline at end of file
"
360,"junit.framework.AssertionFailedError","/src/org/mockito/internal/configuration/SpyAnnotationEngine.java","@@ -16,6 +16,7 @@
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.util.MockUtil;
 
+import static org.mockito.Mockito.withSettings;
 
 @SuppressWarnings({""unchecked""})
 public class SpyAnnotationEngine implements AnnotationEngine {
@@ -46,7 +47,10 @@ public void process(Class<?> context, Object testClass) {
                         // instance has been spied earlier
                         Mockito.reset(instance);
                     } else {
+                        field.set(testClass, Mockito.mock(instance.getClass(), withSettings()
+                                .spiedInstance(instance)
+                                .defaultAnswer(Mockito.CALLS_REAL_METHODS)
+                                .name(field.getName())));
                     }
                 } catch (IllegalAccessException e) {
                     throw new MockitoException(""Problems initiating spied field "" + field.getName(), e);
","@@ -16,6 +16,7 @@
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.util.MockUtil;
 
+import static org.mockito.Mockito.withSettings;
 
 @SuppressWarnings({""unchecked""})
 public class SpyAnnotationEngine implements AnnotationEngine {
@@ -46,7 +47,10 @@ public void process(Class<?> context, Object testClass) {
                         // instance has been spied earlier
                         Mockito.reset(instance);
                     } else {
+                        field.set(testClass, Mockito.mock(instance.getClass(), withSettings()
+                                .spiedInstance(instance)
+                                .defaultAnswer(Mockito.CALLS_REAL_METHODS)
+                                .name(field.getName())));
                     }
                 } catch (IllegalAccessException e) {
                     throw new MockitoException(""Problems initiating spied field "" + field.getName(), e);
"
361,"junit.framework.ComparisonFailure","/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java","@@ -6,6 +6,7 @@
 
 import java.io.Serializable;
 import java.lang.reflect.Method;
+import java.util.Arrays;
 
 import org.mockito.Mockito;
 import org.mockito.cglib.proxy.MethodInterceptor;
@@ -57,7 +58,8 @@ public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr
         }
 
 		private String formatMethodCall() {
+			String args = Arrays.toString(invocation.getArguments());
+			return invocation.getMethod().getName() + ""("" + args.substring(1, args.length() - 1) +	"")"";
 		}
     }
 
","@@ -6,6 +6,7 @@
 
 import java.io.Serializable;
 import java.lang.reflect.Method;
+import java.util.Arrays;
 
 import org.mockito.Mockito;
 import org.mockito.cglib.proxy.MethodInterceptor;
@@ -57,7 +58,8 @@ public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr
         }
 
 		private String formatMethodCall() {
+			String args = Arrays.toString(invocation.getArguments());
+			return invocation.getMethod().getName() + ""("" + args.substring(1, args.length() - 1) +	"")"";
 		}
     }
 
"
362,"java.lang.ArrayIndexOutOfBoundsException","/src/org/mockito/internal/invocation/InvocationMatcher.java","@@ -103,7 +103,7 @@ public String toString(PrintSettings printSettings) {
     public void captureArgumentsFrom(Invocation i) {
         int k = 0;
         for (Matcher m : matchers) {
+            if (m instanceof CapturesArguments && i.getArguments().length > k) {
                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);
             }
             k++;
","@@ -103,7 +103,7 @@ public String toString(PrintSettings printSettings) {
     public void captureArgumentsFrom(Invocation i) {
         int k = 0;
         for (Matcher m : matchers) {
+            if (m instanceof CapturesArguments && i.getArguments().length > k) {
                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);
             }
             k++;
"
363,"java.lang.NullPointerException","/src/org/mockito/internal/invocation/Invocation.java","@@ -8,6 +8,7 @@
 
 import org.hamcrest.Matcher;
 import org.mockito.exceptions.PrintableInvocation;
+import org.mockito.exceptions.Reporter;
 import org.mockito.internal.debugging.Location;
 import org.mockito.internal.invocation.realmethod.RealMethod;
 import org.mockito.internal.matchers.*;
@@ -199,6 +200,9 @@ public int getArgumentsCount() {
     }
 
     public Object callRealMethod() throws Throwable {
+        if (this.getMethod().getDeclaringClass().isInterface()) {
+            new Reporter().cannotCallRealMethodOnInterface();
+        }
         return realMethod.invoke(mock, rawArguments);
     }
 
","@@ -8,6 +8,7 @@
 
 import org.hamcrest.Matcher;
 import org.mockito.exceptions.PrintableInvocation;
+import org.mockito.exceptions.Reporter;
 import org.mockito.internal.debugging.Location;
 import org.mockito.internal.invocation.realmethod.RealMethod;
 import org.mockito.internal.matchers.*;
@@ -199,6 +200,9 @@ public int getArgumentsCount() {
     }
 
     public Object callRealMethod() throws Throwable {
+        if (this.getMethod().getDeclaringClass().isInterface()) {
+            new Reporter().cannotCallRealMethodOnInterface();
+        }
         return realMethod.invoke(mock, rawArguments);
     }
 
"
364,"junit.framework.AssertionFailedError","/src/org/mockito/internal/invocation/InvocationMatcher.java","@@ -95,8 +95,19 @@ public boolean hasSameMethod(Invocation candidate) {
         Method m1 = invocation.getMethod();
         Method m2 = candidate.getMethod();
         
+        if (m1.getName() != null && m1.getName().equals(m2.getName())) {
         	/* Avoid unnecessary cloning */
+        	Class[] params1 = m1.getParameterTypes();
+        	Class[] params2 = m2.getParameterTypes();
+        	if (params1.length == params2.length) {
+        	    for (int i = 0; i < params1.length; i++) {
+        		if (params1[i] != params2[i])
+        		    return false;
+        	    }
+        	    return true;
+        	}
+        }
+        return false;
     }
     
     public Location getLocation() {
","@@ -95,8 +95,19 @@ public boolean hasSameMethod(Invocation candidate) {
         Method m1 = invocation.getMethod();
         Method m2 = candidate.getMethod();
         
+        if (m1.getName() != null && m1.getName().equals(m2.getName())) {
         	/* Avoid unnecessary cloning */
+        	Class[] params1 = m1.getParameterTypes();
+        	Class[] params2 = m2.getParameterTypes();
+        	if (params1.length == params2.length) {
+        	    for (int i = 0; i < params1.length; i++) {
+        		if (params1[i] != params2[i])
+        		    return false;
+        	    }
+        	    return true;
+        	}
+        }
+        return false;
     }
     
     public Location getLocation() {
"
365,"java.lang.NullPointerException","/src/org/mockito/Matchers.java","@@ -359,7 +359,7 @@ public static Collection anyCollection() {
      * @return <code>null</code>.
      */
     public static <T> T isA(Class<T> clazz) {
+        return reportMatcher(new InstanceOf(clazz)).<T>returnFor(clazz);
     }
 
     /**
@@ -476,7 +476,7 @@ public static short eq(short value) {
      * @return <code>null</code>.
      */
     public static <T> T eq(T value) {
+        return (T) reportMatcher(new Equals(value)).<T>returnFor((Class) value.getClass());
     }  
 
     /**
@@ -513,7 +513,7 @@ public static short eq(short value) {
      * @return <code>null</code>.
      */
     public static <T> T same(T value) {
+        return (T) reportMatcher(new Same(value)).<T>returnFor((Class) value.getClass());
     }
 
     /**
","@@ -359,7 +359,7 @@ public static Collection anyCollection() {
      * @return <code>null</code>.
      */
     public static <T> T isA(Class<T> clazz) {
+        return reportMatcher(new InstanceOf(clazz)).<T>returnFor(clazz);
     }
 
     /**
@@ -476,7 +476,7 @@ public static short eq(short value) {
      * @return <code>null</code>.
      */
     public static <T> T eq(T value) {
+        return (T) reportMatcher(new Equals(value)).<T>returnFor((Class) value.getClass());
     }  
 
     /**
@@ -513,7 +513,7 @@ public static short eq(short value) {
      * @return <code>null</code>.
      */
     public static <T> T same(T value) {
+        return (T) reportMatcher(new Same(value)).<T>returnFor((Class) value.getClass());
     }
 
     /**
"
366,"junit.framework.AssertionFailedError","/src/org/mockito/exceptions/Reporter.java","@@ -435,10 +435,11 @@ public void misplacedArgumentMatcher(Location location) {
                 ));
     }
 
+    public void smartNullPointerException(Object obj, Location location) {
         throw new SmartNullPointerException(join(
                 ""You have a NullPointerException here:"",
                 new Location(),
+                obj,
                 ""Because this method was *not* stubbed correctly:"",
                 location,
                 """"
/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java @@ -53,7 +53,7 @@ public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr
                 return ""SmartNull returned by unstubbed "" + formatMethodCall()  + "" method on mock"";
             }
 
+            new Reporter().smartNullPointerException(obj, location);
             return null;
         }
 
","@@ -435,10 +435,11 @@ public void misplacedArgumentMatcher(Location location) {
                 ));
     }
 
+    public void smartNullPointerException(Object obj, Location location) {
         throw new SmartNullPointerException(join(
                 ""You have a NullPointerException here:"",
                 new Location(),
+                obj,
                 ""Because this method was *not* stubbed correctly:"",
                 location,
                 """"
/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java @@ -53,7 +53,7 @@ public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr
                 return ""SmartNull returned by unstubbed "" + formatMethodCall()  + "" method on mock"";
             }
 
+            new Reporter().smartNullPointerException(obj, location);
             return null;
         }
 
"
367,"java.lang.NullPointerException","/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java","@@ -45,6 +45,6 @@ private boolean safelyMatches(Matcher m, Object arg) {
     }
 
     private boolean toStringEquals(Matcher m, Object arg) {
+        return StringDescription.toString(m).equals(arg == null? ""null"" : arg.toString());
     }
 }
","@@ -45,6 +45,6 @@ private boolean safelyMatches(Matcher m, Object arg) {
     }
 
     private boolean toStringEquals(Matcher m, Object arg) {
+        return StringDescription.toString(m).equals(arg == null? ""null"" : arg.toString());
     }
 }
"
368,"java.lang.UnsupportedOperationException","/src/main/java/org/joda/time/Period.java","@@ -1625,13 +1625,19 @@ public Period normalizedStandard(PeriodType type) {
         int years = getYears();
         int months = getMonths();
         if (years != 0 || months != 0) {
+            long totalMonths = years * 12L + months;
+            if (type.isSupported(DurationFieldType.YEARS_TYPE)) {
+                int normalizedYears = FieldUtils.safeToInt(totalMonths / 12);
+                result = result.withYears(normalizedYears);
+                totalMonths = totalMonths - (normalizedYears * 12);
             }
+            if (type.isSupported(DurationFieldType.MONTHS_TYPE)) {
+                int normalizedMonths = FieldUtils.safeToInt(totalMonths);
+                result = result.withMonths(normalizedMonths);
+                totalMonths = totalMonths - normalizedMonths;
+            }
+            if (totalMonths != 0) {
+                throw new UnsupportedOperationException(""Unable to normalize as PeriodType is missing either years or months but period has a month/year amount: "" + toString());
             }
         }
         return result;
","@@ -1625,13 +1625,19 @@ public Period normalizedStandard(PeriodType type) {
         int years = getYears();
         int months = getMonths();
         if (years != 0 || months != 0) {
+            long totalMonths = years * 12L + months;
+            if (type.isSupported(DurationFieldType.YEARS_TYPE)) {
+                int normalizedYears = FieldUtils.safeToInt(totalMonths / 12);
+                result = result.withYears(normalizedYears);
+                totalMonths = totalMonths - (normalizedYears * 12);
             }
+            if (type.isSupported(DurationFieldType.MONTHS_TYPE)) {
+                int normalizedMonths = FieldUtils.safeToInt(totalMonths);
+                result = result.withMonths(normalizedMonths);
+                totalMonths = totalMonths - normalizedMonths;
+            }
+            if (totalMonths != 0) {
+                throw new UnsupportedOperationException(""Unable to normalize as PeriodType is missing either years or months but period has a month/year amount: "" + toString());
             }
         }
         return result;
"
369,"junit.framework.ComparisonFailure","/src/main/java/org/joda/time/MutableDateTime.java","@@ -636,7 +636,9 @@ public void add(DurationFieldType type, int amount) {
         if (type == null) {
             throw new IllegalArgumentException(""Field must not be null"");
         }
+        if (amount != 0) {
             setMillis(type.getField(getChronology()).add(getMillis(), amount));
+        }
     }
 
     //-----------------------------------------------------------------------
@@ -657,7 +659,9 @@ public void setYear(final int year) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addYears(final int years) {
+        if (years != 0) {
             setMillis(getChronology().years().add(getMillis(), years));
+        }
     }
 
     //-----------------------------------------------------------------------
@@ -678,7 +682,9 @@ public void setWeekyear(final int weekyear) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addWeekyears(final int weekyears) {
+        if (weekyears != 0) {
             setMillis(getChronology().weekyears().add(getMillis(), weekyears));
+        }
     }
 
     //-----------------------------------------------------------------------
@@ -699,7 +705,9 @@ public void setMonthOfYear(final int monthOfYear) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addMonths(final int months) {
+        if (months != 0) {
             setMillis(getChronology().months().add(getMillis(), months));
+        }
     }
 
     //-----------------------------------------------------------------------
@@ -720,7 +728,9 @@ public void setWeekOfWeekyear(final int weekOfWeekyear) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addWeeks(final int weeks) {
+        if (weeks != 0) {
             setMillis(getChronology().weeks().add(getMillis(), weeks));
+        }
     }
 
     //-----------------------------------------------------------------------
@@ -761,7 +771,9 @@ public void setDayOfWeek(final int dayOfWeek) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addDays(final int days) {
+        if (days != 0) {
             setMillis(getChronology().days().add(getMillis(), days));
+        }
     }
 
     //-----------------------------------------------------------------------
@@ -782,7 +794,9 @@ public void setHourOfDay(final int hourOfDay) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addHours(final int hours) {
+        if (hours != 0) {
             setMillis(getChronology().hours().add(getMillis(), hours));
+        }
     }
     
     //-----------------------------------------------------------------------
@@ -813,7 +827,9 @@ public void setMinuteOfHour(final int minuteOfHour) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addMinutes(final int minutes) {
+        if (minutes != 0) {
             setMillis(getChronology().minutes().add(getMillis(), minutes));
+        }
     }
 
     //-----------------------------------------------------------------------
@@ -844,7 +860,9 @@ public void setSecondOfMinute(final int secondOfMinute) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addSeconds(final int seconds) {
+        if (seconds != 0) {
             setMillis(getChronology().seconds().add(getMillis(), seconds));
+        }
     }
 
     //-----------------------------------------------------------------------
@@ -877,7 +895,9 @@ public void setMillisOfSecond(final int millisOfSecond) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addMillis(final int millis) {
+        if (millis != 0) {
             setMillis(getChronology().millis().add(getMillis(), millis));
+        }
     }
 
     //-----------------------------------------------------------------------
","@@ -636,7 +636,9 @@ public void add(DurationFieldType type, int amount) {
         if (type == null) {
             throw new IllegalArgumentException(""Field must not be null"");
         }
+        if (amount != 0) {
             setMillis(type.getField(getChronology()).add(getMillis(), amount));
+        }
     }
 
     //-----------------------------------------------------------------------
@@ -657,7 +659,9 @@ public void setYear(final int year) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addYears(final int years) {
+        if (years != 0) {
             setMillis(getChronology().years().add(getMillis(), years));
+        }
     }
 
     //-----------------------------------------------------------------------
@@ -678,7 +682,9 @@ public void setWeekyear(final int weekyear) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addWeekyears(final int weekyears) {
+        if (weekyears != 0) {
             setMillis(getChronology().weekyears().add(getMillis(), weekyears));
+        }
     }
 
     //-----------------------------------------------------------------------
@@ -699,7 +705,9 @@ public void setMonthOfYear(final int monthOfYear) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addMonths(final int months) {
+        if (months != 0) {
             setMillis(getChronology().months().add(getMillis(), months));
+        }
     }
 
     //-----------------------------------------------------------------------
@@ -720,7 +728,9 @@ public void setWeekOfWeekyear(final int weekOfWeekyear) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addWeeks(final int weeks) {
+        if (weeks != 0) {
             setMillis(getChronology().weeks().add(getMillis(), weeks));
+        }
     }
 
     //-----------------------------------------------------------------------
@@ -761,7 +771,9 @@ public void setDayOfWeek(final int dayOfWeek) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addDays(final int days) {
+        if (days != 0) {
             setMillis(getChronology().days().add(getMillis(), days));
+        }
     }
 
     //-----------------------------------------------------------------------
@@ -782,7 +794,9 @@ public void setHourOfDay(final int hourOfDay) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addHours(final int hours) {
+        if (hours != 0) {
             setMillis(getChronology().hours().add(getMillis(), hours));
+        }
     }
     
     //-----------------------------------------------------------------------
@@ -813,7 +827,9 @@ public void setMinuteOfHour(final int minuteOfHour) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addMinutes(final int minutes) {
+        if (minutes != 0) {
             setMillis(getChronology().minutes().add(getMillis(), minutes));
+        }
     }
 
     //-----------------------------------------------------------------------
@@ -844,7 +860,9 @@ public void setSecondOfMinute(final int secondOfMinute) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addSeconds(final int seconds) {
+        if (seconds != 0) {
             setMillis(getChronology().seconds().add(getMillis(), seconds));
+        }
     }
 
     //-----------------------------------------------------------------------
@@ -877,7 +895,9 @@ public void setMillisOfSecond(final int millisOfSecond) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addMillis(final int millis) {
+        if (millis != 0) {
             setMillis(getChronology().millis().add(getMillis(), millis));
+        }
     }
 
     //-----------------------------------------------------------------------
"
370,"junit.framework.AssertionFailedError","/src/main/java/org/joda/time/Partial.java","@@ -214,11 +214,20 @@ public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {
             DateTimeFieldType loopType = types[i];
             DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
             if (i > 0) {
+                if (loopUnitField.isSupported() == false) {
+                    if (lastUnitField.isSupported()) {
+                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" +
+                                        types[i - 1].getName() + "" < "" + loopType.getName());
+                    } else {
+                        throw new IllegalArgumentException(""Types array must not contain duplicate unsupported: "" +
+                                        types[i - 1].getName() + "" and "" + loopType.getName());
+                    }
+                }
                 int compare = lastUnitField.compareTo(loopUnitField);
                 if (compare < 0) {
                     throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" +
                             types[i - 1].getName() + "" < "" + loopType.getName());
+                } else if (compare == 0 && lastUnitField.equals(loopUnitField)) {
                     if (types[i - 1].getRangeDurationType() == null) {
                         if (loopType.getRangeDurationType() == null) {
                             throw new IllegalArgumentException(""Types array must not contain duplicate: "" +
/src/main/java/org/joda/time/field/UnsupportedDurationField.java @@ -224,9 +224,6 @@ public long getUnitMillis() {
      * @return zero always
      */
     public int compareTo(DurationField durationField) {
         return 0;
     }
 
","@@ -214,11 +214,20 @@ public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {
             DateTimeFieldType loopType = types[i];
             DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
             if (i > 0) {
+                if (loopUnitField.isSupported() == false) {
+                    if (lastUnitField.isSupported()) {
+                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" +
+                                        types[i - 1].getName() + "" < "" + loopType.getName());
+                    } else {
+                        throw new IllegalArgumentException(""Types array must not contain duplicate unsupported: "" +
+                                        types[i - 1].getName() + "" and "" + loopType.getName());
+                    }
+                }
                 int compare = lastUnitField.compareTo(loopUnitField);
                 if (compare < 0) {
                     throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" +
                             types[i - 1].getName() + "" < "" + loopType.getName());
+                } else if (compare == 0 && lastUnitField.equals(loopUnitField)) {
                     if (types[i - 1].getRangeDurationType() == null) {
                         if (loopType.getRangeDurationType() == null) {
                             throw new IllegalArgumentException(""Types array must not contain duplicate: "" +
/src/main/java/org/joda/time/field/UnsupportedDurationField.java @@ -224,9 +224,6 @@ public long getUnitMillis() {
      * @return zero always
      */
     public int compareTo(DurationField durationField) {
         return 0;
     }
 
"
371,"junit.framework.AssertionFailedError","/src/main/java/org/joda/time/Partial.java","@@ -461,7 +461,7 @@ public Partial with(DateTimeFieldType fieldType, int value) {
             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
             // use public constructor to ensure full validation
             // this isn't overly efficient, but is safe
+            Partial newPartial = new Partial(newTypes, newValues, iChronology);
             iChronology.validate(newPartial, newValues);
             return newPartial;
         }
","@@ -461,7 +461,7 @@ public Partial with(DateTimeFieldType fieldType, int value) {
             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
             // use public constructor to ensure full validation
             // this isn't overly efficient, but is safe
+            Partial newPartial = new Partial(newTypes, newValues, iChronology);
             iChronology.validate(newPartial, newValues);
             return newPartial;
         }
"
372,"junit.framework.AssertionFailedError","/src/org/mockito/internal/stubbing/answers/AnswersValidator.java","@@ -25,8 +25,16 @@ public void validate(Answer<?> answer, Invocation invocation) {
             validateDoNothing((DoesNothing) answer, invocation);
         }
         
+        if (answer instanceof CallsRealMethods) {
+            validateMockingConcreteClass((CallsRealMethods) answer, invocation);
+        }
     }
 
+    private void validateMockingConcreteClass(CallsRealMethods answer, Invocation invocation) {
+        if (invocation.getMethod().getDeclaringClass().isInterface()) {
+            reporter.cannotCallRealMethodOnInterface();
+        }
+    }
 
     private void validateDoNothing(DoesNothing answer, Invocation invocation) {
         if (!invocation.isVoid()) {
","@@ -25,8 +25,16 @@ public void validate(Answer<?> answer, Invocation invocation) {
             validateDoNothing((DoesNothing) answer, invocation);
         }
         
+        if (answer instanceof CallsRealMethods) {
+            validateMockingConcreteClass((CallsRealMethods) answer, invocation);
+        }
     }
 
+    private void validateMockingConcreteClass(CallsRealMethods answer, Invocation invocation) {
+        if (invocation.getMethod().getDeclaringClass().isInterface()) {
+            reporter.cannotCallRealMethodOnInterface();
+        }
+    }
 
     private void validateDoNothing(DoesNothing answer, Invocation invocation) {
         if (!invocation.isVoid()) {
"
373,"java.lang.IllegalArgumentException","/src/main/java/org/joda/time/Partial.java","@@ -215,7 +215,7 @@ public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {
             DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
             if (i > 0) {
                 int compare = lastUnitField.compareTo(loopUnitField);
+                if (compare < 0) {
                     throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" +
                             types[i - 1].getName() + "" < "" + loopType.getName());
                 } else if (compare == 0) {
@@ -446,6 +446,9 @@ public Partial with(DateTimeFieldType fieldType, int value) {
                         if (compare > 0) {
                             break;
                         } else if (compare == 0) {
+                            if (fieldType.getRangeDurationType() == null) {
+                                break;
+                            }
                             DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                             DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                             if (rangeField.compareTo(loopRangeField) > 0) {
/src/main/java/org/joda/time/field/UnsupportedDurationField.java @@ -224,6 +224,9 @@ public long getUnitMillis() {
      * @return zero always
      */
     public int compareTo(DurationField durationField) {
+        if (durationField.isSupported()) {
+            return 1;
+        }
         return 0;
     }
 
","@@ -215,7 +215,7 @@ public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {
             DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
             if (i > 0) {
                 int compare = lastUnitField.compareTo(loopUnitField);
+                if (compare < 0) {
                     throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" +
                             types[i - 1].getName() + "" < "" + loopType.getName());
                 } else if (compare == 0) {
@@ -446,6 +446,9 @@ public Partial with(DateTimeFieldType fieldType, int value) {
                         if (compare > 0) {
                             break;
                         } else if (compare == 0) {
+                            if (fieldType.getRangeDurationType() == null) {
+                                break;
+                            }
                             DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                             DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                             if (rangeField.compareTo(loopRangeField) > 0) {
/src/main/java/org/joda/time/field/UnsupportedDurationField.java @@ -224,6 +224,9 @@ public long getUnitMillis() {
      * @return zero always
      */
     public int compareTo(DurationField durationField) {
+        if (durationField.isSupported()) {
+            return 1;
+        }
         return 0;
     }
 
"
374,"java.lang.IllegalArgumentException","/src/main/java/org/joda/time/DateTimeZone.java","@@ -276,14 +276,17 @@ public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff
         if (hoursOffset < -23 || hoursOffset > 23) {
             throw new IllegalArgumentException(""Hours out of range: "" + hoursOffset);
         }
+        if (minutesOffset < -59 || minutesOffset > 59) {
             throw new IllegalArgumentException(""Minutes out of range: "" + minutesOffset);
         }
+        if (hoursOffset > 0 && minutesOffset < 0) {
+            throw new IllegalArgumentException(""Positive hours must not have negative minutes: "" + minutesOffset);
+        }
         int offset = 0;
         try {
             int hoursInMinutes = hoursOffset * 60;
             if (hoursInMinutes < 0) {
+                minutesOffset = hoursInMinutes - Math.abs(minutesOffset);
             } else {
                 minutesOffset = hoursInMinutes + minutesOffset;
             }
","@@ -276,14 +276,17 @@ public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff
         if (hoursOffset < -23 || hoursOffset > 23) {
             throw new IllegalArgumentException(""Hours out of range: "" + hoursOffset);
         }
+        if (minutesOffset < -59 || minutesOffset > 59) {
             throw new IllegalArgumentException(""Minutes out of range: "" + minutesOffset);
         }
+        if (hoursOffset > 0 && minutesOffset < 0) {
+            throw new IllegalArgumentException(""Positive hours must not have negative minutes: "" + minutesOffset);
+        }
         int offset = 0;
         try {
             int hoursInMinutes = hoursOffset * 60;
             if (hoursInMinutes < 0) {
+                minutesOffset = hoursInMinutes - Math.abs(minutesOffset);
             } else {
                 minutesOffset = hoursInMinutes + minutesOffset;
             }
"
375,"junit.framework.AssertionFailedError","/src/main/java/org/joda/time/chrono/GJChronology.java","@@ -193,6 +193,10 @@ public static synchronized GJChronology getInstance(
             cutoverInstant = DEFAULT_CUTOVER;
         } else {
             cutoverInstant = gregorianCutover.toInstant();
+            LocalDate cutoverDate = new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone));
+            if (cutoverDate.getYear() <= 0) {
+                throw new IllegalArgumentException(""Cutover too early. Must be on or after 0001-01-01."");
+            }
         }
 
         GJChronology chrono;
@@ -976,6 +980,17 @@ public long add(long instant, int value) {
                 if (instant < iCutover) {
                     // Only adjust if gap fully crossed.
                     if (instant + iGapDuration < iCutover) {
+                        if (iConvertByWeekyear) {
+                            int wyear = iGregorianChronology.weekyear().get(instant);
+                            if (wyear <= 0) {
+                                instant = iGregorianChronology.weekyear().add(instant, -1);
+                            }
+                        } else {
+                            int year = iGregorianChronology.year().get(instant);
+                            if (year <= 0) {
+                                instant = iGregorianChronology.year().add(instant, -1);
+                            }
+                        }
                         instant = gregorianToJulian(instant);
                     }
                 }
@@ -998,6 +1013,17 @@ public long add(long instant, long value) {
                 if (instant < iCutover) {
                     // Only adjust if gap fully crossed.
                     if (instant + iGapDuration < iCutover) {
+                        if (iConvertByWeekyear) {
+                            int wyear = iGregorianChronology.weekyear().get(instant);
+                            if (wyear <= 0) {
+                                instant = iGregorianChronology.weekyear().add(instant, -1);
+                            }
+                        } else {
+                            int year = iGregorianChronology.year().get(instant);
+                            if (year <= 0) {
+                                instant = iGregorianChronology.year().add(instant, -1);
+                            }
+                        }
                         instant = gregorianToJulian(instant);
                     }
                 }
","@@ -193,6 +193,10 @@ public static synchronized GJChronology getInstance(
             cutoverInstant = DEFAULT_CUTOVER;
         } else {
             cutoverInstant = gregorianCutover.toInstant();
+            LocalDate cutoverDate = new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone));
+            if (cutoverDate.getYear() <= 0) {
+                throw new IllegalArgumentException(""Cutover too early. Must be on or after 0001-01-01."");
+            }
         }
 
         GJChronology chrono;
@@ -976,6 +980,17 @@ public long add(long instant, int value) {
                 if (instant < iCutover) {
                     // Only adjust if gap fully crossed.
                     if (instant + iGapDuration < iCutover) {
+                        if (iConvertByWeekyear) {
+                            int wyear = iGregorianChronology.weekyear().get(instant);
+                            if (wyear <= 0) {
+                                instant = iGregorianChronology.weekyear().add(instant, -1);
+                            }
+                        } else {
+                            int year = iGregorianChronology.year().get(instant);
+                            if (year <= 0) {
+                                instant = iGregorianChronology.year().add(instant, -1);
+                            }
+                        }
                         instant = gregorianToJulian(instant);
                     }
                 }
@@ -998,6 +1013,17 @@ public long add(long instant, long value) {
                 if (instant < iCutover) {
                     // Only adjust if gap fully crossed.
                     if (instant + iGapDuration < iCutover) {
+                        if (iConvertByWeekyear) {
+                            int wyear = iGregorianChronology.weekyear().get(instant);
+                            if (wyear <= 0) {
+                                instant = iGregorianChronology.weekyear().add(instant, -1);
+                            }
+                        } else {
+                            int year = iGregorianChronology.year().get(instant);
+                            if (year <= 0) {
+                                instant = iGregorianChronology.year().add(instant, -1);
+                            }
+                        }
                         instant = gregorianToJulian(instant);
                     }
                 }
"
376,"org.joda.time.IllegalFieldValueException","/src/main/java/org/joda/time/format/DateTimeFormatter.java","@@ -705,9 +705,9 @@ public int parseInto(ReadWritableInstant instant, String text, int position) {
         
         long instantMillis = instant.getMillis();
         Chronology chrono = instant.getChronology();
+        int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);
         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
         chrono = selectChronology(chrono);
         
         DateTimeParserBucket bucket = new DateTimeParserBucket(
             instantLocal, chrono, iLocale, iPivotYear, defaultYear);
","@@ -705,9 +705,9 @@ public int parseInto(ReadWritableInstant instant, String text, int position) {
         
         long instantMillis = instant.getMillis();
         Chronology chrono = instant.getChronology();
+        int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);
         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
         chrono = selectChronology(chrono);
         
         DateTimeParserBucket bucket = new DateTimeParserBucket(
             instantLocal, chrono, iLocale, iPivotYear, defaultYear);
"
377,"junit.framework.AssertionFailedError","/src/main/java/org/joda/time/DateTimeZone.java","@@ -255,16 +255,19 @@ public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff
         if (hoursOffset == 0 && minutesOffset == 0) {
             return DateTimeZone.UTC;
         }
+        if (hoursOffset < -23 || hoursOffset > 23) {
+            throw new IllegalArgumentException(""Hours out of range: "" + hoursOffset);
+        }
         if (minutesOffset < 0 || minutesOffset > 59) {
             throw new IllegalArgumentException(""Minutes out of range: "" + minutesOffset);
         }
         int offset = 0;
         try {
+            int hoursInMinutes = hoursOffset * 60;
             if (hoursInMinutes < 0) {
+                minutesOffset = hoursInMinutes - minutesOffset;
             } else {
+                minutesOffset = hoursInMinutes + minutesOffset;
             }
             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);
         } catch (ArithmeticException ex) {
@@ -280,6 +283,9 @@ public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff
      * @return the DateTimeZone object for the offset
      */
     public static DateTimeZone forOffsetMillis(int millisOffset) {
+        if (millisOffset < -MAX_MILLIS || millisOffset > MAX_MILLIS) {
+            throw new IllegalArgumentException(""Millis out of range: "" + millisOffset);
+        }
         String id = printOffset(millisOffset);
         return fixedOffsetZone(id, millisOffset);
     }
","@@ -255,16 +255,19 @@ public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff
         if (hoursOffset == 0 && minutesOffset == 0) {
             return DateTimeZone.UTC;
         }
+        if (hoursOffset < -23 || hoursOffset > 23) {
+            throw new IllegalArgumentException(""Hours out of range: "" + hoursOffset);
+        }
         if (minutesOffset < 0 || minutesOffset > 59) {
             throw new IllegalArgumentException(""Minutes out of range: "" + minutesOffset);
         }
         int offset = 0;
         try {
+            int hoursInMinutes = hoursOffset * 60;
             if (hoursInMinutes < 0) {
+                minutesOffset = hoursInMinutes - minutesOffset;
             } else {
+                minutesOffset = hoursInMinutes + minutesOffset;
             }
             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);
         } catch (ArithmeticException ex) {
@@ -280,6 +283,9 @@ public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff
      * @return the DateTimeZone object for the offset
      */
     public static DateTimeZone forOffsetMillis(int millisOffset) {
+        if (millisOffset < -MAX_MILLIS || millisOffset > MAX_MILLIS) {
+            throw new IllegalArgumentException(""Millis out of range: "" + millisOffset);
+        }
         String id = printOffset(millisOffset);
         return fixedOffsetZone(id, millisOffset);
     }
"
378,"org.joda.time.IllegalFieldValueException","/src/main/java/org/joda/time/base/BaseSingleFieldPeriod.java","@@ -49,6 +49,7 @@
     /** Serialization version. */
     private static final long serialVersionUID = 9386874258972L;
     /** The start of 1972. */
+    private static final long START_1972 = 2L * 365L * 86400L * 1000L;
 
     /** The period in the units of this period. */
     private volatile int iPeriod;
@@ -101,7 +102,7 @@ protected static int between(ReadablePartial start, ReadablePartial end, Readabl
             throw new IllegalArgumentException(""ReadablePartial objects must be contiguous"");
         }
         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();
+        int[] values = chrono.get(zeroInstance, chrono.set(start, START_1972), chrono.set(end, START_1972));
         return values[0];
     }
 
","@@ -49,6 +49,7 @@
     /** Serialization version. */
     private static final long serialVersionUID = 9386874258972L;
     /** The start of 1972. */
+    private static final long START_1972 = 2L * 365L * 86400L * 1000L;
 
     /** The period in the units of this period. */
     private volatile int iPeriod;
@@ -101,7 +102,7 @@ protected static int between(ReadablePartial start, ReadablePartial end, Readabl
             throw new IllegalArgumentException(""ReadablePartial objects must be contiguous"");
         }
         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();
+        int[] values = chrono.get(zeroInstance, chrono.set(start, START_1972), chrono.set(end, START_1972));
         return values[0];
     }
 
"
379,"junit.framework.AssertionFailedError","/src/main/java/org/joda/time/LocalDate.java","@@ -207,9 +207,10 @@ public static LocalDate fromCalendarFields(Calendar calendar) {
         if (calendar == null) {
             throw new IllegalArgumentException(""The calendar must not be null"");
         }
+        int era = calendar.get(Calendar.ERA);
         int yearOfEra = calendar.get(Calendar.YEAR);
         return new LocalDate(
+            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),
             calendar.get(Calendar.MONTH) + 1,
             calendar.get(Calendar.DAY_OF_MONTH)
         );
@@ -240,7 +241,12 @@ public static LocalDate fromDateFields(Date date) {
         if (date == null) {
             throw new IllegalArgumentException(""The date must not be null"");
         }
+        if (date.getTime() < 0) {
             // handle years in era BC
+            GregorianCalendar cal = new GregorianCalendar();
+            cal.setTime(date);
+            return fromCalendarFields(cal);
+        }
         return new LocalDate(
             date.getYear() + 1900,
             date.getMonth() + 1,
/src/main/java/org/joda/time/LocalDateTime.java @@ -196,9 +196,10 @@ public static LocalDateTime fromCalendarFields(Calendar calendar) {
         if (calendar == null) {
             throw new IllegalArgumentException(""The calendar must not be null"");
         }
+        int era = calendar.get(Calendar.ERA);
         int yearOfEra = calendar.get(Calendar.YEAR);
         return new LocalDateTime(
+            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),
             calendar.get(Calendar.MONTH) + 1,
             calendar.get(Calendar.DAY_OF_MONTH),
             calendar.get(Calendar.HOUR_OF_DAY),
@@ -233,7 +234,12 @@ public static LocalDateTime fromDateFields(Date date) {
         if (date == null) {
             throw new IllegalArgumentException(""The date must not be null"");
         }
+        if (date.getTime() < 0) {
             // handle years in era BC
+            GregorianCalendar cal = new GregorianCalendar();
+            cal.setTime(date);
+            return fromCalendarFields(cal);
+        }
         return new LocalDateTime(
             date.getYear() + 1900,
             date.getMonth() + 1,
","@@ -207,9 +207,10 @@ public static LocalDate fromCalendarFields(Calendar calendar) {
         if (calendar == null) {
             throw new IllegalArgumentException(""The calendar must not be null"");
         }
+        int era = calendar.get(Calendar.ERA);
         int yearOfEra = calendar.get(Calendar.YEAR);
         return new LocalDate(
+            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),
             calendar.get(Calendar.MONTH) + 1,
             calendar.get(Calendar.DAY_OF_MONTH)
         );
@@ -240,7 +241,12 @@ public static LocalDate fromDateFields(Date date) {
         if (date == null) {
             throw new IllegalArgumentException(""The date must not be null"");
         }
+        if (date.getTime() < 0) {
             // handle years in era BC
+            GregorianCalendar cal = new GregorianCalendar();
+            cal.setTime(date);
+            return fromCalendarFields(cal);
+        }
         return new LocalDate(
             date.getYear() + 1900,
             date.getMonth() + 1,
/src/main/java/org/joda/time/LocalDateTime.java @@ -196,9 +196,10 @@ public static LocalDateTime fromCalendarFields(Calendar calendar) {
         if (calendar == null) {
             throw new IllegalArgumentException(""The calendar must not be null"");
         }
+        int era = calendar.get(Calendar.ERA);
         int yearOfEra = calendar.get(Calendar.YEAR);
         return new LocalDateTime(
+            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),
             calendar.get(Calendar.MONTH) + 1,
             calendar.get(Calendar.DAY_OF_MONTH),
             calendar.get(Calendar.HOUR_OF_DAY),
@@ -233,7 +234,12 @@ public static LocalDateTime fromDateFields(Date date) {
         if (date == null) {
             throw new IllegalArgumentException(""The date must not be null"");
         }
+        if (date.getTime() < 0) {
             // handle years in era BC
+            GregorianCalendar cal = new GregorianCalendar();
+            cal.setTime(date);
+            return fromCalendarFields(cal);
+        }
         return new LocalDateTime(
             date.getYear() + 1900,
             date.getMonth() + 1,
"
380,"junit.framework.AssertionFailedError","/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java","@@ -65,10 +65,11 @@
 
     static Chronology cLenientISO;
 
+    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>() {
+        protected Boolean initialValue() {
+            return Boolean.FALSE;
+        }
+    };
 
     /**
      * Gets a flag indicating that verbose logging is required.
","@@ -65,10 +65,11 @@
 
     static Chronology cLenientISO;
 
+    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>() {
+        protected Boolean initialValue() {
+            return Boolean.FALSE;
+        }
+    };
 
     /**
      * Gets a flag indicating that verbose logging is required.
"
381,"org.joda.time.IllegalFieldValueException","/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java","@@ -206,7 +206,12 @@ public long add(long instant, long months) {
         if (valueToAdd == 0) {
             return values;
         }
+        if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) {
             // month is largest field and being added to, such as month-day
+            int curMonth0 = partial.getValue(0) - 1;
+            int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1;
+            return set(partial, 0, values, newMonth);
+        }
         if (DateTimeUtils.isContiguous(partial)) {
             long instant = 0L;
             for (int i = 0, isize = partial.size(); i < isize; i++) {
","@@ -206,7 +206,12 @@ public long add(long instant, long months) {
         if (valueToAdd == 0) {
             return values;
         }
+        if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) {
             // month is largest field and being added to, such as month-day
+            int curMonth0 = partial.getValue(0) - 1;
+            int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1;
+            return set(partial, 0, values, newMonth);
+        }
         if (DateTimeUtils.isContiguous(partial)) {
             long instant = 0L;
             for (int i = 0, isize = partial.size(); i < isize; i++) {
"
382,"junit.framework.ComparisonFailure","/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java","@@ -1095,7 +1095,7 @@ public int calculatePrintedLength(ReadablePeriod period, Locale locale) {
             if (iFieldType >= SECONDS_MILLIS) {
                 // valueLong contains the seconds and millis fields
                 // the minimum output is 0.000, which is 4 or 5 digits with a negative
+                sum = (valueLong < 0 ? Math.max(sum, 5) : Math.max(sum, 4));
                 // plus one for the decimal point
                 sum++;
                 if (iFieldType == SECONDS_OPTIONAL_MILLIS &&
@@ -1130,6 +1130,7 @@ public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {
             if (iPrefix != null) {
                 iPrefix.printTo(buf, value);
             }
+            int bufLen = buf.length();
             int minDigits = iMinPrintedDigits;
             if (minDigits <= 1) {
                 FormatUtils.appendUnpaddedInteger(buf, value);
@@ -1139,6 +1140,9 @@ public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {
             if (iFieldType >= SECONDS_MILLIS) {
                 int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);
                 if (iFieldType == SECONDS_MILLIS || dp > 0) {
+                    if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) {
+                        buf.insert(bufLen, '-');
+                    }
                     buf.append('.');
                     FormatUtils.appendPaddedInteger(buf, dp, 3);
                 }
","@@ -1095,7 +1095,7 @@ public int calculatePrintedLength(ReadablePeriod period, Locale locale) {
             if (iFieldType >= SECONDS_MILLIS) {
                 // valueLong contains the seconds and millis fields
                 // the minimum output is 0.000, which is 4 or 5 digits with a negative
+                sum = (valueLong < 0 ? Math.max(sum, 5) : Math.max(sum, 4));
                 // plus one for the decimal point
                 sum++;
                 if (iFieldType == SECONDS_OPTIONAL_MILLIS &&
@@ -1130,6 +1130,7 @@ public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {
             if (iPrefix != null) {
                 iPrefix.printTo(buf, value);
             }
+            int bufLen = buf.length();
             int minDigits = iMinPrintedDigits;
             if (minDigits <= 1) {
                 FormatUtils.appendUnpaddedInteger(buf, value);
@@ -1139,6 +1140,9 @@ public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {
             if (iFieldType >= SECONDS_MILLIS) {
                 int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);
                 if (iFieldType == SECONDS_MILLIS || dp > 0) {
+                    if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) {
+                        buf.insert(bufLen, '-');
+                    }
                     buf.append('.');
                     FormatUtils.appendPaddedInteger(buf, dp, 3);
                 }
"
383,"junit.framework.AssertionFailedError","/src/main/java/org/joda/time/field/FieldUtils.java","@@ -135,6 +135,9 @@ public static int safeMultiply(int val1, int val2) {
     public static long safeMultiply(long val1, int val2) {
         switch (val2) {
             case -1:
+                if (val1 == Long.MIN_VALUE) {
+                    throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
+                }
                 return -val1;
             case 0:
                 return 0L;
","@@ -135,6 +135,9 @@ public static int safeMultiply(int val1, int val2) {
     public static long safeMultiply(long val1, int val2) {
         switch (val2) {
             case -1:
+                if (val1 == Long.MIN_VALUE) {
+                    throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
+                }
                 return -val1;
             case 0:
                 return 0L;
"
384,"junit.framework.AssertionFailedError","/src/main/java/org/joda/time/DateTimeZone.java","@@ -1164,19 +1164,32 @@ public long adjustOffset(long instant, boolean earlierOrLater) {
         // a bit messy, but will work in all non-pathological cases
         
         // evaluate 3 hours before and after to work out if anything is happening
+        long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR;
+        long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR;
+        long offsetBefore = getOffset(instantBefore);
+        long offsetAfter = getOffset(instantAfter);
+        if (offsetBefore <= offsetAfter) {
             return instant;  // not an overlap (less than is a gap, equal is normal case)
         }
         
         // work out range of instants that have duplicate local times
+        long diff = offsetBefore - offsetAfter;
+        long transition = nextTransition(instantBefore);
+        long overlapStart = transition - diff;
+        long overlapEnd = transition + diff;
+        if (instant < overlapStart || instant >= overlapEnd) {
+          return instant;  // not an overlap
+        }
         
         // calculate result
+        long afterStart = instant - overlapStart;
+        if (afterStart >= diff) {
           // currently in later offset
+          return earlierOrLater ? instant : instant - diff;
+        } else {
           // currently in earlier offset
+          return earlierOrLater ? instant + diff : instant;
+        }
     }
 //    System.out.println(new DateTime(transitionStart, DateTimeZone.UTC) + "" "" + new DateTime(transitionStart, this));
 
","@@ -1164,19 +1164,32 @@ public long adjustOffset(long instant, boolean earlierOrLater) {
         // a bit messy, but will work in all non-pathological cases
         
         // evaluate 3 hours before and after to work out if anything is happening
+        long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR;
+        long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR;
+        long offsetBefore = getOffset(instantBefore);
+        long offsetAfter = getOffset(instantAfter);
+        if (offsetBefore <= offsetAfter) {
             return instant;  // not an overlap (less than is a gap, equal is normal case)
         }
         
         // work out range of instants that have duplicate local times
+        long diff = offsetBefore - offsetAfter;
+        long transition = nextTransition(instantBefore);
+        long overlapStart = transition - diff;
+        long overlapEnd = transition + diff;
+        if (instant < overlapStart || instant >= overlapEnd) {
+          return instant;  // not an overlap
+        }
         
         // calculate result
+        long afterStart = instant - overlapStart;
+        if (afterStart >= diff) {
           // currently in later offset
+          return earlierOrLater ? instant : instant - diff;
+        } else {
           // currently in earlier offset
+          return earlierOrLater ? instant + diff : instant;
+        }
     }
 //    System.out.println(new DateTime(transitionStart, DateTimeZone.UTC) + "" "" + new DateTime(transitionStart, this));
 
"
385,"junit.framework.AssertionFailedError","/src/main/java/org/joda/time/format/DateTimeFormatter.java","@@ -706,7 +706,7 @@ public int parseInto(ReadWritableInstant instant, String text, int position) {
         chrono = selectChronology(chrono);
         
         DateTimeParserBucket bucket = new DateTimeParserBucket(
+            instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal));
         int newPos = parser.parseInto(bucket, text, position);
         instant.setMillis(bucket.computeMillis(false, text));
         if (iOffsetParsed && bucket.getOffsetInteger() != null) {
","@@ -706,7 +706,7 @@ public int parseInto(ReadWritableInstant instant, String text, int position) {
         chrono = selectChronology(chrono);
         
         DateTimeParserBucket bucket = new DateTimeParserBucket(
+            instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal));
         int newPos = parser.parseInto(bucket, text, position);
         instant.setMillis(bucket.computeMillis(false, text));
         if (iOffsetParsed && bucket.getOffsetInteger() != null) {
"
386,"java.lang.IllegalArgumentException","/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java","@@ -2539,12 +2539,18 @@ public int estimateParsedLength() {
 
         public int parseInto(DateTimeParserBucket bucket, String text, int position) {
             String str = text.substring(position);
+            String best = null;
             for (String id : ALL_IDS) {
                 if (str.startsWith(id)) {
+                	if (best == null || id.length() > best.length()) {
+                		best = id;
+                	}
                 }
             }
+            if (best != null) {
+                bucket.setZone(DateTimeZone.forID(best));
+                return position + best.length();
+            }
             return ~position;
         }
     }
","@@ -2539,12 +2539,18 @@ public int estimateParsedLength() {
 
         public int parseInto(DateTimeParserBucket bucket, String text, int position) {
             String str = text.substring(position);
+            String best = null;
             for (String id : ALL_IDS) {
                 if (str.startsWith(id)) {
+                	if (best == null || id.length() > best.length()) {
+                		best = id;
+                	}
                 }
             }
+            if (best != null) {
+                bucket.setZone(DateTimeZone.forID(best));
+                return position + best.length();
+            }
             return ~position;
         }
     }
"
387,"org.joda.time.IllegalFieldValueException","/src/main/java/org/joda/time/chrono/GJChronology.java","@@ -361,9 +361,21 @@ public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
 
         // Assume date is Gregorian.
         long instant;
+        try {
             instant = iGregorianChronology.getDateTimeMillis
                 (year, monthOfYear, dayOfMonth,
                  hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+        } catch (IllegalFieldValueException ex) {
+            if (monthOfYear != 2 || dayOfMonth != 29) {
+                throw ex;
+            }
+            instant = iGregorianChronology.getDateTimeMillis
+                (year, monthOfYear, 28,
+                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+            if (instant >= iCutoverMillis) {
+                throw ex;
+            }
+        }
         if (instant < iCutoverMillis) {
             // Maybe it's Julian.
             instant = iJulianChronology.getDateTimeMillis
","@@ -361,9 +361,21 @@ public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
 
         // Assume date is Gregorian.
         long instant;
+        try {
             instant = iGregorianChronology.getDateTimeMillis
                 (year, monthOfYear, dayOfMonth,
                  hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+        } catch (IllegalFieldValueException ex) {
+            if (monthOfYear != 2 || dayOfMonth != 29) {
+                throw ex;
+            }
+            instant = iGregorianChronology.getDateTimeMillis
+                (year, monthOfYear, 28,
+                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
+            if (instant >= iCutoverMillis) {
+                throw ex;
+            }
+        }
         if (instant < iCutoverMillis) {
             // Maybe it's Julian.
             instant = iJulianChronology.getDateTimeMillis
"
388,"junit.framework.ComparisonFailure","/src/main/java/org/joda/time/DateTimeZone.java","@@ -897,7 +897,7 @@ public int getOffsetFromLocal(long instantLocal) {
                     return offsetLocal;
                 }
             }
+        } else if (offsetLocal >= 0) {
             long prev = previousTransition(instantAdjusted);
             if (prev < instantAdjusted) {
                 int offsetPrev = getOffset(prev);
","@@ -897,7 +897,7 @@ public int getOffsetFromLocal(long instantLocal) {
                     return offsetLocal;
                 }
             }
+        } else if (offsetLocal >= 0) {
             long prev = previousTransition(instantAdjusted);
             if (prev < instantAdjusted) {
                 int offsetPrev = getOffset(prev);
"
389,"junit.framework.ComparisonFailure","/src/main/java/org/joda/time/tz/DefaultNameProvider.java","@@ -63,22 +63,32 @@ public String getName(Locale locale, String id, String nameKey) {
         if (byNameKeyCache == null) {
             byIdCache.put(id, byNameKeyCache = createCache());
             
+            String[][] zoneStringsEn = DateTimeUtils.getDateFormatSymbols(Locale.ENGLISH).getZoneStrings();
+            String[] setEn = null;
+            for (String[] strings : zoneStringsEn) {
+              if (strings != null && strings.length == 5 && id.equals(strings[0])) {
+                setEn = strings;
+                break;
+              }
+            }
             String[][] zoneStringsLoc = DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings();
             String[] setLoc = null;
             for (String[] strings : zoneStringsLoc) {
               if (strings != null && strings.length == 5 && id.equals(strings[0])) {
                 setLoc = strings;
+                break;
+              }
+            }
             
+            if (setEn != null && setLoc != null) {
+              byNameKeyCache.put(setEn[2], new String[] {setLoc[2], setLoc[1]});
               // need to handle case where summer and winter have the same
               // abbreviation, such as EST in Australia [1716305]
               // we handle this by appending ""-Summer"", cf ZoneInfoCompiler
+              if (setEn[2].equals(setEn[4])) {
+                  byNameKeyCache.put(setEn[4] + ""-Summer"", new String[] {setLoc[4], setLoc[3]});
               } else {
+                  byNameKeyCache.put(setEn[4], new String[] {setLoc[4], setLoc[3]});
               }
             }
         }
","@@ -63,22 +63,32 @@ public String getName(Locale locale, String id, String nameKey) {
         if (byNameKeyCache == null) {
             byIdCache.put(id, byNameKeyCache = createCache());
             
+            String[][] zoneStringsEn = DateTimeUtils.getDateFormatSymbols(Locale.ENGLISH).getZoneStrings();
+            String[] setEn = null;
+            for (String[] strings : zoneStringsEn) {
+              if (strings != null && strings.length == 5 && id.equals(strings[0])) {
+                setEn = strings;
+                break;
+              }
+            }
             String[][] zoneStringsLoc = DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings();
             String[] setLoc = null;
             for (String[] strings : zoneStringsLoc) {
               if (strings != null && strings.length == 5 && id.equals(strings[0])) {
                 setLoc = strings;
+                break;
+              }
+            }
             
+            if (setEn != null && setLoc != null) {
+              byNameKeyCache.put(setEn[2], new String[] {setLoc[2], setLoc[1]});
               // need to handle case where summer and winter have the same
               // abbreviation, such as EST in Australia [1716305]
               // we handle this by appending ""-Summer"", cf ZoneInfoCompiler
+              if (setEn[2].equals(setEn[4])) {
+                  byNameKeyCache.put(setEn[4] + ""-Summer"", new String[] {setLoc[4], setLoc[3]});
               } else {
+                  byNameKeyCache.put(setEn[4], new String[] {setLoc[4], setLoc[3]});
               }
             }
         }
"
390,"junit.framework.AssertionFailedError","/src/main/java/org/joda/time/base/BasePeriod.java","@@ -219,8 +219,13 @@ protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri
      * @param duration  the duration, in milliseconds
      */
     protected BasePeriod(long duration) {
+        super();
         // bug [3264409]
+        iType = PeriodType.time();
+        int[] values = ISOChronology.getInstanceUTC().get(this, duration);
+        iType = PeriodType.standard();
+        iValues = new int[8];
+        System.arraycopy(values, 0, iValues, 4, 4);
     }
 
     /**
","@@ -219,8 +219,13 @@ protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri
      * @param duration  the duration, in milliseconds
      */
     protected BasePeriod(long duration) {
+        super();
         // bug [3264409]
+        iType = PeriodType.time();
+        int[] values = ISOChronology.getInstanceUTC().get(this, duration);
+        iType = PeriodType.standard();
+        iValues = new int[8];
+        System.arraycopy(values, 0, iValues, 4, 4);
     }
 
     /**
"
391,"junit.framework.ComparisonFailure","/src/main/java/org/joda/time/DateTimeZone.java","@@ -561,6 +561,11 @@ private static synchronized String getConvertedId(String id) {
             // Backwards compatibility with TimeZone.
             map = new HashMap<String, String>();
             map.put(""GMT"", ""UTC"");
+            map.put(""WET"", ""WET"");
+            map.put(""CET"", ""CET"");
+            map.put(""MET"", ""CET"");
+            map.put(""ECT"", ""CET"");
+            map.put(""EET"", ""EET"");
             map.put(""MIT"", ""Pacific/Apia"");
             map.put(""HST"", ""Pacific/Honolulu"");  // JDK 1.1 compatible
             map.put(""AST"", ""America/Anchorage"");
@@ -569,23 +574,19 @@ private static synchronized String getConvertedId(String id) {
             map.put(""PNT"", ""America/Phoenix"");
             map.put(""CST"", ""America/Chicago"");
             map.put(""EST"", ""America/New_York"");  // JDK 1.1 compatible
+            map.put(""IET"", ""America/Indiana/Indianapolis"");
             map.put(""PRT"", ""America/Puerto_Rico"");
             map.put(""CNT"", ""America/St_Johns"");
+            map.put(""AGT"", ""America/Argentina/Buenos_Aires"");
             map.put(""BET"", ""America/Sao_Paulo"");
             map.put(""ART"", ""Africa/Cairo"");
             map.put(""CAT"", ""Africa/Harare"");
             map.put(""EAT"", ""Africa/Addis_Ababa"");
             map.put(""NET"", ""Asia/Yerevan"");
             map.put(""PLT"", ""Asia/Karachi"");
+            map.put(""IST"", ""Asia/Kolkata"");
             map.put(""BST"", ""Asia/Dhaka"");
+            map.put(""VST"", ""Asia/Ho_Chi_Minh"");
             map.put(""CTT"", ""Asia/Shanghai"");
             map.put(""JST"", ""Asia/Tokyo"");
             map.put(""ACT"", ""Australia/Darwin"");
","@@ -561,6 +561,11 @@ private static synchronized String getConvertedId(String id) {
             // Backwards compatibility with TimeZone.
             map = new HashMap<String, String>();
             map.put(""GMT"", ""UTC"");
+            map.put(""WET"", ""WET"");
+            map.put(""CET"", ""CET"");
+            map.put(""MET"", ""CET"");
+            map.put(""ECT"", ""CET"");
+            map.put(""EET"", ""EET"");
             map.put(""MIT"", ""Pacific/Apia"");
             map.put(""HST"", ""Pacific/Honolulu"");  // JDK 1.1 compatible
             map.put(""AST"", ""America/Anchorage"");
@@ -569,23 +574,19 @@ private static synchronized String getConvertedId(String id) {
             map.put(""PNT"", ""America/Phoenix"");
             map.put(""CST"", ""America/Chicago"");
             map.put(""EST"", ""America/New_York"");  // JDK 1.1 compatible
+            map.put(""IET"", ""America/Indiana/Indianapolis"");
             map.put(""PRT"", ""America/Puerto_Rico"");
             map.put(""CNT"", ""America/St_Johns"");
+            map.put(""AGT"", ""America/Argentina/Buenos_Aires"");
             map.put(""BET"", ""America/Sao_Paulo"");
             map.put(""ART"", ""Africa/Cairo"");
             map.put(""CAT"", ""Africa/Harare"");
             map.put(""EAT"", ""Africa/Addis_Ababa"");
             map.put(""NET"", ""Asia/Yerevan"");
             map.put(""PLT"", ""Asia/Karachi"");
+            map.put(""IST"", ""Asia/Kolkata"");
             map.put(""BST"", ""Asia/Dhaka"");
+            map.put(""VST"", ""Asia/Ho_Chi_Minh"");
             map.put(""CTT"", ""Asia/Shanghai"");
             map.put(""JST"", ""Asia/Tokyo"");
             map.put(""ACT"", ""Australia/Darwin"");
"
392,"junit.framework.ComparisonFailure","/src/main/java/org/joda/time/DateTimeZone.java","@@ -896,6 +896,15 @@ public int getOffsetFromLocal(long instantLocal) {
                     return offsetLocal;
                 }
             }
+        } else if (offsetLocal > 0) {
+            long prev = previousTransition(instantAdjusted);
+            if (prev < instantAdjusted) {
+                int offsetPrev = getOffset(prev);
+                int diff = offsetPrev - offsetLocal;
+                if (instantAdjusted - prev <= diff) {
+                    return offsetPrev;
+                }
+            }
         }
         return offsetAdjusted;
     }
","@@ -896,6 +896,15 @@ public int getOffsetFromLocal(long instantLocal) {
                     return offsetLocal;
                 }
             }
+        } else if (offsetLocal > 0) {
+            long prev = previousTransition(instantAdjusted);
+            if (prev < instantAdjusted) {
+                int offsetPrev = getOffset(prev);
+                int diff = offsetPrev - offsetLocal;
+                if (instantAdjusted - prev <= diff) {
+                    return offsetPrev;
+                }
+            }
         }
         return offsetAdjusted;
     }
"
393,"junit.framework.ComparisonFailure","/src/main/java/org/joda/time/chrono/ZonedChronology.java","@@ -433,7 +433,7 @@ public long add(long instant, int value) {
             } else {
                long localInstant = iZone.convertUTCToLocal(instant);
                localInstant = iField.add(localInstant, value);
+               return iZone.convertLocalToUTC(localInstant, false, instant);
             }
         }
 
@@ -445,7 +445,7 @@ public long add(long instant, long value) {
             } else {
                long localInstant = iZone.convertUTCToLocal(instant);
                localInstant = iField.add(localInstant, value);
+               return iZone.convertLocalToUTC(localInstant, false, instant);
             }
         }
 
@@ -457,14 +457,14 @@ public long addWrapField(long instant, int value) {
             } else {
                 long localInstant = iZone.convertUTCToLocal(instant);
                 localInstant = iField.addWrapField(localInstant, value);
+                return iZone.convertLocalToUTC(localInstant, false, instant);
             }
         }
 
         public long set(long instant, int value) {
             long localInstant = iZone.convertUTCToLocal(instant);
             localInstant = iField.set(localInstant, value);
+            long result = iZone.convertLocalToUTC(localInstant, false, instant);
             if (get(result) != value) {
                 throw new IllegalFieldValueException(iField.getType(), new Integer(value),
                     ""Illegal instant due to time zone offset transition: "" +
@@ -478,7 +478,7 @@ public long set(long instant, String text, Locale locale) {
             // cannot verify that new value stuck because set may be lenient
             long localInstant = iZone.convertUTCToLocal(instant);
             localInstant = iField.set(localInstant, text, locale);
+            return iZone.convertLocalToUTC(localInstant, false, instant);
         }
 
         public int getDifference(long minuendInstant, long subtrahendInstant) {
@@ -525,7 +525,7 @@ public long roundFloor(long instant) {
             } else {
                 long localInstant = iZone.convertUTCToLocal(instant);
                 localInstant = iField.roundFloor(localInstant);
+                return iZone.convertLocalToUTC(localInstant, false, instant);
             }
         }
 
@@ -537,7 +537,7 @@ public long roundCeiling(long instant) {
             } else {
                 long localInstant = iZone.convertUTCToLocal(instant);
                 localInstant = iField.roundCeiling(localInstant);
+                return iZone.convertLocalToUTC(localInstant, false, instant);
             }
         }
 
","@@ -433,7 +433,7 @@ public long add(long instant, int value) {
             } else {
                long localInstant = iZone.convertUTCToLocal(instant);
                localInstant = iField.add(localInstant, value);
+               return iZone.convertLocalToUTC(localInstant, false, instant);
             }
         }
 
@@ -445,7 +445,7 @@ public long add(long instant, long value) {
             } else {
                long localInstant = iZone.convertUTCToLocal(instant);
                localInstant = iField.add(localInstant, value);
+               return iZone.convertLocalToUTC(localInstant, false, instant);
             }
         }
 
@@ -457,14 +457,14 @@ public long addWrapField(long instant, int value) {
             } else {
                 long localInstant = iZone.convertUTCToLocal(instant);
                 localInstant = iField.addWrapField(localInstant, value);
+                return iZone.convertLocalToUTC(localInstant, false, instant);
             }
         }
 
         public long set(long instant, int value) {
             long localInstant = iZone.convertUTCToLocal(instant);
             localInstant = iField.set(localInstant, value);
+            long result = iZone.convertLocalToUTC(localInstant, false, instant);
             if (get(result) != value) {
                 throw new IllegalFieldValueException(iField.getType(), new Integer(value),
                     ""Illegal instant due to time zone offset transition: "" +
@@ -478,7 +478,7 @@ public long set(long instant, String text, Locale locale) {
             // cannot verify that new value stuck because set may be lenient
             long localInstant = iZone.convertUTCToLocal(instant);
             localInstant = iField.set(localInstant, text, locale);
+            return iZone.convertLocalToUTC(localInstant, false, instant);
         }
 
         public int getDifference(long minuendInstant, long subtrahendInstant) {
@@ -525,7 +525,7 @@ public long roundFloor(long instant) {
             } else {
                 long localInstant = iZone.convertUTCToLocal(instant);
                 localInstant = iField.roundFloor(localInstant);
+                return iZone.convertLocalToUTC(localInstant, false, instant);
             }
         }
 
@@ -537,7 +537,7 @@ public long roundCeiling(long instant) {
             } else {
                 long localInstant = iZone.convertUTCToLocal(instant);
                 localInstant = iField.roundCeiling(localInstant);
+                return iZone.convertLocalToUTC(localInstant, false, instant);
             }
         }
 
"
394,"junit.framework.AssertionFailedError","/src/main/java/org/joda/time/format/DateTimeParserBucket.java","@@ -352,6 +352,11 @@ public long computeMillis(boolean resetFields, String text) {
             for (int i = 0; i < count; i++) {
                 millis = savedFields[i].set(millis, resetFields);
             }
+            if (resetFields) {
+                for (int i = 0; i < count; i++) {
+                    millis = savedFields[i].set(millis, i == (count - 1));
+                }
+            }
         } catch (IllegalFieldValueException e) {
             if (text != null) {
                 e.prependMessage(""Cannot parse \"""" + text + '""');
","@@ -352,6 +352,11 @@ public long computeMillis(boolean resetFields, String text) {
             for (int i = 0; i < count; i++) {
                 millis = savedFields[i].set(millis, resetFields);
             }
+            if (resetFields) {
+                for (int i = 0; i < count; i++) {
+                    millis = savedFields[i].set(millis, i == (count - 1));
+                }
+            }
         } catch (IllegalFieldValueException e) {
             if (text != null) {
                 e.prependMessage(""Cannot parse \"""" + text + '""');
"
395,"java.lang.IllegalArgumentException","/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java","@@ -798,9 +798,11 @@ private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean no
         int size = elementPairs.size();
         if (size >= 2 && elementPairs.get(0) instanceof Separator) {
             Separator sep = (Separator) elementPairs.get(0);
+            if (sep.iAfterParser == null && sep.iAfterPrinter == null) {
                 PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);
                 sep = sep.finish(f.getPrinter(), f.getParser());
                 return new PeriodFormatter(sep, sep);
+            }
         }
         Object[] comp = createComposite(elementPairs);
         if (notPrinter) {
","@@ -798,9 +798,11 @@ private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean no
         int size = elementPairs.size();
         if (size >= 2 && elementPairs.get(0) instanceof Separator) {
             Separator sep = (Separator) elementPairs.get(0);
+            if (sep.iAfterParser == null && sep.iAfterPrinter == null) {
                 PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);
                 sep = sep.finish(f.getPrinter(), f.getParser());
                 return new PeriodFormatter(sep, sep);
+            }
         }
         Object[] comp = createComposite(elementPairs);
         if (notPrinter) {
"
