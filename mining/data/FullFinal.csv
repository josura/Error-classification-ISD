"ids","error","source","code","solution","CodeWithNoComments","SolutionWithNoComments"
1,"junit.framework.AssertionFailedError","/source/org/jfree/chart/util/ShapeList.java","@@ -108,7 +108,14 @@ public boolean equals(Object obj) {
         if (!(obj instanceof ShapeList)) {
             return false;
         }
         return super.equals(obj);
 
     }
 
","@@ -108,7 +108,14 @@ public boolean equals(Object obj) {
         if (!(obj instanceof ShapeList)) {
             return false;
         }
         ShapeList that = (ShapeList) obj;
         int listSize = size();
         for (int i = 0; i < listSize; i +) {
            if (!ShapeUtilities.equal((Shape) get(i), (Shape) that.get(i))) {
                return false;
            }
         }
         return true;
 
     }
 
","
         if (!(obj instanceof ShapeList)) {
             return false;
         }
         return super.equals(obj);
 
     }
 
","
         if (!(obj instanceof ShapeList)) {
             return false;
         }
         ShapeList that = (ShapeList) obj;
         int listSize = size();
         for (int i = 0; i < listSize; i +) {
            if (!ShapeUtilities.equal((Shape) get(i), (Shape) that.get(i))) {
                return false;
            }
         }
         return true;
 
     }
 
"
2,"junit.framework.ComparisonFailure","/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java","@@ -62,7 +62,7 @@ public StandardToolTipTagFragmentGenerator() {
      * @return The formatted HTML area tag attribute(s).
      */
     public String generateToolTipFragment(String toolTipText) {
        return "" title=\"""" + toolTipText
             + ""\"" alt=\""\"""";
     }
 
","@@ -62,7 +62,7 @@ public StandardToolTipTagFragmentGenerator() {
      * @return The formatted HTML area tag attribute(s).
      */
     public String generateToolTipFragment(String toolTipText) {
        return "" title=\"""" + ImageMapUtilities.htmlEscape(toolTipText) 
             + ""\"" alt=\""\"""";
     }
 
","
        return "" title=\"""" + toolTipText
             + ""\"" alt=\""\"""";
     }
 
","
        return "" title=\"""" + ImageMapUtilities.htmlEscape(toolTipText) 
             + ""\"" alt=\""\"""";
     }
 
"
3,"java.lang.IllegalArgumentException","/source/org/jfree/data/time/TimeSeries.java","@@ -941,7 +941,7 @@ public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)
             endIndex = -(endIndex + 1); // this is first item AFTER end period
             endIndex = endIndex - 1;    // so this is last item BEFORE end
         }
        if (endIndex < 0) {
             emptyRange = true;
         }
         if (emptyRange) {
","@@ -941,7 +941,7 @@ public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)
             endIndex = -(endIndex + 1); // this is first item AFTER end period
             endIndex = endIndex - 1;    // so this is last item BEFORE end
         }
        if ((endIndex < 0)  || (endIndex < startIndex)) {
             emptyRange = true;
         }
         if (emptyRange) {
","
             endIndex = -(endIndex + 1);              endIndex = endIndex - 1;             }
        if (endIndex < 0) {
             emptyRange = true;
         }
         if (emptyRange) {
","
             endIndex = -(endIndex + 1);              endIndex = endIndex - 1;             }
        if ((endIndex < 0)  || (endIndex < startIndex)) {
             emptyRange = true;
         }
         if (emptyRange) {
"
4,"junit.framework.AssertionFailedError","/source/org/jfree/data/time/Week.java","@@ -172,7 +172,7 @@ public Week(Date time) {
      */
     public Week(Date time, TimeZone zone) {
         // defer argument checking...
        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());
     }
 
     /**
","@@ -172,7 +172,7 @@ public Week(Date time) {
      */
     public Week(Date time, TimeZone zone) {
         // defer argument checking...
        this(time, zone, Locale.getDefault());
     }
 
     /**
","
  
     public Week(Date time, TimeZone zone) {
                 this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());
     }
 
","
    
     public Week(Date time, TimeZone zone) {
                 this(time, zone, Locale.getDefault());
     }
 
"
5,"junit.framework.AssertionFailedError","/source/org/jfree/data/time/TimePeriodValues.java","@@ -297,9 +297,9 @@ private void updateBounds(TimePeriod period, int index) {
         }
         
         if (this.maxMiddleIndex >= 0) {
          long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()
                 .getTime();
          long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()
                 .getTime();
             long maxMiddle = s + (e - s) / 2;
             if (middle > maxMiddle) {
","@@ -297,9 +297,9 @@ private void updateBounds(TimePeriod period, int index) {
         }
         
         if (this.maxMiddleIndex >= 0) {
          long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()
                 .getTime();
          long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()
                 .getTime();
             long maxMiddle = s + (e - s) / 2;
             if (middle > maxMiddle) {
","
         }
         
         if (this.maxMiddleIndex >= 0) {
            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()
                 .getTime();
            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()
                 .getTime();
             long maxMiddle = s + (e - s) / 2;
             if (middle > maxMiddle) {
","
         }
         
         if (this.maxMiddleIndex >= 0) {
            long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()
                 .getTime();
            long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()
                 .getTime();
             long maxMiddle = s + (e - s) / 2;
             if (middle > maxMiddle) {
"
6,"java.lang.IndexOutOfBoundsException","/source/org/jfree/data/xy/XYSeries.java","@@ -541,11 +541,15 @@ public XYDataItem addOrUpdate(Number x, Number y) {
         if (x == null) {
             throw new IllegalArgumentException(""Null 'x' argument."");
         }
 
         // if we get to here, we know that duplicate X values are not permitted
         XYDataItem overwritten = null;
         int index = indexOf(x);
      if (index >= 0 && !this.allowDuplicateXValues) {
             XYDataItem existing = (XYDataItem) this.data.get(index);
             try {
                 overwritten = (XYDataItem) existing.clone();
","@@ -541,11 +541,15 @@ public XYDataItem addOrUpdate(Number x, Number y) {
         if (x == null) {
             throw new IllegalArgumentException(""Null 'x' argument."");
         }
      if (this.allowDuplicateXValues) {
          add(x, y);
          return null;
      }
 
         // if we get to here, we know that duplicate X values are not permitted
         XYDataItem overwritten = null;
         int index = indexOf(x);
      if (index >= 0) {
             XYDataItem existing = (XYDataItem) this.data.get(index);
             try {
                 overwritten = (XYDataItem) existing.clone();
","
         if (x == null) {
             throw new IllegalArgumentException(""Null 'x' argument."");
         }
 
                  XYDataItem overwritten = null;
         int index = indexOf(x);
        if (index >= 0 && !this.allowDuplicateXValues) {
             XYDataItem existing = (XYDataItem) this.data.get(index);
             try {
                 overwritten = (XYDataItem) existing.clone();
","
         if (x == null) {
             throw new IllegalArgumentException(""Null 'x' argument."");
         }
        if (this.allowDuplicateXValues) {
            add(x, y);
            return null;
        }
 
                  XYDataItem overwritten = null;
         int index = indexOf(x);
        if (index >= 0) {
             XYDataItem existing = (XYDataItem) this.data.get(index);
             try {
                 overwritten = (XYDataItem) existing.clone();
"
7,"junit.framework.AssertionFailedError","/source/org/jfree/data/time/TimeSeries.java","@@ -1054,6 +1054,8 @@ public TimeSeries createCopy(int start, int end)
             throw new IllegalArgumentException(""Requires start <= end."");
         }
         TimeSeries copy = (TimeSeries) super.clone();
         copy.data = new java.util.ArrayList();
         if (this.data.size() > 0) {
             for (int index = start; index <= end; index++) {
","@@ -1054,6 +1054,8 @@ public TimeSeries createCopy(int start, int end)
             throw new IllegalArgumentException(""Requires start <= end."");
         }
         TimeSeries copy = (TimeSeries) super.clone();
      copy.minY = Double.NaN;
      copy.maxY = Double.NaN;
         copy.data = new java.util.ArrayList();
         if (this.data.size() > 0) {
             for (int index = start; index <= end; index++) {
","
             throw new IllegalArgumentException(""Requires start <= end."");
         }
         TimeSeries copy = (TimeSeries) super.clone();
         copy.data = new java.util.ArrayList();
         if (this.data.size() > 0) {
             for (int index = start; index <= end; index++) {
","
             throw new IllegalArgumentException(""Requires start <= end."");
         }
         TimeSeries copy = (TimeSeries) super.clone();
        copy.minY = Double.NaN;
        copy.maxY = Double.NaN;
         copy.data = new java.util.ArrayList();
         if (this.data.size() > 0) {
             for (int index = start; index <= end; index++) {
"
8,"java.lang.NullPointerException","/source/org/jfree/chart/plot/XYPlot.java","@@ -4490,6 +4490,7 @@ public Range getDataRange(ValueAxis axis) {
                     }
                 }
                 
                     Collection c = r.getAnnotations();
                     Iterator i = c.iterator();
                     while (i.hasNext()) {
@@ -4498,6 +4499,7 @@ public Range getDataRange(ValueAxis axis) {
                             includedAnnotations.add(a);
                         }
                     }
             }
         }
 
","@@ -4490,6 +4490,7 @@ public Range getDataRange(ValueAxis axis) {
                     }
                 }
                 
              if (r != null) {
                     Collection c = r.getAnnotations();
                     Iterator i = c.iterator();
                     while (i.hasNext()) {
@@ -4498,6 +4499,7 @@ public Range getDataRange(ValueAxis axis) {
                             includedAnnotations.add(a);
                         }
                     }
              }
             }
         }
 
","
                     }
                 }
                 
                     Collection c = r.getAnnotations();
                     Iterator i = c.iterator();
                     while (i.hasNext()) {

                             includedAnnotations.add(a);
                         }
                     }
             }
         }
 
","
                     }
                 }
                 
                if (r != null) {
                     Collection c = r.getAnnotations();
                     Iterator i = c.iterator();
                     while (i.hasNext()) {

                             includedAnnotations.add(a);
                         }
                     }
                }
             }
         }
 
"
9,"java.lang.NullPointerException","/source/org/jfree/data/general/DatasetUtilities.java","@@ -752,12 +752,19 @@ public static Range iterateDomainBounds(XYDataset dataset,
             for (int series = 0; series < seriesCount; series++) {
                 int itemCount = dataset.getItemCount(series);
                 for (int item = 0; item < itemCount; item++) {
                     lvalue = intervalXYData.getStartXValue(series, item);
                     uvalue = intervalXYData.getEndXValue(series, item);
                     if (!Double.isNaN(lvalue)) {
                         minimum = Math.min(minimum, lvalue);
                     }
                     if (!Double.isNaN(uvalue)) {
                         maximum = Math.max(maximum, uvalue);
                     }
                 }
@@ -1239,12 +1246,19 @@ public static Range iterateRangeBounds(XYDataset dataset,
             for (int series = 0; series < seriesCount; series++) {
                 int itemCount = dataset.getItemCount(series);
                 for (int item = 0; item < itemCount; item++) {
                     double lvalue = ixyd.getStartYValue(series, item);
                     double uvalue = ixyd.getEndYValue(series, item);
                     if (!Double.isNaN(lvalue)) {
                         minimum = Math.min(minimum, lvalue);
                     }
                     if (!Double.isNaN(uvalue)) {
                         maximum = Math.max(maximum, uvalue);
                     }
                 }
","@@ -752,12 +752,19 @@ public static Range iterateDomainBounds(XYDataset dataset,
             for (int series = 0; series < seriesCount; series++) {
                 int itemCount = dataset.getItemCount(series);
                 for (int item = 0; item < itemCount; item++) {
                  double value = intervalXYData.getXValue(series, item);
                     lvalue = intervalXYData.getStartXValue(series, item);
                     uvalue = intervalXYData.getEndXValue(series, item);
                  if (!Double.isNaN(value)) {
                      minimum = Math.min(minimum, value);
                      maximum = Math.max(maximum, value);
                  }
                     if (!Double.isNaN(lvalue)) {
                         minimum = Math.min(minimum, lvalue);
                      maximum = Math.max(maximum, lvalue);
                     }
                     if (!Double.isNaN(uvalue)) {
                      minimum = Math.min(minimum, uvalue);
                         maximum = Math.max(maximum, uvalue);
                     }
                 }
@@ -1239,12 +1246,19 @@ public static Range iterateRangeBounds(XYDataset dataset,
             for (int series = 0; series < seriesCount; series++) {
                 int itemCount = dataset.getItemCount(series);
                 for (int item = 0; item < itemCount; item++) {
                  double value = ixyd.getYValue(series, item);
                     double lvalue = ixyd.getStartYValue(series, item);
                     double uvalue = ixyd.getEndYValue(series, item);
                  if (!Double.isNaN(value)) {
                      minimum = Math.min(minimum, value);
                      maximum = Math.max(maximum, value);
                  }
                     if (!Double.isNaN(lvalue)) {
                         minimum = Math.min(minimum, lvalue);
                      maximum = Math.max(maximum, lvalue);
                     }
                     if (!Double.isNaN(uvalue)) {
                      minimum = Math.min(minimum, uvalue);
                         maximum = Math.max(maximum, uvalue);
                     }
                 }
","
             for (int series = 0; series < seriesCount; series++) {
                 int itemCount = dataset.getItemCount(series);
                 for (int item = 0; item < itemCount; item++) {
                     lvalue = intervalXYData.getStartXValue(series, item);
                     uvalue = intervalXYData.getEndXValue(series, item);
                     if (!Double.isNaN(lvalue)) {
                         minimum = Math.min(minimum, lvalue);
                     }
                     if (!Double.isNaN(uvalue)) {
                         maximum = Math.max(maximum, uvalue);
                     }
                 }

             for (int series = 0; series < seriesCount; series++) {
                 int itemCount = dataset.getItemCount(series);
                 for (int item = 0; item < itemCount; item++) {
                     double lvalue = ixyd.getStartYValue(series, item);
                     double uvalue = ixyd.getEndYValue(series, item);
                     if (!Double.isNaN(lvalue)) {
                         minimum = Math.min(minimum, lvalue);
                     }
                     if (!Double.isNaN(uvalue)) {
                         maximum = Math.max(maximum, uvalue);
                     }
                 }
","
             for (int series = 0; series < seriesCount; series++) {
                 int itemCount = dataset.getItemCount(series);
                 for (int item = 0; item < itemCount; item++) {
                    double value = intervalXYData.getXValue(series, item);
                     lvalue = intervalXYData.getStartXValue(series, item);
                     uvalue = intervalXYData.getEndXValue(series, item);
                    if (!Double.isNaN(value)) {
                        minimum = Math.min(minimum, value);
                        maximum = Math.max(maximum, value);
                    }
                     if (!Double.isNaN(lvalue)) {
                         minimum = Math.min(minimum, lvalue);
                        maximum = Math.max(maximum, lvalue);
                     }
                     if (!Double.isNaN(uvalue)) {
                        minimum = Math.min(minimum, uvalue);
                         maximum = Math.max(maximum, uvalue);
                     }
                 }

             for (int series = 0; series < seriesCount; series++) {
                 int itemCount = dataset.getItemCount(series);
                 for (int item = 0; item < itemCount; item++) {
                    double value = ixyd.getYValue(series, item);
                     double lvalue = ixyd.getStartYValue(series, item);
                     double uvalue = ixyd.getEndYValue(series, item);
                    if (!Double.isNaN(value)) {
                        minimum = Math.min(minimum, value);
                        maximum = Math.max(maximum, value);
                    }
                     if (!Double.isNaN(lvalue)) {
                         minimum = Math.min(minimum, lvalue);
                        maximum = Math.max(maximum, lvalue);
                     }
                     if (!Double.isNaN(uvalue)) {
                        minimum = Math.min(minimum, uvalue);
                         maximum = Math.max(maximum, uvalue);
                     }
                 }
"
10,"junit.framework.AssertionFailedError","/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java","@@ -1794,7 +1794,7 @@ public LegendItemCollection getLegendItems() {
         }
         int index = this.plot.getIndexOf(this);
         CategoryDataset dataset = this.plot.getDataset(index);
      if (dataset != null) {
             return result;
         }
         int seriesCount = dataset.getRowCount();
","@@ -1794,7 +1794,7 @@ public LegendItemCollection getLegendItems() {
         }
         int index = this.plot.getIndexOf(this);
         CategoryDataset dataset = this.plot.getDataset(index);
      if (dataset == null) {
             return result;
         }
         int seriesCount = dataset.getRowCount();
","
         }
         int index = this.plot.getIndexOf(this);
         CategoryDataset dataset = this.plot.getDataset(index);
        if (dataset != null) {
             return result;
         }
         int seriesCount = dataset.getRowCount();
","
         }
         int index = this.plot.getIndexOf(this);
         CategoryDataset dataset = this.plot.getDataset(index);
        if (dataset == null) {
             return result;
         }
         int seriesCount = dataset.getRowCount();
"
11,"junit.framework.AssertionFailedError","/source/org/jfree/chart/plot/MultiplePiePlot.java","@@ -142,7 +142,7 @@ public MultiplePiePlot() {
      */
     public MultiplePiePlot(CategoryDataset dataset) {
         super();
      this.dataset = dataset;
         PiePlot piePlot = new PiePlot(null);
         this.pieChart = new JFreeChart(piePlot);
         this.pieChart.removeLegend();
","@@ -142,7 +142,7 @@ public MultiplePiePlot() {
      */
     public MultiplePiePlot(CategoryDataset dataset) {
         super();
      setDataset(dataset);
         PiePlot piePlot = new PiePlot(null);
         this.pieChart = new JFreeChart(piePlot);
         this.pieChart.removeLegend();
","
      
     public MultiplePiePlot(CategoryDataset dataset) {
         super();
        this.dataset = dataset;
         PiePlot piePlot = new PiePlot(null);
         this.pieChart = new JFreeChart(piePlot);
         this.pieChart.removeLegend();
","
      
     public MultiplePiePlot(CategoryDataset dataset) {
         super();
        setDataset(dataset);
         PiePlot piePlot = new PiePlot(null);
         this.pieChart = new JFreeChart(piePlot);
         this.pieChart.removeLegend();
"
12,"junit.framework.AssertionFailedError","/source/org/jfree/chart/util/ShapeUtilities.java","@@ -272,7 +272,7 @@ public static boolean equal(GeneralPath p1, GeneralPath p2) {
             return false;
         }
         PathIterator iterator1 = p1.getPathIterator(null);
      PathIterator iterator2 = p1.getPathIterator(null);
         double[] d1 = new double[6];
         double[] d2 = new double[6];
         boolean done = iterator1.isDone() && iterator2.isDone();
","@@ -272,7 +272,7 @@ public static boolean equal(GeneralPath p1, GeneralPath p2) {
             return false;
         }
         PathIterator iterator1 = p1.getPathIterator(null);
      PathIterator iterator2 = p2.getPathIterator(null);
         double[] d1 = new double[6];
         double[] d2 = new double[6];
         boolean done = iterator1.isDone() && iterator2.isDone();
","
             return false;
         }
         PathIterator iterator1 = p1.getPathIterator(null);
        PathIterator iterator2 = p1.getPathIterator(null);
         double[] d1 = new double[6];
         double[] d2 = new double[6];
         boolean done = iterator1.isDone() && iterator2.isDone();
","
             return false;
         }
         PathIterator iterator1 = p1.getPathIterator(null);
        PathIterator iterator2 = p2.getPathIterator(null);
         double[] d1 = new double[6];
         double[] d2 = new double[6];
         boolean done = iterator1.isDone() && iterator2.isDone();
"
13,"java.lang.IllegalArgumentException","/source/org/jfree/chart/block/BorderArrangement.java","@@ -452,7 +452,7 @@ protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,
         h[3] = h[2];
         if (this.rightBlock != null) {
             RectangleConstraint c4 = new RectangleConstraint(0.0,
                  new Range(0.0, constraint.getWidth() - w[2]),
                     LengthConstraintType.RANGE, h[2], null,
                     LengthConstraintType.FIXED);
             Size2D size = this.rightBlock.arrange(g2, c4);
","@@ -452,7 +452,7 @@ protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,
         h[3] = h[2];
         if (this.rightBlock != null) {
             RectangleConstraint c4 = new RectangleConstraint(0.0,
                  new Range(0.0, Math.max(constraint.getWidth() - w[2], 0.0)),
                     LengthConstraintType.RANGE, h[2], null,
                     LengthConstraintType.FIXED);
             Size2D size = this.rightBlock.arrange(g2, c4);
","
         h[3] = h[2];
         if (this.rightBlock != null) {
             RectangleConstraint c4 = new RectangleConstraint(0.0,
                    new Range(0.0, constraint.getWidth() - w[2]),
                     LengthConstraintType.RANGE, h[2], null,
                     LengthConstraintType.FIXED);
             Size2D size = this.rightBlock.arrange(g2, c4);
","
         h[3] = h[2];
         if (this.rightBlock != null) {
             RectangleConstraint c4 = new RectangleConstraint(0.0,
                    new Range(0.0, Math.max(constraint.getWidth() - w[2], 0.0)),
                     LengthConstraintType.RANGE, h[2], null,
                     LengthConstraintType.FIXED);
             Size2D size = this.rightBlock.arrange(g2, c4);
"
14,"java.lang.IndexOutOfBoundsException","/source/org/jfree/data/DefaultKeyedValues.java","@@ -315,30 +315,29 @@ private void rebuildIndex () {
     public void removeValue(int index) {
         this.keys.remove(index);
         this.values.remove(index);
      if (index < this.keys.size()) {
         rebuildIndex();
      }
     }
 
     /**
      * Removes a value from the collection.
      *
      * @param key  the item key (<code>null</code> not permitted).
      * 
      * @throws IllegalArgumentException if <code>key</code> is 
      *     <code>null</code>.
      * @throws UnknownKeyException if <code>key</code> is not recognised.
      */
     public void removeValue(Comparable key) {
         int index = getIndex(key);
         if (index < 0) {
		return;
         }
         removeValue(index);
     }
     
     /**
      * Clears all values from the collection.
      * 
      * @since 1.0.2
      */
/source/org/jfree/data/DefaultKeyedValues2D.java @@ -454,12 +454,21 @@ public void removeColumn(int columnIndex) {
     public void removeColumn(Comparable columnKey) {
         Iterator iterator = this.rows.iterator();
         while (iterator.hasNext()) {
             DefaultKeyedValues rowData = (DefaultKeyedValues) iterator.next();
                 rowData.removeValue(columnKey);
         }
         this.columnKeys.remove(columnKey);
     }
 
     /**
      * Clears all the data and associated keys.
      */
","@@ -315,30 +315,29 @@ private void rebuildIndex () {
     public void removeValue(int index) {
         this.keys.remove(index);
         this.values.remove(index);
         rebuildIndex();
     }
 
     /**
      * Removes a value from the collection.
      *
      * @param key  the item key (<code>null</code> not permitted).
      * 
      * @throws IllegalArgumentException if <code>key</code> is 
      *     <code>null</code>.
      * @throws UnknownKeyException if <code>key</code> is not recognised.
      */
     public void removeValue(Comparable key) {
         int index = getIndex(key);
         if (index < 0) {
          throw new UnknownKeyException(""The key ("" + key 
                  + "") is not recognised."");
         }
         removeValue(index);
     }
     
     /**
      * Clears all values from the collection.
      * 
      * @since 1.0.2
      */
/source/org/jfree/data/DefaultKeyedValues2D.java @@ -454,12 +454,21 @@ public void removeColumn(int columnIndex) {
     public void removeColumn(Comparable columnKey) {
  	if (columnKey == null) {
  		throw new IllegalArgumentException(""Null 'columnKey' argument."");
  	}
  	if (!this.columnKeys.contains(columnKey)) {
  		throw new UnknownKeyException(""Unknown key: "" + columnKey);
  	}
         Iterator iterator = this.rows.iterator();
         while (iterator.hasNext()) {
             DefaultKeyedValues rowData = (DefaultKeyedValues) iterator.next();
          int index = rowData.getIndex(columnKey);
          if (index >= 0) {
                 rowData.removeValue(columnKey);
          }
         }
         this.columnKeys.remove(columnKey);
     }
 
     /**
      * Clears all the data and associated keys.
      */
","
     public void removeValue(int index) {
         this.keys.remove(index);
         this.values.remove(index);
        if (index < this.keys.size()) {
         rebuildIndex();
        }
     }
 
     public void removeValue(Comparable key) {
         int index = getIndex(key);
         if (index < 0) {
			return;
         }
         removeValue(index);
     }
  

     public void removeColumn(Comparable columnKey) {
         Iterator iterator = this.rows.iterator();
         while (iterator.hasNext()) {
             DefaultKeyedValues rowData = (DefaultKeyedValues) iterator.next();
                 rowData.removeValue(columnKey);
         }
         this.columnKeys.remove(columnKey);
     }
 
     
","
     public void removeValue(int index) {
         this.keys.remove(index);
         this.values.remove(index);
         rebuildIndex();
     }
 
     
     public void removeValue(Comparable key) {
         int index = getIndex(key);
         if (index < 0) {
            throw new UnknownKeyException(""The key ("" + key 
                    + "") is not recognised."");
         }
         removeValue(index);
     }
     
     

     public void removeColumn(Comparable columnKey) {
    	if (columnKey == null) {
    		throw new IllegalArgumentException(""Null 'columnKey' argument."");
    	}
    	if (!this.columnKeys.contains(columnKey)) {
    		throw new UnknownKeyException(""Unknown key: "" + columnKey);
    	}
         Iterator iterator = this.rows.iterator();
         while (iterator.hasNext()) {
             DefaultKeyedValues rowData = (DefaultKeyedValues) iterator.next();
            int index = rowData.getIndex(columnKey);
            if (index >= 0) {
                 rowData.removeValue(columnKey);
            }
         }
         this.columnKeys.remove(columnKey);
     }
 
     
"
15,"java.lang.NullPointerException","/source/org/jfree/chart/plot/CategoryPlot.java","@@ -2163,6 +2163,9 @@ public boolean removeDomainMarker(int index, Marker marker, Layer layer,
             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(
                     index));
         }
         boolean removed = markers.remove(marker);
         if (removed && notify) {
             fireChangeEvent();
@@ -2445,6 +2448,9 @@ public boolean removeRangeMarker(int index, Marker marker, Layer layer,
             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(
                     index));
         }
         boolean removed = markers.remove(marker);
         if (removed && notify) {
             fireChangeEvent();
/source/org/jfree/chart/plot/XYPlot.java @@ -2290,6 +2290,9 @@ public boolean removeDomainMarker(int index, Marker marker, Layer layer,
             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(
                     index));
         }
         boolean removed = markers.remove(marker);
         if (removed && notify) {
             fireChangeEvent();
@@ -2526,6 +2529,9 @@ public boolean removeRangeMarker(int index, Marker marker, Layer layer,
             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(
                     index));
         }
         boolean removed = markers.remove(marker);
         if (removed && notify) {
             fireChangeEvent();
","@@ -2163,6 +2163,9 @@ public boolean removeDomainMarker(int index, Marker marker, Layer layer,
             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(
                     index));
         }
      if (markers == null) {
          return false;
      }
         boolean removed = markers.remove(marker);
         if (removed && notify) {
             fireChangeEvent();
@@ -2445,6 +2448,9 @@ public boolean removeRangeMarker(int index, Marker marker, Layer layer,
             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(
                     index));
         }
      if (markers == null) {
          return false;
      }
         boolean removed = markers.remove(marker);
         if (removed && notify) {
             fireChangeEvent();
/source/org/jfree/chart/plot/XYPlot.java @@ -2290,6 +2290,9 @@ public boolean removeDomainMarker(int index, Marker marker, Layer layer,
             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(
                     index));
         }
      if (markers == null) {
          return false;
      }
         boolean removed = markers.remove(marker);
         if (removed && notify) {
             fireChangeEvent();
@@ -2526,6 +2529,9 @@ public boolean removeRangeMarker(int index, Marker marker, Layer layer,
             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(
                     index));
         }
      if (markers == null) {
          return false;
      }
         boolean removed = markers.remove(marker);
         if (removed && notify) {
             fireChangeEvent();
","
             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(
                     index));
         }
         boolean removed = markers.remove(marker);
         if (removed && notify) {
             fireChangeEvent();

             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(
                     index));
         }
         boolean removed = markers.remove(marker);
         if (removed && notify) {
             fireChangeEvent();

             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(
                     index));
         }
         boolean removed = markers.remove(marker);
         if (removed && notify) {
             fireChangeEvent();

             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(
                     index));
         }
         boolean removed = markers.remove(marker);
         if (removed && notify) {
             fireChangeEvent();
","
             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(
                     index));
         }
        if (markers == null) {
            return false;
        }
         boolean removed = markers.remove(marker);
         if (removed && notify) {
             fireChangeEvent();

             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(
                     index));
         }
        if (markers == null) {
            return false;
        }
         boolean removed = markers.remove(marker);
         if (removed && notify) {
             fireChangeEvent();

             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(
                     index));
         }
        if (markers == null) {
            return false;
        }
         boolean removed = markers.remove(marker);
         if (removed && notify) {
             fireChangeEvent();

             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(
                     index));
         }
        if (markers == null) {
            return false;
        }
         boolean removed = markers.remove(marker);
         if (removed && notify) {
             fireChangeEvent();
"
16,"junit.framework.AssertionFailedError","/source/org/jfree/data/statistics/DefaultBoxAndWhiskerCategoryDataset.java","@@ -154,6 +154,7 @@ public void add(BoxAndWhiskerItem item, Comparable rowKey,
                 && this.minimumRangeValueColumn == c))  {
             updateBounds();
         }
             double minval = Double.NaN;
             if (item.getMinOutlier() != null) {
@@ -185,6 +186,7 @@ else if (minval < this.minimumRangeValue) {
                 this.minimumRangeValueRow = r;
                 this.minimumRangeValueColumn = c;
             }
         this.rangeBounds = new Range(this.minimumRangeValue,
               this.maximumRangeValue);
@@ -738,7 +740,44 @@ public List getOutliers(Comparable rowKey, Comparable columnKey) {
      */
     private void updateBounds() {
         this.minimumRangeValue = Double.NaN;
         this.maximumRangeValue = Double.NaN;
     }
     
     /**
","@@ -154,6 +154,7 @@ public void add(BoxAndWhiskerItem item, Comparable rowKey,
                 && this.minimumRangeValueColumn == c))  {
             updateBounds();
         }
      else {
         
             double minval = Double.NaN;
             if (item.getMinOutlier() != null) {
@@ -185,6 +186,7 @@ else if (minval < this.minimumRangeValue) {
                 this.minimumRangeValueRow = r;
                 this.minimumRangeValueColumn = c;
             }
      }
         
         this.rangeBounds = new Range(this.minimumRangeValue,
               this.maximumRangeValue);
@@ -738,7 +740,44 @@ public List getOutliers(Comparable rowKey, Comparable columnKey) {
      */
     private void updateBounds() {
         this.minimumRangeValue = Double.NaN;
      this.minimumRangeValueRow = -1;
      this.minimumRangeValueColumn = -1;
         this.maximumRangeValue = Double.NaN;
      this.maximumRangeValueRow = -1;
      this.maximumRangeValueColumn = -1;
      int rowCount = getRowCount();
      int columnCount = getColumnCount();
      for (int r = 0; r < rowCount; r++) {
          for (int c = 0; c < columnCount; c++) {
              BoxAndWhiskerItem item = getItem(r, c);
              if (item != null) {
                  Number min = item.getMinOutlier();
                  if (min != null) {
                      double minv = min.doubleValue();
                      if (!Double.isNaN(minv)) {
                          if (minv < this.minimumRangeValue || Double.isNaN(
                                  this.minimumRangeValue)) {
                              this.minimumRangeValue = minv;
                              this.minimumRangeValueRow = r;
                              this.minimumRangeValueColumn = c;
                          }
                      }
                  }
                  Number max = item.getMaxOutlier();
                  if (max != null) {
                      double maxv = max.doubleValue();
                      if (!Double.isNaN(maxv)) {
                          if (maxv > this.maximumRangeValue || Double.isNaN(
                                  this.maximumRangeValue)) {
                              this.maximumRangeValue = maxv;
                              this.maximumRangeValueRow = r;
                              this.maximumRangeValueColumn = c;
                          }
                      }
                  }
              }
          }
      }
     }
     
     /**
","
                 && this.minimumRangeValueColumn == c))  {
             updateBounds();
         }
             double minval = Double.NaN;
             if (item.getMinOutlier() != null) {

                 this.minimumRangeValueRow = r;
                 this.minimumRangeValueColumn = c;
             }
         this.rangeBounds = new Range(this.minimumRangeValue,
               this.maximumRangeValue);

      
     private void updateBounds() {
         this.minimumRangeValue = Double.NaN;
         this.maximumRangeValue = Double.NaN;
     }
","
                 && this.minimumRangeValueColumn == c))  {
             updateBounds();
         }
        else {
         
             double minval = Double.NaN;
             if (item.getMinOutlier() != null) {

                 this.minimumRangeValueRow = r;
                 this.minimumRangeValueColumn = c;
             }
        }
         
         this.rangeBounds = new Range(this.minimumRangeValue,
               this.maximumRangeValue);

      
     private void updateBounds() {
         this.minimumRangeValue = Double.NaN;
        this.minimumRangeValueRow = -1;
        this.minimumRangeValueColumn = -1;
         this.maximumRangeValue = Double.NaN;
        this.maximumRangeValueRow = -1;
        this.maximumRangeValueColumn = -1;
        int rowCount = getRowCount();
        int columnCount = getColumnCount();
        for (int r = 0; r < rowCount; r++) {
            for (int c = 0; c < columnCount; c++) {
                BoxAndWhiskerItem item = getItem(r, c);
                if (item != null) {
                    Number min = item.getMinOutlier();
                    if (min != null) {
                        double minv = min.doubleValue();
                        if (!Double.isNaN(minv)) {
                            if (minv < this.minimumRangeValue || Double.isNaN(
                                    this.minimumRangeValue)) {
                                this.minimumRangeValue = minv;
                                this.minimumRangeValueRow = r;
                                this.minimumRangeValueColumn = c;
                            }
                        }
                    }
                    Number max = item.getMaxOutlier();
                    if (max != null) {
                        double maxv = max.doubleValue();
                        if (!Double.isNaN(maxv)) {
                            if (maxv > this.maximumRangeValue || Double.isNaN(
                                    this.maximumRangeValue)) {
                                this.maximumRangeValue = maxv;
                                this.maximumRangeValueRow = r;
                                this.maximumRangeValueColumn = c;
                            }
                        }
                    }
                }
            }
        }
     }
     
"
17,"junit.framework.AssertionFailedError","/source/org/jfree/chart/plot/PiePlot.java","@@ -1375,6 +1375,9 @@ public void setExplodePercent(Comparable key, double percent) {
      * @return The percent.
      */
     public double getMaximumExplodePercent() {
         double result = 0.0;
         Iterator iterator = this.dataset.getKeys().iterator();
         while (iterator.hasNext()) {
@@ -2048,8 +2051,10 @@ public PiePlotState initialise(Graphics2D g2, Rectangle2D plotArea,
      
         PiePlotState state = new PiePlotState(info);
         state.setPassesRequired(2);
             state.setTotal(DatasetUtilities.calculatePieDatasetTotal(
                     plot.getDataset()));
         state.setLatestAngle(plot.getStartAngle());
         return state;
         
","@@ -1375,6 +1375,9 @@ public void setExplodePercent(Comparable key, double percent) {
      * @return The percent.
      */
     public double getMaximumExplodePercent() {
      if (this.dataset == null) {
          return 0.0;
      }
         double result = 0.0;
         Iterator iterator = this.dataset.getKeys().iterator();
         while (iterator.hasNext()) {
@@ -2048,8 +2051,10 @@ public PiePlotState initialise(Graphics2D g2, Rectangle2D plotArea,
      
         PiePlotState state = new PiePlotState(info);
         state.setPassesRequired(2);
      if (this.dataset != null) {
             state.setTotal(DatasetUtilities.calculatePieDatasetTotal(
                     plot.getDataset()));
      }
         state.setLatestAngle(plot.getStartAngle());
         return state;
         
","
         double result = 0.0;
         Iterator iterator = this.dataset.getKeys().iterator();
         while (iterator.hasNext()) {

      
         PiePlotState state = new PiePlotState(info);
         state.setPassesRequired(2);
             state.setTotal(DatasetUtilities.calculatePieDatasetTotal(
                     plot.getDataset()));
         state.setLatestAngle(plot.getStartAngle());
         return state;
         
","
     public double getMaximumExplodePercent() {
        if (this.dataset == null) {
            return 0.0;
        }
         double result = 0.0;
         Iterator iterator = this.dataset.getKeys().iterator();
         while (iterator.hasNext()) {

      
         PiePlotState state = new PiePlotState(info);
         state.setPassesRequired(2);
        if (this.dataset != null) {
             state.setTotal(DatasetUtilities.calculatePieDatasetTotal(
                     plot.getDataset()));
        }
         state.setLatestAngle(plot.getStartAngle());
         return state;
         
"
18,"java.lang.NullPointerException","/source/org/jfree/data/category/DefaultIntervalCategoryDataset.java","@@ -204,8 +204,8 @@ public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,
 
             }
             else {
              this.seriesKeys = null;
              this.categoryKeys = null;
             }
         }
 
@@ -335,7 +335,7 @@ public void setCategoryKeys(Comparable[] categoryKeys) {
         if (categoryKeys == null) {
             throw new IllegalArgumentException(""Null 'categoryKeys' argument."");
         }
      if (categoryKeys.length != this.startData[0].length) {
             throw new IllegalArgumentException(
                     ""The number of categories does not match the data."");
         }
","@@ -204,8 +204,8 @@ public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,
 
             }
             else {
              this.seriesKeys = new Comparable[0];
              this.categoryKeys = new Comparable[0];
             }
         }
 
@@ -335,7 +335,7 @@ public void setCategoryKeys(Comparable[] categoryKeys) {
         if (categoryKeys == null) {
             throw new IllegalArgumentException(""Null 'categoryKeys' argument."");
         }
      if (categoryKeys.length != getCategoryCount()) {
             throw new IllegalArgumentException(
                     ""The number of categories does not match the data."");
         }
","
 
             }
             else {
                this.seriesKeys = null;
                this.categoryKeys = null;
             }
         }
 

         if (categoryKeys == null) {
             throw new IllegalArgumentException(""Null 'categoryKeys' argument."");
         }
        if (categoryKeys.length != this.startData[0].length) {
             throw new IllegalArgumentException(
                     ""The number of categories does not match the data."");
         }
","
 
             }
             else {
                this.seriesKeys = new Comparable[0];
                this.categoryKeys = new Comparable[0];
             }
         }
 

         if (categoryKeys == null) {
             throw new IllegalArgumentException(""Null 'categoryKeys' argument."");
         }
        if (categoryKeys.length != getCategoryCount()) {
             throw new IllegalArgumentException(
                     ""The number of categories does not match the data."");
         }
"
19,"java.lang.IllegalArgumentException","/source/org/jfree/data/time/TimeSeries.java","@@ -854,7 +854,8 @@ public void delete(int start, int end) {
      *         subclasses may differ.
      */
     public Object clone() throws CloneNotSupportedException {
      Object clone = createCopy(0, getItemCount() - 1);
         return clone;
     }
 
","@@ -854,7 +854,8 @@ public void delete(int start, int end) {
      *         subclasses may differ.
      */
     public Object clone() throws CloneNotSupportedException {
      TimeSeries clone = (TimeSeries) super.clone();
      clone.data = (List) ObjectUtilities.deepClone(this.data);
         return clone;
     }
 
","
        Object clone = createCopy(0, getItemCount() - 1);
         return clone;
     }
 
","
        TimeSeries clone = (TimeSeries) super.clone();
        clone.data = (List) ObjectUtilities.deepClone(this.data);
         return clone;
     }
 
"
20,"junit.framework.AssertionFailedError","/source/org/jfree/chart/plot/ValueMarker.java","@@ -92,7 +92,7 @@ public ValueMarker(double value, Paint paint, Stroke stroke) {
      */
     public ValueMarker(double value, Paint paint, Stroke stroke, 
                        Paint outlinePaint, Stroke outlineStroke, float alpha) {
      super(paint, stroke, paint, stroke, alpha);
         this.value = value;
     }
     
","@@ -92,7 +92,7 @@ public ValueMarker(double value, Paint paint, Stroke stroke) {
      */
     public ValueMarker(double value, Paint paint, Stroke stroke, 
                        Paint outlinePaint, Stroke outlineStroke, float alpha) {
      super(paint, stroke, outlinePaint, outlineStroke, alpha);
         this.value = value;
     }
     
","
      
     public ValueMarker(double value, Paint paint, Stroke stroke, 
                        Paint outlinePaint, Stroke outlineStroke, float alpha) {
        super(paint, stroke, paint, stroke, alpha);
         this.value = value;
     }
     
","
      
     public ValueMarker(double value, Paint paint, Stroke stroke, 
                        Paint outlinePaint, Stroke outlineStroke, float alpha) {
        super(paint, stroke, outlinePaint, outlineStroke, alpha);
         this.value = value;
     }
     
"
21,"junit.framework.AssertionFailedError","/source/org/jfree/chart/plot/CategoryPlot.java","@@ -695,6 +695,9 @@ public void setDomainAxes(CategoryAxis[] axes) {
      * @since 1.0.3
      */
     public int getDomainAxisIndex(CategoryAxis axis) {
         return this.domainAxes.indexOf(axis);
     }
     
@@ -970,6 +973,9 @@ public void setRangeAxes(ValueAxis[] axes) {
      * @since 1.0.7
      */
     public int getRangeAxisIndex(ValueAxis axis) {
         int result = this.rangeAxes.indexOf(axis);
         if (result < 0) { // try the parent plot
             Plot parent = getParent();
","@@ -695,6 +695,9 @@ public void setDomainAxes(CategoryAxis[] axes) {
      * @since 1.0.3
      */
     public int getDomainAxisIndex(CategoryAxis axis) {
      if (axis == null) {
          throw new IllegalArgumentException(""Null 'axis' argument."");
      }
         return this.domainAxes.indexOf(axis);
     }
     
@@ -970,6 +973,9 @@ public void setRangeAxes(ValueAxis[] axes) {
      * @since 1.0.7
      */
     public int getRangeAxisIndex(ValueAxis axis) {
      if (axis == null) {
          throw new IllegalArgumentException(""Null 'axis' argument."");
      }
         int result = this.rangeAxes.indexOf(axis);
         if (result < 0) { // try the parent plot
             Plot parent = getParent();
","
  
     public int getDomainAxisIndex(CategoryAxis axis) {
         return this.domainAxes.indexOf(axis);
     }
     

         int result = this.rangeAxes.indexOf(axis);
         if (result < 0) {              Plot parent = getParent();
","
  
     public int getDomainAxisIndex(CategoryAxis axis) {
        if (axis == null) {
            throw new IllegalArgumentException(""Null 'axis' argument."");
        }
         return this.domainAxes.indexOf(axis);
     }
     

 
     public int getRangeAxisIndex(ValueAxis axis) {
        if (axis == null) {
            throw new IllegalArgumentException(""Null 'axis' argument."");
        }
         int result = this.rangeAxes.indexOf(axis);
         if (result < 0) {              Plot parent = getParent();
"
22,"org.jfree.data.UnknownKeyException","/source/org/jfree/data/KeyedObjects2D.java","@@ -228,9 +228,10 @@ public Object getObject(Comparable rowKey, Comparable columnKey) {
             throw new UnknownKeyException(""Column key ("" + columnKey 
                     + "") not recognised."");
         }
      if (row >= 0) {
         KeyedObjects rowData = (KeyedObjects) this.rows.get(row);
          return rowData.getObject(columnKey);
         }
         else {
             return null;
@@ -315,8 +316,29 @@ public void removeObject(Comparable rowKey, Comparable columnKey) {
         }
         
         // 2. check whether the column is now empty.
     }
 
     /**
@@ -342,6 +364,10 @@ public void removeRow(int rowIndex) {
      */
     public void removeRow(Comparable rowKey) {
         int index = getRowIndex(rowKey);
         removeRow(index);
     }
 
@@ -375,7 +401,10 @@ public void removeColumn(Comparable columnKey) {
         Iterator iterator = this.rows.iterator();
         while (iterator.hasNext()) {
             KeyedObjects rowData = (KeyedObjects) iterator.next();
              rowData.removeValue(columnKey);
         }
         this.columnKeys.remove(columnKey);
     }
","@@ -228,9 +228,10 @@ public Object getObject(Comparable rowKey, Comparable columnKey) {
             throw new UnknownKeyException(""Column key ("" + columnKey 
                     + "") not recognised."");
         }
         KeyedObjects rowData = (KeyedObjects) this.rows.get(row);
      int index = rowData.getIndex(columnKey);
      if (index >= 0) {
          return rowData.getObject(index);
         }
         else {
             return null;
@@ -315,8 +316,29 @@ public void removeObject(Comparable rowKey, Comparable columnKey) {
         }
         
         // 2. check whether the column is now empty.
      allNull = true;
         
      for (int item = 0, itemCount = this.rows.size(); item < itemCount; 
           item++) {
          row = (KeyedObjects) this.rows.get(item);
          int columnIndex = row.getIndex(columnKey);
          if (columnIndex >= 0 && row.getObject(columnIndex) != null) {
              allNull = false;
              break;
          }
      }
         
      if (allNull) {
          for (int item = 0, itemCount = this.rows.size(); item < itemCount; 
               item++) {
              row = (KeyedObjects) this.rows.get(item);
              int columnIndex = row.getIndex(columnKey);
              if (columnIndex >= 0) {
                  row.removeValue(columnIndex);
              }
          }
          this.columnKeys.remove(columnKey);
      }
     }
 
     /**
@@ -342,6 +364,10 @@ public void removeRow(int rowIndex) {
      */
     public void removeRow(Comparable rowKey) {
         int index = getRowIndex(rowKey);
      if (index < 0) {
          throw new UnknownKeyException(""Row key ("" + rowKey 
                  + "") not recognised."");
      }
         removeRow(index);
     }
 
@@ -375,7 +401,10 @@ public void removeColumn(Comparable columnKey) {
         Iterator iterator = this.rows.iterator();
         while (iterator.hasNext()) {
             KeyedObjects rowData = (KeyedObjects) iterator.next();
          int i = rowData.getIndex(columnKey);
          if (i >= 0) {
              rowData.removeValue(i);
          }
         }
         this.columnKeys.remove(columnKey);
     }
","
             throw new UnknownKeyException(""Column key ("" + columnKey 
                     + "") not recognised."");
         }
        if (row >= 0) {
         KeyedObjects rowData = (KeyedObjects) this.rows.get(row);
            return rowData.getObject(columnKey);
         }
         else {
             return null;

         }
         
              }

     public void removeRow(Comparable rowKey) {
         int index = getRowIndex(rowKey);
         removeRow(index);
     }
 

         Iterator iterator = this.rows.iterator();
         while (iterator.hasNext()) {
             KeyedObjects rowData = (KeyedObjects) iterator.next();
                rowData.removeValue(columnKey);
         }
         this.columnKeys.remove(columnKey);
     }
","
             throw new UnknownKeyException(""Column key ("" + columnKey 
                     + "") not recognised."");
         }
         KeyedObjects rowData = (KeyedObjects) this.rows.get(row);
        int index = rowData.getIndex(columnKey);
        if (index >= 0) {
            return rowData.getObject(index);
         }
         else {
             return null;

         }
         
                 allNull = true;
         
        for (int item = 0, itemCount = this.rows.size(); item < itemCount; 
             item++) {
            row = (KeyedObjects) this.rows.get(item);
            int columnIndex = row.getIndex(columnKey);
            if (columnIndex >= 0 && row.getObject(columnIndex) != null) {
                allNull = false;
                break;
            }
        }
         
        if (allNull) {
            for (int item = 0, itemCount = this.rows.size(); item < itemCount; 
                 item++) {
                row = (KeyedObjects) this.rows.get(item);
                int columnIndex = row.getIndex(columnKey);
                if (columnIndex >= 0) {
                    row.removeValue(columnIndex);
                }
            }
            this.columnKeys.remove(columnKey);
        }
     }
 

     public void removeRow(Comparable rowKey) {
         int index = getRowIndex(rowKey);
        if (index < 0) {
            throw new UnknownKeyException(""Row key ("" + rowKey 
                    + "") not recognised."");
        }
         removeRow(index);
     }
 

         Iterator iterator = this.rows.iterator();
         while (iterator.hasNext()) {
             KeyedObjects rowData = (KeyedObjects) iterator.next();
            int i = rowData.getIndex(columnKey);
            if (i >= 0) {
                rowData.removeValue(i);
            }
         }
         this.columnKeys.remove(columnKey);
     }
"
23,"junit.framework.AssertionFailedError","/source/org/jfree/chart/axis/Axis.java","@@ -1189,11 +1189,13 @@ else if (edge == RectangleEdge.RIGHT) {
         }
         if (plotState != null && hotspot != null) {
             ChartRenderingInfo owner = plotState.getOwner();
                 EntityCollection entities = owner.getEntityCollection();
                 if (entities != null) {
                     entities.add(new AxisLabelEntity(this, hotspot, 
                             this.labelToolTip, this.labelURL));
                 }
         }
         return state;
 
","@@ -1189,11 +1189,13 @@ else if (edge == RectangleEdge.RIGHT) {
         }
         if (plotState != null && hotspot != null) {
             ChartRenderingInfo owner = plotState.getOwner();
          if (owner != null) {
                 EntityCollection entities = owner.getEntityCollection();
                 if (entities != null) {
                     entities.add(new AxisLabelEntity(this, hotspot, 
                             this.labelToolTip, this.labelURL));
                 }
          }
         }
         return state;
 
","
         }
         if (plotState != null && hotspot != null) {
             ChartRenderingInfo owner = plotState.getOwner();
                 EntityCollection entities = owner.getEntityCollection();
                 if (entities != null) {
                     entities.add(new AxisLabelEntity(this, hotspot, 
                             this.labelToolTip, this.labelURL));
                 }
         }
         return state;
 
","
         }
         if (plotState != null && hotspot != null) {
             ChartRenderingInfo owner = plotState.getOwner();
            if (owner != null) {
                 EntityCollection entities = owner.getEntityCollection();
                 if (entities != null) {
                     entities.add(new AxisLabelEntity(this, hotspot, 
                             this.labelToolTip, this.labelURL));
                 }
            }
         }
         return state;
 
"
24,"junit.framework.AssertionFailedError","/source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java","@@ -256,6 +256,9 @@ protected void drawHorizontalItem(Graphics2D g2,
 
         // BAR X
         Number meanValue = dataset.getMeanValue(row, column);
 
         double value = meanValue.doubleValue();
         double base = 0.0;
@@ -312,7 +315,9 @@ else if (lclip <= 0.0) { // cases 5, 6, 7 and 8
         }
 
         // standard deviation lines
          double valueDelta = dataset.getStdDevValue(row, column).doubleValue();
             double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() 
                     + valueDelta, dataArea, yAxisLocation);
             double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() 
@@ -341,6 +346,7 @@ else if (lclip <= 0.0) { // cases 5, 6, 7 and 8
             line = new Line2D.Double(lowVal, rectY + rectHeight * 0.25, 
                                      lowVal, rectY + rectHeight * 0.75);
             g2.draw(line);
         
         CategoryItemLabelGenerator generator = getItemLabelGenerator(row, 
                 column);
@@ -400,6 +406,9 @@ protected void drawVerticalItem(Graphics2D g2,
 
         // BAR Y
         Number meanValue = dataset.getMeanValue(row, column);
 
         double value = meanValue.doubleValue();
         double base = 0.0;
@@ -456,7 +465,9 @@ else if (lclip <= 0.0) { // cases 5, 6, 7 and 8
         }
 
         // standard deviation lines
          double valueDelta = dataset.getStdDevValue(row, column).doubleValue();
             double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() 
                     + valueDelta, dataArea, yAxisLocation);
             double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() 
@@ -484,6 +495,7 @@ else if (lclip <= 0.0) { // cases 5, 6, 7 and 8
             line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, lowVal,
                                      rectX + rectWidth / 2.0d + 5.0d, lowVal);
             g2.draw(line);
         
         CategoryItemLabelGenerator generator = getItemLabelGenerator(row, 
                 column);
","@@ -256,6 +256,9 @@ protected void drawHorizontalItem(Graphics2D g2,
 
         // BAR X
         Number meanValue = dataset.getMeanValue(row, column);
      if (meanValue == null) {
          return;
      }
 
         double value = meanValue.doubleValue();
         double base = 0.0;
@@ -312,7 +315,9 @@ else if (lclip <= 0.0) { // cases 5, 6, 7 and 8
         }
 
         // standard deviation lines
      Number n = dataset.getStdDevValue(row, column);
      if (n != null) {
          double valueDelta = n.doubleValue();
             double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() 
                     + valueDelta, dataArea, yAxisLocation);
             double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() 
@@ -341,6 +346,7 @@ else if (lclip <= 0.0) { // cases 5, 6, 7 and 8
             line = new Line2D.Double(lowVal, rectY + rectHeight * 0.25, 
                                      lowVal, rectY + rectHeight * 0.75);
             g2.draw(line);
      }
         
         CategoryItemLabelGenerator generator = getItemLabelGenerator(row, 
                 column);
@@ -400,6 +406,9 @@ protected void drawVerticalItem(Graphics2D g2,
 
         // BAR Y
         Number meanValue = dataset.getMeanValue(row, column);
      if (meanValue == null) {
          return;
      }
 
         double value = meanValue.doubleValue();
         double base = 0.0;
@@ -456,7 +465,9 @@ else if (lclip <= 0.0) { // cases 5, 6, 7 and 8
         }
 
         // standard deviation lines
      Number n = dataset.getStdDevValue(row, column);
      if (n != null) {
          double valueDelta = n.doubleValue();
             double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() 
                     + valueDelta, dataArea, yAxisLocation);
             double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() 
@@ -484,6 +495,7 @@ else if (lclip <= 0.0) { // cases 5, 6, 7 and 8
             line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, lowVal,
                                      rectX + rectWidth / 2.0d + 5.0d, lowVal);
             g2.draw(line);
      }
         
         CategoryItemLabelGenerator generator = getItemLabelGenerator(row, 
                 column);
","
 
                  Number meanValue = dataset.getMeanValue(row, column);
 
         double value = meanValue.doubleValue();
         double base = 0.0;

 
                     double valueDelta = dataset.getStdDevValue(row, column).doubleValue();
             double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() 
                     + valueDelta, dataArea, yAxisLocation);
             double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() 

                                      lowVal, rectY + rectHeight * 0.75);
             g2.draw(line);
         
         CategoryItemLabelGenerator generator = getItemLabelGenerator(row, 
                 column);

 
                  Number meanValue = dataset.getMeanValue(row, column);
 
         double value = meanValue.doubleValue();
         double base = 0.0;

 
                     double valueDelta = dataset.getStdDevValue(row, column).doubleValue();
             double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() 
                     + valueDelta, dataArea, yAxisLocation);
             double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() 

                                      rectX + rectWidth / 2.0d + 5.0d, lowVal);
             g2.draw(line);
         
         CategoryItemLabelGenerator generator = getItemLabelGenerator(row, 
                 column);
","
 
                  Number meanValue = dataset.getMeanValue(row, column);
        if (meanValue == null) {
            return;
        }
 
         double value = meanValue.doubleValue();
         double base = 0.0;

 
                 Number n = dataset.getStdDevValue(row, column);
        if (n != null) {
            double valueDelta = n.doubleValue();
             double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() 
                     + valueDelta, dataArea, yAxisLocation);
             double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() 

                                      lowVal, rectY + rectHeight * 0.75);
             g2.draw(line);
        }
         
         CategoryItemLabelGenerator generator = getItemLabelGenerator(row, 
                 column);

 
                  Number meanValue = dataset.getMeanValue(row, column);
        if (meanValue == null) {
            return;
        }
 
         double value = meanValue.doubleValue();
         double base = 0.0;

 
                 Number n = dataset.getStdDevValue(row, column);
        if (n != null) {
            double valueDelta = n.doubleValue();
             double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() 
                     + valueDelta, dataArea, yAxisLocation);
             double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() 

                                      rectX + rectWidth / 2.0d + 5.0d, lowVal);
             g2.draw(line);
        }
         
         CategoryItemLabelGenerator generator = getItemLabelGenerator(row, 
                 column);
"
25,"junit.framework.AssertionFailedError","/source/org/jfree/chart/renderer/category/MinMaxCategoryRenderer.java","@@ -432,6 +432,25 @@ public void drawItem(Graphics2D g2, CategoryItemRendererState state,
      *
      * @since 1.0.7
      */
 
     /**
      * Returns an icon.
","@@ -432,6 +432,25 @@ public void drawItem(Graphics2D g2, CategoryItemRendererState state,
      *
      * @since 1.0.7
      */
  public boolean equals(Object obj) {
      if (obj == this) {
          return true;
      }
      if (!(obj instanceof MinMaxCategoryRenderer)) {
          return false;
      }
      MinMaxCategoryRenderer that = (MinMaxCategoryRenderer) obj;
      if (this.plotLines != that.plotLines) {
          return false;
      }
      if (!PaintUtilities.equal(this.groupPaint, that.groupPaint)) {
          return false;
      }
      if (!this.groupStroke.equals(that.groupStroke)) {
          return false;
      }
      return super.equals(obj);
  }
 
     /**
      * Returns an icon.
","
    
","
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (!(obj instanceof MinMaxCategoryRenderer)) {
            return false;
        }
        MinMaxCategoryRenderer that = (MinMaxCategoryRenderer) obj;
        if (this.plotLines != that.plotLines) {
            return false;
        }
        if (!PaintUtilities.equal(this.groupPaint, that.groupPaint)) {
            return false;
        }
        if (!this.groupStroke.equals(that.groupStroke)) {
            return false;
        }
        return super.equals(obj);
    }
 
"
26,"java.lang.IllegalArgumentException","/source/org/jfree/chart/renderer/GrayPaintScale.java","@@ -123,7 +123,7 @@ public double getUpperBound() {
     public Paint getPaint(double value) {
         double v = Math.max(value, this.lowerBound);
         v = Math.min(v, this.upperBound);
      int g = (int) ((value - this.lowerBound) / (this.upperBound 
                 - this.lowerBound) * 255.0);
         return new Color(g, g, g);
     }
","@@ -123,7 +123,7 @@ public double getUpperBound() {
     public Paint getPaint(double value) {
         double v = Math.max(value, this.lowerBound);
         v = Math.min(v, this.upperBound);
      int g = (int) ((v - this.lowerBound) / (this.upperBound 
                 - this.lowerBound) * 255.0);
         return new Color(g, g, g);
     }
","
     public Paint getPaint(double value) {
         double v = Math.max(value, this.lowerBound);
         v = Math.min(v, this.upperBound);
        int g = (int) ((value - this.lowerBound) / (this.upperBound 
                 - this.lowerBound) * 255.0);
         return new Color(g, g, g);
     }
","
     public Paint getPaint(double value) {
         double v = Math.max(value, this.lowerBound);
         v = Math.min(v, this.upperBound);
        int g = (int) ((v - this.lowerBound) / (this.upperBound 
                 - this.lowerBound) * 255.0);
         return new Color(g, g, g);
     }
"
27,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java","@@ -152,7 +152,7 @@ public void enterScope(NodeTraversal t) {
     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);
     reachingUses.analyze();
     for (Candidate c : candidates) {
    if (c.canInline()) {
         c.inlineVariable();
 
         // If definition c has dependencies, then inlining it may have
@@ -277,7 +277,7 @@ private Node getDefCfgNode() {
       return defMetadata.node;
     }
 
  private boolean canInline() {
       // Cannot inline a parameter.
       if (getDefCfgNode().isFunction()) {
         return false;
@@ -372,6 +372,12 @@ public boolean apply(Node input) {
                   case Token.REGEXP:
                   case Token.NEW:
                     return true;
                 }
                 return false;
               }
","@@ -152,7 +152,7 @@ public void enterScope(NodeTraversal t) {
     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);
     reachingUses.analyze();
     for (Candidate c : candidates) {
    if (c.canInline(t.getScope())) {
         c.inlineVariable();
 
         // If definition c has dependencies, then inlining it may have
@@ -277,7 +277,7 @@ private Node getDefCfgNode() {
       return defMetadata.node;
     }
 
  private boolean canInline(final Scope scope) {
       // Cannot inline a parameter.
       if (getDefCfgNode().isFunction()) {
         return false;
@@ -372,6 +372,12 @@ public boolean apply(Node input) {
                   case Token.REGEXP:
                   case Token.NEW:
                     return true;
                case Token.NAME:
                  Var var = scope.getOwnSlot(input.getString());
                  if (var != null
                      && var.getParentNode().isCatch()) {
                    return true;
                  }
                 }
                 return false;
               }
","
     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);
     reachingUses.analyze();
     for (Candidate c : candidates) {
      if (c.canInline()) {
         c.inlineVariable();
 
         
       return defMetadata.node;
     }
 
    private boolean canInline() {
              if (getDefCfgNode().isFunction()) {
         return false;

                   case Token.REGEXP:
                   case Token.NEW:
                     return true;
                 }
                 return false;
               }
","
     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);
     reachingUses.analyze();
     for (Candidate c : candidates) {
      if (c.canInline(t.getScope())) {
         c.inlineVariable();
 
         
       return defMetadata.node;
     }
 
    private boolean canInline(final Scope scope) {
              if (getDefCfgNode().isFunction()) {
         return false;

                   case Token.REGEXP:
                   case Token.NEW:
                     return true;
                  case Token.NAME:
                    Var var = scope.getOwnSlot(input.getString());
                    if (var != null
                        && var.getParentNode().isCatch()) {
                      return true;
                    }
                 }
                 return false;
               }
"
28,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java","@@ -610,9 +610,13 @@ public JSType caseNumberType() {
     public JSType caseObjectType(ObjectType type) {
       if (value.equals(""function"")) {
         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);
      return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;
           // Objects are restricted to ""Function"", subtypes are left
           // Only filter out subtypes of ""function""
       }
       return matchesExpectation(""object"") ? type : null;
     }
","@@ -610,9 +610,13 @@ public JSType caseNumberType() {
     public JSType caseObjectType(ObjectType type) {
       if (value.equals(""function"")) {
         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);
      if (resultEqualsValue) {
           // Objects are restricted to ""Function"", subtypes are left
        return ctorType.getGreatestSubtype(type);
      } else {
           // Only filter out subtypes of ""function""
        return type.isSubtype(ctorType) ? null : type;
      }
       }
       return matchesExpectation(""object"") ? type : null;
     }
","
     public JSType caseObjectType(ObjectType type) {
       if (value.equals(""function"")) {
         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);
        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;
                             }
       return matchesExpectation(""object"") ? type : null;
     }
","
     public JSType caseObjectType(ObjectType type) {
       if (value.equals(""function"")) {
         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);
        if (resultEqualsValue) {
                     return ctorType.getGreatestSubtype(type);
        } else {
                     return type.isSubtype(ctorType) ? null : type;
        }
       }
       return matchesExpectation(""object"") ? type : null;
     }
"
29,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/InlineObjectLiterals.java","@@ -173,6 +173,9 @@ private boolean isInlinableObject(List<Reference> refs) {
 
           // Deleting a property has different semantics from deleting
           // a variable, so deleted properties should not be inlined.
 
           // NOTE(nicksantos): This pass's object-splitting algorithm has
           // a blind spot. It assumes that if a property isn't defined on an
","@@ -173,6 +173,9 @@ private boolean isInlinableObject(List<Reference> refs) {
 
           // Deleting a property has different semantics from deleting
           // a variable, so deleted properties should not be inlined.
        if (gramps.isDelProp()) {
          return false;
        }
 
           // NOTE(nicksantos): This pass's object-splitting algorithm has
           // a blind spot. It assumes that if a property isn't defined on an
","
 
                       
                      ","
 
                                if (gramps.isDelProp()) {
            return false;
          }
 
                      "
30,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/TypeValidator.java","@@ -363,9 +363,6 @@ boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,
       JSType leftType, Node owner, String propName) {
     // The NoType check is a hack to make typedefs work OK.
     if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {
    if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {
      registerMismatch(rightType, leftType, null);
    } else {
       // Do not type-check interface methods, because we expect that
       // they will have dummy implementations that do not match the type
       // annotations.
@@ -382,7 +379,6 @@ boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,
           ""assignment to property "" + propName + "" of "" +
           getReadableJSTypeName(owner, true),
           rightType, leftType);
    }
       return false;
     }
     return true;
@@ -402,11 +398,7 @@ boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,
   boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,
       JSType leftType, String msg) {
     if (!rightType.canAssignTo(leftType)) {
    if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {
      registerMismatch(rightType, leftType, null);
    } else {
       mismatch(t, n, msg, rightType, leftType);
    }
       return false;
     }
     return true;
","@@ -363,9 +363,6 @@ boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,
       JSType leftType, Node owner, String propName) {
     // The NoType check is a hack to make typedefs work OK.
     if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {
       // Do not type-check interface methods, because we expect that
       // they will have dummy implementations that do not match the type
       // annotations.
@@ -382,7 +379,6 @@ boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,
           ""assignment to property "" + propName + "" of "" +
           getReadableJSTypeName(owner, true),
           rightType, leftType);
       return false;
     }
     return true;
@@ -402,11 +398,7 @@ boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,
   boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,
       JSType leftType, String msg) {
     if (!rightType.canAssignTo(leftType)) {
       mismatch(t, n, msg, rightType, leftType);
       return false;
     }
     return true;
","
       JSType leftType, Node owner, String propName) {
          if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {
      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {
        registerMismatch(rightType, leftType, null);
      } else {
                     
           ""assignment to property "" + propName + "" of "" +
           getReadableJSTypeName(owner, true),
           rightType, leftType);
      }
       return false;
     }
     return true;

   boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,
       JSType leftType, String msg) {
     if (!rightType.canAssignTo(leftType)) {
      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {
        registerMismatch(rightType, leftType, null);
      } else {
       mismatch(t, n, msg, rightType, leftType);
      }
       return false;
     }
     return true;
","
       JSType leftType, Node owner, String propName) {
          if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {
                     
           ""assignment to property "" + propName + "" of "" +
           getReadableJSTypeName(owner, true),
           rightType, leftType);
       return false;
     }
     return true;

   boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,
       JSType leftType, String msg) {
     if (!rightType.canAssignTo(leftType)) {
       mismatch(t, n, msg, rightType, leftType);
       return false;
     }
     return true;
"
31,"java.lang.NullPointerException","/src/com/google/javascript/jscomp/TypeCheck.java","@@ -1569,9 +1569,13 @@ private void checkInterfaceConflictProperties(NodeTraversal t, Node n,
       ObjectType interfaceType) {
     ObjectType implicitProto = interfaceType.getImplicitPrototype();
     Set<String> currentPropertyNames;
       // This can be the case if interfaceType is proxy to a non-existent
       // object (which is a bad type annotation, but shouldn't crash).
       currentPropertyNames = implicitProto.getOwnPropertyNames();
     for (String name : currentPropertyNames) {
       ObjectType oType = properties.get(name);
       if (oType != null) {
","@@ -1569,9 +1569,13 @@ private void checkInterfaceConflictProperties(NodeTraversal t, Node n,
       ObjectType interfaceType) {
     ObjectType implicitProto = interfaceType.getImplicitPrototype();
     Set<String> currentPropertyNames;
  if (implicitProto == null) {
       // This can be the case if interfaceType is proxy to a non-existent
       // object (which is a bad type annotation, but shouldn't crash).
    currentPropertyNames = ImmutableSet.of();
  } else {
       currentPropertyNames = implicitProto.getOwnPropertyNames();
  }
     for (String name : currentPropertyNames) {
       ObjectType oType = properties.get(name);
       if (oType != null) {
","
       ObjectType interfaceType) {
     ObjectType implicitProto = interfaceType.getImplicitPrototype();
     Set<String> currentPropertyNames;
                     currentPropertyNames = implicitProto.getOwnPropertyNames();
     for (String name : currentPropertyNames) {
       ObjectType oType = properties.get(name);
       if (oType != null) {
","
       ObjectType interfaceType) {
     ObjectType implicitProto = interfaceType.getImplicitPrototype();
     Set<String> currentPropertyNames;
    if (implicitProto == null) {
                    currentPropertyNames = ImmutableSet.of();
    } else {
       currentPropertyNames = implicitProto.getOwnPropertyNames();
    }
     for (String name : currentPropertyNames) {
       ObjectType oType = properties.get(name);
       if (oType != null) {
"
32,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/RemoveUnusedVars.java","@@ -376,6 +376,9 @@ private void removeUnreferencedFunctionArgs(Scope fnScope) {
     // is removing globals, then it's OK to remove unused function args.
     //
     // See http://code.google.com/p/closure-compiler/issues/detail?id=253
 
     Node function = fnScope.getRootNode();
 
","@@ -376,6 +376,9 @@ private void removeUnreferencedFunctionArgs(Scope fnScope) {
     // is removing globals, then it's OK to remove unused function args.
     //
     // See http://code.google.com/p/closure-compiler/issues/detail?id=253
  if (!removeGlobals) {
    return;
  }
 
     Node function = fnScope.getRootNode();
 
","
                
     Node function = fnScope.getRootNode();
 
","
                   if (!removeGlobals) {
      return;
    }
 
     Node function = fnScope.getRootNode();
 
"
33,"junit.framework.AssertionFailedError","/src/com/google/javascript/rhino/jstype/NamedType.java","@@ -187,7 +187,7 @@ JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {
     // makes more sense. Now, resolution via registry is first in order to
     // avoid triggering the warnings built into the resolution via properties.
     boolean resolved = resolveViaRegistry(t, enclosing);
  if (detectImplicitPrototypeCycle()) {
       handleTypeCycle(t);
     }
 
@@ -199,7 +199,7 @@ JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {
     }
 
     resolveViaProperties(t, enclosing);
  if (detectImplicitPrototypeCycle()) {
       handleTypeCycle(t);
     }
 
","@@ -187,7 +187,7 @@ JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {
     // makes more sense. Now, resolution via registry is first in order to
     // avoid triggering the warnings built into the resolution via properties.
     boolean resolved = resolveViaRegistry(t, enclosing);
  if (detectInheritanceCycle()) {
       handleTypeCycle(t);
     }
 
@@ -199,7 +199,7 @@ JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {
     }
 
     resolveViaProperties(t, enclosing);
  if (detectInheritanceCycle()) {
       handleTypeCycle(t);
     }
 
","
               boolean resolved = resolveViaRegistry(t, enclosing);
    if (detectImplicitPrototypeCycle()) {
       handleTypeCycle(t);
     }
 

     }
 
     resolveViaProperties(t, enclosing);
    if (detectImplicitPrototypeCycle()) {
       handleTypeCycle(t);
     }
 
","
               boolean resolved = resolveViaRegistry(t, enclosing);
    if (detectInheritanceCycle()) {
       handleTypeCycle(t);
     }
 

     }
 
     resolveViaProperties(t, enclosing);
    if (detectInheritanceCycle()) {
       handleTypeCycle(t);
     }
 
"
34,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/CollapseVariableDeclarations.java","@@ -201,10 +201,14 @@ private boolean canBeRedeclared(Node n, Scope s) {
       Var var = s.getVar(lhs.getString());
       return var != null
           && var.getScope() == s
           && !blacklistedVars.contains(var);
     }
   }
 
 
   private void applyCollapses() {
     for (Collapse collapse : collapses) {
","@@ -201,10 +201,14 @@ private boolean canBeRedeclared(Node n, Scope s) {
       Var var = s.getVar(lhs.getString());
       return var != null
           && var.getScope() == s
        && !isNamedParameter(var)
           && !blacklistedVars.contains(var);
     }
   }
 
private boolean isNamedParameter(Var v) {
  return v.getParentNode().isParamList();
}
 
   private void applyCollapses() {
     for (Collapse collapse : collapses) {
","
       Var var = s.getVar(lhs.getString());
       return var != null
           && var.getScope() == s
           && !blacklistedVars.contains(var);
     }
   }
 
 
   private void applyCollapses() {
     for (Collapse collapse : collapses) {
","
       Var var = s.getVar(lhs.getString());
       return var != null
           && var.getScope() == s
          && !isNamedParameter(var)
           && !blacklistedVars.contains(var);
     }
   }
 
  private boolean isNamedParameter(Var v) {
    return v.getParentNode().isParamList();
  }
 
   private void applyCollapses() {
     for (Collapse collapse : collapses) {
"
35,"junit.framework.ComparisonFailure","/src/com/google/javascript/jscomp/ProcessCommonJSModules.java","@@ -116,6 +116,7 @@ public static String toModuleName(String requiredFilename,
   private String normalizeSourceName(String filename) {
     // The DOS command shell will normalize ""/"" to ""\"", so we have to
     // wrestle it back.
 
     if (filename.indexOf(filenamePrefix) == 0) {
       filename = filename.substring(filenamePrefix.length());
@@ -180,7 +181,7 @@ private void visitScript(NodeTraversal t, Node script) {
       Preconditions.checkArgument(scriptNodeCount == 1,
           ""ProcessCommonJSModules supports only one invocation per "" +
           ""CompilerInput / script node"");
    String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));
       script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())
           .copyInformationFromForTree(script));
       if (reportDependencies) {
","@@ -116,6 +116,7 @@ public static String toModuleName(String requiredFilename,
   private String normalizeSourceName(String filename) {
     // The DOS command shell will normalize ""/"" to ""\"", so we have to
     // wrestle it back.
  filename = filename.replace(""\\"", ""/"");
 
     if (filename.indexOf(filenamePrefix) == 0) {
       filename = filename.substring(filenamePrefix.length());
@@ -180,7 +181,7 @@ private void visitScript(NodeTraversal t, Node script) {
       Preconditions.checkArgument(scriptNodeCount == 1,
           ""ProcessCommonJSModules supports only one invocation per "" +
           ""CompilerInput / script node"");
    String moduleName = guessCJSModuleName(script.getSourceFileName());
       script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())
           .copyInformationFromForTree(script));
       if (reportDependencies) {
","
   private String normalizeSourceName(String filename) {
           
     if (filename.indexOf(filenamePrefix) == 0) {
       filename = filename.substring(filenamePrefix.length());

       Preconditions.checkArgument(scriptNodeCount == 1,
           ""ProcessCommonJSModules supports only one invocation per "" +
           ""CompilerInput / script node"");
      String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));
       script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())
           .copyInformationFromForTree(script));
       if (reportDependencies) {
","
   private String normalizeSourceName(String filename) {
              filename = filename.replace(""\\"", ""/"");
 
     if (filename.indexOf(filenamePrefix) == 0) {
       filename = filename.substring(filenamePrefix.length());

       Preconditions.checkArgument(scriptNodeCount == 1,
           ""ProcessCommonJSModules supports only one invocation per "" +
           ""CompilerInput / script node"");
      String moduleName = guessCJSModuleName(script.getSourceFileName());
       script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())
           .copyInformationFromForTree(script));
       if (reportDependencies) {
"
36,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/TypeCheck.java","@@ -1311,8 +1311,6 @@ private void visitGetProp(NodeTraversal t, Node n, Node parent) {
 
     if (childType.isDict()) {
       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, ""'.'"", ""dict"");
  } else if (n.getJSType() != null && parent.isAssign()) {
    return;
     } else if (validator.expectNotNullOrUndefined(t, n, childType,
         ""No properties on this expression"", getNativeType(OBJECT_TYPE))) {
       checkPropertyAccess(childType, property.getString(), t, n);
","@@ -1311,8 +1311,6 @@ private void visitGetProp(NodeTraversal t, Node n, Node parent) {
 
     if (childType.isDict()) {
       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, ""'.'"", ""dict"");
     } else if (validator.expectNotNullOrUndefined(t, n, childType,
         ""No properties on this expression"", getNativeType(OBJECT_TYPE))) {
       checkPropertyAccess(childType, property.getString(), t, n);
","
 
     if (childType.isDict()) {
       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, ""'.'"", ""dict"");
    } else if (n.getJSType() != null && parent.isAssign()) {
      return;
     } else if (validator.expectNotNullOrUndefined(t, n, childType,
         ""No properties on this expression"", getNativeType(OBJECT_TYPE))) {
       checkPropertyAccess(childType, property.getString(), t, n);
","
 
     if (childType.isDict()) {
       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, ""'.'"", ""dict"");
     } else if (validator.expectNotNullOrUndefined(t, n, childType,
         ""No properties on this expression"", getNativeType(OBJECT_TYPE))) {
       checkPropertyAccess(childType, property.getString(), t, n);
"
37,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java","@@ -157,6 +157,12 @@ ReachingUses flowThrough(Node n, ReachingUses input) {
   }
 
   private boolean hasExceptionHandler(Node cfgNode) {
    return false;
   }
 
","@@ -157,6 +157,12 @@ ReachingUses flowThrough(Node n, ReachingUses input) {
   }
 
   private boolean hasExceptionHandler(Node cfgNode) {
  List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode);
  for (DiGraphEdge<Node, Branch> edge : branchEdges) {
    if (edge.getValue() == Branch.ON_EX) {
      return true;
    }
  }
     return false;
   }
 
","
   }
 
   private boolean hasExceptionHandler(Node cfgNode) {
    return false;
   }
 
","
   }
 
   private boolean hasExceptionHandler(Node cfgNode) {
    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode);
    for (DiGraphEdge<Node, Branch> edge : branchEdges) {
      if (edge.getValue() == Branch.ON_EX) {
        return true;
      }
    }
     return false;
   }
 
"
38,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/NodeUtil.java","@@ -1414,7 +1414,7 @@ static boolean mayBeString(Node n) {
 
   static boolean mayBeString(Node n, boolean recurse) {
     if (recurse) {
    return allResultsMatch(n, MAY_BE_STRING_PREDICATE);
     } else {
       return mayBeStringHelper(n);
     }
","@@ -1414,7 +1414,7 @@ static boolean mayBeString(Node n) {
 
   static boolean mayBeString(Node n, boolean recurse) {
     if (recurse) {
    return anyResultsMatch(n, MAY_BE_STRING_PREDICATE);
     } else {
       return mayBeStringHelper(n);
     }
","
 
   static boolean mayBeString(Node n, boolean recurse) {
     if (recurse) {
      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);
     } else {
       return mayBeStringHelper(n);
     }
","
 
   static boolean mayBeString(Node n, boolean recurse) {
     if (recurse) {
      return anyResultsMatch(n, MAY_BE_STRING_PREDICATE);
     } else {
       return mayBeStringHelper(n);
     }
"
39,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/ControlFlowAnalysis.java","@@ -764,7 +764,7 @@ private static Node computeFollowNode(
         } else if (parent.getLastChild() == node){
           if (cfa != null) {
             for (Node finallyNode : cfa.finallyMap.get(parent)) {
            cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);
             }
           }
           return computeFollowNode(fromNode, parent, cfa);
","@@ -764,7 +764,7 @@ private static Node computeFollowNode(
         } else if (parent.getLastChild() == node){
           if (cfa != null) {
             for (Node finallyNode : cfa.finallyMap.get(parent)) {
            cfa.createEdge(fromNode, Branch.ON_EX, finallyNode);
             }
           }
           return computeFollowNode(fromNode, parent, cfa);
","
         } else if (parent.getLastChild() == node){
           if (cfa != null) {
             for (Node finallyNode : cfa.finallyMap.get(parent)) {
              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);
             }
           }
           return computeFollowNode(fromNode, parent, cfa);
","
         } else if (parent.getLastChild() == node){
           if (cfa != null) {
             for (Node finallyNode : cfa.finallyMap.get(parent)) {
              cfa.createEdge(fromNode, Branch.ON_EX, finallyNode);
             }
           }
           return computeFollowNode(fromNode, parent, cfa);
"
40,"junit.framework.ComparisonFailure","/src/com/google/javascript/jscomp/TypedScopeCreator.java","@@ -1288,8 +1288,12 @@ private JSType getDeclaredType(String sourceName, JSDocInfo info,
           if (info.isConstant()) {
             JSType knownType = null;
             if (rValue != null) {
            if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {
                 // If rValue has a type-cast, we use the type in the type-cast.
                 // If rValue's type was already computed during scope creation,
                 // then we can safely use that.
                 return rValue.getJSType();
","@@ -1288,8 +1288,12 @@ private JSType getDeclaredType(String sourceName, JSDocInfo info,
           if (info.isConstant()) {
             JSType knownType = null;
             if (rValue != null) {
            JSDocInfo rValueInfo = rValue.getJSDocInfo();
            if (rValueInfo != null && rValueInfo.hasType()) {
                 // If rValue has a type-cast, we use the type in the type-cast.
              return rValueInfo.getType().evaluate(scope, typeRegistry);
            } else if (rValue.getJSType() != null
                && !rValue.getJSType().isUnknownType()) {
                 // If rValue's type was already computed during scope creation,
                 // then we can safely use that.
                 return rValue.getJSType();
","
           if (info.isConstant()) {
             JSType knownType = null;
             if (rValue != null) {
              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {
                                                                    return rValue.getJSType();
","
           if (info.isConstant()) {
             JSType knownType = null;
             if (rValue != null) {
              JSDocInfo rValueInfo = rValue.getJSDocInfo();
              if (rValueInfo != null && rValueInfo.hasType()) {
                                 return rValueInfo.getType().evaluate(scope, typeRegistry);
              } else if (rValue.getJSType() != null
                  && !rValue.getJSType().isUnknownType()) {
                                                   return rValue.getJSType();
"
41,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java","@@ -123,8 +123,8 @@ private void traverse(Node node) {
     do {
       Node c = node.getFirstChild();
       while(c != null) {
      traverse(c);
         Node next = c.getNext();
         c = next;
       }
 
","@@ -123,8 +123,8 @@ private void traverse(Node node) {
     do {
       Node c = node.getFirstChild();
       while(c != null) {
         Node next = c.getNext();
      traverse(c);
         c = next;
       }
 
","
     do {
       Node c = node.getFirstChild();
       while(c != null) {
        traverse(c);
         Node next = c.getNext();
         c = next;
       }
 
","
     do {
       Node c = node.getFirstChild();
       while(c != null) {
         Node next = c.getNext();
        traverse(c);
         c = next;
       }
 
"
42,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/CheckSideEffects.java","@@ -98,7 +98,7 @@ public void visit(NodeTraversal t, Node n, Node parent) {
     // Do not try to remove a block or an expr result. We already handle
     // these cases when we visit the child, and the peephole passes will
     // fix up the tree in more clever ways when these are removed.
  if (n.isExprResult()) {
       return;
     }
 
@@ -110,24 +110,7 @@ public void visit(NodeTraversal t, Node n, Node parent) {
 
     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
  if (parent.getType() == Token.COMMA) {
    if (isResultUsed) {
      return;
    }
    if (n == parent.getLastChild()) {
      for (Node an : parent.getAncestors()) {
        int ancestorType = an.getType();
        if (ancestorType == Token.COMMA) continue;
        if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;
        else break;
      }
    }
  } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
    if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {
      return;
    }
  }
  if (
  if (!isResultUsed &&
         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
       String msg = ""This code lacks side-effects. Is there a bug?"";
       if (n.isString()) {
","@@ -98,7 +98,7 @@ public void visit(NodeTraversal t, Node n, Node parent) {
     // Do not try to remove a block or an expr result. We already handle
     // these cases when we visit the child, and the peephole passes will
     // fix up the tree in more clever ways when these are removed.
  if (n.isExprResult() || n.isBlock()) {
       return;
     }
 
@@ -110,24 +110,7 @@ public void visit(NodeTraversal t, Node n, Node parent) {
 
     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
  if (!isResultUsed &&
         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
       String msg = ""This code lacks side-effects. Is there a bug?"";
       if (n.isString()) {
","
                   if (n.isExprResult()) {
       return;
     }
 

 
     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
    if (parent.getType() == Token.COMMA) {
      if (isResultUsed) {
        return;
      }
      if (n == parent.getLastChild()) {
        for (Node an : parent.getAncestors()) {
          int ancestorType = an.getType();
          if (ancestorType == Token.COMMA) continue;
          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;
          else break;
        }
      }
    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
      if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {
        return;
      }
    }
    if (
    if (!isResultUsed &&
         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
       String msg = ""This code lacks side-effects. Is there a bug?"";
       if (n.isString()) {
","
                   if (n.isExprResult() || n.isBlock()) {
       return;
     }
 

 
     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
    if (!isResultUsed &&
         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
       String msg = ""This code lacks side-effects. Is there a bug?"";
       if (n.isString()) {
"
43,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java","@@ -99,6 +99,9 @@ public boolean apply(Node n) {
           return true;
         }
 
         for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
           if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {
","@@ -99,6 +99,9 @@ public boolean apply(Node n) {
           return true;
         }
 
      if (n.isDelProp()) {
        return true;
      }
 
         for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
           if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {
","
           return true;
         }
 
         for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
           if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {
","
           return true;
         }
 
        if (n.isDelProp()) {
          return true;
        }
 
         for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
           if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {
"
44,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/ScopedAliases.java","@@ -167,17 +167,23 @@ public void applyAlias() {
 
   private class AliasedTypeNode implements AliasUsage {
     private final Node typeReference;
     private final String aliasName;
 
  AliasedTypeNode(Node typeReference,
         String aliasName) {
       this.typeReference = typeReference;
       this.aliasName = aliasName;
     }
 
     @Override
     public void applyAlias() {
    typeReference.setString(aliasName);
     }
   }
 
@@ -465,7 +471,7 @@ private void fixTypeNode(Node typeNode) {
         Var aliasVar = aliases.get(baseName);
         if (aliasVar != null) {
           Node aliasedNode = aliasVar.getInitialValue();
        aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex)));
         }
       }
 
","@@ -167,17 +167,23 @@ public void applyAlias() {
 
   private class AliasedTypeNode implements AliasUsage {
     private final Node typeReference;
  private final Node aliasDefinition;
     private final String aliasName;
 
  AliasedTypeNode(Node typeReference, Node aliasDefinition,
         String aliasName) {
       this.typeReference = typeReference;
    this.aliasDefinition = aliasDefinition;
       this.aliasName = aliasName;
     }
 
     @Override
     public void applyAlias() {
    String typeName = typeReference.getString();
    String aliasExpanded =
        Preconditions.checkNotNull(aliasDefinition.getQualifiedName());
    Preconditions.checkState(typeName.startsWith(aliasName));
    typeReference.setString(typeName.replaceFirst(aliasName, aliasExpanded));
     }
   }
 
@@ -465,7 +471,7 @@ private void fixTypeNode(Node typeNode) {
         Var aliasVar = aliases.get(baseName);
         if (aliasVar != null) {
           Node aliasedNode = aliasVar.getInitialValue();
        aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode, baseName));
         }
       }
 
","
 
   private class AliasedTypeNode implements AliasUsage {
     private final Node typeReference;
     private final String aliasName;
 
    AliasedTypeNode(Node typeReference,
         String aliasName) {
       this.typeReference = typeReference;
       this.aliasName = aliasName;
     }
 
     @Override
     public void applyAlias() {
      typeReference.setString(aliasName);
     }
   }
 

         Var aliasVar = aliases.get(baseName);
         if (aliasVar != null) {
           Node aliasedNode = aliasVar.getInitialValue();
          aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex)));
         }
       }
 
","
 
   private class AliasedTypeNode implements AliasUsage {
     private final Node typeReference;
    private final Node aliasDefinition;
     private final String aliasName;
 
    AliasedTypeNode(Node typeReference, Node aliasDefinition,
         String aliasName) {
       this.typeReference = typeReference;
      this.aliasDefinition = aliasDefinition;
       this.aliasName = aliasName;
     }
 
     @Override
     public void applyAlias() {
      String typeName = typeReference.getString();
      String aliasExpanded =
          Preconditions.checkNotNull(aliasDefinition.getQualifiedName());
      Preconditions.checkState(typeName.startsWith(aliasName));
      typeReference.setString(typeName.replaceFirst(aliasName, aliasExpanded));
     }
   }
 

         Var aliasVar = aliases.get(baseName);
         if (aliasVar != null) {
           Node aliasedNode = aliasVar.getInitialValue();
          aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode, baseName));
         }
       }
 
"
45,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/Compiler.java","@@ -1285,7 +1285,7 @@ Node parseInputs() {
 
       // Check if the sources need to be re-ordered.
       boolean staleInputs = false;
    if (options.dependencyOptions.needsManagement() && options.closurePass) {
         for (CompilerInput input : inputs) {
           // Forward-declare all the provided types, so that they
           // are not flagged even if they are dropped from the process.
","@@ -1285,7 +1285,7 @@ Node parseInputs() {
 
       // Check if the sources need to be re-ordered.
       boolean staleInputs = false;
    if (options.dependencyOptions.needsManagement()) {
         for (CompilerInput input : inputs) {
           // Forward-declare all the provided types, so that they
           // are not flagged even if they are dropped from the process.
","
 
              boolean staleInputs = false;
      if (options.dependencyOptions.needsManagement() && options.closurePass) {
         for (CompilerInput input : inputs) {
                      ","
 
              boolean staleInputs = false;
      if (options.dependencyOptions.needsManagement()) {
         for (CompilerInput input : inputs) {
                      "
46,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java","@@ -217,7 +217,8 @@ private Node tryFoldSimpleFunctionCall(Node n) {
       // slightly different semantics than '' + (a). See
       // http://code.google.com/p/closure-compiler/issues/detail?id=759
       Node value = callTarget.getNext();
    if (value != null) {
         Node addition = IR.add(
             IR.string("""").srcref(callTarget),
             value.detachFromParent());
","@@ -217,7 +217,8 @@ private Node tryFoldSimpleFunctionCall(Node n) {
       // slightly different semantics than '' + (a). See
       // http://code.google.com/p/closure-compiler/issues/detail?id=759
       Node value = callTarget.getNext();
    if (value != null && value.getNext() == null &&
        NodeUtil.isImmutableValue(value)) {
         Node addition = IR.add(
             IR.string("""").srcref(callTarget),
             value.detachFromParent());
","
                     Node value = callTarget.getNext();
      if (value != null) {
         Node addition = IR.add(
             IR.string("""").srcref(callTarget),
             value.detachFromParent());
","
                     Node value = callTarget.getNext();
      if (value != null && value.getNext() == null &&
          NodeUtil.isImmutableValue(value)) {
         Node addition = IR.add(
             IR.string("""").srcref(callTarget),
             value.detachFromParent());
"
47,"java.lang.IllegalArgumentException","/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java","@@ -169,7 +169,9 @@ protected void declareNameInScope(FlowScope scope, Node node, JSType type) {
         scope.inferQualifiedSlot(node, qualifiedName, origType, type);
         break;
 
         // ""this"" references aren't currently modeled in the CFG.
 
       default:
         throw new IllegalArgumentException(""Node cannot be refined. \n"" +
","@@ -169,7 +169,9 @@ protected void declareNameInScope(FlowScope scope, Node node, JSType type) {
         scope.inferQualifiedSlot(node, qualifiedName, origType, type);
         break;
 
    case Token.THIS:
         // ""this"" references aren't currently modeled in the CFG.
      break;
 
       default:
         throw new IllegalArgumentException(""Node cannot be refined. \n"" +
","
         scope.inferQualifiedSlot(node, qualifiedName, origType, type);
         break;
 
          
       default:
         throw new IllegalArgumentException(""Node cannot be refined. \n"" +
","
         scope.inferQualifiedSlot(node, qualifiedName, origType, type);
         break;
 
      case Token.THIS:
                 break;
 
       default:
         throw new IllegalArgumentException(""Node cannot be refined. \n"" +
"
48,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/PeepholeFoldConstants.java","@@ -1448,8 +1448,14 @@ private Node tryFoldArrayAccess(Node n, Node left, Node right) {
 
     Node current = left.getFirstChild();
     Node elem = null;
  for (int i = 0; current != null && i < intIndex; i++) {
         elem = current;
 
       current = current.getNext();
     }
","@@ -1448,8 +1448,14 @@ private Node tryFoldArrayAccess(Node n, Node left, Node right) {
 
     Node current = left.getFirstChild();
     Node elem = null;
  for (int i = 0; current != null; i++) {
    if (i != intIndex) {
      if (mayHaveSideEffects(current)) {
        return n;
      }
    } else {
         elem = current;
    }
 
       current = current.getNext();
     }
","
 
     Node current = left.getFirstChild();
     Node elem = null;
    for (int i = 0; current != null && i < intIndex; i++) {
         elem = current;
 
       current = current.getNext();
     }
","
 
     Node current = left.getFirstChild();
     Node elem = null;
    for (int i = 0; current != null; i++) {
      if (i != intIndex) {
        if (mayHaveSideEffects(current)) {
          return n;
        }
      } else {
         elem = current;
      }
 
       current = current.getNext();
     }
"
49,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/ScopedAliases.java","@@ -275,8 +275,8 @@ private void findAliases(NodeTraversal t) {
         Node n = v.getNode();
         int type = n.getType();
         Node parent = n.getParent();
      if (parent.isVar()) {
        if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {
           String name = n.getString();
           Var aliasVar = scope.getVar(name);
           aliases.put(name, aliasVar);
@@ -284,15 +284,16 @@ private void findAliases(NodeTraversal t) {
           String qualifiedName =
               aliasVar.getInitialValue().getQualifiedName();
           transformation.addAlias(name, qualifiedName);
           // Bleeding functions already get a BAD_PARAMETERS error, so just
           // do nothing.
           // Parameters of the scope function also get a BAD_PARAMETERS
           // error.
         } else {
           // TODO(robbyw): Support using locals for private variables.
           report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
         }
      }
       }
     }
 
","@@ -275,8 +275,8 @@ private void findAliases(NodeTraversal t) {
         Node n = v.getNode();
         int type = n.getType();
         Node parent = n.getParent();
      if (parent.isVar() &&
          n.hasChildren() && n.getFirstChild().isQualifiedName()) {
           String name = n.getString();
           Var aliasVar = scope.getVar(name);
           aliases.put(name, aliasVar);
@@ -284,15 +284,16 @@ private void findAliases(NodeTraversal t) {
           String qualifiedName =
               aliasVar.getInitialValue().getQualifiedName();
           transformation.addAlias(name, qualifiedName);
      } else if (v.isBleedingFunction()) {
           // Bleeding functions already get a BAD_PARAMETERS error, so just
           // do nothing.
      } else if (parent.getType() == Token.LP) {
           // Parameters of the scope function also get a BAD_PARAMETERS
           // error.
         } else {
           // TODO(robbyw): Support using locals for private variables.
           report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
         }
       }
     }
 
","
         Node n = v.getNode();
         int type = n.getType();
         Node parent = n.getParent();
        if (parent.isVar()) {
          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {
           String name = n.getString();
           Var aliasVar = scope.getVar(name);
           aliases.put(name, aliasVar);

           String qualifiedName =
               aliasVar.getInitialValue().getQualifiedName();
           transformation.addAlias(name, qualifiedName);
                                                     } else {
                      report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
         }
        }
       }
     }
 
","
         Node n = v.getNode();
         int type = n.getType();
         Node parent = n.getParent();
        if (parent.isVar() &&
            n.hasChildren() && n.getFirstChild().isQualifiedName()) {
           String name = n.getString();
           Var aliasVar = scope.getVar(name);
           aliases.put(name, aliasVar);

           String qualifiedName =
               aliasVar.getInitialValue().getQualifiedName();
           transformation.addAlias(name, qualifiedName);
        } else if (v.isBleedingFunction()) {
                              } else if (parent.getType() == Token.LP) {
                               } else {
                      report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
         }
       }
     }
 
"
50,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/CheckSideEffects.java","@@ -98,44 +98,20 @@ public void visit(NodeTraversal t, Node n, Node parent) {
     // Do not try to remove a block or an expr result. We already handle
     // these cases when we visit the child, and the peephole passes will
     // fix up the tree in more clever ways when these are removed.
  if (parent.getType() == Token.COMMA) {
    Node gramps = parent.getParent();
    if (gramps.isCall() && parent == gramps.getFirstChild()) {
      if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && ""eval"".equals(n.getNext().getString())) {
       return;
      }
     }
 
     // This no-op statement was there so that JSDoc information could
     // be attached to the name. This check should not complain about it.
    if (n == parent.getLastChild()) {
      for (Node an : parent.getAncestors()) {
        int ancestorType = an.getType();
        if (ancestorType == Token.COMMA)
          continue;
        if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)
          return;
        else
          break;
      }
    }
  } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
    if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||
         n == parent.getFirstChild().getNext().getNext())) {
    } else {
       return;
    }
     }
 
     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
     if (!isResultUsed &&
         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
    if (n.isQualifiedName() && n.getJSDocInfo() != null) {
      return;
    } else if (n.isExprResult()) {
      return;
    }
       String msg = ""This code lacks side-effects. Is there a bug?"";
       if (n.isString()) {
         msg = ""Is there a missing '+' on the previous line?"";
","@@ -98,44 +98,20 @@ public void visit(NodeTraversal t, Node n, Node parent) {
     // Do not try to remove a block or an expr result. We already handle
     // these cases when we visit the child, and the peephole passes will
     // fix up the tree in more clever ways when these are removed.
  if (n.isExprResult() || n.isBlock()) {
       return;
     }
 
     // This no-op statement was there so that JSDoc information could
     // be attached to the name. This check should not complain about it.
  if (n.isQualifiedName() && n.getJSDocInfo() != null) {
       return;
     }
 
     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
     if (!isResultUsed &&
         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
       String msg = ""This code lacks side-effects. Is there a bug?"";
       if (n.isString()) {
         msg = ""Is there a missing '+' on the previous line?"";
","
                   if (parent.getType() == Token.COMMA) {
      Node gramps = parent.getParent();
      if (gramps.isCall() && parent == gramps.getFirstChild()) {
        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && ""eval"".equals(n.getNext().getString())) {
       return;
        }
     }
 
                if (n == parent.getLastChild()) {
        for (Node an : parent.getAncestors()) {
          int ancestorType = an.getType();
          if (ancestorType == Token.COMMA)
            continue;
          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)
            return;
          else
            break;
        }
      }
    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {
      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||
           n == parent.getFirstChild().getNext().getNext())) {
      } else {
       return;
      }
     }
 
     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
     if (!isResultUsed &&
         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
      if (n.isQualifiedName() && n.getJSDocInfo() != null) {
        return;
      } else if (n.isExprResult()) {
        return;
      }
       String msg = ""This code lacks side-effects. Is there a bug?"";
       if (n.isString()) {
         msg = ""Is there a missing '+' on the previous line?"";
","
                   if (n.isExprResult() || n.isBlock()) {
       return;
     }
 
              if (n.isQualifiedName() && n.getJSDocInfo() != null) {
       return;
     }
 
     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);
     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());
     if (!isResultUsed &&
         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {
       String msg = ""This code lacks side-effects. Is there a bug?"";
       if (n.isString()) {
         msg = ""Is there a missing '+' on the previous line?"";
"
51,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/ProcessCommonJSModules.java","@@ -125,6 +125,7 @@ private String normalizeSourceName(String filename) {
       AbstractPostOrderCallback {
 
     private int scriptNodeCount = 0;
 
     @Override
     public void visit(NodeTraversal t, Node n, Node parent) {
@@ -204,6 +205,9 @@ private void visitScript(NodeTraversal t, Node script) {
      */
     private void emitOptionalModuleExportsOverride(Node script,
         String moduleName) {
 
       Node moduleExportsProp = IR.getprop(IR.name(moduleName),
           IR.string(""module$exports""));
@@ -225,6 +229,7 @@ private void visitModuleExports(Node prop) {
       Node exports = prop.getChildAtIndex(1);
       exports.putProp(Node.ORIGINALNAME_PROP, ""exports"");
       exports.setString(""module$exports"");
     }
 
     /**
","@@ -125,6 +125,7 @@ private String normalizeSourceName(String filename) {
       AbstractPostOrderCallback {
 
     private int scriptNodeCount = 0;
  private Set<String> modulesWithExports = Sets.newHashSet();
 
     @Override
     public void visit(NodeTraversal t, Node n, Node parent) {
@@ -204,6 +205,9 @@ private void visitScript(NodeTraversal t, Node script) {
      */
     private void emitOptionalModuleExportsOverride(Node script,
         String moduleName) {
    if (!modulesWithExports.contains(moduleName)) {
      return;
    }
 
       Node moduleExportsProp = IR.getprop(IR.name(moduleName),
           IR.string(""module$exports""));
@@ -225,6 +229,7 @@ private void visitModuleExports(Node prop) {
       Node exports = prop.getChildAtIndex(1);
       exports.putProp(Node.ORIGINALNAME_PROP, ""exports"");
       exports.setString(""module$exports"");
    modulesWithExports.add(moduleName);
     }
 
     /**
","
       AbstractPostOrderCallback {
 
     private int scriptNodeCount = 0;
 
     @Override
     public void visit(NodeTraversal t, Node n, Node parent) {

      
     private void emitOptionalModuleExportsOverride(Node script,
         String moduleName) {
 
       Node moduleExportsProp = IR.getprop(IR.name(moduleName),
           IR.string(""module$exports""));

       Node exports = prop.getChildAtIndex(1);
       exports.putProp(Node.ORIGINALNAME_PROP, ""exports"");
       exports.setString(""module$exports"");
     }
","
       AbstractPostOrderCallback {
 
     private int scriptNodeCount = 0;
    private Set<String> modulesWithExports = Sets.newHashSet();
 
     @Override
     public void visit(NodeTraversal t, Node n, Node parent) {

      
     private void emitOptionalModuleExportsOverride(Node script,
         String moduleName) {
      if (!modulesWithExports.contains(moduleName)) {
        return;
      }
 
       Node moduleExportsProp = IR.getprop(IR.name(moduleName),
           IR.string(""module$exports""));

       Node exports = prop.getChildAtIndex(1);
       exports.putProp(Node.ORIGINALNAME_PROP, ""exports"");
       exports.setString(""module$exports"");
      modulesWithExports.add(moduleName);
     }
 
"
52,"junit.framework.ComparisonFailure","/src/com/google/javascript/jscomp/TypeInference.java","@@ -1033,9 +1033,9 @@ private void updateTypeOfThisOnClosure(Node n, FunctionType fnType) {
   }
 
   private FlowScope traverseNew(Node n, FlowScope scope) {
 
     Node constructor = n.getFirstChild();
  scope = traverse(constructor, scope);
     JSType constructorType = constructor.getJSType();
     JSType type = null;
     if (constructorType != null) {
@@ -1052,13 +1052,11 @@ private FlowScope traverseNew(Node n, FlowScope scope) {
         }
         if (ct != null && ct.isConstructor()) {
           type = ct.getInstanceType();
         }
       }
     }
     n.setJSType(type);
  for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {
    scope = traverse(arg, scope);
  }
     return scope;
   }
 
","@@ -1033,9 +1033,9 @@ private void updateTypeOfThisOnClosure(Node n, FunctionType fnType) {
   }
 
   private FlowScope traverseNew(Node n, FlowScope scope) {
  scope = traverseChildren(n, scope);
 
     Node constructor = n.getFirstChild();
     JSType constructorType = constructor.getJSType();
     JSType type = null;
     if (constructorType != null) {
@@ -1052,13 +1052,11 @@ private FlowScope traverseNew(Node n, FlowScope scope) {
         }
         if (ct != null && ct.isConstructor()) {
           type = ct.getInstanceType();
        backwardsInferenceFromCallSite(n, ct);
         }
       }
     }
     n.setJSType(type);
     return scope;
   }
 
","
   }
 
   private FlowScope traverseNew(Node n, FlowScope scope) {
 
     Node constructor = n.getFirstChild();
    scope = traverse(constructor, scope);
     JSType constructorType = constructor.getJSType();
     JSType type = null;
     if (constructorType != null) {

         }
         if (ct != null && ct.isConstructor()) {
           type = ct.getInstanceType();
         }
       }
     }
     n.setJSType(type);
    for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {
      scope = traverse(arg, scope);
    }
     return scope;
   }
 
","
   }
 
   private FlowScope traverseNew(Node n, FlowScope scope) {
    scope = traverseChildren(n, scope);
 
     Node constructor = n.getFirstChild();
     JSType constructorType = constructor.getJSType();
     JSType type = null;
     if (constructorType != null) {

         }
         if (ct != null && ct.isConstructor()) {
           type = ct.getInstanceType();
          backwardsInferenceFromCallSite(n, ct);
         }
       }
     }
     n.setJSType(type);
     return scope;
   }
 
"
53,"java.lang.IllegalStateException","/src/com/google/javascript/rhino/IR.java","@@ -108,6 +108,9 @@ public static Node block(Node ... stmts) {
     return block;
   }
 
 
   public static Node script(Node ... stmts) {
     // TODO(johnlenz): finish setting up the SCRIPT node
@@ -221,8 +224,8 @@ public static Node labelName(String name) {
   }
 
   public static Node tryFinally(Node tryBody, Node finallyBody) {
  Preconditions.checkState(tryBody.isLabelName());
  Preconditions.checkState(finallyBody.isLabelName());
     Node catchBody = block().copyInformationFrom(tryBody);
     return new Node(Token.TRY, tryBody, catchBody, finallyBody);
   }
@@ -230,7 +233,7 @@ public static Node tryFinally(Node tryBody, Node finallyBody) {
   public static Node tryCatch(Node tryBody, Node catchNode) {
     Preconditions.checkState(tryBody.isBlock());
     Preconditions.checkState(catchNode.isCatch());
  Node catchBody = block(catchNode).copyInformationFrom(catchNode);
     return new Node(Token.TRY, tryBody, catchBody);
   }
 
","@@ -108,6 +108,9 @@ public static Node block(Node ... stmts) {
     return block;
   }
 
private static Node blockUnchecked(Node stmt) {
  return new Node(Token.BLOCK, stmt);
}
 
   public static Node script(Node ... stmts) {
     // TODO(johnlenz): finish setting up the SCRIPT node
@@ -221,8 +224,8 @@ public static Node labelName(String name) {
   }
 
   public static Node tryFinally(Node tryBody, Node finallyBody) {
  Preconditions.checkState(tryBody.isBlock());
  Preconditions.checkState(finallyBody.isBlock());
     Node catchBody = block().copyInformationFrom(tryBody);
     return new Node(Token.TRY, tryBody, catchBody, finallyBody);
   }
@@ -230,7 +233,7 @@ public static Node tryFinally(Node tryBody, Node finallyBody) {
   public static Node tryCatch(Node tryBody, Node catchNode) {
     Preconditions.checkState(tryBody.isBlock());
     Preconditions.checkState(catchNode.isCatch());
  Node catchBody = blockUnchecked(catchNode).copyInformationFrom(catchNode);
     return new Node(Token.TRY, tryBody, catchBody);
   }
 
","
     return block;
   }
 
 
   public static Node script(Node ... stmts) {
     
   }
 
   public static Node tryFinally(Node tryBody, Node finallyBody) {
    Preconditions.checkState(tryBody.isLabelName());
    Preconditions.checkState(finallyBody.isLabelName());
     Node catchBody = block().copyInformationFrom(tryBody);
     return new Node(Token.TRY, tryBody, catchBody, finallyBody);
   }

   public static Node tryCatch(Node tryBody, Node catchNode) {
     Preconditions.checkState(tryBody.isBlock());
     Preconditions.checkState(catchNode.isCatch());
    Node catchBody = block(catchNode).copyInformationFrom(catchNode);
     return new Node(Token.TRY, tryBody, catchBody);
   }
 
","
     return block;
   }
 
  private static Node blockUnchecked(Node stmt) {
    return new Node(Token.BLOCK, stmt);
  }
 
   public static Node script(Node ... stmts) {
     
   }
 
   public static Node tryFinally(Node tryBody, Node finallyBody) {
    Preconditions.checkState(tryBody.isBlock());
    Preconditions.checkState(finallyBody.isBlock());
     Node catchBody = block().copyInformationFrom(tryBody);
     return new Node(Token.TRY, tryBody, catchBody, finallyBody);
   }

   public static Node tryCatch(Node tryBody, Node catchNode) {
     Preconditions.checkState(tryBody.isBlock());
     Preconditions.checkState(catchNode.isCatch());
    Node catchBody = blockUnchecked(catchNode).copyInformationFrom(catchNode);
     return new Node(Token.TRY, tryBody, catchBody);
   }
 
"
54,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/InlineObjectLiterals.java","@@ -154,6 +154,7 @@ private boolean isVarInlineForbidden(Var var) {
      */
     private boolean isInlinableObject(List<Reference> refs) {
       boolean ret = false;
       for (Reference ref : refs) {
         Node name = ref.getNode();
         Node parent = ref.getParent();
@@ -178,6 +179,14 @@ private boolean isInlinableObject(List<Reference> refs) {
           // We short-circuit this problem by bailing out if we see a reference
           // to a property that isn't defined on the object literal. This
           // isn't a perfect algorithm, but it should catch most cases.
           continue;
         }
 
@@ -213,6 +222,7 @@ private boolean isInlinableObject(List<Reference> refs) {
             return false;
           }
 
 
           Node childVal = child.getFirstChild();
           // Check if childVal is the parent of any of the passed in
","@@ -154,6 +154,7 @@ private boolean isVarInlineForbidden(Var var) {
      */
     private boolean isInlinableObject(List<Reference> refs) {
       boolean ret = false;
    Set<String> validProperties = Sets.newHashSet();
       for (Reference ref : refs) {
         Node name = ref.getNode();
         Node parent = ref.getParent();
@@ -178,6 +179,14 @@ private boolean isInlinableObject(List<Reference> refs) {
           // We short-circuit this problem by bailing out if we see a reference
           // to a property that isn't defined on the object literal. This
           // isn't a perfect algorithm, but it should catch most cases.
        String propName = parent.getLastChild().getString();
        if (!validProperties.contains(propName)) {
          if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {
            validProperties.add(propName);
          } else {
            return false;
          }
        }
           continue;
         }
 
@@ -213,6 +222,7 @@ private boolean isInlinableObject(List<Reference> refs) {
             return false;
           }
 
        validProperties.add(child.getString());
 
           Node childVal = child.getFirstChild();
           // Check if childVal is the parent of any of the passed in
","
      
     private boolean isInlinableObject(List<Reference> refs) {
       boolean ret = false;
       for (Reference ref : refs) {
         Node name = ref.getNode();
         Node parent = ref.getParent();

                                            continue;
         }
 

             return false;
           }
 
 
           Node childVal = child.getFirstChild();
           ","
      
     private boolean isInlinableObject(List<Reference> refs) {
       boolean ret = false;
      Set<String> validProperties = Sets.newHashSet();
       for (Reference ref : refs) {
         Node name = ref.getNode();
         Node parent = ref.getParent();

                                           String propName = parent.getLastChild().getString();
          if (!validProperties.contains(propName)) {
            if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {
              validProperties.add(propName);
            } else {
              return false;
            }
          }
           continue;
         }
 

             return false;
           }
 
          validProperties.add(child.getString());
 
           Node childVal = child.getFirstChild();
           "
55,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java","@@ -154,7 +154,7 @@ public void exitScope(NodeTraversal t) {}
 
   @Override
   public void process(Node externs, Node root) {
  (new NodeTraversal(compiler, this)).traverse(root);
   }
 
   @Override
/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java @@ -68,6 +68,7 @@
   private static class Definition {
     final Node node;
     final Set<Var> depends = Sets.newHashSet();
 
     Definition(Node node) {
       this.node = node;
@@ -393,9 +394,13 @@ private void computeDependence(final Definition def, Node rValue) {
         new AbstractCfgNodeTraversalCallback() {
       @Override
       public void visit(NodeTraversal t, Node n, Node parent) {
      if (n.isName() && jsScope.isDeclared(n.getString(), true)) {
           Var dep = jsScope.getVar(n.getString());
             def.depends.add(dep);
         }
       }
     });
@@ -427,6 +432,9 @@ boolean dependsOnOuterScopeVars(String name, Node useNode) {
     GraphNode<Node, Branch> n = getCfg().getNode(useNode);
     FlowState<MustDef> state = n.getAnnotation();
     Definition def = state.getIn().reachingDef.get(jsScope.getVar(name));
 
     for (Var s : def.depends) {
       if (s.scope != jsScope) {
","@@ -154,7 +154,7 @@ public void exitScope(NodeTraversal t) {}
 
   @Override
   public void process(Node externs, Node root) {
  (new NodeTraversal(compiler, this)).traverseRoots(externs, root);
   }
 
   @Override
/src/com/google/javascript/jscomp/MustBeReachingVariableDef.java @@ -68,6 +68,7 @@
   private static class Definition {
     final Node node;
     final Set<Var> depends = Sets.newHashSet();
  private boolean unknownDependencies = false;
 
     Definition(Node node) {
       this.node = node;
@@ -393,9 +394,13 @@ private void computeDependence(final Definition def, Node rValue) {
         new AbstractCfgNodeTraversalCallback() {
       @Override
       public void visit(NodeTraversal t, Node n, Node parent) {
      if (n.isName()) {
           Var dep = jsScope.getVar(n.getString());
        if (dep == null) {
          def.unknownDependencies = true;
        } else {
             def.depends.add(dep);
        }
         }
       }
     });
@@ -427,6 +432,9 @@ boolean dependsOnOuterScopeVars(String name, Node useNode) {
     GraphNode<Node, Branch> n = getCfg().getNode(useNode);
     FlowState<MustDef> state = n.getAnnotation();
     Definition def = state.getIn().reachingDef.get(jsScope.getVar(name));
  if (def.unknownDependencies) {
    return true;
  }
 
     for (Var s : def.depends) {
       if (s.scope != jsScope) {
","
 
   @Override
   public void process(Node externs, Node root) {
    (new NodeTraversal(compiler, this)).traverse(root);
   }
 
   @Override

   private static class Definition {
     final Node node;
     final Set<Var> depends = Sets.newHashSet();
 
     Definition(Node node) {
       this.node = node;

         new AbstractCfgNodeTraversalCallback() {
       @Override
       public void visit(NodeTraversal t, Node n, Node parent) {
        if (n.isName() && jsScope.isDeclared(n.getString(), true)) {
           Var dep = jsScope.getVar(n.getString());
             def.depends.add(dep);
         }
       }
     });

     GraphNode<Node, Branch> n = getCfg().getNode(useNode);
     FlowState<MustDef> state = n.getAnnotation();
     Definition def = state.getIn().reachingDef.get(jsScope.getVar(name));
 
     for (Var s : def.depends) {
       if (s.scope != jsScope) {
","
 
   @Override
   public void process(Node externs, Node root) {
    (new NodeTraversal(compiler, this)).traverseRoots(externs, root);
   }
 
   @Override

   private static class Definition {
     final Node node;
     final Set<Var> depends = Sets.newHashSet();
    private boolean unknownDependencies = false;
 
     Definition(Node node) {
       this.node = node;

         new AbstractCfgNodeTraversalCallback() {
       @Override
       public void visit(NodeTraversal t, Node n, Node parent) {
        if (n.isName()) {
           Var dep = jsScope.getVar(n.getString());
          if (dep == null) {
            def.unknownDependencies = true;
          } else {
             def.depends.add(dep);
          }
         }
       }
     });

     GraphNode<Node, Branch> n = getCfg().getNode(useNode);
     FlowState<MustDef> state = n.getAnnotation();
     Definition def = state.getIn().reachingDef.get(jsScope.getVar(name));
    if (def.unknownDependencies) {
      return true;
    }
 
     for (Var s : def.depends) {
       if (s.scope != jsScope) {
"
56,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/Compiler.java","@@ -1282,7 +1282,6 @@ Node parseInputs() {
 
       // Check if the sources need to be re-ordered.
       if (options.dependencyOptions.needsManagement() &&
        !options.skipAllPasses &&
           options.closurePass) {
         for (CompilerInput input : inputs) {
           // Forward-declare all the provided types, so that they
","@@ -1282,7 +1282,6 @@ Node parseInputs() {
 
       // Check if the sources need to be re-ordered.
       if (options.dependencyOptions.needsManagement() &&
           options.closurePass) {
         for (CompilerInput input : inputs) {
           // Forward-declare all the provided types, so that they
","
 
              if (options.dependencyOptions.needsManagement() &&
          !options.skipAllPasses &&
           options.closurePass) {
         for (CompilerInput input : inputs) {
           ","
 
              if (options.dependencyOptions.needsManagement() &&
           options.closurePass) {
         for (CompilerInput input : inputs) {
           "
57,"junit.framework.ComparisonFailure","/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java","@@ -1355,12 +1355,14 @@ private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,
     // Track the start of the line to count whitespace that
     // the tokenizer skipped. Because this case is rare, it's easier
     // to do this here than in the tokenizer.
 
     do {
       switch (token) {
         case STAR:
           if (ignoreStar) {
             // Mark the position after the star as the new start of the line.
           } else {
             // The star is part of the comment.
             if (builder.length() > 0) {
@@ -1379,6 +1381,7 @@ private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,
           }
 
           ignoreStar = true;
           token = next();
           continue;
 
@@ -1386,7 +1389,19 @@ private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,
           ignoreStar = false;
           state = State.SEARCHING_ANNOTATION;
 
               // All tokens must be separated by a space.
 
           if (token == JsDocToken.EOC ||
               token == JsDocToken.EOF ||
@@ -1411,9 +1426,6 @@ private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,
             return new ExtractionInfo(multilineText, token);
           }
 
        if (builder.length() > 0) {
          builder.append(' ');
        }
           builder.append(toString(token));
 
           line = stream.getRemainingJSDocLine();
","@@ -1355,12 +1355,14 @@ private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,
     // Track the start of the line to count whitespace that
     // the tokenizer skipped. Because this case is rare, it's easier
     // to do this here than in the tokenizer.
  int lineStartChar = -1;
 
     do {
       switch (token) {
         case STAR:
           if (ignoreStar) {
             // Mark the position after the star as the new start of the line.
          lineStartChar = stream.getCharno() + 1;
           } else {
             // The star is part of the comment.
             if (builder.length() > 0) {
@@ -1379,6 +1381,7 @@ private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,
           }
 
           ignoreStar = true;
        lineStartChar = 0;
           token = next();
           continue;
 
@@ -1386,7 +1389,19 @@ private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,
           ignoreStar = false;
           state = State.SEARCHING_ANNOTATION;
 
        boolean isEOC = token == JsDocToken.EOC;
        if (!isEOC) {
          if (lineStartChar != -1 && option == WhitespaceOption.PRESERVE) {
            int numSpaces = stream.getCharno() - lineStartChar;
            for (int i = 0; i < numSpaces; i++) {
              builder.append(' ');
            }
            lineStartChar = -1;
          } else if (builder.length() > 0) {
               // All tokens must be separated by a space.
            builder.append(' ');
          }
        }
 
           if (token == JsDocToken.EOC ||
               token == JsDocToken.EOF ||
@@ -1411,9 +1426,6 @@ private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,
             return new ExtractionInfo(multilineText, token);
           }
 
           builder.append(toString(token));
 
           line = stream.getRemainingJSDocLine();
","
                
     do {
       switch (token) {
         case STAR:
           if (ignoreStar) {
                        } else {
                          if (builder.length() > 0) {

           }
 
           ignoreStar = true;
           token = next();
           continue;
 

           ignoreStar = false;
           state = State.SEARCHING_ANNOTATION;
 
                
           if (token == JsDocToken.EOC ||
               token == JsDocToken.EOF ||

             return new ExtractionInfo(multilineText, token);
           }
 
          if (builder.length() > 0) {
            builder.append(' ');
          }
           builder.append(toString(token));
 
           line = stream.getRemainingJSDocLine();
","
                   int lineStartChar = -1;
 
     do {
       switch (token) {
         case STAR:
           if (ignoreStar) {
                         lineStartChar = stream.getCharno() + 1;
           } else {
                          if (builder.length() > 0) {

           }
 
           ignoreStar = true;
          lineStartChar = 0;
           token = next();
           continue;
 

           ignoreStar = false;
           state = State.SEARCHING_ANNOTATION;
 
          boolean isEOC = token == JsDocToken.EOC;
          if (!isEOC) {
            if (lineStartChar != -1 && option == WhitespaceOption.PRESERVE) {
              int numSpaces = stream.getCharno() - lineStartChar;
              for (int i = 0; i < numSpaces; i++) {
                builder.append(' ');
              }
              lineStartChar = -1;
            } else if (builder.length() > 0) {
                             builder.append(' ');
            }
          }
 
           if (token == JsDocToken.EOC ||
               token == JsDocToken.EOF ||

             return new ExtractionInfo(multilineText, token);
           }
 
           builder.append(toString(token));
 
           line = stream.getRemainingJSDocLine();
"
58,"junit.framework.AssertionFailedError","/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java","@@ -554,6 +554,9 @@ JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {
   @Override
   public void matchConstraint(ObjectType constraintObj) {
     // We only want to match contraints on anonymous types.
 
     // Handle the case where the constraint object is a record type.
     //
","@@ -554,6 +554,9 @@ JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {
   @Override
   public void matchConstraint(ObjectType constraintObj) {
     // We only want to match contraints on anonymous types.
  if (hasReferenceName()) {
    return;
  }
 
     // Handle the case where the constraint object is a record type.
     //
","
   @Override
   public void matchConstraint(ObjectType constraintObj) {
      
          ","
   @Override
   public void matchConstraint(ObjectType constraintObj) {
         if (hasReferenceName()) {
      return;
    }
 
          "
59,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/InlineCostEstimator.java","@@ -99,5 +99,9 @@ void addIdentifier(String identifier) {
      * Constants (true, false, null) are considered basically free,
      * because it's likely that they will get folded when we're done.
      */
   }
 }
","@@ -99,5 +99,9 @@ void addIdentifier(String identifier) {
      * Constants (true, false, null) are considered basically free,
      * because it's likely that they will get folded when we're done.
      */
  @Override
  void addConstant(String newcode) {
    add(""0"");
  }
   }
 }
","
 }
","
    void addConstant(String newcode) {
      add(""0"");
    }
   }
 }
"
60,"java.lang.StackOverflowError","/src/com/google/javascript/jscomp/CodeGenerator.java","@@ -119,9 +119,7 @@ void add(Node n, Context context) {
         cc.addOp(opstr, true);
         addExpr(last, p, rhsContext);
       } else {
      addExpr(first, p, context);
      cc.addOp(opstr, true);
      addExpr(last, p + 1, rhsContext);
       }
       return;
     }
@@ -751,7 +749,7 @@ private void unrollBinaryOperator(
     Node current = firstNonOperator;
     do {
       current = current.getParent();
    cc.listSeparator();
       addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);
     } while (current != n);
   }
/src/com/google/javascript/jscomp/CodePrinter.java @@ -331,7 +331,7 @@ void endCaseBody() {
     @Override
     void appendOp(String op, boolean binOp) {
       if (binOp) {
      if (getLastChar() != ' ') {
           append("" "");
         }
         append(op);
","@@ -119,9 +119,7 @@ void add(Node n, Context context) {
         cc.addOp(opstr, true);
         addExpr(last, p, rhsContext);
       } else {
      unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);
       }
       return;
     }
@@ -751,7 +749,7 @@ private void unrollBinaryOperator(
     Node current = firstNonOperator;
     do {
       current = current.getParent();
    cc.addOp(opStr, true);
       addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);
     } while (current != n);
   }
/src/com/google/javascript/jscomp/CodePrinter.java @@ -331,7 +331,7 @@ void endCaseBody() {
     @Override
     void appendOp(String op, boolean binOp) {
       if (binOp) {
      if (getLastChar() != ' ' && op.charAt(0) != ',') {
           append("" "");
         }
         append(op);
","
         cc.addOp(opstr, true);
         addExpr(last, p, rhsContext);
       } else {
        addExpr(first, p, context);
        cc.addOp(opstr, true);
        addExpr(last, p + 1, rhsContext);
       }
       return;
     }

     Node current = firstNonOperator;
     do {
       current = current.getParent();
      cc.listSeparator();
       addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);
     } while (current != n);
   }

     @Override
     void appendOp(String op, boolean binOp) {
       if (binOp) {
        if (getLastChar() != ' ') {
           append("" "");
         }
         append(op);
","
         cc.addOp(opstr, true);
         addExpr(last, p, rhsContext);
       } else {
        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);
       }
       return;
     }

     Node current = firstNonOperator;
     do {
       current = current.getParent();
      cc.addOp(opStr, true);
       addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);
     } while (current != n);
   }

     @Override
     void appendOp(String op, boolean binOp) {
       if (binOp) {
        if (getLastChar() != ' ' && op.charAt(0) != ',') {
           append("" "");
         }
         append(op);
"
61,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/TypeInference.java","@@ -1118,21 +1118,8 @@ private void inferPropertyTypesToMatchConstraint(
 
     ObjectType constraintObj =
         ObjectType.cast(constraint.restrictByNotNullOrUndefined());
  if (constraintObj != null && constraintObj.isRecordType()) {
    ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());
    if (objType != null) {
      for (String prop : constraintObj.getOwnPropertyNames()) {
        JSType propType = constraintObj.getPropertyType(prop);
        if (!objType.isPropertyTypeDeclared(prop)) {
          JSType typeToInfer = propType;
          if (!objType.hasProperty(prop)) {
            typeToInfer =
                getNativeType(VOID_TYPE).getLeastSupertype(propType);
          }
          objType.defineInferredProperty(prop, typeToInfer, null);
        }
      }
    }
     }
   }
 
","@@ -1118,21 +1118,8 @@ private void inferPropertyTypesToMatchConstraint(
 
     ObjectType constraintObj =
         ObjectType.cast(constraint.restrictByNotNullOrUndefined());
  if (constraintObj != null) {
    type.matchConstraint(constraintObj);
     }
   }
 
","
 
     ObjectType constraintObj =
         ObjectType.cast(constraint.restrictByNotNullOrUndefined());
    if (constraintObj != null && constraintObj.isRecordType()) {
      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());
      if (objType != null) {
        for (String prop : constraintObj.getOwnPropertyNames()) {
          JSType propType = constraintObj.getPropertyType(prop);
          if (!objType.isPropertyTypeDeclared(prop)) {
            JSType typeToInfer = propType;
            if (!objType.hasProperty(prop)) {
              typeToInfer =
                  getNativeType(VOID_TYPE).getLeastSupertype(propType);
            }
            objType.defineInferredProperty(prop, typeToInfer, null);
          }
        }
      }
     }
   }
 
","
 
     ObjectType constraintObj =
         ObjectType.cast(constraint.restrictByNotNullOrUndefined());
    if (constraintObj != null) {
      type.matchConstraint(constraintObj);
     }
   }
 
"
62,"java.lang.RuntimeException","/src/com/google/javascript/jscomp/NodeTraversal.java","@@ -538,7 +538,7 @@ private void traverseFunction(Node n, Node parent) {
 
     // Body
     Preconditions.checkState(body.getNext() == null &&
          body.isBlock());
     traverseBranch(body, n);
 
     popScope();
/src/com/google/javascript/jscomp/parsing/IRFactory.java @@ -664,9 +664,13 @@ Node processFunctionNode(FunctionNode functionNode) {
       node.addChildToBack(lp);
 
       Node bodyNode = transform(functionNode.getBody());
         // When in ideMode Rhino tries to parse some constructs the compiler
         // doesn't support, repair it here. see Rhino's
         // Parser#parseFunctionBodyExpr.
       parseDirectives(bodyNode);
       node.addChildToBack(bodyNode);
      return node;
","@@ -538,7 +538,7 @@ private void traverseFunction(Node n, Node parent) {
 
     // Body
     Preconditions.checkState(body.getNext() == null &&
          body.isBlock(), body);
     traverseBranch(body, n);
 
     popScope();
/src/com/google/javascript/jscomp/parsing/IRFactory.java @@ -664,9 +664,13 @@ Node processFunctionNode(FunctionNode functionNode) {
       node.addChildToBack(lp);
 
       Node bodyNode = transform(functionNode.getBody());
    if (!bodyNode.isBlock()) {
         // When in ideMode Rhino tries to parse some constructs the compiler
         // doesn't support, repair it here. see Rhino's
         // Parser#parseFunctionBodyExpr.
      Preconditions.checkState(config.isIdeMode);
      bodyNode = IR.block();
    }
       parseDirectives(bodyNode);
       node.addChildToBack(bodyNode);
      return node;
","
 
          Preconditions.checkState(body.getNext() == null &&
            body.isBlock());
     traverseBranch(body, n);
 
     popScope();

       node.addChildToBack(lp);
 
       Node bodyNode = transform(functionNode.getBody());
                                  parseDirectives(bodyNode);
       node.addChildToBack(bodyNode);
      return node;
","
 
          Preconditions.checkState(body.getNext() == null &&
            body.isBlock(), body);
     traverseBranch(body, n);
 
     popScope();

       node.addChildToBack(lp);
 
       Node bodyNode = transform(functionNode.getBody());
      if (!bodyNode.isBlock()) {
                                   Preconditions.checkState(config.isIdeMode);
        bodyNode = IR.block();
      }
       parseDirectives(bodyNode);
       node.addChildToBack(bodyNode);
      return node;
"
63,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/InlineVariables.java","@@ -572,6 +572,9 @@ private boolean canInline(
 
           // issue 668: Don't inline singleton getter methods
           // calls as this confused class removing logic.
         }
       }
 
","@@ -572,6 +572,9 @@ private boolean canInline(
 
           // issue 668: Don't inline singleton getter methods
           // calls as this confused class removing logic.
        if (convention.getSingletonGetterClassName(callNode) != null) {
          return false;
        }
         }
       }
 
","
 
                               }
       }
 
","
 
                                if (convention.getSingletonGetterClassName(callNode) != null) {
            return false;
          }
         }
       }
 
"
64,"junit.framework.ComparisonFailure","/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java","@@ -377,10 +377,10 @@ String toStringHelper(boolean forAnnotations) {
 
         sb.append(property);
         sb.append("": "");
      sb.append(getPropertyType(property).toString());
 
         ++i;
      if (i == MAX_PRETTY_PRINTED_PROPERTIES) {
           sb.append("", ..."");
           break;
         }
@@ -391,7 +391,7 @@ String toStringHelper(boolean forAnnotations) {
       prettyPrint = true;
       return sb.toString();
     } else {
    return ""{...}"";
     }
   }
 
","@@ -377,10 +377,10 @@ String toStringHelper(boolean forAnnotations) {
 
         sb.append(property);
         sb.append("": "");
      sb.append(getPropertyType(property).toStringHelper(forAnnotations));
 
         ++i;
      if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) {
           sb.append("", ..."");
           break;
         }
@@ -391,7 +391,7 @@ String toStringHelper(boolean forAnnotations) {
       prettyPrint = true;
       return sb.toString();
     } else {
    return forAnnotations ? ""?"" : ""{...}"";
     }
   }
 
","
 
         sb.append(property);
         sb.append("": "");
        sb.append(getPropertyType(property).toString());
 
         ++i;
        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {
           sb.append("", ..."");
           break;
         }

       prettyPrint = true;
       return sb.toString();
     } else {
      return ""{...}"";
     }
   }
 
","
 
         sb.append(property);
         sb.append("": "");
        sb.append(getPropertyType(property).toStringHelper(forAnnotations));
 
         ++i;
        if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) {
           sb.append("", ..."");
           break;
         }

       prettyPrint = true;
       return sb.toString();
     } else {
      return forAnnotations ? ""?"" : ""{...}"";
     }
   }
 
"
65,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/RemoveUnusedVars.java","@@ -729,6 +729,7 @@ private void interpretAssigns() {
             assignedToUnknownValue = true;
           }
 
           for (Assign assign : assignsByVar.get(var)) {
             if (assign.isPropertyAssign) {
               hasPropertyAssign = true;
@@ -736,9 +737,12 @@ private void interpretAssigns() {
                 assign.assignNode.getLastChild(), true)) {
               assignedToUnknownValue = true;
             }
           }
 
        if (assignedToUnknownValue && hasPropertyAssign) {
             changes = markReferencedVar(var) || changes;
             maybeUnreferenced.remove(current);
             current--;
@@ -901,7 +905,7 @@ void apply() {
       this.nameNode = nameNode;
       this.isPropertyAssign = isPropertyAssign;
 
    this.maybeAliased = !assignNode.getParent().isExprResult();
       this.mayHaveSecondarySideEffects =
           maybeAliased ||
           NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) ||
","@@ -729,6 +729,7 @@ private void interpretAssigns() {
             assignedToUnknownValue = true;
           }
 
        boolean maybeEscaped = false;
           for (Assign assign : assignsByVar.get(var)) {
             if (assign.isPropertyAssign) {
               hasPropertyAssign = true;
@@ -736,9 +737,12 @@ private void interpretAssigns() {
                 assign.assignNode.getLastChild(), true)) {
               assignedToUnknownValue = true;
             }
          if (assign.maybeAliased) {
            maybeEscaped = true;
          }
           }
 
        if ((assignedToUnknownValue || maybeEscaped) && hasPropertyAssign) {
             changes = markReferencedVar(var) || changes;
             maybeUnreferenced.remove(current);
             current--;
@@ -901,7 +905,7 @@ void apply() {
       this.nameNode = nameNode;
       this.isPropertyAssign = isPropertyAssign;
 
    this.maybeAliased = NodeUtil.isExpressionResultUsed(assignNode);
       this.mayHaveSecondarySideEffects =
           maybeAliased ||
           NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) ||
","
             assignedToUnknownValue = true;
           }
 
           for (Assign assign : assignsByVar.get(var)) {
             if (assign.isPropertyAssign) {
               hasPropertyAssign = true;

                 assign.assignNode.getLastChild(), true)) {
               assignedToUnknownValue = true;
             }
           }
 
          if (assignedToUnknownValue && hasPropertyAssign) {
             changes = markReferencedVar(var) || changes;
             maybeUnreferenced.remove(current);
             current--;

       this.nameNode = nameNode;
       this.isPropertyAssign = isPropertyAssign;
 
      this.maybeAliased = !assignNode.getParent().isExprResult();
       this.mayHaveSecondarySideEffects =
           maybeAliased ||
           NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) ||
","
             assignedToUnknownValue = true;
           }
 
          boolean maybeEscaped = false;
           for (Assign assign : assignsByVar.get(var)) {
             if (assign.isPropertyAssign) {
               hasPropertyAssign = true;

                 assign.assignNode.getLastChild(), true)) {
               assignedToUnknownValue = true;
             }
            if (assign.maybeAliased) {
              maybeEscaped = true;
            }
           }
 
          if ((assignedToUnknownValue || maybeEscaped) && hasPropertyAssign) {
             changes = markReferencedVar(var) || changes;
             maybeUnreferenced.remove(current);
             current--;

       this.nameNode = nameNode;
       this.isPropertyAssign = isPropertyAssign;
 
      this.maybeAliased = NodeUtil.isExpressionResultUsed(assignNode);
       this.mayHaveSecondarySideEffects =
           maybeAliased ||
           NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) ||
"
66,"junit.framework.ComparisonFailure","/src/com/google/javascript/jscomp/CodeConsumer.java","@@ -242,7 +242,7 @@ void addNumber(double x) {
     // x--4 (which is a syntax error).
     char prev = getLastChar();
     boolean negativeZero = isNegativeZero(x);
  if (x < 0 && prev == '-') {
       add("" "");
     }
 
","@@ -242,7 +242,7 @@ void addNumber(double x) {
     // x--4 (which is a syntax error).
     char prev = getLastChar();
     boolean negativeZero = isNegativeZero(x);
  if ((x < 0 || negativeZero) && prev == '-') {
       add("" "");
     }
 
","
          char prev = getLastChar();
     boolean negativeZero = isNegativeZero(x);
    if (x < 0 && prev == '-') {
       add("" "");
     }
 
","
          char prev = getLastChar();
     boolean negativeZero = isNegativeZero(x);
    if ((x < 0 || negativeZero) && prev == '-') {
       add("" "");
     }
 
"
67,"java.lang.RuntimeException","/src/com/google/javascript/jscomp/NameAnalyzer.java","@@ -632,11 +632,9 @@ public void visit(NodeTraversal t, Node n, Node parent) {
         Node nameNode = n.getFirstChild();
         NameInformation ns = createNameInformation(t, nameNode, n);
         if (ns != null && ns.onlyAffectsClassDef) {
        JsName name = getName(ns.name, false);
        if (name != null) {
           refNodes.add(new ClassDefiningFunctionNode(
               name, n, parent, parent.getParent()));
        }
         }
       }
     }
","@@ -632,11 +632,9 @@ public void visit(NodeTraversal t, Node n, Node parent) {
         Node nameNode = n.getFirstChild();
         NameInformation ns = createNameInformation(t, nameNode, n);
         if (ns != null && ns.onlyAffectsClassDef) {
        JsName name = getName(ns.name, true);
           refNodes.add(new ClassDefiningFunctionNode(
               name, n, parent, parent.getParent()));
         }
       }
     }
","
         Node nameNode = n.getFirstChild();
         NameInformation ns = createNameInformation(t, nameNode, n);
         if (ns != null && ns.onlyAffectsClassDef) {
          JsName name = getName(ns.name, false);
          if (name != null) {
           refNodes.add(new ClassDefiningFunctionNode(
               name, n, parent, parent.getParent()));
          }
         }
       }
     }
","
         Node nameNode = n.getFirstChild();
         NameInformation ns = createNameInformation(t, nameNode, n);
         if (ns != null && ns.onlyAffectsClassDef) {
          JsName name = getName(ns.name, true);
           refNodes.add(new ClassDefiningFunctionNode(
               name, n, parent, parent.getParent()));
         }
       }
     }
"
68,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/parsing/IRFactory.java","@@ -565,8 +565,15 @@ Node processExpressionStatement(ExpressionStatement statementNode) {
 
     @Override
     Node processForInLoop(ForInLoop loopNode) {
 
         // Return the bare minimum to put the AST in a valid state.
       return newNode(
           Token.FOR,
           transform(loopNode.getIterator()),
","@@ -565,8 +565,15 @@ Node processExpressionStatement(ExpressionStatement statementNode) {
 
     @Override
     Node processForInLoop(ForInLoop loopNode) {
    if (loopNode.isForEach()) {
      errorReporter.error(
          ""unsupported language extension: for each"",
          sourceName,
          loopNode.getLineno(), """", 0);
 
         // Return the bare minimum to put the AST in a valid state.
      return newNode(Token.EXPR_RESULT, Node.newNumber(0));
    }
       return newNode(
           Token.FOR,
           transform(loopNode.getIterator()),
","
 
     @Override
     Node processForInLoop(ForInLoop loopNode) {
 
                return newNode(
           Token.FOR,
           transform(loopNode.getIterator()),
","
 
     @Override
     Node processForInLoop(ForInLoop loopNode) {
      if (loopNode.isForEach()) {
        errorReporter.error(
            ""unsupported language extension: for each"",
            sourceName,
            loopNode.getLineno(), """", 0);
 
                 return newNode(Token.EXPR_RESULT, Node.newNumber(0));
      }
       return newNode(
           Token.FOR,
           transform(loopNode.getIterator()),
"
69,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/FunctionTypeBuilder.java","@@ -289,6 +289,9 @@ FunctionTypeBuilder inferFromOverriddenFunction(
       }
 
       // Clone any remaining params that aren't in the function literal.
 
       parametersNode = paramBuilder.build();
     }
@@ -480,6 +483,12 @@ FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,
     }
 
     // Copy over any old parameters that aren't in the param list.
 
     if (templateTypeName != null && !foundTemplateType) {
       reportError(TEMPLATE_TYPE_EXPECTED, fnName);
","@@ -289,6 +289,9 @@ FunctionTypeBuilder inferFromOverriddenFunction(
       }
 
       // Clone any remaining params that aren't in the function literal.
    while (oldParams.hasNext()) {
      paramBuilder.newParameterFromNode(oldParams.next());
    }
 
       parametersNode = paramBuilder.build();
     }
@@ -480,6 +483,12 @@ FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,
     }
 
     // Copy over any old parameters that aren't in the param list.
  if (!isVarArgs) {
    while (oldParameterType != null && !isVarArgs) {
      builder.newParameterFromNode(oldParameterType);
      oldParameterType = oldParameterType.getNext();
    }
  }
 
     if (templateTypeName != null && !foundTemplateType) {
       reportError(TEMPLATE_TYPE_EXPECTED, fnName);
","
       }
 
        
       parametersNode = paramBuilder.build();
     }

     }
 
      
     if (templateTypeName != null && !foundTemplateType) {
       reportError(TEMPLATE_TYPE_EXPECTED, fnName);
","
       }
 
             while (oldParams.hasNext()) {
        paramBuilder.newParameterFromNode(oldParams.next());
      }
 
       parametersNode = paramBuilder.build();
     }

     }
 
         if (!isVarArgs) {
      while (oldParameterType != null && !isVarArgs) {
        builder.newParameterFromNode(oldParameterType);
        oldParameterType = oldParameterType.getNext();
      }
    }
 
     if (templateTypeName != null && !foundTemplateType) {
       reportError(TEMPLATE_TYPE_EXPECTED, fnName);
"
70,"junit.framework.ComparisonFailure","/src/com/google/javascript/jscomp/CodeConsumer.java","@@ -191,11 +191,13 @@ void add(String newcode) {
       // need space to separate. This is not pretty printing.
       // For example: ""return foo;""
       append("" "");
       // Do not allow a forward slash to appear after a DIV.
       // For example,
       // REGEXP DIV REGEXP
       // is valid and should print like
       // / // / /
     }
 
     append(newcode);
","@@ -191,11 +191,13 @@ void add(String newcode) {
       // need space to separate. This is not pretty printing.
       // For example: ""return foo;""
       append("" "");
  } else if (c == '/' && getLastChar() == '/') {
       // Do not allow a forward slash to appear after a DIV.
       // For example,
       // REGEXP DIV REGEXP
       // is valid and should print like
       // / // / /
    append("" "");
     }
 
     append(newcode);
","
                     append("" "");
                                        }
 
     append(newcode);
","
                     append("" "");
    } else if (c == '/' && getLastChar() == '/') {
                                         append("" "");
     }
 
     append(newcode);
"
71,"junit.framework.ComparisonFailure","/src/com/google/javascript/jscomp/TypedScopeCreator.java","@@ -390,50 +390,51 @@ private void identifyNameNode(
   private JSType getNativeType(JSTypeNative nativeType) {
     return typeRegistry.getNativeType(nativeType);
   }
 
   private abstract class AbstractScopeBuilder
       implements NodeTraversal.Callback {
 
     /**
      * The scope that we're builidng.
      */
     final Scope scope;
 
     private final List<DeferredSetType> deferredSetTypes =
         Lists.newArrayList();
 
     /**
      * Functions that we found in the global scope and not in externs.
      */
     private final List<Node> nonExternFunctions = Lists.newArrayList();
 
     /**
      * Object literals with a @lends annotation aren't analyzed until we
      * reach the root of the statement they're defined in.
      *
      * This ensures that if there are any @lends annotations on the object
      * literals, the type on the @lends annotation resolves correctly.
      *
      * For more information, see
      * http://code.google.com/p/closure-compiler/issues/detail?id=314
      */
 
     /**
      * Type-less stubs.
      *
      * If at the end of traversal, we still don't have types for these
      * stubs, then we should declare UNKNOWN types.
      */
     private final List<StubDeclaration> stubDeclarations =
         Lists.newArrayList();
 
     /**
      * The current source file that we're in.
      */
     private String sourceName = null;
 
     /**
      * The InputId of the current node.
      */
     private InputId inputId;
 
@@ -498,90 +499,106 @@ public final boolean shouldTraverse(NodeTraversal t, Node n,
     public void visit(NodeTraversal t, Node n, Node parent) {
       inputId = t.getInputId();
       attachLiteralTypes(t, n);
 
       switch (n.getType()) {
         case Token.CALL:
           checkForClassDefiningCalls(t, n, parent);
           checkForCallingConventionDefiningCalls(n, delegateCallingConventions);
           break;
 
         case Token.FUNCTION:
           if (t.getInput() == null || !t.getInput().isExtern()) {
             nonExternFunctions.add(n);
           }
 
           // Hoisted functions are handled during pre-traversal.
           if (!NodeUtil.isHoistedFunctionDeclaration(n)) {
             defineFunctionLiteral(n, parent);
           }
           break;
 
         case Token.ASSIGN:
           // Handle initialization of properties.
           Node firstChild = n.getFirstChild();
           if (firstChild.isGetProp() &&
               firstChild.isQualifiedName()) {
             maybeDeclareQualifiedName(t, n.getJSDocInfo(),
                 firstChild, n, firstChild.getNext());
           }
           break;
 
         case Token.CATCH:
           defineCatch(n, parent);
           break;
 
         case Token.VAR:
           defineVar(n, parent);
           break;
 
         case Token.GETPROP:
           // Handle stubbed properties.
           if (parent.isExprResult() &&
               n.isQualifiedName()) {
             maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);
           }
           break;
       }
 
       // Analyze any @lends object literals in this statement.
     }
 
     private void attachLiteralTypes(NodeTraversal t, Node n) {
       switch (n.getType()) {
         case Token.NULL:
           n.setJSType(getNativeType(NULL_TYPE));
           break;
 
         case Token.VOID:
           n.setJSType(getNativeType(VOID_TYPE));
           break;
 
         case Token.STRING:
           // Defer keys to the Token.OBJECTLIT case
           if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
             n.setJSType(getNativeType(STRING_TYPE));
           }
           break;
 
         case Token.NUMBER:
           n.setJSType(getNativeType(NUMBER_TYPE));
           break;
 
         case Token.TRUE:
         case Token.FALSE:
           n.setJSType(getNativeType(BOOLEAN_TYPE));
           break;
 
         case Token.REGEXP:
           n.setJSType(getNativeType(REGEXP_TYPE));
           break;
 
         case Token.OBJECTLIT:
             defineObjectLiteral(n);
           break;
 
           // NOTE(nicksantos): If we ever support Array tuples,
           // we will need to put ARRAYLIT here as well.
       }
     }
 
","@@ -390,50 +390,51 @@ private void identifyNameNode(
   private JSType getNativeType(JSTypeNative nativeType) {
     return typeRegistry.getNativeType(nativeType);
   }
 
   private abstract class AbstractScopeBuilder
       implements NodeTraversal.Callback {
 
     /**
      * The scope that we're builidng.
      */
     final Scope scope;
 
     private final List<DeferredSetType> deferredSetTypes =
         Lists.newArrayList();
 
     /**
      * Functions that we found in the global scope and not in externs.
      */
     private final List<Node> nonExternFunctions = Lists.newArrayList();
 
     /**
      * Object literals with a @lends annotation aren't analyzed until we
      * reach the root of the statement they're defined in.
      *
      * This ensures that if there are any @lends annotations on the object
      * literals, the type on the @lends annotation resolves correctly.
      *
      * For more information, see
      * http://code.google.com/p/closure-compiler/issues/detail?id=314
      */
  private List<Node> lentObjectLiterals = null;
 
     /**
      * Type-less stubs.
      *
      * If at the end of traversal, we still don't have types for these
      * stubs, then we should declare UNKNOWN types.
      */
     private final List<StubDeclaration> stubDeclarations =
         Lists.newArrayList();
 
     /**
      * The current source file that we're in.
      */
     private String sourceName = null;
 
     /**
      * The InputId of the current node.
      */
     private InputId inputId;
 
@@ -498,90 +499,106 @@ public final boolean shouldTraverse(NodeTraversal t, Node n,
     public void visit(NodeTraversal t, Node n, Node parent) {
       inputId = t.getInputId();
       attachLiteralTypes(t, n);
 
       switch (n.getType()) {
         case Token.CALL:
           checkForClassDefiningCalls(t, n, parent);
           checkForCallingConventionDefiningCalls(n, delegateCallingConventions);
           break;
 
         case Token.FUNCTION:
           if (t.getInput() == null || !t.getInput().isExtern()) {
             nonExternFunctions.add(n);
           }
 
           // Hoisted functions are handled during pre-traversal.
           if (!NodeUtil.isHoistedFunctionDeclaration(n)) {
             defineFunctionLiteral(n, parent);
           }
           break;
 
         case Token.ASSIGN:
           // Handle initialization of properties.
           Node firstChild = n.getFirstChild();
           if (firstChild.isGetProp() &&
               firstChild.isQualifiedName()) {
             maybeDeclareQualifiedName(t, n.getJSDocInfo(),
                 firstChild, n, firstChild.getNext());
           }
           break;
 
         case Token.CATCH:
           defineCatch(n, parent);
           break;
 
         case Token.VAR:
           defineVar(n, parent);
           break;
 
         case Token.GETPROP:
           // Handle stubbed properties.
           if (parent.isExprResult() &&
               n.isQualifiedName()) {
             maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);
           }
           break;
       }
 
       // Analyze any @lends object literals in this statement.
    if (n.getParent() != null && NodeUtil.isStatement(n) &&
        lentObjectLiterals != null) {
      for (Node objLit : lentObjectLiterals) {
        defineObjectLiteral(objLit);
      }
      lentObjectLiterals.clear();
    }
     }
 
     private void attachLiteralTypes(NodeTraversal t, Node n) {
       switch (n.getType()) {
         case Token.NULL:
           n.setJSType(getNativeType(NULL_TYPE));
           break;
 
         case Token.VOID:
           n.setJSType(getNativeType(VOID_TYPE));
           break;
 
         case Token.STRING:
           // Defer keys to the Token.OBJECTLIT case
           if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
             n.setJSType(getNativeType(STRING_TYPE));
           }
           break;
 
         case Token.NUMBER:
           n.setJSType(getNativeType(NUMBER_TYPE));
           break;
 
         case Token.TRUE:
         case Token.FALSE:
           n.setJSType(getNativeType(BOOLEAN_TYPE));
           break;
 
         case Token.REGEXP:
           n.setJSType(getNativeType(REGEXP_TYPE));
           break;
 
         case Token.OBJECTLIT:
        JSDocInfo info = n.getJSDocInfo();
        if (info != null &&
            info.getLendsName() != null) {
          if (lentObjectLiterals == null) {
            lentObjectLiterals = Lists.newArrayList();
          }
          lentObjectLiterals.add(n);
        } else {
             defineObjectLiteral(n);
        }
           break;
 
           // NOTE(nicksantos): If we ever support Array tuples,
           // we will need to put ARRAYLIT here as well.
       }
     }
 
","
   private JSType getNativeType(JSTypeNative nativeType) {
     return typeRegistry.getNativeType(nativeType);
   }
 
   private abstract class AbstractScopeBuilder
       implements NodeTraversal.Callback {
 
     final Scope scope;
 
     private final List<DeferredSetType> deferredSetTypes =
         Lists.newArrayList();
 
     private final List<Node> nonExternFunctions = Lists.newArrayList();
 
 
     private final List<StubDeclaration> stubDeclarations =
         Lists.newArrayList();
      private String sourceName = null;
 
     private InputId inputId;
 

     public void visit(NodeTraversal t, Node n, Node parent) {
       inputId = t.getInputId();
       attachLiteralTypes(t, n);
 
       switch (n.getType()) {
         case Token.CALL:
           checkForClassDefiningCalls(t, n, parent);
           checkForCallingConventionDefiningCalls(n, delegateCallingConventions);
           break;
 
         case Token.FUNCTION:
           if (t.getInput() == null || !t.getInput().isExtern()) {
             nonExternFunctions.add(n);
           }
 
                      if (!NodeUtil.isHoistedFunctionDeclaration(n)) {
             defineFunctionLiteral(n, parent);
           }
           break;
 
         case Token.ASSIGN:
                      Node firstChild = n.getFirstChild();
           if (firstChild.isGetProp() &&
               firstChild.isQualifiedName()) {
             maybeDeclareQualifiedName(t, n.getJSDocInfo(),
                 firstChild, n, firstChild.getNext());
           }
           break;
 
         case Token.CATCH:
           defineCatch(n, parent);
           break;
 
         case Token.VAR:
           defineVar(n, parent);
           break;
 
         case Token.GETPROP:
                      if (parent.isExprResult() &&
               n.isQualifiedName()) {
             maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);
           }
           break;
       }
 
            }
 
     private void attachLiteralTypes(NodeTraversal t, Node n) {
       switch (n.getType()) {
         case Token.NULL:
           n.setJSType(getNativeType(NULL_TYPE));
           break;
 
         case Token.VOID:
           n.setJSType(getNativeType(VOID_TYPE));
           break;
 
         case Token.STRING:
                      if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
             n.setJSType(getNativeType(STRING_TYPE));
           }
           break;
 
         case Token.NUMBER:
           n.setJSType(getNativeType(NUMBER_TYPE));
           break;
 
         case Token.TRUE:
         case Token.FALSE:
           n.setJSType(getNativeType(BOOLEAN_TYPE));
           break;
 
         case Token.REGEXP:
           n.setJSType(getNativeType(REGEXP_TYPE));
           break;
 
         case Token.OBJECTLIT:
             defineObjectLiteral(n);
           break;
 
                             }
     }
 
","
   private JSType getNativeType(JSTypeNative nativeType) {
     return typeRegistry.getNativeType(nativeType);
   }
 
   private abstract class AbstractScopeBuilder
       implements NodeTraversal.Callback {     final Scope scope;
 
     private final List<DeferredSetType> deferredSetTypes =
         Lists.newArrayList();     private final List<Node> nonExternFunctions = Lists.newArrayList();
 
    private List<Node> lentObjectLiterals = null;
 
     private final List<StubDeclaration> stubDeclarations =
         Lists.newArrayList();
 
     private String sourceName = null;
 
     private InputId inputId;
 

     public void visit(NodeTraversal t, Node n, Node parent) {
       inputId = t.getInputId();
       attachLiteralTypes(t, n);
 
       switch (n.getType()) {
         case Token.CALL:
           checkForClassDefiningCalls(t, n, parent);
           checkForCallingConventionDefiningCalls(n, delegateCallingConventions);
           break;
 
         case Token.FUNCTION:
           if (t.getInput() == null || !t.getInput().isExtern()) {
             nonExternFunctions.add(n);
           }
 
                      if (!NodeUtil.isHoistedFunctionDeclaration(n)) {
             defineFunctionLiteral(n, parent);
           }
           break;
 
         case Token.ASSIGN:
                      Node firstChild = n.getFirstChild();
           if (firstChild.isGetProp() &&
               firstChild.isQualifiedName()) {
             maybeDeclareQualifiedName(t, n.getJSDocInfo(),
                 firstChild, n, firstChild.getNext());
           }
           break;
 
         case Token.CATCH:
           defineCatch(n, parent);
           break;
 
         case Token.VAR:
           defineVar(n, parent);
           break;
 
         case Token.GETPROP:
                      if (parent.isExprResult() &&
               n.isQualifiedName()) {
             maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);
           }
           break;
       }
 
             if (n.getParent() != null && NodeUtil.isStatement(n) &&
          lentObjectLiterals != null) {
        for (Node objLit : lentObjectLiterals) {
          defineObjectLiteral(objLit);
        }
        lentObjectLiterals.clear();
      }
     }
 
     private void attachLiteralTypes(NodeTraversal t, Node n) {
       switch (n.getType()) {
         case Token.NULL:
           n.setJSType(getNativeType(NULL_TYPE));
           break;
 
         case Token.VOID:
           n.setJSType(getNativeType(VOID_TYPE));
           break;
 
         case Token.STRING:
                      if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
             n.setJSType(getNativeType(STRING_TYPE));
           }
           break;
 
         case Token.NUMBER:
           n.setJSType(getNativeType(NUMBER_TYPE));
           break;
 
         case Token.TRUE:
         case Token.FALSE:
           n.setJSType(getNativeType(BOOLEAN_TYPE));
           break;
 
         case Token.REGEXP:
           n.setJSType(getNativeType(REGEXP_TYPE));
           break;
 
         case Token.OBJECTLIT:
          JSDocInfo info = n.getJSDocInfo();
          if (info != null &&
              info.getLendsName() != null) {
            if (lentObjectLiterals == null) {
              lentObjectLiterals = Lists.newArrayList();
            }
            lentObjectLiterals.add(n);
          } else {
             defineObjectLiteral(n);
          }
           break;
 
                             }
     }
 
"
72,"junit.framework.AssertionFailedError","/src/com/google/javascript/rhino/jstype/RecordType.java","@@ -137,22 +137,6 @@ boolean defineProperty(String propertyName, JSType type,
         propertyNode);
   }
 
@Override
public JSType getLeastSupertype(JSType that) {
  if (!that.isRecordType()) {
    return super.getLeastSupertype(that);
  }
  RecordTypeBuilder builder = new RecordTypeBuilder(registry);
  for (String property : properties.keySet()) {
    if (that.toMaybeRecordType().hasProperty(property) &&
        that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(
            getPropertyType(property))) {
      builder.addProperty(property, getPropertyType(property),
          getPropertyNode(property));
    }
  }
  return builder.build();
}
   JSType getGreatestSubtypeHelper(JSType that) {
     if (that.isRecordType()) {
       RecordType thatRecord = that.toMaybeRecordType();
","@@ -137,22 +137,6 @@ boolean defineProperty(String propertyName, JSType type,
         propertyNode);
   }
 
   JSType getGreatestSubtypeHelper(JSType that) {
     if (that.isRecordType()) {
       RecordType thatRecord = that.toMaybeRecordType();
","
         propertyNode);
   }
 
  @Override
  public JSType getLeastSupertype(JSType that) {
    if (!that.isRecordType()) {
      return super.getLeastSupertype(that);
    }
    RecordTypeBuilder builder = new RecordTypeBuilder(registry);
    for (String property : properties.keySet()) {
      if (that.toMaybeRecordType().hasProperty(property) &&
          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(
              getPropertyType(property))) {
        builder.addProperty(property, getPropertyType(property),
            getPropertyNode(property));
      }
    }
    return builder.build();
  }
   JSType getGreatestSubtypeHelper(JSType that) {
     if (that.isRecordType()) {
       RecordType thatRecord = that.toMaybeRecordType();
","
         propertyNode);
   }
 
   JSType getGreatestSubtypeHelper(JSType that) {
     if (that.isRecordType()) {
       RecordType thatRecord = that.toMaybeRecordType();
"
73,"junit.framework.AssertionFailedError","/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java","@@ -486,8 +486,8 @@ private OriginalMapping getOriginalMappingForEntry(Entry entry) {
       // Adjust the line/column here to be start at 1.
       Builder x = OriginalMapping.newBuilder()
         .setOriginalFile(sources[entry.getSourceFileId()])
      .setLineNumber(entry.getSourceLine())
      .setColumnPosition(entry.getSourceColumn());
       if (entry.getNameId() != UNMAPPED) {
         x.setIdentifier(names[entry.getNameId()]);
       }
/src/com/google/javascript/jscomp/SourceMap.java @@ -135,10 +135,15 @@ public void addMapping(
     // zero based.
     // We don't change this for the v1 or v2 source maps but for
     // v3 we make them both 0 based.
 
     generator.addMapping(
         sourceFile, originalName,
      new FilePosition(node.getLineno(), node.getCharno()),
         outputStartPosition, outputEndPosition);
   }
 
","@@ -486,8 +486,8 @@ private OriginalMapping getOriginalMappingForEntry(Entry entry) {
       // Adjust the line/column here to be start at 1.
       Builder x = OriginalMapping.newBuilder()
         .setOriginalFile(sources[entry.getSourceFileId()])
      .setLineNumber(entry.getSourceLine() + 1)
      .setColumnPosition(entry.getSourceColumn() + 1);
       if (entry.getNameId() != UNMAPPED) {
         x.setIdentifier(names[entry.getNameId()]);
       }
/src/com/google/javascript/jscomp/SourceMap.java @@ -135,10 +135,15 @@ public void addMapping(
     // zero based.
     // We don't change this for the v1 or v2 source maps but for
     // v3 we make them both 0 based.
  int lineBaseOffset = 1;
  if (generator instanceof SourceMapGeneratorV1
      || generator instanceof SourceMapGeneratorV2) {
    lineBaseOffset = 0;
  }
 
     generator.addMapping(
         sourceFile, originalName,
      new FilePosition(node.getLineno() - lineBaseOffset, node.getCharno()),
         outputStartPosition, outputEndPosition);
   }
 
","
              Builder x = OriginalMapping.newBuilder()
         .setOriginalFile(sources[entry.getSourceFileId()])
        .setLineNumber(entry.getSourceLine())
        .setColumnPosition(entry.getSourceColumn());
       if (entry.getNameId() != UNMAPPED) {
         x.setIdentifier(names[entry.getNameId()]);
       }

                
     generator.addMapping(
         sourceFile, originalName,
        new FilePosition(node.getLineno(), node.getCharno()),
         outputStartPosition, outputEndPosition);
   }
 
","
              Builder x = OriginalMapping.newBuilder()
         .setOriginalFile(sources[entry.getSourceFileId()])
        .setLineNumber(entry.getSourceLine() + 1)
        .setColumnPosition(entry.getSourceColumn() + 1);
       if (entry.getNameId() != UNMAPPED) {
         x.setIdentifier(names[entry.getNameId()]);
       }

                   int lineBaseOffset = 1;
    if (generator instanceof SourceMapGeneratorV1
        || generator instanceof SourceMapGeneratorV2) {
      lineBaseOffset = 0;
    }
 
     generator.addMapping(
         sourceFile, originalName,
        new FilePosition(node.getLineno() - lineBaseOffset, node.getCharno()),
         outputStartPosition, outputEndPosition);
   }
 
"
74,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/TypedScopeCreator.java","@@ -1518,11 +1518,14 @@ void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,
             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
       }
 
    if (inferred) {
         // Determining declaration for #2
      inferred = !(rhsValue != null &&
          rhsValue.isFunction() &&
          (info != null || !scope.isDeclared(qName, false)));
       }
 
       if (!inferred) {
","@@ -1518,11 +1518,14 @@ void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,
             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
       }
 
    if (inferred && rhsValue != null && rhsValue.isFunction()) {
         // Determining declaration for #2
      if (info != null) {
        inferred = false;
      } else if (!scope.isDeclared(qName, false) &&
                 n.isUnscopedQualifiedName()) {
        inferred = false;
      }
       }
 
       if (!inferred) {
","
             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
       }
 
      if (inferred) {
                 inferred = !(rhsValue != null &&
            rhsValue.isFunction() &&
            (info != null || !scope.isDeclared(qName, false)));
       }
 
       if (!inferred) {
","
             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));
       }
 
      if (inferred && rhsValue != null && rhsValue.isFunction()) {
                 if (info != null) {
          inferred = false;
        } else if (!scope.isDeclared(qName, false) &&
                   n.isUnscopedQualifiedName()) {
          inferred = false;
        }
       }
 
       if (!inferred) {
"
75,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java","@@ -88,14 +88,6 @@ public void enterScope(NodeTraversal t) {
       renamer = nameStack.peek().forChildScope();
     }
 
  if (declarationRoot.getType() == Token.FUNCTION) {
    for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {
      String name = c.getString();
      renamer.addDeclaredName(name);
    }
    Node functionBody = declarationRoot.getLastChild();
    findDeclaredNames(functionBody, null, renamer);
  }  else 
     if (declarationRoot.getType() != Token.FUNCTION) {
       // Add the block declarations
       findDeclaredNames(declarationRoot, null, renamer);
@@ -127,11 +119,22 @@ public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
             renamer.addDeclaredName(name);
           }
 
 
 
           // Add the function parameters
 
           // Add the function body declarations
 
           nameStack.push(renamer);
         }
@@ -170,13 +173,16 @@ public void visit(NodeTraversal t, Node n, Node parent) {
 
       case Token.FUNCTION:
         // Remove the function body scope
         // Remove function recursive name (if any).
         nameStack.pop();
         break;
 
         // Note: The parameters and function body variables live in the
         // same scope, we introduce the scope when in the ""shouldTraverse""
         // visit of LP, but remove it when when we exit the function above.
 
       case Token.CATCH:
         // Remove catch except name from the stack of names.
","@@ -88,14 +88,6 @@ public void enterScope(NodeTraversal t) {
       renamer = nameStack.peek().forChildScope();
     }
 
     if (declarationRoot.getType() != Token.FUNCTION) {
       // Add the block declarations
       findDeclaredNames(declarationRoot, null, renamer);
@@ -127,11 +119,22 @@ public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
             renamer.addDeclaredName(name);
           }
 
        nameStack.push(renamer);
      }
      break;
 
    case Token.LP: {
        Renamer renamer = nameStack.peek().forChildScope();
 
           // Add the function parameters
        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
          String name = c.getString();
          renamer.addDeclaredName(name);
        }
 
           // Add the function body declarations
        Node functionBody = n.getNext();
        findDeclaredNames(functionBody, null, renamer);
 
           nameStack.push(renamer);
         }
@@ -170,13 +173,16 @@ public void visit(NodeTraversal t, Node n, Node parent) {
 
       case Token.FUNCTION:
         // Remove the function body scope
      nameStack.pop();
         // Remove function recursive name (if any).
         nameStack.pop();
         break;
 
    case Token.LP:
         // Note: The parameters and function body variables live in the
         // same scope, we introduce the scope when in the ""shouldTraverse""
         // visit of LP, but remove it when when we exit the function above.
      break;
 
       case Token.CATCH:
         // Remove catch except name from the stack of names.
","
       renamer = nameStack.peek().forChildScope();
     }
 
    if (declarationRoot.getType() == Token.FUNCTION) {
      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {
        String name = c.getString();
        renamer.addDeclaredName(name);
      }
      Node functionBody = declarationRoot.getLastChild();
      findDeclaredNames(functionBody, null, renamer);
    }  else 
     if (declarationRoot.getType() != Token.FUNCTION) {
              findDeclaredNames(declarationRoot, null, renamer);

             renamer.addDeclaredName(name);
           }
 
 
 
            
            
           nameStack.push(renamer);
         }

 
       case Token.FUNCTION:
                           nameStack.pop();
         break;
 
                            
       case Token.CATCH:
         ","
       renamer = nameStack.peek().forChildScope();
     }
 
     if (declarationRoot.getType() != Token.FUNCTION) {
              findDeclaredNames(declarationRoot, null, renamer);

             renamer.addDeclaredName(name);
           }
 
          nameStack.push(renamer);
        }
        break;
 
      case Token.LP: {
          Renamer renamer = nameStack.peek().forChildScope();
 
                     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {
            String name = c.getString();
            renamer.addDeclaredName(name);
          }
 
                     Node functionBody = n.getNext();
          findDeclaredNames(functionBody, null, renamer);
 
           nameStack.push(renamer);
         }

 
       case Token.FUNCTION:
                 nameStack.pop();
                  nameStack.pop();
         break;
 
      case Token.LP:
                                   break;
 
       case Token.CATCH:
         "
76,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java","@@ -373,7 +373,7 @@ private Node tryFoldArrayJoin(Node n) {
 
     Node right = callTarget.getNext();
     if (right != null) {
    if (!NodeUtil.isImmutableValue(right)) {
         return n;
       }
     }
@@ -386,7 +386,12 @@ private Node tryFoldArrayJoin(Node n) {
       return n;
     }
 
       // "","" is the default, it doesn't need to be explicit
 
     String joinString = (right == null) ? "","" : NodeUtil.getStringValue(right);
     List<Node> arrayFoldedChildren = Lists.newLinkedList();
","@@ -373,7 +373,7 @@ private Node tryFoldArrayJoin(Node n) {
 
     Node right = callTarget.getNext();
     if (right != null) {
    if (right.getNext() != null || !NodeUtil.isImmutableValue(right)) {
         return n;
       }
     }
@@ -386,7 +386,12 @@ private Node tryFoldArrayJoin(Node n) {
       return n;
     }
 
  if (right != null && right.getType() == Token.STRING
      && "","".equals(right.getString())) {
       // "","" is the default, it doesn't need to be explicit
    n.removeChild(right);
    reportCodeChange();
  }
 
     String joinString = (right == null) ? "","" : NodeUtil.getStringValue(right);
     List<Node> arrayFoldedChildren = Lists.newLinkedList();
","
 
     Node right = callTarget.getNext();
     if (right != null) {
      if (!NodeUtil.isImmutableValue(right)) {
         return n;
       }
     }

       return n;
     }
 
        
     String joinString = (right == null) ? "","" : NodeUtil.getStringValue(right);
     List<Node> arrayFoldedChildren = Lists.newLinkedList();
","
 
     Node right = callTarget.getNext();
     if (right != null) {
      if (right.getNext() != null || !NodeUtil.isImmutableValue(right)) {
         return n;
       }
     }

       return n;
     }
 
    if (right != null && right.getType() == Token.STRING
        && "","".equals(right.getString())) {
             n.removeChild(right);
      reportCodeChange();
    }
 
     String joinString = (right == null) ? "","" : NodeUtil.getStringValue(right);
     List<Node> arrayFoldedChildren = Lists.newLinkedList();
"
77,"java.lang.RuntimeException","/src/com/google/javascript/jscomp/InlineObjectLiterals.java","@@ -328,6 +328,9 @@ private void replaceAssignmentExpression(Var v, Reference ref,
       }
 
       Node replacement;
         // All assignments evaluate to true, so make sure that the
         // expr statement evaluates to true in case it matters.
         nodes.add(new Node(Token.TRUE));
@@ -347,6 +350,7 @@ private void replaceAssignmentExpression(Var v, Reference ref,
         }
         cur.addChildToFront(nodes.get(i));
         cur.addChildToFront(nodes.get(i + 1));
 
       Node replace = ref.getParent();
       replacement.copyInformationFromForTree(replace);
","@@ -328,6 +328,9 @@ private void replaceAssignmentExpression(Var v, Reference ref,
       }
 
       Node replacement;
    if (nodes.isEmpty()) {
      replacement = new Node(Token.TRUE);
    } else {
         // All assignments evaluate to true, so make sure that the
         // expr statement evaluates to true in case it matters.
         nodes.add(new Node(Token.TRUE));
@@ -347,6 +350,7 @@ private void replaceAssignmentExpression(Var v, Reference ref,
         }
         cur.addChildToFront(nodes.get(i));
         cur.addChildToFront(nodes.get(i + 1));
    }
 
       Node replace = ref.getParent();
       replacement.copyInformationFromForTree(replace);
","
       }
 
       Node replacement;
                           nodes.add(new Node(Token.TRUE));

         }
         cur.addChildToFront(nodes.get(i));
         cur.addChildToFront(nodes.get(i + 1));
 
       Node replace = ref.getParent();
       replacement.copyInformationFromForTree(replace);
","
       }
 
       Node replacement;
      if (nodes.isEmpty()) {
        replacement = new Node(Token.TRUE);
      } else {
                           nodes.add(new Node(Token.TRUE));

         }
         cur.addChildToFront(nodes.get(i));
         cur.addChildToFront(nodes.get(i + 1));
      }
 
       Node replace = ref.getParent();
       replacement.copyInformationFromForTree(replace);
"
78,"junit.framework.ComparisonFailure","/src/com/google/javascript/jscomp/CodeConsumer.java","@@ -238,7 +238,7 @@ void addNumber(double x) {
       add("" "");
     }
 
  if ((long) x == x) {
       long value = (long) x;
       long mantissa = value;
       int exp = 0;
","@@ -238,7 +238,7 @@ void addNumber(double x) {
       add("" "");
     }
 
  if ((long) x == x && !isNegativeZero(x)) {
       long value = (long) x;
       long mantissa = value;
       int exp = 0;
","
       add("" "");
     }
 
    if ((long) x == x) {
       long value = (long) x;
       long mantissa = value;
       int exp = 0;
","
       add("" "");
     }
 
    if ((long) x == x && !isNegativeZero(x)) {
       long value = (long) x;
       long mantissa = value;
       int exp = 0;
"
79,"junit.framework.ComparisonFailure","/src/com/google/javascript/jscomp/CodeGenerator.java","@@ -742,7 +742,7 @@ static boolean isSimpleNumber(String s) {
         return false;
       }
     }
  return len > 0;
   }
 
   static double getSimpleNumber(String s) {
","@@ -742,7 +742,7 @@ static boolean isSimpleNumber(String s) {
         return false;
       }
     }
  return len > 0 && s.charAt(0) != '0';
   }
 
   static double getSimpleNumber(String s) {
","
         return false;
       }
     }
    return len > 0;
   }
 
   static double getSimpleNumber(String s) {
","
         return false;
       }
     }
    return len > 0 && s.charAt(0) != '0';
   }
 
   static double getSimpleNumber(String s) {
"
80,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/Compiler.java","@@ -252,7 +252,8 @@ public void initOptions(CompilerOptions options) {
           CheckLevel.OFF);
     }
 
  if (options.checkGlobalThisLevel.isOn()) {
       options.setWarningLevel(
           DiagnosticGroups.GLOBAL_THIS,
           options.checkGlobalThisLevel);
","@@ -252,7 +252,8 @@ public void initOptions(CompilerOptions options) {
           CheckLevel.OFF);
     }
 
  if (options.checkGlobalThisLevel.isOn() &&
      !options.disables(DiagnosticGroups.GLOBAL_THIS)) {
       options.setWarningLevel(
           DiagnosticGroups.GLOBAL_THIS,
           options.checkGlobalThisLevel);
","
           CheckLevel.OFF);
     }
 
    if (options.checkGlobalThisLevel.isOn()) {
       options.setWarningLevel(
           DiagnosticGroups.GLOBAL_THIS,
           options.checkGlobalThisLevel);
","
           CheckLevel.OFF);
     }
 
    if (options.checkGlobalThisLevel.isOn() &&
        !options.disables(DiagnosticGroups.GLOBAL_THIS)) {
       options.setWarningLevel(
           DiagnosticGroups.GLOBAL_THIS,
           options.checkGlobalThisLevel);
"
81,"java.lang.IllegalStateException","/src/com/google/javascript/jscomp/FunctionRewriter.java","@@ -114,7 +114,8 @@ public Node parseHelperCode(Reducer reducer) {
   }
 
   private static boolean isReduceableFunctionExpression(Node n) {
  return NodeUtil.isFunctionExpression(n);
   }
 
   /**
","@@ -114,7 +114,8 @@ public Node parseHelperCode(Reducer reducer) {
   }
 
   private static boolean isReduceableFunctionExpression(Node n) {
  return NodeUtil.isFunctionExpression(n)
      && !NodeUtil.isGetOrSetKey(n.getParent());
   }
 
   /**
","
   }
 
   private static boolean isReduceableFunctionExpression(Node n) {
    return NodeUtil.isFunctionExpression(n);
   }
","
   }
 
   private static boolean isReduceableFunctionExpression(Node n) {
    return NodeUtil.isFunctionExpression(n)
        && !NodeUtil.isGetOrSetKey(n.getParent());
   }
"
82,"junit.framework.ComparisonFailure","/src/com/google/javascript/jscomp/TypedScopeCreator.java","@@ -1410,7 +1410,13 @@ void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,
           // then they are responsible for making sure that the object literal's
           // implicit prototype is set up appropriately. We just obey
           // the @extends tag.
        if (!qVar.isTypeInferred()) {
             // If the programmer has declared that F inherits from Super,
             // and they assign F.prototype to some arbitrary expression,
             // there's not much we can do. We just ignore the expression,
/src/com/google/javascript/rhino/jstype/FunctionType.java @@ -338,7 +338,6 @@ public void setPrototypeBasedOn(ObjectType baseType) {
     //
     // In the second case, we just use the anonymous object as the prototype.
     if (baseType.hasReferenceName() ||
      baseType.isUnknownType() ||
         isNativeObjectType() ||
         baseType.isFunctionPrototypeType() ||
         !(baseType instanceof PrototypeObjectType)) {
@@ -363,14 +362,18 @@ public boolean setPrototype(PrototypeObjectType prototype) {
       return false;
     }
 
  boolean replacedPrototype = prototype != null;
 
     this.prototype = prototype;
     this.prototypeSlot = new SimpleSlot(""prototype"", prototype, true);
     this.prototype.setOwnerFunction(this);
 
       // Disassociating the old prototype makes this easier to debug--
       // we don't have to worry about two prototypes running around.
 
     if (isConstructor() || isInterface()) {
       FunctionType superClass = getSuperClassConstructor();
","@@ -1410,7 +1410,13 @@ void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,
           // then they are responsible for making sure that the object literal's
           // implicit prototype is set up appropriately. We just obey
           // the @extends tag.
        ObjectType qVarType = ObjectType.cast(qVar.getType());
        if (qVarType != null &&
            rhsValue != null &&
            rhsValue.getType() == Token.OBJECTLIT) {
          typeRegistry.resetImplicitPrototype(
              rhsValue.getJSType(), qVarType.getImplicitPrototype());
        } else if (!qVar.isTypeInferred()) {
             // If the programmer has declared that F inherits from Super,
             // and they assign F.prototype to some arbitrary expression,
             // there's not much we can do. We just ignore the expression,
/src/com/google/javascript/rhino/jstype/FunctionType.java @@ -338,7 +338,6 @@ public void setPrototypeBasedOn(ObjectType baseType) {
     //
     // In the second case, we just use the anonymous object as the prototype.
     if (baseType.hasReferenceName() ||
         isNativeObjectType() ||
         baseType.isFunctionPrototypeType() ||
         !(baseType instanceof PrototypeObjectType)) {
@@ -363,14 +362,18 @@ public boolean setPrototype(PrototypeObjectType prototype) {
       return false;
     }
 
  PrototypeObjectType oldPrototype = this.prototype;
  boolean replacedPrototype = oldPrototype != null;
 
     this.prototype = prototype;
     this.prototypeSlot = new SimpleSlot(""prototype"", prototype, true);
     this.prototype.setOwnerFunction(this);
 
  if (oldPrototype != null) {
       // Disassociating the old prototype makes this easier to debug--
       // we don't have to worry about two prototypes running around.
    oldPrototype.setOwnerFunction(null);
  }
 
     if (isConstructor() || isInterface()) {
       FunctionType superClass = getSuperClassConstructor();
","
                                           if (!qVar.isTypeInferred()) {

               if (baseType.hasReferenceName() ||
        baseType.isUnknownType() ||
         isNativeObjectType() ||
         baseType.isFunctionPrototypeType() ||
         !(baseType instanceof PrototypeObjectType)) {

       return false;
     }
 
    boolean replacedPrototype = prototype != null;
 
     this.prototype = prototype;
     this.prototypeSlot = new SimpleSlot(""prototype"", prototype, true);
     this.prototype.setOwnerFunction(this);
 
               
     if (isConstructor() || isInterface()) {
       FunctionType superClass = getSuperClassConstructor();
","
                                           ObjectType qVarType = ObjectType.cast(qVar.getType());
          if (qVarType != null &&
              rhsValue != null &&
              rhsValue.getType() == Token.OBJECTLIT) {
            typeRegistry.resetImplicitPrototype(
                rhsValue.getJSType(), qVarType.getImplicitPrototype());
          } else if (!qVar.isTypeInferred()) {

               if (baseType.hasReferenceName() ||
         isNativeObjectType() ||
         baseType.isFunctionPrototypeType() ||
         !(baseType instanceof PrototypeObjectType)) {

       return false;
     }
 
    PrototypeObjectType oldPrototype = this.prototype;
    boolean replacedPrototype = oldPrototype != null;
 
     this.prototype = prototype;
     this.prototypeSlot = new SimpleSlot(""prototype"", prototype, true);
     this.prototype.setOwnerFunction(this);
 
    if (oldPrototype != null) {
                    oldPrototype.setOwnerFunction(null);
    }
 
     if (isConstructor() || isInterface()) {
       FunctionType superClass = getSuperClassConstructor();
"
83,"junit.framework.ComparisonFailure","/src/com/google/javascript/jscomp/SourceFile.java","@@ -239,7 +239,11 @@ public String getLine(int lineNumber) {
       // If next new line cannot be found, there are two cases
       // 1. pos already reaches the end of file, then null should be returned
       // 2. otherwise, return the contents between pos and the end of file.
         return null;
     } else {
       return js.substring(pos, js.indexOf('\n', pos));
     }
","@@ -239,7 +239,11 @@ public String getLine(int lineNumber) {
       // If next new line cannot be found, there are two cases
       // 1. pos already reaches the end of file, then null should be returned
       // 2. otherwise, return the contents between pos and the end of file.
    if (pos >= js.length()) {
         return null;
    } else {
      return js.substring(pos, js.length());
    }
     } else {
       return js.substring(pos, js.indexOf('\n', pos));
     }
","
                              return null;
     } else {
       return js.substring(pos, js.indexOf('\n', pos));
     }
","
                           if (pos >= js.length()) {
         return null;
      } else {
        return js.substring(pos, js.length());
      }
     } else {
       return js.substring(pos, js.indexOf('\n', pos));
     }
"
84,"java.lang.IllegalStateException","/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java","@@ -203,8 +203,12 @@ private void computeGenKill(Node n, BitSet gen, BitSet kill,
             // for(var x in y) {...}
             lhs = lhs.getLastChild();
           }
             addToSetIfLocal(lhs, kill);
             addToSetIfLocal(lhs, gen);
           computeGenKill(rhs, gen, kill, conditional);
         }
         return;
","@@ -203,8 +203,12 @@ private void computeGenKill(Node n, BitSet gen, BitSet kill,
             // for(var x in y) {...}
             lhs = lhs.getLastChild();
           }
        if (NodeUtil.isName(lhs)) {
             addToSetIfLocal(lhs, kill);
             addToSetIfLocal(lhs, gen);
        } else {
          computeGenKill(lhs, gen, kill, conditional);
        }
           computeGenKill(rhs, gen, kill, conditional);
         }
         return;
","
                          lhs = lhs.getLastChild();
           }
             addToSetIfLocal(lhs, kill);
             addToSetIfLocal(lhs, gen);
           computeGenKill(rhs, gen, kill, conditional);
         }
         return;
","
                          lhs = lhs.getLastChild();
           }
          if (NodeUtil.isName(lhs)) {
             addToSetIfLocal(lhs, kill);
             addToSetIfLocal(lhs, gen);
          } else {
            computeGenKill(lhs, gen, kill, conditional);
          }
           computeGenKill(rhs, gen, kill, conditional);
         }
         return;
"
85,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/ClosureCodingConvention.java","@@ -194,7 +194,7 @@ private static String extractClassNameIfGoog(Node node, Node parent,
         String qualifiedName = callee.getQualifiedName();
         if (functionName.equals(qualifiedName)) {
           Node target = callee.getNext();
        if (target != null) {
             className = target.getString();
           }
         }
","@@ -194,7 +194,7 @@ private static String extractClassNameIfGoog(Node node, Node parent,
         String qualifiedName = callee.getQualifiedName();
         if (functionName.equals(qualifiedName)) {
           Node target = callee.getNext();
        if (target != null && target.getType() == Token.STRING) {
             className = target.getString();
           }
         }
","
         String qualifiedName = callee.getQualifiedName();
         if (functionName.equals(qualifiedName)) {
           Node target = callee.getNext();
          if (target != null) {
             className = target.getString();
           }
         }
","
         String qualifiedName = callee.getQualifiedName();
         if (functionName.equals(qualifiedName)) {
           Node target = callee.getNext();
          if (target != null && target.getType() == Token.STRING) {
             className = target.getString();
           }
         }
"
86,"junit.framework.ComparisonFailure","/src/com/google/javascript/jscomp/LightweightMessageFormatter.java","@@ -95,7 +95,7 @@ private String format(JSError error, boolean warning) {
       // charno == sourceExpert.length() means something is missing
       // at the end of the line
       if (excerpt.equals(LINE)
        && 0 <= charno && charno < sourceExcerpt.length()) {
         for (int i = 0; i < charno; i++) {
           char c = sourceExcerpt.charAt(i);
           if (Character.isWhitespace(c)) {
","@@ -95,7 +95,7 @@ private String format(JSError error, boolean warning) {
       // charno == sourceExpert.length() means something is missing
       // at the end of the line
       if (excerpt.equals(LINE)
        && 0 <= charno && charno <= sourceExcerpt.length()) {
         for (int i = 0; i < charno; i++) {
           char c = sourceExcerpt.charAt(i);
           if (Character.isWhitespace(c)) {
","
                     if (excerpt.equals(LINE)
          && 0 <= charno && charno < sourceExcerpt.length()) {
         for (int i = 0; i < charno; i++) {
           char c = sourceExcerpt.charAt(i);
           if (Character.isWhitespace(c)) {
","
                     if (excerpt.equals(LINE)
          && 0 <= charno && charno <= sourceExcerpt.length()) {
         for (int i = 0; i < charno; i++) {
           char c = sourceExcerpt.charAt(i);
           if (Character.isWhitespace(c)) {
"
87,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/NodeUtil.java","@@ -105,6 +105,8 @@ static TernaryValue getImpureBooleanValue(Node n) {
         // ignoring side-effects
         return TernaryValue.TRUE;
 
 
       default:
         return getPureBooleanValue(n);
@@ -133,7 +135,10 @@ static TernaryValue getPureBooleanValue(Node n) {
         return TernaryValue.FALSE;
 
       case Token.VOID:
           return TernaryValue.FALSE;
 
       case Token.NAME:
         String name = n.getString();
","@@ -105,6 +105,8 @@ static TernaryValue getImpureBooleanValue(Node n) {
         // ignoring side-effects
         return TernaryValue.TRUE;
 
    case Token.VOID:
      return TernaryValue.FALSE;
 
       default:
         return getPureBooleanValue(n);
@@ -133,7 +135,10 @@ static TernaryValue getPureBooleanValue(Node n) {
         return TernaryValue.FALSE;
 
       case Token.VOID:
      if (!mayHaveSideEffects(n.getFirstChild())) {
           return TernaryValue.FALSE;
      }
      break;
 
       case Token.NAME:
         String name = n.getString();
","
                  return TernaryValue.TRUE;
 
 
       default:
         return getPureBooleanValue(n);

         return TernaryValue.FALSE;
 
       case Token.VOID:
           return TernaryValue.FALSE;
 
       case Token.NAME:
         String name = n.getString();
","
                  return TernaryValue.TRUE;
 
      case Token.VOID:
        return TernaryValue.FALSE;
 
       default:
         return getPureBooleanValue(n);

         return TernaryValue.FALSE;
 
       case Token.VOID:
        if (!mayHaveSideEffects(n.getFirstChild())) {
           return TernaryValue.FALSE;
        }
        break;
 
       case Token.NAME:
         String name = n.getString();
"
88,"junit.framework.ComparisonFailure","/src/com/google/javascript/jscomp/LightweightMessageFormatter.java","@@ -95,7 +95,7 @@ private String format(JSError error, boolean warning) {
       // charno == sourceExpert.length() means something is missing
       // at the end of the line
       if (excerpt.equals(LINE)
        && 0 <= charno && charno < sourceExcerpt.length()) {
         for (int i = 0; i < charno; i++) {
           char c = sourceExcerpt.charAt(i);
           if (Character.isWhitespace(c)) {
","@@ -95,7 +95,7 @@ private String format(JSError error, boolean warning) {
       // charno == sourceExpert.length() means something is missing
       // at the end of the line
       if (excerpt.equals(LINE)
        && 0 <= charno && charno <= sourceExcerpt.length()) {
         for (int i = 0; i < charno; i++) {
           char c = sourceExcerpt.charAt(i);
           if (Character.isWhitespace(c)) {
","
                     if (excerpt.equals(LINE)
          && 0 <= charno && charno < sourceExcerpt.length()) {
         for (int i = 0; i < charno; i++) {
           char c = sourceExcerpt.charAt(i);
           if (Character.isWhitespace(c)) {
","
                     if (excerpt.equals(LINE)
          && 0 <= charno && charno <= sourceExcerpt.length()) {
         for (int i = 0; i < charno; i++) {
           char c = sourceExcerpt.charAt(i);
           if (Character.isWhitespace(c)) {
"
89,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/NodeUtil.java","@@ -955,6 +955,12 @@ static boolean functionCallHasSideEffects(
       }
 
       // Functions in the ""Math"" namespace have no side effects.
 
       if (compiler != null && !compiler.hasRegExpGlobalReferences()) {
         if (nameNode.getFirstChild().getType() == Token.REGEXP
","@@ -955,6 +955,12 @@ static boolean functionCallHasSideEffects(
       }
 
       // Functions in the ""Math"" namespace have no side effects.
    if (nameNode.getFirstChild().getType() == Token.NAME) {
      String namespaceName = nameNode.getFirstChild().getString();
      if (namespaceName.equals(""Math"")) {
        return false;
      }
    }
 
       if (compiler != null && !compiler.hasRegExpGlobalReferences()) {
         if (nameNode.getFirstChild().getType() == Token.REGEXP
","
       }
 
        
       if (compiler != null && !compiler.hasRegExpGlobalReferences()) {
         if (nameNode.getFirstChild().getType() == Token.REGEXP
","
       }
 
             if (nameNode.getFirstChild().getType() == Token.NAME) {
        String namespaceName = nameNode.getFirstChild().getString();
        if (namespaceName.equals(""Math"")) {
          return false;
        }
      }
 
       if (compiler != null && !compiler.hasRegExpGlobalReferences()) {
         if (nameNode.getFirstChild().getType() == Token.REGEXP
"
90,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/Compiler.java","@@ -1429,7 +1429,7 @@ public Void call() throws Exception {
 
         // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'
         // for the first input file
      String code = toSource(root, sourceMap);
         if (!code.isEmpty()) {
           cb.append(code);
 
@@ -1458,19 +1458,19 @@ public Void call() throws Exception {
   @Override
   String toSource(Node n) {
     initCompilerOptionsIfTesting();
  return toSource(n, null);
   }
 
   /**
    * Generates JavaScript source code for an AST.
    */
private String toSource(Node n, SourceMap sourceMap) {
     CodePrinter.Builder builder = new CodePrinter.Builder(n);
     builder.setPrettyPrint(options.prettyPrint);
     builder.setLineBreak(options.lineBreak);
     builder.setSourceMap(sourceMap);
     builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);
  builder.setTagAsStrict(
         options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);
     builder.setLineLengthThreshold(options.lineLengthThreshold);
 
","@@ -1429,7 +1429,7 @@ public Void call() throws Exception {
 
         // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'
         // for the first input file
      String code = toSource(root, sourceMap, inputSeqNum == 0);
         if (!code.isEmpty()) {
           cb.append(code);
 
@@ -1458,19 +1458,19 @@ public Void call() throws Exception {
   @Override
   String toSource(Node n) {
     initCompilerOptionsIfTesting();
  return toSource(n, null, true);
   }
 
   /**
    * Generates JavaScript source code for an AST.
    */
private String toSource(Node n, SourceMap sourceMap, boolean firstOutput) {
     CodePrinter.Builder builder = new CodePrinter.Builder(n);
     builder.setPrettyPrint(options.prettyPrint);
     builder.setLineBreak(options.lineBreak);
     builder.setSourceMap(sourceMap);
     builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);
  builder.setTagAsStrict(firstOutput &&
         options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);
     builder.setLineLengthThreshold(options.lineLengthThreshold);
 
","
 
                          String code = toSource(root, sourceMap);
         if (!code.isEmpty()) {
           cb.append(code);
 

   @Override
   String toSource(Node n) {
     initCompilerOptionsIfTesting();
    return toSource(n, null);
   }
 
  private String toSource(Node n, SourceMap sourceMap) {
     CodePrinter.Builder builder = new CodePrinter.Builder(n);
     builder.setPrettyPrint(options.prettyPrint);
     builder.setLineBreak(options.lineBreak);
     builder.setSourceMap(sourceMap);
     builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);
    builder.setTagAsStrict(
         options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);
     builder.setLineLengthThreshold(options.lineLengthThreshold);
 
","
 
                          String code = toSource(root, sourceMap, inputSeqNum == 0);
         if (!code.isEmpty()) {
           cb.append(code);
 

   @Override
   String toSource(Node n) {
     initCompilerOptionsIfTesting();
    return toSource(n, null, true);
   }
 
  private String toSource(Node n, SourceMap sourceMap, boolean firstOutput) {
     CodePrinter.Builder builder = new CodePrinter.Builder(n);
     builder.setPrettyPrint(options.prettyPrint);
     builder.setLineBreak(options.lineBreak);
     builder.setSourceMap(sourceMap);
     builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);
    builder.setTagAsStrict(firstOutput &&
         options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);
     builder.setLineLengthThreshold(options.lineLengthThreshold);
 
"
91,"junit.framework.ComparisonFailure","/src/com/google/javascript/jscomp/CodeGenerator.java","@@ -1012,7 +1012,7 @@ static String strEscape(String s, char quote,
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       switch (c) {
      case '\0': sb.append(""\\0""); break;
         case '\n': sb.append(""\\n""); break;
         case '\r': sb.append(""\\r""); break;
         case '\t': sb.append(""\\t""); break;
","@@ -1012,7 +1012,7 @@ static String strEscape(String s, char quote,
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       switch (c) {
      case '\0': sb.append(""\\000""); break;
         case '\n': sb.append(""\\n""); break;
         case '\r': sb.append(""\\r""); break;
         case '\t': sb.append(""\\t""); break;
","
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       switch (c) {
        case '\0': sb.append(""\\0""); break;
         case '\n': sb.append(""\\n""); break;
         case '\r': sb.append(""\\r""); break;
         case '\t': sb.append(""\\t""); break;
","
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       switch (c) {
        case '\0': sb.append(""\\000""); break;
         case '\n': sb.append(""\\n""); break;
         case '\r': sb.append(""\\r""); break;
         case '\t': sb.append(""\\t""); break;
"
92,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/TypeCheck.java","@@ -513,7 +513,9 @@ public void visit(NodeTraversal t, Node n, Node parent) {
         // Object literal keys are handled with OBJECTLIT
         if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
           ensureTyped(t, n, STRING_TYPE);
           // Object literal keys are not typeable
         }
         break;
 
","@@ -513,7 +513,9 @@ public void visit(NodeTraversal t, Node n, Node parent) {
         // Object literal keys are handled with OBJECTLIT
         if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
           ensureTyped(t, n, STRING_TYPE);
      } else {
           // Object literal keys are not typeable
        typeable = false;
         }
         break;
 
","
                  if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
           ensureTyped(t, n, STRING_TYPE);
                    }
         break;
 
","
                  if (!NodeUtil.isObjectLitKey(n, n.getParent())) {
           ensureTyped(t, n, STRING_TYPE);
        } else {
                     typeable = false;
         }
         break;
 
"
93,"junit.framework.ComparisonFailure","/src/com/google/javascript/jscomp/CodeGenerator.java","@@ -1042,7 +1042,7 @@ static String strEscape(String s, char quote,
             // No charsetEncoder provided - pass straight latin characters
             // through, and escape the rest.  Doing the explicit character
             // check is measurably faster than using the CharsetEncoder.
          if (c > 0x1f && c <= 0x7f) {
               sb.append(c);
             } else {
               // Other characters can be misinterpreted by some js parsers,
","@@ -1042,7 +1042,7 @@ static String strEscape(String s, char quote,
             // No charsetEncoder provided - pass straight latin characters
             // through, and escape the rest.  Doing the explicit character
             // check is measurably faster than using the CharsetEncoder.
          if (c > 0x1f && c < 0x7f) {
               sb.append(c);
             } else {
               // Other characters can be misinterpreted by some js parsers,
","
                                                   if (c > 0x1f && c <= 0x7f) {
               sb.append(c);
             } else {
               ","
                                                   if (c > 0x1f && c < 0x7f) {
               sb.append(c);
             } else {
               "
94,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java","@@ -315,7 +315,7 @@ private boolean isPrototypePropertyAssign(Node assign) {
       Node n = assign.getFirstChild();
       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)
           && n.getType() == Token.GETPROP
        ) {
         // We want to exclude the assignment itself from the usage list
         boolean isChainedProperty =
             n.getFirstChild().getType() == Token.GETPROP;
","@@ -315,7 +315,7 @@ private boolean isPrototypePropertyAssign(Node assign) {
       Node n = assign.getFirstChild();
       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)
           && n.getType() == Token.GETPROP
        && assign.getParent().getType() == Token.EXPR_RESULT) {
         // We want to exclude the assignment itself from the usage list
         boolean isChainedProperty =
             n.getFirstChild().getType() == Token.GETPROP;
","
       Node n = assign.getFirstChild();
       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)
           && n.getType() == Token.GETPROP
          ) {
                  boolean isChainedProperty =
             n.getFirstChild().getType() == Token.GETPROP;
","
       Node n = assign.getFirstChild();
       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)
           && n.getType() == Token.GETPROP
          && assign.getParent().getType() == Token.EXPR_RESULT) {
                  boolean isChainedProperty =
             n.getFirstChild().getType() == Token.GETPROP;
"
95,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/PeepholeFoldConstants.java","@@ -904,8 +904,8 @@ private Node tryFoldComparison(Node n, Node left, Node right) {
           && right.getString().equals(""undefined""))
           || (Token.VOID == right.getType()
               && NodeUtil.isLiteralValue(right.getFirstChild(), false)));
  int lhType = left.getType();
  int rhType = right.getType();
     switch (lhType) {
       case Token.VOID:
         if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {
@@ -1071,6 +1071,19 @@ private Node tryFoldComparison(Node n, Node left, Node right) {
   /**
    * @return Translate NOT expressions into TRUE or FALSE when possible.
    */
 
   /**
    * The result of the comparison as a Boolean or null if the
","@@ -904,8 +904,8 @@ private Node tryFoldComparison(Node n, Node left, Node right) {
           && right.getString().equals(""undefined""))
           || (Token.VOID == right.getType()
               && NodeUtil.isLiteralValue(right.getFirstChild(), false)));
  int lhType = getNormalizedNodeType(left);
  int rhType = getNormalizedNodeType(right);
     switch (lhType) {
       case Token.VOID:
         if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {
@@ -1071,6 +1071,19 @@ private Node tryFoldComparison(Node n, Node left, Node right) {
   /**
    * @return Translate NOT expressions into TRUE or FALSE when possible.
    */
private int getNormalizedNodeType(Node n) {
  int type = n.getType();
  if (type == Token.NOT) {
    TernaryValue value = NodeUtil.getPureBooleanValue(n);
    switch (value) {
      case TRUE:
        return Token.TRUE;
      case FALSE:
        return Token.FALSE;
    }
  }
  return type;
}
 
   /**
    * The result of the comparison as a Boolean or null if the
","
           && right.getString().equals(""undefined""))
           || (Token.VOID == right.getType()
               && NodeUtil.isLiteralValue(right.getFirstChild(), false)));
    int lhType = left.getType();
    int rhType = right.getType();
     switch (lhType) {
       case Token.VOID:
         if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {

","
           && right.getString().equals(""undefined""))
           || (Token.VOID == right.getType()
               && NodeUtil.isLiteralValue(right.getFirstChild(), false)));
    int lhType = getNormalizedNodeType(left);
    int rhType = getNormalizedNodeType(right);
     switch (lhType) {
       case Token.VOID:
         if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {

    int type = n.getType();
    if (type == Token.NOT) {
      TernaryValue value = NodeUtil.getPureBooleanValue(n);
      switch (value) {
        case TRUE:
          return Token.TRUE;
        case FALSE:
          return Token.FALSE;
      }
    }
    return type;
  }
"
96,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/CheckAccessControls.java","@@ -413,7 +413,7 @@ private void checkPropertyVisibility(NodeTraversal t,
     if (objectType != null) {
       // Is this a normal property access, or are we trying to override
       // an existing property?
    boolean isOverride = t.inGlobalScope() &&
           parent.getType() == Token.ASSIGN &&
           parent.getFirstChild() == getprop;
 
","@@ -413,7 +413,7 @@ private void checkPropertyVisibility(NodeTraversal t,
     if (objectType != null) {
       // Is this a normal property access, or are we trying to override
       // an existing property?
    boolean isOverride = parent.getJSDocInfo() != null &&
           parent.getType() == Token.ASSIGN &&
           parent.getFirstChild() == getprop;
 
","
     if (objectType != null) {
                    boolean isOverride = t.inGlobalScope() &&
           parent.getType() == Token.ASSIGN &&
           parent.getFirstChild() == getprop;
 
","
     if (objectType != null) {
                    boolean isOverride = parent.getJSDocInfo() != null &&
           parent.getType() == Token.ASSIGN &&
           parent.getFirstChild() == getprop;
 
"
97,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java","@@ -865,9 +865,9 @@ boolean parse() {
                         }
                         break;
                     }
 
                   token = eatTokensUntilEOL();
                }
                   continue retry;
               }
             }
@@ -1706,6 +1706,7 @@ private Node parseBasicTypeExpression(JsDocToken token) {
       }
     }
 
     return reportGenericTypeSyntaxWarning();
   }
 
@@ -1758,6 +1759,7 @@ private Node parseFunctionType(JsDocToken token) {
     // NOTE(nicksantos): We're not implementing generics at the moment, so
     // just throw out TypeParameters.
     if (token != JsDocToken.LP) {
       return reportTypeSyntaxWarning(""msg.jsdoc.missing.lp"");
     }
 
","@@ -865,9 +865,9 @@ boolean parse() {
                         }
                         break;
                     }
                }
 
                   token = eatTokensUntilEOL();
                   continue retry;
               }
             }
@@ -1706,6 +1706,7 @@ private Node parseBasicTypeExpression(JsDocToken token) {
       }
     }
 
  restoreLookAhead(token);
     return reportGenericTypeSyntaxWarning();
   }
 
@@ -1758,6 +1759,7 @@ private Node parseFunctionType(JsDocToken token) {
     // NOTE(nicksantos): We're not implementing generics at the moment, so
     // just throw out TypeParameters.
     if (token != JsDocToken.LP) {
    restoreLookAhead(token);
       return reportTypeSyntaxWarning(""msg.jsdoc.missing.lp"");
     }
 
","
                         }
                         break;
                     }
 
                   token = eatTokensUntilEOL();
                  }
                   continue retry;
               }
             }

       }
     }
 
     return reportGenericTypeSyntaxWarning();
   }


               if (token != JsDocToken.LP) {
       return reportTypeSyntaxWarning(""msg.jsdoc.missing.lp"");
     }
 
","
                         }
                         break;
                     }
                  }
 
                   token = eatTokensUntilEOL();
                   continue retry;
               }
             }

       }
     }
 
    restoreLookAhead(token);
     return reportGenericTypeSyntaxWarning();
   }
 

               if (token != JsDocToken.LP) {
      restoreLookAhead(token);
       return reportTypeSyntaxWarning(""msg.jsdoc.missing.lp"");
     }
 
"
98,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/TypeCheck.java","@@ -1577,6 +1577,13 @@ private void visitCall(NodeTraversal t, Node n) {
 
       // Functions with explcit 'this' types must be called in a GETPROP
       // or GETELEM.
 
       visitParameterList(t, n, functionType);
       ensureTyped(t, n, functionType.getReturnType());
","@@ -1577,6 +1577,13 @@ private void visitCall(NodeTraversal t, Node n) {
 
       // Functions with explcit 'this' types must be called in a GETPROP
       // or GETELEM.
    if (functionType.isOrdinaryFunction() &&
        !functionType.getTypeOfThis().isUnknownType() &&
        !functionType.getTypeOfThis().isNativeObjectType() &&
        !(child.getType() == Token.GETELEM ||
          child.getType() == Token.GETPROP)) {
      report(t, n, EXPECTED_THIS_TYPE, functionType.toString());
    }
 
       visitParameterList(t, n, functionType);
       ensureTyped(t, n, functionType.getReturnType());
","
 
               
       visitParameterList(t, n, functionType);
       ensureTyped(t, n, functionType.getReturnType());
","
 
                    if (functionType.isOrdinaryFunction() &&
          !functionType.getTypeOfThis().isUnknownType() &&
          !functionType.getTypeOfThis().isNativeObjectType() &&
          !(child.getType() == Token.GETELEM ||
            child.getType() == Token.GETPROP)) {
        report(t, n, EXPECTED_THIS_TYPE, functionType.toString());
      }
 
       visitParameterList(t, n, functionType);
       ensureTyped(t, n, functionType.getReturnType());
"
99,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/TypedScopeCreator.java","@@ -1742,7 +1742,7 @@ private void declareArguments(Node functionNode) {
           for (Node astParameter : astParameters.children()) {
             if (jsDocParameter != null) {
               defineSlot(astParameter, functionNode,
                jsDocParameter.getJSType(), true);
               jsDocParameter = jsDocParameter.getNext();
             } else {
               defineSlot(astParameter, functionNode, null, true);
","@@ -1742,7 +1742,7 @@ private void declareArguments(Node functionNode) {
           for (Node astParameter : astParameters.children()) {
             if (jsDocParameter != null) {
               defineSlot(astParameter, functionNode,
                jsDocParameter.getJSType(), false);
               jsDocParameter = jsDocParameter.getNext();
             } else {
               defineSlot(astParameter, functionNode, null, true);
","
           for (Node astParameter : astParameters.children()) {
             if (jsDocParameter != null) {
               defineSlot(astParameter, functionNode,
                  jsDocParameter.getJSType(), true);
               jsDocParameter = jsDocParameter.getNext();
             } else {
               defineSlot(astParameter, functionNode, null, true);
","
           for (Node astParameter : astParameters.children()) {
             if (jsDocParameter != null) {
               defineSlot(astParameter, functionNode,
                  jsDocParameter.getJSType(), false);
               jsDocParameter = jsDocParameter.getNext();
             } else {
               defineSlot(astParameter, functionNode, null, true);
"
100,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/FunctionToBlockMutator.java","@@ -149,6 +149,8 @@ private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {
                 ""inline_"",
                 isCallInLoop)));
     // Make label names unique to this instance.
   }
 
   static class LabelNameSupplier implements Supplier<String> {
/src/com/google/javascript/jscomp/RenameLabels.java @@ -212,7 +212,7 @@ private void visitLabel(Node node, Node parent) {
       String name = nameNode.getString();
       LabelInfo li = getLabelInfo(name);
       // This is a label...
    if (li.referenced) {
         String newName = getNameForId(li.id);
         if (!name.equals(newName)) {
           // ... and it is used, give it the short name.
","@@ -149,6 +149,8 @@ private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {
                 ""inline_"",
                 isCallInLoop)));
     // Make label names unique to this instance.
  new RenameLabels(compiler, new LabelNameSupplier(idSupplier), false)
      .process(null, fnNode);
   }
 
   static class LabelNameSupplier implements Supplier<String> {
/src/com/google/javascript/jscomp/RenameLabels.java @@ -212,7 +212,7 @@ private void visitLabel(Node node, Node parent) {
       String name = nameNode.getString();
       LabelInfo li = getLabelInfo(name);
       // This is a label...
    if (li.referenced || !removeUnused) {
         String newName = getNameForId(li.id);
         if (!name.equals(newName)) {
           // ... and it is used, give it the short name.
","
                 ""inline_"",
                 isCallInLoop)));
        }
 
   static class LabelNameSupplier implements Supplier<String> {

       String name = nameNode.getString();
       LabelInfo li = getLabelInfo(name);
             if (li.referenced) {
         String newName = getNameForId(li.id);
         if (!name.equals(newName)) {
           ","
                 ""inline_"",
                 isCallInLoop)));
         new RenameLabels(compiler, new LabelNameSupplier(idSupplier), false)
        .process(null, fnNode);
   }
 
   static class LabelNameSupplier implements Supplier<String> {

       String name = nameNode.getString();
       LabelInfo li = getLabelInfo(name);
             if (li.referenced || !removeUnused) {
         String newName = getNameForId(li.id);
         if (!name.equals(newName)) {
           "
101,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java","@@ -297,26 +297,40 @@ private boolean isVariableStillLiveWithinExpression(
           // If the currently node is the first child of
           // AND/OR, be conservative only consider the READs
           // of the second operand.
 
         case Token.HOOK:
           // If current node is the condition, check each following
           // branch, otherwise it is a conditional branch and the
           // other branch can be ignored.
 
         default:
           for(Node sibling = n.getNext(); sibling != null;
               sibling = sibling.getNext()) {
          if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {
             state = isVariableReadBeforeKill(sibling, variable);
 
       // If we see a READ or KILL there is no need to continue.
       if (state == VariableLiveness.READ) {
         return true;
       } else if (state == VariableLiveness.KILL) {
         return false;
          }
        }
    }
       }
       n = n.getParent();
     }
@@ -337,6 +351,9 @@ private boolean isVariableStillLiveWithinExpression(
    */
   private VariableLiveness isVariableReadBeforeKill(
       Node n, String variable) {
 
     if (NodeUtil.isName(n) && variable.equals(n.getString())) {
       if (NodeUtil.isLhs(n, n.getParent())) {
@@ -359,9 +376,25 @@ private VariableLiveness isVariableReadBeforeKill(
       // Conditionals
       case Token.OR:
       case Token.AND:
         // With a AND/OR the first branch always runs, but the second is
         // may not.
       case Token.HOOK:
         return checkHookBranchReadBeforeKill(
             n.getFirstChild().getNext(), n.getLastChild(), variable);
 
@@ -369,13 +402,11 @@ private VariableLiveness isVariableReadBeforeKill(
         // Expressions are evaluated left-right, depth first.
         for (Node child = n.getFirstChild();
             child != null; child = child.getNext()) {
        if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION
           VariableLiveness state = isVariableReadBeforeKill(child, variable);
           if (state != VariableLiveness.MAYBE_LIVE) {
             return state;
           }
         }
    }
     }
 
     return VariableLiveness.MAYBE_LIVE;
","@@ -297,26 +297,40 @@ private boolean isVariableStillLiveWithinExpression(
           // If the currently node is the first child of
           // AND/OR, be conservative only consider the READs
           // of the second operand.
        if (n.getNext() != null) {
          state = isVariableReadBeforeKill(
              n.getNext(), variable);
          if (state == VariableLiveness.KILL) {
            state = VariableLiveness.MAYBE_LIVE;
          }
        }
        break;
 
         case Token.HOOK:
           // If current node is the condition, check each following
           // branch, otherwise it is a conditional branch and the
           // other branch can be ignored.
        if (n.getNext() != null && n.getNext().getNext() != null) {
          state = checkHookBranchReadBeforeKill(
              n.getNext(), n.getNext().getNext(), variable);
        }
        break;
 
         default:
           for(Node sibling = n.getNext(); sibling != null;
               sibling = sibling.getNext()) {
             state = isVariableReadBeforeKill(sibling, variable);
          if (state != VariableLiveness.MAYBE_LIVE) {
            break;
          }
        }
    }
 
       // If we see a READ or KILL there is no need to continue.
       if (state == VariableLiveness.READ) {
         return true;
       } else if (state == VariableLiveness.KILL) {
         return false;
       }
       n = n.getParent();
     }
@@ -337,6 +351,9 @@ private boolean isVariableStillLiveWithinExpression(
    */
   private VariableLiveness isVariableReadBeforeKill(
       Node n, String variable) {
  if (ControlFlowGraph.isEnteringNewCfgNode(n)) { // Not a FUNCTION
    return VariableLiveness.MAYBE_LIVE;
  }
 
     if (NodeUtil.isName(n) && variable.equals(n.getString())) {
       if (NodeUtil.isLhs(n, n.getParent())) {
@@ -359,9 +376,25 @@ private VariableLiveness isVariableReadBeforeKill(
       // Conditionals
       case Token.OR:
       case Token.AND:
      VariableLiveness v1 = isVariableReadBeforeKill(
        n.getFirstChild(), variable);
      VariableLiveness v2 = isVariableReadBeforeKill(
        n.getLastChild(), variable);
         // With a AND/OR the first branch always runs, but the second is
         // may not.
      if (v1 != VariableLiveness.MAYBE_LIVE) {
        return v1;
      } else if (v2 == VariableLiveness.READ) {
        return VariableLiveness.READ;
      } else {
        return VariableLiveness.MAYBE_LIVE;
      }
       case Token.HOOK:
      VariableLiveness first = isVariableReadBeforeKill(
          n.getFirstChild(), variable);
      if (first != VariableLiveness.MAYBE_LIVE) {
        return first;
      }
         return checkHookBranchReadBeforeKill(
             n.getFirstChild().getNext(), n.getLastChild(), variable);
 
@@ -369,13 +402,11 @@ private VariableLiveness isVariableReadBeforeKill(
         // Expressions are evaluated left-right, depth first.
         for (Node child = n.getFirstChild();
             child != null; child = child.getNext()) {
           VariableLiveness state = isVariableReadBeforeKill(child, variable);
           if (state != VariableLiveness.MAYBE_LIVE) {
             return state;
           }
         }
     }
 
     return VariableLiveness.MAYBE_LIVE;
","
                                  
         case Token.HOOK:
                                  
         default:
           for(Node sibling = n.getNext(); sibling != null;
               sibling = sibling.getNext()) {
            if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {
             state = isVariableReadBeforeKill(sibling, variable);
 
              if (state == VariableLiveness.READ) {
         return true;
       } else if (state == VariableLiveness.KILL) {
         return false;
            }
          }
      }
       }
       n = n.getParent();
     }

    
   private VariableLiveness isVariableReadBeforeKill(
       Node n, String variable) {
 
     if (NodeUtil.isName(n) && variable.equals(n.getString())) {
       if (NodeUtil.isLhs(n, n.getParent())) {

              case Token.OR:
       case Token.AND:
                         case Token.HOOK:
         return checkHookBranchReadBeforeKill(
             n.getFirstChild().getNext(), n.getLastChild(), variable);
 

                  for (Node child = n.getFirstChild();
             child != null; child = child.getNext()) {
          if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {            VariableLiveness state = isVariableReadBeforeKill(child, variable);
           if (state != VariableLiveness.MAYBE_LIVE) {
             return state;
           }
         }
      }
     }
 
     return VariableLiveness.MAYBE_LIVE;
","
                                           if (n.getNext() != null) {
            state = isVariableReadBeforeKill(
                n.getNext(), variable);
            if (state == VariableLiveness.KILL) {
              state = VariableLiveness.MAYBE_LIVE;
            }
          }
          break;
 
         case Token.HOOK:
                                           if (n.getNext() != null && n.getNext().getNext() != null) {
            state = checkHookBranchReadBeforeKill(
                n.getNext(), n.getNext().getNext(), variable);
          }
          break;
 
         default:
           for(Node sibling = n.getNext(); sibling != null;
               sibling = sibling.getNext()) {
             state = isVariableReadBeforeKill(sibling, variable);
            if (state != VariableLiveness.MAYBE_LIVE) {
              break;
            }
          }
      }
 
              if (state == VariableLiveness.READ) {
         return true;
       } else if (state == VariableLiveness.KILL) {
         return false;
       }
       n = n.getParent();
     }

    
   private VariableLiveness isVariableReadBeforeKill(
       Node n, String variable) {
    if (ControlFlowGraph.isEnteringNewCfgNode(n)) {       return VariableLiveness.MAYBE_LIVE;
    }
 
     if (NodeUtil.isName(n) && variable.equals(n.getString())) {
       if (NodeUtil.isLhs(n, n.getParent())) {

              case Token.OR:
       case Token.AND:
        VariableLiveness v1 = isVariableReadBeforeKill(
          n.getFirstChild(), variable);
        VariableLiveness v2 = isVariableReadBeforeKill(
          n.getLastChild(), variable);
                          if (v1 != VariableLiveness.MAYBE_LIVE) {
          return v1;
        } else if (v2 == VariableLiveness.READ) {
          return VariableLiveness.READ;
        } else {
          return VariableLiveness.MAYBE_LIVE;
        }
       case Token.HOOK:
        VariableLiveness first = isVariableReadBeforeKill(
            n.getFirstChild(), variable);
        if (first != VariableLiveness.MAYBE_LIVE) {
          return first;
        }
         return checkHookBranchReadBeforeKill(
             n.getFirstChild().getNext(), n.getLastChild(), variable);
 

                  for (Node child = n.getFirstChild();
             child != null; child = child.getNext()) {
           VariableLiveness state = isVariableReadBeforeKill(child, variable);
           if (state != VariableLiveness.MAYBE_LIVE) {
             return state;
           }
         }
     }
 
     return VariableLiveness.MAYBE_LIVE;
"
102,"java.lang.RuntimeException","/src/com/google/javascript/jscomp/Normalize.java","@@ -119,7 +119,7 @@ private void reportCodeChange(String changeDescription) {
   public void process(Node externs, Node root) {
     new NodeTraversal(
         compiler, new NormalizeStatements(compiler, assertOnChange))
      .traverse(root);
     if (MAKE_LOCAL_NAMES_UNIQUE) {
       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
       NodeTraversal t = new NodeTraversal(compiler, renamer);
/src/com/google/javascript/jscomp/VarCheck.java @@ -218,6 +218,7 @@ private void createSynthesizedExternVar(String varName) {
     getSynthesizedExternsRoot().addChildToBack(
         new Node(Token.VAR, nameNode));
     varsToDeclareInExterns.remove(varName);
   }
 
   /**
","@@ -119,7 +119,7 @@ private void reportCodeChange(String changeDescription) {
   public void process(Node externs, Node root) {
     new NodeTraversal(
         compiler, new NormalizeStatements(compiler, assertOnChange))
      .traverseRoots(externs, root);
     if (MAKE_LOCAL_NAMES_UNIQUE) {
       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
       NodeTraversal t = new NodeTraversal(compiler, renamer);
/src/com/google/javascript/jscomp/VarCheck.java @@ -218,6 +218,7 @@ private void createSynthesizedExternVar(String varName) {
     getSynthesizedExternsRoot().addChildToBack(
         new Node(Token.VAR, nameNode));
     varsToDeclareInExterns.remove(varName);
  compiler.reportCodeChange();
   }
 
   /**
","
   public void process(Node externs, Node root) {
     new NodeTraversal(
         compiler, new NormalizeStatements(compiler, assertOnChange))
        .traverse(root);
     if (MAKE_LOCAL_NAMES_UNIQUE) {
       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
       NodeTraversal t = new NodeTraversal(compiler, renamer);

     getSynthesizedExternsRoot().addChildToBack(
         new Node(Token.VAR, nameNode));
     varsToDeclareInExterns.remove(varName);
   }
 
","
   public void process(Node externs, Node root) {
     new NodeTraversal(
         compiler, new NormalizeStatements(compiler, assertOnChange))
        .traverseRoots(externs, root);
     if (MAKE_LOCAL_NAMES_UNIQUE) {
       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
       NodeTraversal t = new NodeTraversal(compiler, renamer);

     getSynthesizedExternsRoot().addChildToBack(
         new Node(Token.VAR, nameNode));
     varsToDeclareInExterns.remove(varName);
    compiler.reportCodeChange();
   }
 
"
103,"junit.framework.ComparisonFailure","/src/com/google/javascript/jscomp/CodeGenerator.java","@@ -963,6 +963,7 @@ static String strEscape(String s, char quote,
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       switch (c) {
         case '\n': sb.append(""\\n""); break;
         case '\r': sb.append(""\\r""); break;
         case '\t': sb.append(""\\t""); break;
","@@ -963,6 +963,7 @@ static String strEscape(String s, char quote,
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       switch (c) {
      case '\0': sb.append(""\\0""); break;
         case '\n': sb.append(""\\n""); break;
         case '\r': sb.append(""\\r""); break;
         case '\t': sb.append(""\\t""); break;
","
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       switch (c) {
         case '\n': sb.append(""\\n""); break;
         case '\r': sb.append(""\\r""); break;
         case '\t': sb.append(""\\t""); break;
","
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       switch (c) {
        case '\0': sb.append(""\\0""); break;
         case '\n': sb.append(""\\n""); break;
         case '\r': sb.append(""\\r""); break;
         case '\t': sb.append(""\\t""); break;
"
104,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/NodeUtil.java","@@ -310,7 +310,10 @@ static Double getNumberValue(Node n) {
   }
 
   static Double getStringNumberValue(String rawJsString) {
       // vertical tab is not always whitespace
 
     String s = trimJsWhiteSpace(rawJsString);
     // return ScriptRuntime.toNumber(s);
@@ -372,7 +375,7 @@ static String trimJsWhiteSpace(String s) {
   static TernaryValue isStrWhiteSpaceChar(int c) {
     switch (c) {
       case '\u000B': // <VT>
      return TernaryValue.TRUE;
       case ' ': // <SP>
       case '\n': // <LF>
       case '\r': // <CR>
","@@ -310,7 +310,10 @@ static Double getNumberValue(Node n) {
   }
 
   static Double getStringNumberValue(String rawJsString) {
  if (rawJsString.contains(""\u000b"")) {
       // vertical tab is not always whitespace
    return null;
  }
 
     String s = trimJsWhiteSpace(rawJsString);
     // return ScriptRuntime.toNumber(s);
@@ -372,7 +375,7 @@ static String trimJsWhiteSpace(String s) {
   static TernaryValue isStrWhiteSpaceChar(int c) {
     switch (c) {
       case '\u000B': // <VT>
      return TernaryValue.UNKNOWN;  // IE says ""no"", EcmaScript says ""yes""
       case ' ': // <SP>
       case '\n': // <LF>
       case '\r': // <CR>
","
   }
 
   static Double getStringNumberValue(String rawJsString) {
        
     String s = trimJsWhiteSpace(rawJsString);
     
   static TernaryValue isStrWhiteSpaceChar(int c) {
     switch (c) {
       case '\u000B':         return TernaryValue.TRUE;
       case ' ':        case '\n':        case '\r': ","
   }
 
   static Double getStringNumberValue(String rawJsString) {
    if (rawJsString.contains(""\u000b"")) {
             return null;
    }
 
     String s = trimJsWhiteSpace(rawJsString);
     
   static TernaryValue isStrWhiteSpaceChar(int c) {
     switch (c) {
       case '\u000B':         return TernaryValue.UNKNOWN;         case ' ':        case '\n':        case '\r': "
105,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/PeepholeFoldConstants.java","@@ -708,14 +708,12 @@ private Node performArithmeticOp(int opType, Node left, Node right) {
         break;
       case Token.MOD:
         if (rval == 0) {
        error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
           return null;
         }
         result = lval % rval;
         break;
       case Token.DIV:
         if (rval == 0) {
        error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
           return null;
         }
         result = lval / rval;
","@@ -708,14 +708,12 @@ private Node performArithmeticOp(int opType, Node left, Node right) {
         break;
       case Token.MOD:
         if (rval == 0) {
           return null;
         }
         result = lval % rval;
         break;
       case Token.DIV:
         if (rval == 0) {
           return null;
         }
         result = lval / rval;
","
         break;
       case Token.MOD:
         if (rval == 0) {
          error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
           return null;
         }
         result = lval % rval;
         break;
       case Token.DIV:
         if (rval == 0) {
          error(DiagnosticType.error(""JSC_DIVIDE_BY_0_ERROR"", ""Divide by 0""), right);
           return null;
         }
         result = lval / rval;
","
         break;
       case Token.MOD:
         if (rval == 0) {
           return null;
         }
         result = lval % rval;
         break;
       case Token.DIV:
         if (rval == 0) {
           return null;
         }
         result = lval / rval;
"
106,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/CommandLineRunner.java","@@ -331,7 +331,10 @@ public BooleanOptionHandler(
 
       @Override
       public int parseArguments(Parameters params) throws CmdLineException {
      String param = params.getParameter(0);
 
         if (param == null) {
           setter.addValue(true);
","@@ -331,7 +331,10 @@ public BooleanOptionHandler(
 
       @Override
       public int parseArguments(Parameters params) throws CmdLineException {
      String param = null;
      try {
        param = params.getParameter(0);
      } catch (CmdLineException e) {}
 
         if (param == null) {
           setter.addValue(true);
","
 
       @Override
       public int parseArguments(Parameters params) throws CmdLineException {
        String param = params.getParameter(0);
 
         if (param == null) {
           setter.addValue(true);
","
 
       @Override
       public int parseArguments(Parameters params) throws CmdLineException {
        String param = null;
        try {
          param = params.getParameter(0);
        } catch (CmdLineException e) {}
 
         if (param == null) {
           setter.addValue(true);
"
107,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/NodeUtil.java","@@ -1259,6 +1259,7 @@ static boolean isBooleanResultHelper(Node n) {
       // Inversion
       case Token.NOT:
       // delete operator returns a boolean.
         return true;
       default:
         return false;
@@ -2907,6 +2908,7 @@ static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
       case Token.OBJECTLIT:
         // Literals objects with non-literal children are allowed.
         return true;
       case Token.IN:
         // TODO(johnlenz): should IN operator be included in #isSimpleOperator?
         return true;
","@@ -1259,6 +1259,7 @@ static boolean isBooleanResultHelper(Node n) {
       // Inversion
       case Token.NOT:
       // delete operator returns a boolean.
    case Token.DELPROP:
         return true;
       default:
         return false;
@@ -2907,6 +2908,7 @@ static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
       case Token.OBJECTLIT:
         // Literals objects with non-literal children are allowed.
         return true;
    case Token.DELPROP:
       case Token.IN:
         // TODO(johnlenz): should IN operator be included in #isSimpleOperator?
         return true;
","
              case Token.NOT:
                return true;
       default:
         return false;

       case Token.OBJECTLIT:
                  return true;
       case Token.IN:
                  return true;
","
              case Token.NOT:
             case Token.DELPROP:
         return true;
       default:
         return false;

       case Token.OBJECTLIT:
                  return true;
      case Token.DELPROP:
       case Token.IN:
                  return true;
"
108,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/parsing/IRFactory.java","@@ -514,6 +514,13 @@ Node processFunctionNode(FunctionNode functionNode) {
       Name name = functionNode.getFunctionName();
       Boolean isUnnamedFunction = false;
       if (name == null) {
         name = new Name();
         name.setIdentifier("""");
         isUnnamedFunction = true;
","@@ -514,6 +514,13 @@ Node processFunctionNode(FunctionNode functionNode) {
       Name name = functionNode.getFunctionName();
       Boolean isUnnamedFunction = false;
       if (name == null) {
      int functionType = functionNode.getFunctionType();
      if (functionType != FunctionNode.FUNCTION_EXPRESSION) {
        errorReporter.error(
          ""unnamed function statement"",
          sourceName,
          functionNode.getLineno(), """", 0);
      }
         name = new Name();
         name.setIdentifier("""");
         isUnnamedFunction = true;
","
       Name name = functionNode.getFunctionName();
       Boolean isUnnamedFunction = false;
       if (name == null) {
         name = new Name();
         name.setIdentifier("""");
         isUnnamedFunction = true;
","
       Name name = functionNode.getFunctionName();
       Boolean isUnnamedFunction = false;
       if (name == null) {
        int functionType = functionNode.getFunctionType();
        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {
          errorReporter.error(
            ""unnamed function statement"",
            sourceName,
            functionNode.getLineno(), """", 0);
        }
         name = new Name();
         name.setIdentifier("""");
         isUnnamedFunction = true;
"
109,"junit.framework.AssertionFailedError","/src/com/google/javascript/rhino/jstype/JSType.java","@@ -160,7 +160,9 @@ public boolean isNoObjectType() {
   }
 
   public final boolean isEmptyType() {
  return isNoType() || isNoObjectType() || isNoResolvedType();
   }
 
   public boolean isNumberObjectType() {
","@@ -160,7 +160,9 @@ public boolean isNoObjectType() {
   }
 
   public final boolean isEmptyType() {
  return isNoType() || isNoObjectType() || isNoResolvedType() ||
      (registry.getNativeFunctionType(
           JSTypeNative.LEAST_FUNCTION_TYPE) == this);
   }
 
   public boolean isNumberObjectType() {
","
   }
 
   public final boolean isEmptyType() {
    return isNoType() || isNoObjectType() || isNoResolvedType();
   }
 
   public boolean isNumberObjectType() {
","
   }
 
   public final boolean isEmptyType() {
    return isNoType() || isNoObjectType() || isNoResolvedType() ||
        (registry.getNativeFunctionType(
             JSTypeNative.LEAST_FUNCTION_TYPE) == this);
   }
 
   public boolean isNumberObjectType() {
"
110,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/UnreachableCodeElimination.java","@@ -150,20 +150,7 @@ private Node tryRemoveUnconditionalBranching(Node n) {
       return n;
     }
 
  if (n.getParent() == null) {
    List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();
    if (outEdges.size() == 1) {
      return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());
    }
  }
     switch (n.getType()) {
    case Token.BLOCK:
      if (n.hasChildren()) {
        Node first = n.getFirstChild();
        return tryRemoveUnconditionalBranching(first);
      } else {
        return tryRemoveUnconditionalBranching(ControlFlowAnalysis.computeFollowNode(n));
      }
       case Token.RETURN:
         if (n.hasChildren()) {
           break;
@@ -180,7 +167,7 @@ private Node tryRemoveUnconditionalBranching(Node n) {
             (n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) {
 
           Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);
        Node fallThrough = tryRemoveUnconditionalBranching(computeFollowing(n));
           Node nextCfgNode = outEdges.get(0).getDestination().getValue();
           if (nextCfgNode == fallThrough) {
             removeDeadExprStatementSafely(n);
@@ -193,6 +180,13 @@ private Node tryRemoveUnconditionalBranching(Node n) {
 
   private Node computeFollowing(Node n) {
     Node next = ControlFlowAnalysis.computeFollowNode(n);
     return next;
   }
 
","@@ -150,20 +150,7 @@ private Node tryRemoveUnconditionalBranching(Node n) {
       return n;
     }
 
     switch (n.getType()) {
       case Token.RETURN:
         if (n.hasChildren()) {
           break;
@@ -180,7 +167,7 @@ private Node tryRemoveUnconditionalBranching(Node n) {
             (n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) {
 
           Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);
        Node fallThrough = computeFollowing(n);
           Node nextCfgNode = outEdges.get(0).getDestination().getValue();
           if (nextCfgNode == fallThrough) {
             removeDeadExprStatementSafely(n);
@@ -193,6 +180,13 @@ private Node tryRemoveUnconditionalBranching(Node n) {
 
   private Node computeFollowing(Node n) {
     Node next = ControlFlowAnalysis.computeFollowNode(n);
  while (next != null && next.getType() == Token.BLOCK) {
    if (next.hasChildren()) {
      next = next.getFirstChild();
    } else {
      next = computeFollowing(next);
    }
  }
     return next;
   }
 
","
       return n;
     }
 
    if (n.getParent() == null) {
      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();
      if (outEdges.size() == 1) {
        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());
      }
    }
     switch (n.getType()) {
      case Token.BLOCK:
        if (n.hasChildren()) {
          Node first = n.getFirstChild();
          return tryRemoveUnconditionalBranching(first);
        } else {
          return tryRemoveUnconditionalBranching(ControlFlowAnalysis.computeFollowNode(n));
        }
       case Token.RETURN:
         if (n.hasChildren()) {
           break;

             (n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) {
 
           Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);
          Node fallThrough = tryRemoveUnconditionalBranching(computeFollowing(n));
           Node nextCfgNode = outEdges.get(0).getDestination().getValue();
           if (nextCfgNode == fallThrough) {
             removeDeadExprStatementSafely(n);

 
   private Node computeFollowing(Node n) {
     Node next = ControlFlowAnalysis.computeFollowNode(n);
     return next;
   }
 
","
       return n;
     }
 
     switch (n.getType()) {
       case Token.RETURN:
         if (n.hasChildren()) {
           break;

             (n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) {
 
           Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);
          Node fallThrough = computeFollowing(n);
           Node nextCfgNode = outEdges.get(0).getDestination().getValue();
           if (nextCfgNode == fallThrough) {
             removeDeadExprStatementSafely(n);

 
   private Node computeFollowing(Node n) {
     Node next = ControlFlowAnalysis.computeFollowNode(n);
    while (next != null && next.getType() == Token.BLOCK) {
      if (next.hasChildren()) {
        next = next.getFirstChild();
      } else {
        next = computeFollowing(next);
      }
    }
     return next;
   }
 
"
111,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/NodeUtil.java","@@ -2462,7 +2462,7 @@ static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
         // TODO(nicksantos): This needs to be changed so that it
         // returns true iff we're sure the value was never aliased from inside
         // the constructor (similar to callHasLocalResult)
      return true;
       case Token.FUNCTION:
       case Token.REGEXP:
       case Token.ARRAYLIT:
","@@ -2462,7 +2462,7 @@ static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
         // TODO(nicksantos): This needs to be changed so that it
         // returns true iff we're sure the value was never aliased from inside
         // the constructor (similar to callHasLocalResult)
      return false;
       case Token.FUNCTION:
       case Token.REGEXP:
       case Token.ARRAYLIT:
","
                                   return true;
       case Token.FUNCTION:
       case Token.REGEXP:
       case Token.ARRAYLIT:
","
                                   return false;
       case Token.FUNCTION:
       case Token.REGEXP:
       case Token.ARRAYLIT:
"
112,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/parsing/IRFactory.java","@@ -338,6 +338,13 @@ Node processArrayLiteral(ArrayLiteral literalNode) {
     @Override
     Node processAssignment(Assignment assignmentNode) {
       Node assign = processInfixExpression(assignmentNode);
       return assign;
     }
 
@@ -794,6 +801,17 @@ Node processUnaryExpression(UnaryExpression exprNode) {
         operand.setDouble(-operand.getDouble());
         return operand;
       } else {
 
         Node node = newNode(type, operand);
         if (exprNode.isPostfix()) {
@@ -803,6 +821,15 @@ Node processUnaryExpression(UnaryExpression exprNode) {
       }
     }
 
 
     @Override
     Node processVariableDeclaration(VariableDeclaration declarationNode) {
","@@ -338,6 +338,13 @@ Node processArrayLiteral(ArrayLiteral literalNode) {
     @Override
     Node processAssignment(Assignment assignmentNode) {
       Node assign = processInfixExpression(assignmentNode);
    Node target = assign.getFirstChild();
    if (!validAssignmentTarget(target)) {
      errorReporter.error(
        ""invalid assignment target"",
        sourceName,
        target.getLineno(), """", 0);
    }
       return assign;
     }
 
@@ -794,6 +801,17 @@ Node processUnaryExpression(UnaryExpression exprNode) {
         operand.setDouble(-operand.getDouble());
         return operand;
       } else {
      if (type == Token.INC || type == Token.DEC) {
        if (!validAssignmentTarget(operand)) {
          String msg = (type == Token.INC)
              ? ""invalid increment target""
              : ""invalid decrement target"";
          errorReporter.error(
            msg,
            sourceName,
            operand.getLineno(), """", 0);
        }
      }
 
         Node node = newNode(type, operand);
         if (exprNode.isPostfix()) {
@@ -803,6 +821,15 @@ Node processUnaryExpression(UnaryExpression exprNode) {
       }
     }
 
  private boolean validAssignmentTarget(Node target) {
    switch (target.getType()) {
      case Token.NAME:
      case Token.GETPROP:
      case Token.GETELEM:
        return true;
    }
    return false;
  }
 
     @Override
     Node processVariableDeclaration(VariableDeclaration declarationNode) {
","
     @Override
     Node processAssignment(Assignment assignmentNode) {
       Node assign = processInfixExpression(assignmentNode);
       return assign;
     }
 

         operand.setDouble(-operand.getDouble());
         return operand;
       } else {
 
         Node node = newNode(type, operand);
         if (exprNode.isPostfix()) {

       }
     }
 
 
     @Override
     Node processVariableDeclaration(VariableDeclaration declarationNode) {
","
     @Override
     Node processAssignment(Assignment assignmentNode) {
       Node assign = processInfixExpression(assignmentNode);
      Node target = assign.getFirstChild();
      if (!validAssignmentTarget(target)) {
        errorReporter.error(
          ""invalid assignment target"",
          sourceName,
          target.getLineno(), """", 0);
      }
       return assign;
     }
 

         operand.setDouble(-operand.getDouble());
         return operand;
       } else {
        if (type == Token.INC || type == Token.DEC) {
          if (!validAssignmentTarget(operand)) {
            String msg = (type == Token.INC)
                ? ""invalid increment target""
                : ""invalid decrement target"";
            errorReporter.error(
              msg,
              sourceName,
              operand.getLineno(), """", 0);
          }
        }
 
         Node node = newNode(type, operand);
         if (exprNode.isPostfix()) {

       }
     }
 
    private boolean validAssignmentTarget(Node target) {
      switch (target.getType()) {
        case Token.NAME:
        case Token.GETPROP:
        case Token.GETELEM:
          return true;
      }
      return false;
    }
 
     @Override
     Node processVariableDeclaration(VariableDeclaration declarationNode) {
"
113,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/CollapseProperties.java","@@ -481,6 +481,9 @@ private void updateSimpleDeclaration(String alias, Name refName, Ref ref) {
     Node greatGramps = gramps.getParent();
     Node greatGreatGramps = greatGramps.getParent();
 
 
     // Create the new alias node.
     Node nameNode = NodeUtil.newName(
/src/com/google/javascript/jscomp/GlobalNamespace.java @@ -917,7 +917,7 @@ boolean canCollapseUnannotatedChildNames() {
       }
 
       // If this is aliased, then its properties can't be collapsed either.
    if (type != Type.FUNCTION && aliasingGets > 0) {
         return false;
       }
 
","@@ -481,6 +481,9 @@ private void updateSimpleDeclaration(String alias, Name refName, Ref ref) {
     Node greatGramps = gramps.getParent();
     Node greatGreatGramps = greatGramps.getParent();
 
  if (rvalue != null && rvalue.getType() == Token.FUNCTION) {
    checkForHosedThisReferences(rvalue, refName.docInfo, refName);
  }
 
     // Create the new alias node.
     Node nameNode = NodeUtil.newName(
/src/com/google/javascript/jscomp/GlobalNamespace.java @@ -917,7 +917,7 @@ boolean canCollapseUnannotatedChildNames() {
       }
 
       // If this is aliased, then its properties can't be collapsed either.
    if (aliasingGets > 0) {
         return false;
       }
 
","
     Node greatGramps = gramps.getParent();
     Node greatGreatGramps = greatGramps.getParent();
 
 
          Node nameNode = NodeUtil.newName(

       }
 
             if (type != Type.FUNCTION && aliasingGets > 0) {
         return false;
       }
 
","
     Node greatGramps = gramps.getParent();
     Node greatGreatGramps = greatGramps.getParent();
 
    if (rvalue != null && rvalue.getType() == Token.FUNCTION) {
      checkForHosedThisReferences(rvalue, refName.docInfo, refName);
    }
 
          Node nameNode = NodeUtil.newName(

       }
 
             if (aliasingGets > 0) {
         return false;
       }
 
"
114,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java","@@ -324,9 +324,15 @@ private VariableLiveness isVariableReadBeforeKill(
       Node n, String variable) {
     if (NodeUtil.isName(n) && variable.equals(n.getString())) {
       if (NodeUtil.isLhs(n, n.getParent())) {
         // The expression to which the assignment is made is evaluated before
         // the RHS is evaluated (normal left to right evaluation) but the KILL
         // occurs after the RHS is evaluated.
         return VariableLiveness.KILL;
       } else {
         return VariableLiveness.READ;
","@@ -324,9 +324,15 @@ private VariableLiveness isVariableReadBeforeKill(
       Node n, String variable) {
     if (NodeUtil.isName(n) && variable.equals(n.getString())) {
       if (NodeUtil.isLhs(n, n.getParent())) {
      Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);
         // The expression to which the assignment is made is evaluated before
         // the RHS is evaluated (normal left to right evaluation) but the KILL
         // occurs after the RHS is evaluated.
      Node rhs = n.getNext();
      VariableLiveness state = isVariableReadBeforeKill(rhs, variable);
      if (state == VariableLiveness.READ) {
        return state;
      }
         return VariableLiveness.KILL;
       } else {
         return VariableLiveness.READ;
","
       Node n, String variable) {
     if (NodeUtil.isName(n) && variable.equals(n.getString())) {
       if (NodeUtil.isLhs(n, n.getParent())) {
                                    return VariableLiveness.KILL;
       } else {
         return VariableLiveness.READ;
","
       Node n, String variable) {
     if (NodeUtil.isName(n) && variable.equals(n.getString())) {
       if (NodeUtil.isLhs(n, n.getParent())) {
        Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);
                                   Node rhs = n.getNext();
        VariableLiveness state = isVariableReadBeforeKill(rhs, variable);
        if (state == VariableLiveness.READ) {
          return state;
        }
         return VariableLiveness.KILL;
       } else {
         return VariableLiveness.READ;
"
115,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java","@@ -520,17 +520,29 @@ private boolean isFoldableExpressBlock(Node n) {
     if (n.getType() == Token.BLOCK) {
       if (n.hasOneChild()) {
         Node maybeExpr = n.getFirstChild();
           // IE has a bug where event handlers behave differently when
           // their return value is used vs. when their return value is in
           // an EXPR_RESULT. It's pretty freaking weird. See:
           // http://code.google.com/p/closure-compiler/issues/detail?id=291
           // We try to detect this case, and not fold EXPR_RESULTs
           // into other expressions.
 
             // We only have to worry about methods with an implicit 'this'
             // param, or this doesn't happen.
 
        return NodeUtil.isExpressionNode(maybeExpr);
       }
     }
 
","@@ -520,17 +520,29 @@ private boolean isFoldableExpressBlock(Node n) {
     if (n.getType() == Token.BLOCK) {
       if (n.hasOneChild()) {
         Node maybeExpr = n.getFirstChild();
      if (maybeExpr.getType() == Token.EXPR_RESULT) {
           // IE has a bug where event handlers behave differently when
           // their return value is used vs. when their return value is in
           // an EXPR_RESULT. It's pretty freaking weird. See:
           // http://code.google.com/p/closure-compiler/issues/detail?id=291
           // We try to detect this case, and not fold EXPR_RESULTs
           // into other expressions.
        if (maybeExpr.getFirstChild().getType() == Token.CALL) {
          Node calledFn = maybeExpr.getFirstChild().getFirstChild();
 
             // We only have to worry about methods with an implicit 'this'
             // param, or this doesn't happen.
          if (calledFn.getType() == Token.GETELEM) {
            return false;
          } else if (calledFn.getType() == Token.GETPROP &&
                     calledFn.getLastChild().getString().startsWith(""on"")) {
            return false;
          }
        }
 
        return true;
      }
      return false;
       }
     }
 
","
     if (n.getType() == Token.BLOCK) {
       if (n.hasOneChild()) {
         Node maybeExpr = n.getFirstChild();
                                                                   
                           
          return NodeUtil.isExpressionNode(maybeExpr);
       }
     }
 
","
     if (n.getType() == Token.BLOCK) {
       if (n.hasOneChild()) {
         Node maybeExpr = n.getFirstChild();
        if (maybeExpr.getType() == Token.EXPR_RESULT) {
                                                                            if (maybeExpr.getFirstChild().getType() == Token.CALL) {
            Node calledFn = maybeExpr.getFirstChild().getFirstChild();
 
                                      if (calledFn.getType() == Token.GETELEM) {
              return false;
            } else if (calledFn.getType() == Token.GETPROP &&
                       calledFn.getLastChild().getString().startsWith(""on"")) {
              return false;
            }
          }
 
          return true;
        }
        return false;
       }
     }
 
"
116,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java","@@ -786,7 +786,7 @@ void replace() {
         } else {
           // In this case, the name was implicitly provided by two independent
           // modules. We need to move this code up to a common module.
        int indexOfDot = namespace.indexOf('.');
           if (indexOfDot == -1) {
             // Any old place is fine.
             compiler.getNodeForCodeInsertion(minimumModule)
","@@ -786,7 +786,7 @@ void replace() {
         } else {
           // In this case, the name was implicitly provided by two independent
           // modules. We need to move this code up to a common module.
        int indexOfDot = namespace.lastIndexOf('.');
           if (indexOfDot == -1) {
             // Any old place is fine.
             compiler.getNodeForCodeInsertion(minimumModule)
","
         } else {
                                int indexOfDot = namespace.indexOf('.');
           if (indexOfDot == -1) {
                          compiler.getNodeForCodeInsertion(minimumModule)
","
         } else {
                                int indexOfDot = namespace.lastIndexOf('.');
           if (indexOfDot == -1) {
                          compiler.getNodeForCodeInsertion(minimumModule)
"
117,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/TypedScopeCreator.java","@@ -896,9 +896,16 @@ void defineSlot(Node n, Node parent, JSType type, boolean inferred) {
       // scope where the root object appears. This helps out people
       // who declare ""global"" names in an anonymous namespace.
       Scope scopeToDeclareIn = scope;
 
         // don't try to declare in the global scope if there's
         // already a symbol there with this name.
 
       // declared in closest scope?
       if (scopeToDeclareIn.isDeclared(variableName, false)) {
","@@ -896,9 +896,16 @@ void defineSlot(Node n, Node parent, JSType type, boolean inferred) {
       // scope where the root object appears. This helps out people
       // who declare ""global"" names in an anonymous namespace.
       Scope scopeToDeclareIn = scope;
    if (n.getType() == Token.GETPROP && !scope.isGlobal() &&
        isQnameRootedInGlobalScope(n)) {
      Scope globalScope = scope.getGlobalScope();
 
         // don't try to declare in the global scope if there's
         // already a symbol there with this name.
      if (!globalScope.isDeclared(variableName, false)) {
        scopeToDeclareIn = scope.getGlobalScope();
      }
    }
 
       // declared in closest scope?
       if (scopeToDeclareIn.isDeclared(variableName, false)) {
","
                     Scope scopeToDeclareIn = scope;
 
                   
              if (scopeToDeclareIn.isDeclared(variableName, false)) {
","
                     Scope scopeToDeclareIn = scope;
      if (n.getType() == Token.GETPROP && !scope.isGlobal() &&
          isQnameRootedInGlobalScope(n)) {
        Scope globalScope = scope.getGlobalScope();
 
                          if (!globalScope.isDeclared(variableName, false)) {
          scopeToDeclareIn = scope.getGlobalScope();
        }
      }
 
              if (scopeToDeclareIn.isDeclared(variableName, false)) {
"
118,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/FunctionTypeBuilder.java","@@ -181,7 +181,7 @@ public boolean apply(JSType type) {
       // create interfaces JSType, ObjectType, FunctionType etc and have
       // separate implementation instead of the class hierarchy, so that
       // union types can also be object types, etc.
    if (!type.isSubtype(
               typeRegistry.getNativeType(OBJECT_TYPE))) {
         reportWarning(THIS_TYPE_NON_OBJECT, type.toString());
         return false;
/src/com/google/javascript/rhino/jstype/FunctionType.java @@ -877,6 +877,9 @@ JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {
     // mean ""nullable Foo"". For certain tags (like @extends) we de-nullify
     // the name for them.
     JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);
     if (maybeTypeOfThis instanceof ObjectType) {
       typeOfThis = (ObjectType) maybeTypeOfThis;
     }
","@@ -181,7 +181,7 @@ public boolean apply(JSType type) {
       // create interfaces JSType, ObjectType, FunctionType etc and have
       // separate implementation instead of the class hierarchy, so that
       // union types can also be object types, etc.
    if (!type.restrictByNotNullOrUndefined().isSubtype(
               typeRegistry.getNativeType(OBJECT_TYPE))) {
         reportWarning(THIS_TYPE_NON_OBJECT, type.toString());
         return false;
/src/com/google/javascript/rhino/jstype/FunctionType.java @@ -877,6 +877,9 @@ JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {
     // mean ""nullable Foo"". For certain tags (like @extends) we de-nullify
     // the name for them.
     JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);
  if (maybeTypeOfThis != null) {
    maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined();
  }
     if (maybeTypeOfThis instanceof ObjectType) {
       typeOfThis = (ObjectType) maybeTypeOfThis;
     }
","
                           if (!type.isSubtype(
               typeRegistry.getNativeType(OBJECT_TYPE))) {
         reportWarning(THIS_TYPE_NON_OBJECT, type.toString());
         return false;

               JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);
     if (maybeTypeOfThis instanceof ObjectType) {
       typeOfThis = (ObjectType) maybeTypeOfThis;
     }
","
                           if (!type.restrictByNotNullOrUndefined().isSubtype(
               typeRegistry.getNativeType(OBJECT_TYPE))) {
         reportWarning(THIS_TYPE_NON_OBJECT, type.toString());
         return false;

               JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);
    if (maybeTypeOfThis != null) {
      maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined();
    }
     if (maybeTypeOfThis instanceof ObjectType) {
       typeOfThis = (ObjectType) maybeTypeOfThis;
     }
"
119,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/NodeUtil.java","@@ -326,14 +326,33 @@ static boolean isValidDefineValue(Node val, Set<String> defines) {
         return true;
 
       // Binary operators are only valid if both children are valid.
       case Token.BITAND:
       case Token.BITNOT:
       case Token.BITOR:
       case Token.BITXOR:
 
       // Uniary operators are valid if the child is valid.
       case Token.NOT:
       case Token.NEG:
         return isValidDefineValue(val.getFirstChild(), defines);
 
       // Names are valid if and only if they are defines themselves.
","@@ -326,14 +326,33 @@ static boolean isValidDefineValue(Node val, Set<String> defines) {
         return true;
 
       // Binary operators are only valid if both children are valid.
    case Token.ADD:
       case Token.BITAND:
       case Token.BITNOT:
       case Token.BITOR:
       case Token.BITXOR:
    case Token.DIV:
    case Token.EQ:
    case Token.GE:
    case Token.GT:
    case Token.LE:
    case Token.LSH:
    case Token.LT:
    case Token.MOD:
    case Token.MUL:
    case Token.NE:
    case Token.RSH:
    case Token.SHEQ:
    case Token.SHNE:
    case Token.SUB:
    case Token.URSH:
      return isValidDefineValue(val.getFirstChild(), defines)
          && isValidDefineValue(val.getLastChild(), defines);
 
       // Uniary operators are valid if the child is valid.
       case Token.NOT:
       case Token.NEG:
    case Token.POS:
         return isValidDefineValue(val.getFirstChild(), defines);
 
       // Names are valid if and only if they are defines themselves.
","
         return true;
 
              case Token.BITAND:
       case Token.BITNOT:
       case Token.BITOR:
       case Token.BITXOR:
 
              case Token.NOT:
       case Token.NEG:
         return isValidDefineValue(val.getFirstChild(), defines);
 
       ","
         return true;
 
             case Token.ADD:
       case Token.BITAND:
       case Token.BITNOT:
       case Token.BITOR:
       case Token.BITXOR:
      case Token.DIV:
      case Token.EQ:
      case Token.GE:
      case Token.GT:
      case Token.LE:
      case Token.LSH:
      case Token.LT:
      case Token.MOD:
      case Token.MUL:
      case Token.NE:
      case Token.RSH:
      case Token.SHEQ:
      case Token.SHNE:
      case Token.SUB:
      case Token.URSH:
        return isValidDefineValue(val.getFirstChild(), defines)
            && isValidDefineValue(val.getLastChild(), defines);
 
              case Token.NOT:
       case Token.NEG:
      case Token.POS:
         return isValidDefineValue(val.getFirstChild(), defines);
 
       "
120,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/CheckGlobalThis.java","@@ -112,6 +112,15 @@ public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
       }
 
       // Don't traverse functions that are getting lent to a prototype.
     }
 
     if (parent != null && parent.getType() == Token.ASSIGN) {
","@@ -112,6 +112,15 @@ public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
       }
 
       // Don't traverse functions that are getting lent to a prototype.
    Node gramps = parent.getParent();
    if (NodeUtil.isObjectLitKey(parent, gramps)) {
      JSDocInfo maybeLends = gramps.getJSDocInfo();
      if (maybeLends != null &&
          maybeLends.getLendsName() != null &&
          maybeLends.getLendsName().endsWith("".prototype"")) {
        return false;
      }
    }
     }
 
     if (parent != null && parent.getType() == Token.ASSIGN) {
","
       }
 
            }
 
     if (parent != null && parent.getType() == Token.ASSIGN) {
","
       }
 
             Node gramps = parent.getParent();
      if (NodeUtil.isObjectLitKey(parent, gramps)) {
        JSDocInfo maybeLends = gramps.getJSDocInfo();
        if (maybeLends != null &&
            maybeLends.getLendsName() != null &&
            maybeLends.getLendsName().endsWith("".prototype"")) {
          return false;
        }
      }
     }
 
     if (parent != null && parent.getType() == Token.ASSIGN) {
"
121,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java","@@ -786,7 +786,7 @@ void replace() {
         } else {
           // In this case, the name was implicitly provided by two independent
           // modules. We need to move this code up to a common module.
        int indexOfDot = namespace.indexOf('.');
           if (indexOfDot == -1) {
             // Any old place is fine.
             compiler.getNodeForCodeInsertion(minimumModule)
","@@ -786,7 +786,7 @@ void replace() {
         } else {
           // In this case, the name was implicitly provided by two independent
           // modules. We need to move this code up to a common module.
        int indexOfDot = namespace.lastIndexOf('.');
           if (indexOfDot == -1) {
             // Any old place is fine.
             compiler.getNodeForCodeInsertion(minimumModule)
","
         } else {
                                int indexOfDot = namespace.indexOf('.');
           if (indexOfDot == -1) {
                          compiler.getNodeForCodeInsertion(minimumModule)
","
         } else {
                                int indexOfDot = namespace.lastIndexOf('.');
           if (indexOfDot == -1) {
                          compiler.getNodeForCodeInsertion(minimumModule)
"
122,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/PeepholeFoldConstants.java","@@ -695,7 +695,8 @@ private Node tryFoldShift(Node n, Node left, Node right) {
           // JavaScript handles zero shifts on signed numbers differently than
           // Java as an Java int can not represent the unsigned 32-bit number
           // where JavaScript can so use a long here.
        result = lvalInt >>> rvalInt;
           break;
         default:
           throw new AssertionError(""Unknown shift operator: "" +
","@@ -695,7 +695,8 @@ private Node tryFoldShift(Node n, Node left, Node right) {
           // JavaScript handles zero shifts on signed numbers differently than
           // Java as an Java int can not represent the unsigned 32-bit number
           // where JavaScript can so use a long here.
        long lvalLong = lvalInt & 0xffffffffL;
        result = lvalLong >>> rvalInt;
           break;
         default:
           throw new AssertionError(""Unknown shift operator: "" +
","
                                           result = lvalInt >>> rvalInt;
           break;
         default:
           throw new AssertionError(""Unknown shift operator: "" +
","
                                           long lvalLong = lvalInt & 0xffffffffL;
          result = lvalLong >>> rvalInt;
           break;
         default:
           throw new AssertionError(""Unknown shift operator: "" +
"
123,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/TypeCheck.java","@@ -1406,10 +1406,13 @@ private void visitParameterList(NodeTraversal t, Node call,
     Node parameter = null;
     Node argument = null;
     while (arguments.hasNext() &&
         parameters.hasNext()) {
       // If there are no parameters left in the list, then the while loop
       // above implies that this must be a var_args function.
         parameter = parameters.next();
       argument = arguments.next();
       ordinal++;
 
","@@ -1406,10 +1406,13 @@ private void visitParameterList(NodeTraversal t, Node call,
     Node parameter = null;
     Node argument = null;
     while (arguments.hasNext() &&
         (parameters.hasNext() ||
          parameter != null && parameter.isVarArgs())) {
       // If there are no parameters left in the list, then the while loop
       // above implies that this must be a var_args function.
    if (parameters.hasNext()) {
         parameter = parameters.next();
    }
       argument = arguments.next();
       ordinal++;
 
","
     Node parameter = null;
     Node argument = null;
     while (arguments.hasNext() &&
           parameters.hasNext()) {
                       parameter = parameters.next();
       argument = arguments.next();
       ordinal++;
 
","
     Node parameter = null;
     Node argument = null;
     while (arguments.hasNext() &&
           (parameters.hasNext() ||
            parameter != null && parameter.isVarArgs())) {
                    if (parameters.hasNext()) {
         parameter = parameters.next();
      }
       argument = arguments.next();
       ordinal++;
 
"
124,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/CommandLineRunner.java","@@ -430,10 +430,8 @@ protected CompilerOptions createOptions() {
     for (FormattingOption formattingOption : flags.formatting) {
       formattingOption.applyToOptions(options);
     }
  if (flags.process_closure_primitives) {
    options.closurePass = true;
  }
 
     initOptionsFromFlags(options);
     return options;
   }
","@@ -430,10 +430,8 @@ protected CompilerOptions createOptions() {
     for (FormattingOption formattingOption : flags.formatting) {
       formattingOption.applyToOptions(options);
     }
 
  options.closurePass = flags.process_closure_primitives;
     initOptionsFromFlags(options);
     return options;
   }
","
     for (FormattingOption formattingOption : flags.formatting) {
       formattingOption.applyToOptions(options);
     }
    if (flags.process_closure_primitives) {
      options.closurePass = true;
    }
 
     initOptionsFromFlags(options);
     return options;
   }
","
     for (FormattingOption formattingOption : flags.formatting) {
       formattingOption.applyToOptions(options);
     }
 
    options.closurePass = flags.process_closure_primitives;
     initOptionsFromFlags(options);
     return options;
   }
"
125,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/CheckGlobalThis.java","@@ -96,6 +96,13 @@ public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
       // var a = function() { }; // or
       // function a() {} // or
       // a.x = function() {};
     }
 
     if (parent != null && parent.getType() == Token.ASSIGN) {
@@ -143,7 +150,7 @@ private boolean shouldReportThis(Node n, Node parent) {
     }
 
     // Also report a THIS with a property access.
  return false;
   }
 
   /**
","@@ -96,6 +96,13 @@ public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
       // var a = function() { }; // or
       // function a() {} // or
       // a.x = function() {};
    int pType = parent.getType();
    if (!(pType == Token.BLOCK ||
          pType == Token.SCRIPT ||
          pType == Token.NAME ||
          pType == Token.ASSIGN)) {
      return false;
    }
     }
 
     if (parent != null && parent.getType() == Token.ASSIGN) {
@@ -143,7 +150,7 @@ private boolean shouldReportThis(Node n, Node parent) {
     }
 
     // Also report a THIS with a property access.
  return parent != null && NodeUtil.isGet(parent);
   }
 
   /**
","
                          }
 
     if (parent != null && parent.getType() == Token.ASSIGN) {

     }
 
         return false;
   }
 
","
                           int pType = parent.getType();
      if (!(pType == Token.BLOCK ||
            pType == Token.SCRIPT ||
            pType == Token.NAME ||
            pType == Token.ASSIGN)) {
        return false;
      }
     }
 
     if (parent != null && parent.getType() == Token.ASSIGN) {

     }
 
         return parent != null && NodeUtil.isGet(parent);
   }
 
"
126,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java","@@ -354,15 +354,23 @@ Reference getInitializingReferenceForConstants() {
     boolean isAssignedOnceInLifetime() {
       Reference ref = getOneAndOnlyAssignment();
       if (ref == null) {
         return false;
       }
 
       // Make sure this assignment is not in a loop.
 
       return true;
     }
 
     /**
      * @return The one and only assignment. Returns if there are 0 or 2+
      *    assignments.
      */
@@ -523,41 +531,52 @@ Scope getScope() {
     public String getSourceName() {
       return sourceName;
     }
   }
 
   /**
    * Represents a section of code that is uninterrupted by control structures
    * (conditional or iterative logic).
    */
   static final class BasicBlock {
 
     private final BasicBlock parent;
 
     /**
      * Determines whether the block may not be part of the normal control flow,
      * but instead ""hoisted"" to the top of the scope.
      */
     private final boolean isHoisted;
 
     /**
      * Whether this block denotes a function scope.
      */
 
     /**
      * Whether this block denotes a loop.
      */
 
     /**
      * Creates a new block.
      * @param parent The containing block.
      * @param root The root node of the block.
      */
     BasicBlock(BasicBlock parent, Node root) {
       this.parent = parent;
 
       // only named functions may be hoisted.
       this.isHoisted = NodeUtil.isHoistedFunctionDeclaration(root);
 
 
     }
 
","@@ -354,15 +354,23 @@ Reference getInitializingReferenceForConstants() {
     boolean isAssignedOnceInLifetime() {
       Reference ref = getOneAndOnlyAssignment();
       if (ref == null) {
         return false;
       }
 
       // Make sure this assignment is not in a loop.
    for (BasicBlock block = ref.getBasicBlock();
         block != null; block = block.getParent()) {
      if (block.isFunction) {
        break;
      } else if (block.isLoop) {
        return false;
      }
    }
 
       return true;
     }
 
     /**
      * @return The one and only assignment. Returns if there are 0 or 2+
      *    assignments.
      */
@@ -523,41 +531,52 @@ Scope getScope() {
     public String getSourceName() {
       return sourceName;
     }
   }
 
   /**
    * Represents a section of code that is uninterrupted by control structures
    * (conditional or iterative logic).
    */
   static final class BasicBlock {
 
     private final BasicBlock parent;
 
     /**
      * Determines whether the block may not be part of the normal control flow,
      * but instead ""hoisted"" to the top of the scope.
      */
     private final boolean isHoisted;
 
     /**
      * Whether this block denotes a function scope.
      */
  private final boolean isFunction;
 
     /**
      * Whether this block denotes a loop.
      */
  private final boolean isLoop;
 
     /**
      * Creates a new block.
      * @param parent The containing block.
      * @param root The root node of the block.
      */
     BasicBlock(BasicBlock parent, Node root) {
       this.parent = parent;
 
       // only named functions may be hoisted.
       this.isHoisted = NodeUtil.isHoistedFunctionDeclaration(root);
 
    this.isFunction = root.getType() == Token.FUNCTION;
 
    if (root.getParent() != null) {
      int pType = root.getParent().getType();
      this.isLoop = pType == Token.DO ||
          pType == Token.WHILE ||
          pType == Token.FOR;
    } else {
      this.isLoop = false;
    }
     }
 
","
     boolean isAssignedOnceInLifetime() {
       Reference ref = getOneAndOnlyAssignment();
       if (ref == null) {
         return false;
       }
 
        
       return true;
     }
     public String getSourceName() {
       return sourceName;
     }
   }
 
  
   static final class BasicBlock {
 
     private final BasicBlock parent;
 
     private final boolean isHoisted;
 
 
 
   
     BasicBlock(BasicBlock parent, Node root) {
       this.parent = parent;
 
              this.isHoisted = NodeUtil.isHoistedFunctionDeclaration(root);
 
 
     }
 
","
     boolean isAssignedOnceInLifetime() {
       Reference ref = getOneAndOnlyAssignment();
       if (ref == null) {
         return false;
       }
 
             for (BasicBlock block = ref.getBasicBlock();
           block != null; block = block.getParent()) {
        if (block.isFunction) {
          break;
        } else if (block.isLoop) {
          return false;
        }
      }
 
       return true;
     }
     public String getSourceName() {
       return sourceName;
     }
   }   static final class BasicBlock {
 
     private final BasicBlock parent;
 
     private final boolean isHoisted;
 
    private final boolean isFunction;
 
 
    private final boolean isLoop;
      BasicBlock(BasicBlock parent, Node root) {
       this.parent = parent;
 
              this.isHoisted = NodeUtil.isHoistedFunctionDeclaration(root);
 
      this.isFunction = root.getType() == Token.FUNCTION;
 
      if (root.getParent() != null) {
        int pType = root.getParent().getType();
        this.isLoop = pType == Token.DO ||
            pType == Token.WHILE ||
            pType == Token.FOR;
      } else {
        this.isLoop = false;
      }
     }
 
"
127,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/CheckGlobalThis.java","@@ -89,6 +89,7 @@ public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
       JSDocInfo jsDoc = getFunctionJsDocInfo(n);
       if (jsDoc != null &&
           (jsDoc.isConstructor() ||
            jsDoc.hasThisType() ||
            jsDoc.isOverride())) {
         return false;
@@ -122,13 +123,17 @@ public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
       } else {
         // Only traverse the right side if it's not an assignment to a prototype
         // property or subproperty.
           if (lhs.getType() == Token.GETPROP &&
               lhs.getLastChild().getString().equals(""prototype"")) {
             return false;
           }
        if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains("".prototype."")) {
             return false;
           }
       }
     }
 
","@@ -89,6 +89,7 @@ public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
       JSDocInfo jsDoc = getFunctionJsDocInfo(n);
       if (jsDoc != null &&
           (jsDoc.isConstructor() ||
         jsDoc.isInterface() ||
            jsDoc.hasThisType() ||
            jsDoc.isOverride())) {
         return false;
@@ -122,13 +123,17 @@ public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {
       } else {
         // Only traverse the right side if it's not an assignment to a prototype
         // property or subproperty.
      if (NodeUtil.isGet(lhs)) {
           if (lhs.getType() == Token.GETPROP &&
               lhs.getLastChild().getString().equals(""prototype"")) {
             return false;
           }
        Node llhs = lhs.getFirstChild();
        if (llhs.getType() == Token.GETPROP &&
            llhs.getLastChild().getString().equals(""prototype"")) {
             return false;
           }
      }
       }
     }
 
","
       JSDocInfo jsDoc = getFunctionJsDocInfo(n);
       if (jsDoc != null &&
           (jsDoc.isConstructor() ||
            jsDoc.hasThisType() ||
            jsDoc.isOverride())) {
         return false;

       } else {
                             if (lhs.getType() == Token.GETPROP &&
               lhs.getLastChild().getString().equals(""prototype"")) {
             return false;
           }
          if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains("".prototype."")) {
             return false;
           }
       }
     }
 
","
       JSDocInfo jsDoc = getFunctionJsDocInfo(n);
       if (jsDoc != null &&
           (jsDoc.isConstructor() ||
           jsDoc.isInterface() ||
            jsDoc.hasThisType() ||
            jsDoc.isOverride())) {
         return false;

       } else {
                          if (NodeUtil.isGet(lhs)) {
           if (lhs.getType() == Token.GETPROP &&
               lhs.getLastChild().getString().equals(""prototype"")) {
             return false;
           }
          Node llhs = lhs.getFirstChild();
          if (llhs.getType() == Token.GETPROP &&
              llhs.getLastChild().getString().equals(""prototype"")) {
             return false;
           }
        }
       }
     }
 
"
128,"junit.framework.AssertionFailedError","/src/com/google/javascript/rhino/jstype/UnionType.java","@@ -288,7 +288,7 @@ JSType meet(JSType that) {
       builder.addAlternate(that);
     }
     JSType result = builder.build();
  if (result != null) {
       return result;
     } else if (this.isObject() && that.isObject()) {
       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);
","@@ -288,7 +288,7 @@ JSType meet(JSType that) {
       builder.addAlternate(that);
     }
     JSType result = builder.build();
  if (!result.isNoType()) {
       return result;
     } else if (this.isObject() && that.isObject()) {
       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);
","
       builder.addAlternate(that);
     }
     JSType result = builder.build();
    if (result != null) {
       return result;
     } else if (this.isObject() && that.isObject()) {
       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);
","
       builder.addAlternate(that);
     }
     JSType result = builder.build();
    if (!result.isNoType()) {
       return result;
     } else if (this.isObject() && that.isObject()) {
       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);
"
129,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/FoldConstants.java","@@ -1474,22 +1474,24 @@ void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,
 
     String joinString = NodeUtil.getStringValue(right);
     List<Node> arrayFoldedChildren = Lists.newLinkedList();
  StringBuilder sb = new StringBuilder();
     int foldedSize = 0;
     Node elem = arrayNode.getFirstChild();
     // Merges adjacent String nodes.
     while (elem != null) {
       if (NodeUtil.isImmutableValue(elem)) {
      if (sb.length() > 0) {
           sb.append(joinString);
         }
         sb.append(NodeUtil.getStringValue(elem));
       } else {
      if (sb.length() > 0) {
           // + 2 for the quotes.
           foldedSize += sb.length() + 2;
           arrayFoldedChildren.add(Node.newString(sb.toString()));
        sb = new StringBuilder();
         }
         foldedSize += InlineCostEstimator.getCost(elem);
         arrayFoldedChildren.add(elem);
@@ -1497,7 +1499,7 @@ void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,
       elem = elem.getNext();
     }
 
  if (sb.length() > 0) {
       // + 2 for the quotes.
       foldedSize += sb.length() + 2;
       arrayFoldedChildren.add(Node.newString(sb.toString()));
","@@ -1474,22 +1474,24 @@ void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,
 
     String joinString = NodeUtil.getStringValue(right);
     List<Node> arrayFoldedChildren = Lists.newLinkedList();
  StringBuilder sb = null;
     int foldedSize = 0;
     Node elem = arrayNode.getFirstChild();
     // Merges adjacent String nodes.
     while (elem != null) {
       if (NodeUtil.isImmutableValue(elem)) {
      if (sb == null) {
        sb = new StringBuilder();
      } else {
           sb.append(joinString);
         }
         sb.append(NodeUtil.getStringValue(elem));
       } else {
      if (sb != null) {
           // + 2 for the quotes.
           foldedSize += sb.length() + 2;
           arrayFoldedChildren.add(Node.newString(sb.toString()));
        sb = null;
         }
         foldedSize += InlineCostEstimator.getCost(elem);
         arrayFoldedChildren.add(elem);
@@ -1497,7 +1499,7 @@ void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,
       elem = elem.getNext();
     }
 
  if (sb != null) {
       // + 2 for the quotes.
       foldedSize += sb.length() + 2;
       arrayFoldedChildren.add(Node.newString(sb.toString()));
","
 
     String joinString = NodeUtil.getStringValue(right);
     List<Node> arrayFoldedChildren = Lists.newLinkedList();
    StringBuilder sb = new StringBuilder();
     int foldedSize = 0;
     Node elem = arrayNode.getFirstChild();
          while (elem != null) {
       if (NodeUtil.isImmutableValue(elem)) {
        if (sb.length() > 0) {
           sb.append(joinString);
         }
         sb.append(NodeUtil.getStringValue(elem));
       } else {
        if (sb.length() > 0) {
                      foldedSize += sb.length() + 2;
           arrayFoldedChildren.add(Node.newString(sb.toString()));
          sb = new StringBuilder();
         }
         foldedSize += InlineCostEstimator.getCost(elem);
         arrayFoldedChildren.add(elem);

       elem = elem.getNext();
     }
 
    if (sb.length() > 0) {
              foldedSize += sb.length() + 2;
       arrayFoldedChildren.add(Node.newString(sb.toString()));
","
 
     String joinString = NodeUtil.getStringValue(right);
     List<Node> arrayFoldedChildren = Lists.newLinkedList();
    StringBuilder sb = null;
     int foldedSize = 0;
     Node elem = arrayNode.getFirstChild();
          while (elem != null) {
       if (NodeUtil.isImmutableValue(elem)) {
        if (sb == null) {
          sb = new StringBuilder();
        } else {
           sb.append(joinString);
         }
         sb.append(NodeUtil.getStringValue(elem));
       } else {
        if (sb != null) {
                      foldedSize += sb.length() + 2;
           arrayFoldedChildren.add(Node.newString(sb.toString()));
          sb = null;
         }
         foldedSize += InlineCostEstimator.getCost(elem);
         arrayFoldedChildren.add(elem);

       elem = elem.getNext();
     }
 
    if (sb != null) {
              foldedSize += sb.length() + 2;
       arrayFoldedChildren.add(Node.newString(sb.toString()));
"
130,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/GlobalNamespace.java","@@ -904,6 +904,10 @@ boolean canCollapseUnannotatedChildNames() {
       // Don't try to collapse if the one global set is a twin reference.
       // We could theoretically handle this case in CollapseProperties, but
       // it's probably not worth the effort.
 
       if (isClassOrEnum) {
         return true;
/src/com/google/javascript/rhino/JSDocInfoBuilder.java @@ -186,9 +186,7 @@ public void markName(String name, int lineno, int charno) {
    * @return {@code true} if the description was recorded.
    */
   public boolean recordBlockDescription(String description) {
  if (parseDocumentation) {
     populated = true;
  }
     return currentInfo.documentBlock(description);
   }
 
","@@ -904,6 +904,10 @@ boolean canCollapseUnannotatedChildNames() {
       // Don't try to collapse if the one global set is a twin reference.
       // We could theoretically handle this case in CollapseProperties, but
       // it's probably not worth the effort.
    Preconditions.checkNotNull(declaration);
    if (declaration.getTwin() != null) {
      return false;
    }
 
       if (isClassOrEnum) {
         return true;
/src/com/google/javascript/rhino/JSDocInfoBuilder.java @@ -186,9 +186,7 @@ public void markName(String name, int lineno, int charno) {
    * @return {@code true} if the description was recorded.
    */
   public boolean recordBlockDescription(String description) {
     populated = true;
     return currentInfo.documentBlock(description);
   }
 
","
                      
       if (isClassOrEnum) {
         return true;

    if (parseDocumentation) {
     populated = true;
    }
     return currentInfo.documentBlock(description);
   }
 
","
                           Preconditions.checkNotNull(declaration);
      if (declaration.getTwin() != null) {
        return false;
      }
 
       if (isClassOrEnum) {
         return true;

     populated = true;
     return currentInfo.documentBlock(description);
   }
 
"
131,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/Normalize.java","@@ -86,12 +86,12 @@ private void reportCodeChange(String changeDescription) {
   @Override
   public void process(Node externs, Node root) {
     NodeTraversal.traverse(compiler, root, this);
     if (MAKE_LOCAL_NAMES_UNIQUE) {
       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
       NodeTraversal t = new NodeTraversal(compiler, renamer);
       t.traverseRoots(externs, root);
     }
  removeDuplicateDeclarations(root);
     new PropogateConstantAnnotations(compiler, assertOnChange)
         .process(externs, root);
   }
","@@ -86,12 +86,12 @@ private void reportCodeChange(String changeDescription) {
   @Override
   public void process(Node externs, Node root) {
     NodeTraversal.traverse(compiler, root, this);
  removeDuplicateDeclarations(root);
     if (MAKE_LOCAL_NAMES_UNIQUE) {
       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
       NodeTraversal t = new NodeTraversal(compiler, renamer);
       t.traverseRoots(externs, root);
     }
     new PropogateConstantAnnotations(compiler, assertOnChange)
         .process(externs, root);
   }
","
   @Override
   public void process(Node externs, Node root) {
     NodeTraversal.traverse(compiler, root, this);
     if (MAKE_LOCAL_NAMES_UNIQUE) {
       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
       NodeTraversal t = new NodeTraversal(compiler, renamer);
       t.traverseRoots(externs, root);
     }
    removeDuplicateDeclarations(root);
     new PropogateConstantAnnotations(compiler, assertOnChange)
         .process(externs, root);
   }
","
   @Override
   public void process(Node externs, Node root) {
     NodeTraversal.traverse(compiler, root, this);
    removeDuplicateDeclarations(root);
     if (MAKE_LOCAL_NAMES_UNIQUE) {
       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();
       NodeTraversal t = new NodeTraversal(compiler, renamer);
       t.traverseRoots(externs, root);
     }
     new PropogateConstantAnnotations(compiler, assertOnChange)
         .process(externs, root);
   }
"
132,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/ControlFlowAnalysis.java","@@ -891,6 +891,7 @@ private static boolean mayThrowException(Node n) {
       case Token.ASSIGN:
       case Token.INC:
       case Token.DEC:
         return true;
       case Token.FUNCTION:
         return false;
/src/com/google/javascript/jscomp/DisambiguateProperties.java @@ -760,9 +760,16 @@ public JSTypeSystem(AbstractCompiler compiler) {
       }
       // If the property does not exist on the referenced type but the original
       // type is an object type, see if any subtype has the property.
         // getGreatestSubtypeWithProperty does not guarantee that the property
         // is defined on the returned type, it just indicates that it might be,
         // so we have to double check.
       return foundType;
     }
 
","@@ -891,6 +891,7 @@ private static boolean mayThrowException(Node n) {
       case Token.ASSIGN:
       case Token.INC:
       case Token.DEC:
    case Token.INSTANCEOF:
         return true;
       case Token.FUNCTION:
         return false;
/src/com/google/javascript/jscomp/DisambiguateProperties.java @@ -760,9 +760,16 @@ public JSTypeSystem(AbstractCompiler compiler) {
       }
       // If the property does not exist on the referenced type but the original
       // type is an object type, see if any subtype has the property.
    if (foundType == null) {
      ObjectType maybeType = ObjectType.cast(
          registry.getGreatestSubtypeWithProperty(type, field));
         // getGreatestSubtypeWithProperty does not guarantee that the property
         // is defined on the returned type, it just indicates that it might be,
         // so we have to double check.
      if (maybeType != null && maybeType.hasOwnProperty(field)) {
        foundType = maybeType;
      }
    }
       return foundType;
     }
 
","
       case Token.ASSIGN:
       case Token.INC:
       case Token.DEC:
         return true;
       case Token.FUNCTION:
         return false;

       }
                                                return foundType;
     }
 
","
       case Token.ASSIGN:
       case Token.INC:
       case Token.DEC:
      case Token.INSTANCEOF:
         return true;
       case Token.FUNCTION:
         return false;

       }
                    if (foundType == null) {
        ObjectType maybeType = ObjectType.cast(
            registry.getGreatestSubtypeWithProperty(type, field));
                                   if (maybeType != null && maybeType.hasOwnProperty(field)) {
          foundType = maybeType;
        }
      }
       return foundType;
     }
 
"
133,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/CommandLineRunner.java","@@ -859,6 +859,7 @@ protected CompilerOptions createOptions() {
       // so we might as well inline it. But shut off the i18n warnings,
       // because the user didn't really ask for i18n.
       options.messageBundle = new EmptyMessageBundle();
     }
 
     return options;
","@@ -859,6 +859,7 @@ protected CompilerOptions createOptions() {
       // so we might as well inline it. But shut off the i18n warnings,
       // because the user didn't really ask for i18n.
       options.messageBundle = new EmptyMessageBundle();
    options.setWarningLevel(JsMessageVisitor.MSG_CONVENTIONS, CheckLevel.OFF);
     }
 
     return options;
","
                     options.messageBundle = new EmptyMessageBundle();
     }
 
     return options;
","
                     options.messageBundle = new EmptyMessageBundle();
      options.setWarningLevel(JsMessageVisitor.MSG_CONVENTIONS, CheckLevel.OFF);
     }
 
     return options;
"
134,"java.lang.IllegalStateException","/src/com/google/javascript/jscomp/ScopedAliases.java","@@ -256,6 +256,7 @@ public void applyAlias() {
     private final Map<String, Var> aliases = Maps.newHashMap();
 
     // Also temporary and cleared for each scope.
 
     // Suppose you create an alias.
     // var x = goog.x;
@@ -313,6 +314,7 @@ public void exitScope(NodeTraversal t) {
 
       if (t.getScopeDepth() == 2) {
         renameNamespaceShadows(t);
         aliases.clear();
         forbiddenLocals.clear();
         transformation = null;
@@ -429,6 +431,7 @@ private void findAliases(NodeTraversal t) {
             } else {
               grandparent.addChildBefore(newDecl, varNode);
             }
           }
 
           // Rewrite ""var name = EXPR;"" to ""var name = $jscomp.scope.name;""
@@ -578,7 +581,7 @@ public void visit(NodeTraversal t, Node n, Node parent) {
         // When we inject declarations, we duplicate jsdoc. Make sure
         // we only process that jsdoc once.
         JSDocInfo info = n.getJSDocInfo();
      if (info != null) {
           for (Node node : info.getTypeNodes()) {
             fixTypeNode(node);
           }
","@@ -256,6 +256,7 @@ public void applyAlias() {
     private final Map<String, Var> aliases = Maps.newHashMap();
 
     // Also temporary and cleared for each scope.
  private final Set<Node> injectedDecls = Sets.newHashSet();
 
     // Suppose you create an alias.
     // var x = goog.x;
@@ -313,6 +314,7 @@ public void exitScope(NodeTraversal t) {
 
       if (t.getScopeDepth() == 2) {
         renameNamespaceShadows(t);
      injectedDecls.clear();
         aliases.clear();
         forbiddenLocals.clear();
         transformation = null;
@@ -429,6 +431,7 @@ private void findAliases(NodeTraversal t) {
             } else {
               grandparent.addChildBefore(newDecl, varNode);
             }
          injectedDecls.add(newDecl.getFirstChild());
           }
 
           // Rewrite ""var name = EXPR;"" to ""var name = $jscomp.scope.name;""
@@ -578,7 +581,7 @@ public void visit(NodeTraversal t, Node n, Node parent) {
         // When we inject declarations, we duplicate jsdoc. Make sure
         // we only process that jsdoc once.
         JSDocInfo info = n.getJSDocInfo();
      if (info != null && !injectedDecls.contains(n)) {
           for (Node node : info.getTypeNodes()) {
             fixTypeNode(node);
           }
","
     private final Map<String, Var> aliases = Maps.newHashMap();
 
      
          
 
       if (t.getScopeDepth() == 2) {
         renameNamespaceShadows(t);
         aliases.clear();
         forbiddenLocals.clear();
         transformation = null;

             } else {
               grandparent.addChildBefore(newDecl, varNode);
             }
           }
 
           
                           JSDocInfo info = n.getJSDocInfo();
        if (info != null) {
           for (Node node : info.getTypeNodes()) {
             fixTypeNode(node);
           }
","
     private final Map<String, Var> aliases = Maps.newHashMap();
 
         private final Set<Node> injectedDecls = Sets.newHashSet();
 
          
 
       if (t.getScopeDepth() == 2) {
         renameNamespaceShadows(t);
        injectedDecls.clear();
         aliases.clear();
         forbiddenLocals.clear();
         transformation = null;

             } else {
               grandparent.addChildBefore(newDecl, varNode);
             }
            injectedDecls.add(newDecl.getFirstChild());
           }
 
           
                           JSDocInfo info = n.getJSDocInfo();
        if (info != null && !injectedDecls.contains(n)) {
           for (Node node : info.getTypeNodes()) {
             fixTypeNode(node);
           }
"
135,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java","@@ -1905,7 +1905,11 @@ private Node parseTypeExpression(JsDocToken token) {
    * For expressions on the right hand side of a this: or new:
    */
   private Node parseContextTypeExpression(JsDocToken token) {
        return parseTypeName(token);
   }
 
   /**
","@@ -1905,7 +1905,11 @@ private Node parseTypeExpression(JsDocToken token) {
    * For expressions on the right hand side of a this: or new:
    */
   private Node parseContextTypeExpression(JsDocToken token) {
  if (token == JsDocToken.QMARK) {
    return newNode(Token.QMARK);
  } else {
    return parseBasicTypeExpression(token);
  }
   }
 
   /**
","
          return parseTypeName(token);
   }
 
","
    if (token == JsDocToken.QMARK) {
      return newNode(Token.QMARK);
    } else {
      return parseBasicTypeExpression(token);
    }
   }
 
"
136,"junit.framework.ComparisonFailure","/src/com/google/javascript/jscomp/TypeValidator.java","@@ -722,8 +722,20 @@ private String formatFoundRequired(String description, JSType found,
    *     to an Object type, if possible.
    */
   String getReadableJSTypeName(Node n, boolean dereference) {
 
     // The best type name is the actual type name.
 
     // If we're analyzing a GETPROP, the property may be inherited by the
     // prototype chain. So climb the prototype chain and find out where
@@ -753,18 +765,6 @@ String getReadableJSTypeName(Node n, boolean dereference) {
       }
     }
 
  JSType type = getJSType(n);
  if (dereference) {
    ObjectType dereferenced = type.dereference();
    if (dereferenced != null) {
      type = dereferenced;
    }
  }
  if (type.isFunctionPrototypeType() ||
      (type.toObjectType() != null &&
       type.toObjectType().getConstructor() != null)) {
    return type.toString();
  }
     String qualifiedName = n.getQualifiedName();
     if (qualifiedName != null) {
       return qualifiedName;
","@@ -722,8 +722,20 @@ private String formatFoundRequired(String description, JSType found,
    *     to an Object type, if possible.
    */
   String getReadableJSTypeName(Node n, boolean dereference) {
  JSType type = getJSType(n);
  if (dereference) {
    ObjectType dereferenced = type.dereference();
    if (dereferenced != null) {
      type = dereferenced;
    }
  }
 
     // The best type name is the actual type name.
  if (type.isFunctionPrototypeType() ||
      (type.toObjectType() != null &&
       type.toObjectType().getConstructor() != null)) {
    return type.toString();
  }
 
     // If we're analyzing a GETPROP, the property may be inherited by the
     // prototype chain. So climb the prototype chain and find out where
@@ -753,18 +765,6 @@ String getReadableJSTypeName(Node n, boolean dereference) {
       }
     }
 
     String qualifiedName = n.getQualifiedName();
     if (qualifiedName != null) {
       return qualifiedName;
","
 
      
          
       }
     }
 
    JSType type = getJSType(n);
    if (dereference) {
      ObjectType dereferenced = type.dereference();
      if (dereferenced != null) {
        type = dereferenced;
      }
    }
    if (type.isFunctionPrototypeType() ||
        (type.toObjectType() != null &&
         type.toObjectType().getConstructor() != null)) {
      return type.toString();
    }
     String qualifiedName = n.getQualifiedName();
     if (qualifiedName != null) {
       return qualifiedName;
","
    JSType type = getJSType(n);
    if (dereference) {
      ObjectType dereferenced = type.dereference();
      if (dereferenced != null) {
        type = dereferenced;
      }
    }
 
         if (type.isFunctionPrototypeType() ||
        (type.toObjectType() != null &&
         type.toObjectType().getConstructor() != null)) {
      return type.toString();
    }
 
          
       }
     }
 
     String qualifiedName = n.getQualifiedName();
     if (qualifiedName != null) {
       return qualifiedName;
"
137,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/TypeInference.java","@@ -1189,9 +1189,15 @@ private boolean inferTemplatedTypesForCall(
     }
 
     // Try to infer the template types
  Map<TemplateType, JSType> inferred = 
      inferTemplateTypesFromParameters(fnType, n);
 
     // Replace all template types. If we couldn't find a replacement, we
     // replace it with UNKNOWN.
","@@ -1189,9 +1189,15 @@ private boolean inferTemplatedTypesForCall(
     }
 
     // Try to infer the template types
  Map<TemplateType, JSType> inferred = Maps.filterKeys(
      inferTemplateTypesFromParameters(fnType, n),
      new Predicate<TemplateType>() {
        @Override
        public boolean apply(TemplateType key) {
          return keys.contains(key);
        }}
      );
 
     // Replace all template types. If we couldn't find a replacement, we
     // replace it with UNKNOWN.
","
     }
 
         Map<TemplateType, JSType> inferred = 
        inferTemplateTypesFromParameters(fnType, n);
-
+
 
          ","
     }
 
     -
    Map<TemplateType, JSType> inferred = Maps.filterKeys(
        inferTemplateTypesFromParameters(fnType, n),
        new Predicate<TemplateType>() {
+
          @Override
          public boolean apply(TemplateType key) {
            return keys.contains(key);
          }}
        );
 
          "
138,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/NameAnalyzer.java","@@ -575,7 +575,7 @@ private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {
           } else {
             recordDepScope(nameNode, ns);
           }
      } else {
           // The rhs of the assignment is the caller, so it's used by the
           // context. Don't associate it w/ the lhs.
           // FYI: this fixes only the specific case where the assignment is the
","@@ -575,7 +575,7 @@ private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {
           } else {
             recordDepScope(nameNode, ns);
           }
      } else if (!(parent.isCall() && parent.getFirstChild() == n)) {
           // The rhs of the assignment is the caller, so it's used by the
           // context. Don't associate it w/ the lhs.
           // FYI: this fixes only the specific case where the assignment is the
","
           } else {
             recordDepScope(nameNode, ns);
           }
        } else {
                                 ","
           } else {
             recordDepScope(nameNode, ns);
           }
        } else if (!(parent.isCall() && parent.getFirstChild() == n)) {
                                 "
139,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java","@@ -326,7 +326,7 @@ private void processRequireCall(NodeTraversal t, Node n, Node parent) {
       // the checks for broken requires turned off. In these cases, we
       // allow broken requires to be preserved by the first run to
       // let them be caught in the subsequent run.
    if (provided != null) {
         parent.detachFromParent();
         compiler.reportCodeChange();
       }
","@@ -326,7 +326,7 @@ private void processRequireCall(NodeTraversal t, Node n, Node parent) {
       // the checks for broken requires turned off. In these cases, we
       // allow broken requires to be preserved by the first run to
       // let them be caught in the subsequent run.
    if (provided != null || requiresLevel.isOn()) {
         parent.detachFromParent();
         compiler.reportCodeChange();
       }
","
                           if (provided != null) {
         parent.detachFromParent();
         compiler.reportCodeChange();
       }
","
                           if (provided != null || requiresLevel.isOn()) {
         parent.detachFromParent();
         compiler.reportCodeChange();
       }
"
140,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/FunctionInjector.java","@@ -694,14 +694,6 @@ private CanInlineResult canInlineReferenceDirectly(
 
     Node block = fnNode.getLastChild();
 
  boolean hasSideEffects = false;
  if (block.hasChildren()) {
    Preconditions.checkState(block.hasOneChild());
    Node stmt = block.getFirstChild();
    if (stmt.isReturn()) {
      hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);
    }
  }
     // CALL NODE: [ NAME, ARG1, ARG2, ... ]
     Node cArg = callNode.getFirstChild().getNext();
 
@@ -727,9 +719,6 @@ private CanInlineResult canInlineReferenceDirectly(
       // For each named parameter check if a mutable argument use more than one.
       if (fnParam != null) {
         if (cArg != null) {
        if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {
          return CanInlineResult.NO;
        }
           // Check for arguments that are evaluated more than once.
           // Note: Unlike block inlining, there it is not possible that a
           // parameter reference will be in a loop.
","@@ -694,14 +694,6 @@ private CanInlineResult canInlineReferenceDirectly(
 
     Node block = fnNode.getLastChild();
 
     // CALL NODE: [ NAME, ARG1, ARG2, ... ]
     Node cArg = callNode.getFirstChild().getNext();
 
@@ -727,9 +719,6 @@ private CanInlineResult canInlineReferenceDirectly(
       // For each named parameter check if a mutable argument use more than one.
       if (fnParam != null) {
         if (cArg != null) {
           // Check for arguments that are evaluated more than once.
           // Note: Unlike block inlining, there it is not possible that a
           // parameter reference will be in a loop.
","
 
     Node block = fnNode.getLastChild();
 
    boolean hasSideEffects = false;
    if (block.hasChildren()) {
      Preconditions.checkState(block.hasOneChild());
      Node stmt = block.getFirstChild();
      if (stmt.isReturn()) {
        hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);
      }
    }
          Node cArg = callNode.getFirstChild().getNext();
 

              if (fnParam != null) {
         if (cArg != null) {
          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {
            return CanInlineResult.NO;
          }
                                 ","
 
     Node block = fnNode.getLastChild();
 
          Node cArg = callNode.getFirstChild().getNext();
 

              if (fnParam != null) {
         if (cArg != null) {
                                 "
141,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/FunctionInjector.java","@@ -694,6 +694,15 @@ private CanInlineResult canInlineReferenceDirectly(
 
     Node block = fnNode.getLastChild();
 
 
     // CALL NODE: [ NAME, ARG1, ARG2, ... ]
     Node cArg = callNode.getFirstChild().getNext();
@@ -720,6 +729,9 @@ private CanInlineResult canInlineReferenceDirectly(
       // For each named parameter check if a mutable argument use more than one.
       if (fnParam != null) {
         if (cArg != null) {
 
           // Check for arguments that are evaluated more than once.
           // Note: Unlike block inlining, there it is not possible that a
","@@ -694,6 +694,15 @@ private CanInlineResult canInlineReferenceDirectly(
 
     Node block = fnNode.getLastChild();
 
  boolean hasSideEffects = false;  // empty function case
  if (block.hasChildren()) {
    Preconditions.checkState(block.hasOneChild());
    Node stmt = block.getFirstChild();
    if (stmt.isReturn()) {
      hasSideEffects = NodeUtil.mayHaveSideEffects(
          stmt.getFirstChild(), compiler);
    }
  }
 
     // CALL NODE: [ NAME, ARG1, ARG2, ... ]
     Node cArg = callNode.getFirstChild().getNext();
@@ -720,6 +729,9 @@ private CanInlineResult canInlineReferenceDirectly(
       // For each named parameter check if a mutable argument use more than one.
       if (fnParam != null) {
         if (cArg != null) {
        if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {
          return CanInlineResult.NO;
        }
 
           // Check for arguments that are evaluated more than once.
           // Note: Unlike block inlining, there it is not possible that a
","
 
     Node block = fnNode.getLastChild();
 
 
          Node cArg = callNode.getFirstChild().getNext();

              if (fnParam != null) {
         if (cArg != null) {
 
                      ","
 
     Node block = fnNode.getLastChild();
 
    boolean hasSideEffects = false;      if (block.hasChildren()) {
      Preconditions.checkState(block.hasOneChild());
      Node stmt = block.getFirstChild();
      if (stmt.isReturn()) {
        hasSideEffects = NodeUtil.mayHaveSideEffects(
            stmt.getFirstChild(), compiler);
      }
    }
 
          Node cArg = callNode.getFirstChild().getNext();

              if (fnParam != null) {
         if (cArg != null) {
          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {
            return CanInlineResult.NO;
          }
 
                      "
142,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java","@@ -51,7 +51,8 @@
       new RestrictByTrueTypeOfResultVisitor() {
         @Override
         protected JSType caseTopType(JSType topType) {
        return topType;
         }
 
         @Override
","@@ -51,7 +51,8 @@
       new RestrictByTrueTypeOfResultVisitor() {
         @Override
         protected JSType caseTopType(JSType topType) {
        return topType.isAllType() ?
            getNativeType(ARRAY_TYPE) : topType;
         }
 
         @Override
","
       new RestrictByTrueTypeOfResultVisitor() {
         @Override
         protected JSType caseTopType(JSType topType) {
          return topType;
         }
 
         @Override
","
       new RestrictByTrueTypeOfResultVisitor() {
         @Override
         protected JSType caseTopType(JSType topType) {
          return topType.isAllType() ?
              getNativeType(ARRAY_TYPE) : topType;
         }
 
         @Override
"
143,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/ScopedAliases.java","@@ -355,6 +355,7 @@ private void findAliases(NodeTraversal t) {
         Node n = v.getNode();
         Node parent = n.getParent();
         boolean isVar = parent.isVar();
         if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {
           recordAlias(v);
         } else if (v.isBleedingFunction()) {
@@ -363,12 +364,13 @@ private void findAliases(NodeTraversal t) {
         } else if (parent.getType() == Token.LP) {
           // Parameters of the scope function also get a BAD_PARAMETERS
           // error.
      } else if (isVar) {
           Node grandparent = parent.getParent();
        Node value = n.hasChildren() ?
            v.getInitialValue().detachFromParent() :
               null;
        Node varNode = parent;
 
           String name = n.getString();
           int nameCount = scopedAliasNames.count(name);
@@ -380,7 +382,9 @@ private void findAliases(NodeTraversal t) {
 
           // First, we need to free up the function expression (EXPR)
           // to be used in another expression.
             // Replace ""function NAME() { ... }"" with ""var NAME;"".
 
             // We can't keep the local name on the function expression,
             // because IE is buggy and will leak the name into the global
@@ -389,9 +393,19 @@ private void findAliases(NodeTraversal t) {
             //
             // This will only cause problems if this is a hoisted, recursive
             // function, and the programmer is using the hoisting.
 
               // If this is a VAR, we can just detach the expression and
               // the tree will still be valid.
 
           // Add $jscomp.scope.name = EXPR;
           // Make sure we copy over all the jsdoc and debug info.
@@ -405,7 +419,11 @@ private void findAliases(NodeTraversal t) {
             NodeUtil.setDebugInformation(
                 newDecl.getFirstChild().getFirstChild(), n, name);
 
               grandparent.addChildBefore(newDecl, varNode);
           }
 
           // Rewrite ""var name = EXPR;"" to ""var name = $jscomp.scope.name;""
/src/com/google/javascript/rhino/Node.java @@ -551,6 +551,9 @@ public Node getChildBefore(Node child) {
       return null;
     }
     Node n = first;
 
     while (n.next != child) {
       n = n.next;
","@@ -355,6 +355,7 @@ private void findAliases(NodeTraversal t) {
         Node n = v.getNode();
         Node parent = n.getParent();
         boolean isVar = parent.isVar();
      boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);
         if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {
           recordAlias(v);
         } else if (v.isBleedingFunction()) {
@@ -363,12 +364,13 @@ private void findAliases(NodeTraversal t) {
         } else if (parent.getType() == Token.LP) {
           // Parameters of the scope function also get a BAD_PARAMETERS
           // error.
      } else if (isVar || isFunctionDecl) {
        boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);
           Node grandparent = parent.getParent();
        Node value = v.getInitialValue() != null ?
            v.getInitialValue() :
               null;
        Node varNode = null;
 
           String name = n.getString();
           int nameCount = scopedAliasNames.count(name);
@@ -380,7 +382,9 @@ private void findAliases(NodeTraversal t) {
 
           // First, we need to free up the function expression (EXPR)
           // to be used in another expression.
        if (isFunctionDecl) {
             // Replace ""function NAME() { ... }"" with ""var NAME;"".
          Node existingName = v.getNameNode();
 
             // We can't keep the local name on the function expression,
             // because IE is buggy and will leak the name into the global
@@ -389,9 +393,19 @@ private void findAliases(NodeTraversal t) {
             //
             // This will only cause problems if this is a hoisted, recursive
             // function, and the programmer is using the hoisting.
          Node newName = IR.name("""").useSourceInfoFrom(existingName);
          value.replaceChild(existingName, newName);
 
          varNode = IR.var(existingName).useSourceInfoFrom(existingName);
          grandparent.replaceChild(parent, varNode);
        } else {
          if (value != null) {
               // If this is a VAR, we can just detach the expression and
               // the tree will still be valid.
            value.detachFromParent();
          }
          varNode = parent;
        }
 
           // Add $jscomp.scope.name = EXPR;
           // Make sure we copy over all the jsdoc and debug info.
@@ -405,7 +419,11 @@ private void findAliases(NodeTraversal t) {
             NodeUtil.setDebugInformation(
                 newDecl.getFirstChild().getFirstChild(), n, name);
 
          if (isHoisted) {
            grandparent.addChildToFront(newDecl);
          } else {
               grandparent.addChildBefore(newDecl, varNode);
          }
           }
 
           // Rewrite ""var name = EXPR;"" to ""var name = $jscomp.scope.name;""
/src/com/google/javascript/rhino/Node.java @@ -551,6 +551,9 @@ public Node getChildBefore(Node child) {
       return null;
     }
     Node n = first;
  if (n == null) {
    throw new RuntimeException(""node is not a child"");
  }
 
     while (n.next != child) {
       n = n.next;
","
         Node n = v.getNode();
         Node parent = n.getParent();
         boolean isVar = parent.isVar();
         if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {
           recordAlias(v);
         } else if (v.isBleedingFunction()) {

         } else if (parent.getType() == Token.LP) {
                              } else if (isVar) {
           Node grandparent = parent.getParent();
          Node value = n.hasChildren() ?
              v.getInitialValue().detachFromParent() :
               null;
          Node varNode = parent;
 
           String name = n.getString();
           int nameCount = scopedAliasNames.count(name);

                    
                                        
                               
                    
             NodeUtil.setDebugInformation(
                 newDecl.getFirstChild().getFirstChild(), n, name);
 
               grandparent.addChildBefore(newDecl, varNode);
           }
 

       return null;
     }
     Node n = first;
 
     while (n.next != child) {
       n = n.next;
","
         Node n = v.getNode();
         Node parent = n.getParent();
         boolean isVar = parent.isVar();
        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);
         if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {
           recordAlias(v);
         } else if (v.isBleedingFunction()) {

         } else if (parent.getType() == Token.LP) {
                              } else if (isVar || isFunctionDecl) {
          boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);
           Node grandparent = parent.getParent();
          Node value = v.getInitialValue() != null ?
              v.getInitialValue() :
               null;
          Node varNode = null;
 
           String name = n.getString();
           int nameCount = scopedAliasNames.count(name);

 
                                if (isFunctionDecl) {
                         Node existingName = v.getNameNode();
 
                          
                                                   Node newName = IR.name("""").useSourceInfoFrom(existingName);
            value.replaceChild(existingName, newName);
 
            varNode = IR.var(existingName).useSourceInfoFrom(existingName);
            grandparent.replaceChild(parent, varNode);
          } else {
            if (value != null) {
                                            value.detachFromParent();
            }
            varNode = parent;
          }
 
                      
             NodeUtil.setDebugInformation(
                 newDecl.getFirstChild().getFirstChild(), n, name);
 
            if (isHoisted) {
              grandparent.addChildToFront(newDecl);
            } else {
               grandparent.addChildBefore(newDecl, varNode);
            }
           }
 

       return null;
     }
     Node n = first;
    if (n == null) {
      throw new RuntimeException(""node is not a child"");
    }
 
     while (n.next != child) {
       n = n.next;
"
144,"junit.framework.ComparisonFailure","/src/com/google/javascript/jscomp/DisambiguateProperties.java","@@ -492,6 +492,9 @@ private void handleObjectLit(NodeTraversal t, Node n) {
           child != null;
           child = child.getNext()) {
         // Maybe STRING, GET, SET
 
         // We should never see a mix of numbers and strings.
         String name = child.getString();
","@@ -492,6 +492,9 @@ private void handleObjectLit(NodeTraversal t, Node n) {
           child != null;
           child = child.getNext()) {
         // Maybe STRING, GET, SET
      if (child.isQuotedString()) {
        continue;
      }
 
         // We should never see a mix of numbers and strings.
         String name = child.getString();
","
           child != null;
           child = child.getNext()) {
          
                  String name = child.getString();
","
           child != null;
           child = child.getNext()) {
                 if (child.isQuotedString()) {
          continue;
        }
 
                  String name = child.getString();
"
145,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java","@@ -428,6 +428,9 @@ boolean isAssignedOnceInLifetime() {
       for (BasicBlock block = ref.getBasicBlock();
            block != null; block = block.getParent()) {
         if (block.isFunction) {
           break;
         } else if (block.isLoop) {
           return false;
","@@ -428,6 +428,9 @@ boolean isAssignedOnceInLifetime() {
       for (BasicBlock block = ref.getBasicBlock();
            block != null; block = block.getParent()) {
         if (block.isFunction) {
        if (ref.getSymbol().getScope() != ref.scope) {
          return false;
        }
           break;
         } else if (block.isLoop) {
           return false;
","
       for (BasicBlock block = ref.getBasicBlock();
            block != null; block = block.getParent()) {
         if (block.isFunction) {
           break;
         } else if (block.isLoop) {
           return false;
","
       for (BasicBlock block = ref.getBasicBlock();
            block != null; block = block.getParent()) {
         if (block.isFunction) {
          if (ref.getSymbol().getScope() != ref.scope) {
            return false;
          }
           break;
         } else if (block.isLoop) {
           return false;
"
146,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/GlobalNamespace.java","@@ -363,6 +363,7 @@ public void collect(JSModule module, Scope scope, Node n) {
                 isSet = true;
                 type = Name.Type.FUNCTION;
                 break;
               case Token.INC:
               case Token.DEC:
                 isSet = true;
","@@ -363,6 +363,7 @@ public void collect(JSModule module, Scope scope, Node n) {
                 isSet = true;
                 type = Name.Type.FUNCTION;
                 break;
            case Token.CATCH:
               case Token.INC:
               case Token.DEC:
                 isSet = true;
","
                 isSet = true;
                 type = Name.Type.FUNCTION;
                 break;
               case Token.INC:
               case Token.DEC:
                 isSet = true;
","
                 isSet = true;
                 type = Name.Type.FUNCTION;
                 break;
              case Token.CATCH:
               case Token.INC:
               case Token.DEC:
                 isSet = true;
"
147,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/InlineVariables.java","@@ -301,10 +301,12 @@ private void inlineNonConstants(
       if (!maybeModifiedArguments &&
           !staleVars.contains(v) &&
           referenceInfo.isWellDefined() &&
        referenceInfo.isAssignedOnceInLifetime()) {
           // Inlining the variable based solely on well-defined and assigned
           // once is *NOT* correct. We relax the correctness requirement if
           // the variable is declared constant.
         List<Reference> refs = referenceInfo.references;
         for (int i = 1 /* start from a read */; i < refs.size(); i++) {
           Node nameNode = refs.get(i).getNode();
","@@ -301,10 +301,12 @@ private void inlineNonConstants(
       if (!maybeModifiedArguments &&
           !staleVars.contains(v) &&
           referenceInfo.isWellDefined() &&
        referenceInfo.isAssignedOnceInLifetime() &&
           // Inlining the variable based solely on well-defined and assigned
           // once is *NOT* correct. We relax the correctness requirement if
           // the variable is declared constant.
        (isInlineableDeclaredConstant(v, referenceInfo) ||
         referenceInfo.isOnlyAssignmentSameScopeAsDeclaration())) {
         List<Reference> refs = referenceInfo.references;
         for (int i = 1 /* start from a read */; i < refs.size(); i++) {
           Node nameNode = refs.get(i).getNode();
","
       if (!maybeModifiedArguments &&
           !staleVars.contains(v) &&
           referenceInfo.isWellDefined() &&
          referenceInfo.isAssignedOnceInLifetime()) {
                                          List<Reference> refs = referenceInfo.references;
         for (int i = 1 ; i < refs.size(); i++) {
           Node nameNode = refs.get(i).getNode();
","
       if (!maybeModifiedArguments &&
           !staleVars.contains(v) &&
           referenceInfo.isWellDefined() &&
          referenceInfo.isAssignedOnceInLifetime() &&
                                           (isInlineableDeclaredConstant(v, referenceInfo) ||
           referenceInfo.isOnlyAssignmentSameScopeAsDeclaration())) {
         List<Reference> refs = referenceInfo.references;
         for (int i = 1 ; i < refs.size(); i++) {
           Node nameNode = refs.get(i).getNode();
"
148,"junit.framework.ComparisonFailure","/src/com/google/javascript/jscomp/CodeGenerator.java","@@ -282,7 +282,7 @@ void add(Node n, Context context) {
       case Token.HOOK: {
         Preconditions.checkState(childCount == 3);
         int p = NodeUtil.precedence(type);
      Context rhsContext = Context.OTHER;
         addExpr(first, p + 1, context);
         cc.addOp(""?"", true);
         addExpr(first.getNext(), 1, rhsContext);
","@@ -282,7 +282,7 @@ void add(Node n, Context context) {
       case Token.HOOK: {
         Preconditions.checkState(childCount == 3);
         int p = NodeUtil.precedence(type);
      Context rhsContext = getContextForNoInOperator(context);
         addExpr(first, p + 1, context);
         cc.addOp(""?"", true);
         addExpr(first.getNext(), 1, rhsContext);
","
       case Token.HOOK: {
         Preconditions.checkState(childCount == 3);
         int p = NodeUtil.precedence(type);
        Context rhsContext = Context.OTHER;
         addExpr(first, p + 1, context);
         cc.addOp(""?"", true);
         addExpr(first.getNext(), 1, rhsContext);
","
       case Token.HOOK: {
         Preconditions.checkState(childCount == 3);
         int p = NodeUtil.precedence(type);
        Context rhsContext = getContextForNoInOperator(context);
         addExpr(first, p + 1, context);
         cc.addOp(""?"", true);
         addExpr(first.getNext(), 1, rhsContext);
"
149,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/parsing/IRFactory.java","@@ -249,7 +249,8 @@ private Node transformBlock(AstNode node) {
    * Check to see if the given block comment looks like it should be JSDoc.
    */
   private void handleBlockComment(Comment comment) {
  if (comment.getValue().indexOf(""/* @"") != -1 || comment.getValue().indexOf(""\n * @"") != -1) {
       errorReporter.warning(
           SUSPICIOUS_COMMENT_WARNING,
           sourceName,
","@@ -249,7 +249,8 @@ private Node transformBlock(AstNode node) {
    * Check to see if the given block comment looks like it should be JSDoc.
    */
   private void handleBlockComment(Comment comment) {
  Pattern p = Pattern.compile(""(/|(\n[ \t]*))\\*[ \t]*@[a-zA-Z]"");
  if (p.matcher(comment.getValue()).find()) {
       errorReporter.warning(
           SUSPICIOUS_COMMENT_WARNING,
           sourceName,
","
    if (comment.getValue().indexOf(""/* @"") != -1 || comment.getValue().indexOf(""\n * @"") != -1) {
       errorReporter.warning(
           SUSPICIOUS_COMMENT_WARNING,
           sourceName,
","
 
   private void handleBlockComment(Comment comment) {
    Pattern p = Pattern.compile(""(/|(\n[ \t]*))\\*[ \t]*@[a-zA-Z]"");
    if (p.matcher(comment.getValue()).find()) {
       errorReporter.warning(
           SUSPICIOUS_COMMENT_WARNING,
           sourceName,
"
150,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/MinimizeExitPoints.java","@@ -138,10 +138,6 @@ void tryMinimizeExits(Node n, int exitType, String labelName) {
        * can cause problems if it changes the completion type of the finally
        * block. See ECMA 262 Sections 8.9 & 12.14
        */
    if (NodeUtil.hasFinally(n)) {
      Node finallyBlock = n.getLastChild();
      tryMinimizeExits(finallyBlock, exitType, labelName);
    }
     }
 
     // Just a 'label'.
","@@ -138,10 +138,6 @@ void tryMinimizeExits(Node n, int exitType, String labelName) {
        * can cause problems if it changes the completion type of the finally
        * block. See ECMA 262 Sections 8.9 & 12.14
        */
     }
 
     // Just a 'label'.
","
        Node finallyBlock = n.getLastChild();
        tryMinimizeExits(finallyBlock, exitType, labelName);
      }
     }
 
     ","
     }
 
     "
151,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/ExploitAssigns.java","@@ -210,7 +210,9 @@ private boolean isSafeReplacement(Node node, Node replacement) {
     }
     Preconditions.checkArgument(node.isGetProp());
 
       node = node.getFirstChild();
     if (node.isName()
         && isNameAssignedTo(node.getString(), replacement)) {
       return false;
","@@ -210,7 +210,9 @@ private boolean isSafeReplacement(Node node, Node replacement) {
     }
     Preconditions.checkArgument(node.isGetProp());
 
  while (node.isGetProp()) {
       node = node.getFirstChild();
  }
     if (node.isName()
         && isNameAssignedTo(node.getString(), replacement)) {
       return false;
","
     }
     Preconditions.checkArgument(node.isGetProp());
 
       node = node.getFirstChild();
     if (node.isName()
         && isNameAssignedTo(node.getString(), replacement)) {
       return false;
","
     }
     Preconditions.checkArgument(node.isGetProp());
 
    while (node.isGetProp()) {
       node = node.getFirstChild();
    }
     if (node.isName()
         && isNameAssignedTo(node.getString(), replacement)) {
       return false;
"
152,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/UnreachableCodeElimination.java","@@ -167,13 +167,22 @@ private void tryRemoveUnconditionalBranching(Node n) {
                 outEdges.get(0).getValue() == Branch.UNCOND);
             Node fallThrough = computeFollowing(n);
             Node nextCfgNode = outEdges.get(0).getDestination().getValue();
          if (nextCfgNode == fallThrough) {
               removeNode(n);
             }
           }
       }
     }
 
 
     private Node computeFollowing(Node n) {
       Node next = ControlFlowAnalysis.computeFollowNode(n);
","@@ -167,13 +167,22 @@ private void tryRemoveUnconditionalBranching(Node n) {
                 outEdges.get(0).getValue() == Branch.UNCOND);
             Node fallThrough = computeFollowing(n);
             Node nextCfgNode = outEdges.get(0).getDestination().getValue();
          if (nextCfgNode == fallThrough && !inFinally(n.getParent(), n)) {
               removeNode(n);
             }
           }
       }
     }
 
  private boolean inFinally(Node parent, Node child) {
    if (parent == null || parent.isFunction()) {
      return false;
    } else if (NodeUtil.isTryFinallyNode(parent, child)) {
      return true;
    } else {
      return inFinally(parent.getParent(), parent);
    }
  }
 
     private Node computeFollowing(Node n) {
       Node next = ControlFlowAnalysis.computeFollowNode(n);
","
                 outEdges.get(0).getValue() == Branch.UNCOND);
             Node fallThrough = computeFollowing(n);
             Node nextCfgNode = outEdges.get(0).getDestination().getValue();
            if (nextCfgNode == fallThrough) {
               removeNode(n);
             }
           }
       }
     }
 
 
     private Node computeFollowing(Node n) {
       Node next = ControlFlowAnalysis.computeFollowNode(n);
","
                 outEdges.get(0).getValue() == Branch.UNCOND);
             Node fallThrough = computeFollowing(n);
             Node nextCfgNode = outEdges.get(0).getDestination().getValue();
            if (nextCfgNode == fallThrough && !inFinally(n.getParent(), n)) {
               removeNode(n);
             }
           }
       }
     }
 
    private boolean inFinally(Node parent, Node child) {
      if (parent == null || parent.isFunction()) {
        return false;
      } else if (NodeUtil.isTryFinallyNode(parent, child)) {
        return true;
      } else {
        return inFinally(parent.getParent(), parent);
      }
    }
 
     private Node computeFollowing(Node n) {
       Node next = ControlFlowAnalysis.computeFollowNode(n);
"
153,"java.lang.IllegalStateException","/src/com/google/javascript/jscomp/TypeCheck.java","@@ -1658,7 +1658,7 @@ private void visitNew(NodeTraversal t, Node n) {
     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();
     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {
       FunctionType fnType = type.toMaybeFunctionType();
    if (fnType != null) {
         visitParameterList(t, n, fnType);
         ensureTyped(t, n, fnType.getInstanceType());
       } else {
","@@ -1658,7 +1658,7 @@ private void visitNew(NodeTraversal t, Node n) {
     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();
     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {
       FunctionType fnType = type.toMaybeFunctionType();
    if (fnType != null && fnType.hasInstanceType()) {
         visitParameterList(t, n, fnType);
         ensureTyped(t, n, fnType.getInstanceType());
       } else {
","
     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();
     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {
       FunctionType fnType = type.toMaybeFunctionType();
      if (fnType != null) {
         visitParameterList(t, n, fnType);
         ensureTyped(t, n, fnType.getInstanceType());
       } else {
","
     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();
     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {
       FunctionType fnType = type.toMaybeFunctionType();
      if (fnType != null && fnType.hasInstanceType()) {
         visitParameterList(t, n, fnType);
         ensureTyped(t, n, fnType.getInstanceType());
       } else {
"
154,"junit.framework.ComparisonFailure","/src/com/google/javascript/jscomp/CodeGenerator.java","@@ -782,13 +782,16 @@ private void unrollBinaryOperator(
 
   static boolean isSimpleNumber(String s) {
     int len = s.length();
     for (int index = 0; index < len; index++) {
       char c = s.charAt(index);
       if (c < '0' || c > '9') {
         return false;
       }
     }
  return len > 0 && s.charAt(0) != '0';
   }
 
   static double getSimpleNumber(String s) {
","@@ -782,13 +782,16 @@ private void unrollBinaryOperator(
 
   static boolean isSimpleNumber(String s) {
     int len = s.length();
  if (len == 0) {
    return false;
  }
     for (int index = 0; index < len; index++) {
       char c = s.charAt(index);
       if (c < '0' || c > '9') {
         return false;
       }
     }
  return len == 1 || s.charAt(0) != '0';
   }
 
   static double getSimpleNumber(String s) {
","
 
   static boolean isSimpleNumber(String s) {
     int len = s.length();
     for (int index = 0; index < len; index++) {
       char c = s.charAt(index);
       if (c < '0' || c > '9') {
         return false;
       }
     }
    return len > 0 && s.charAt(0) != '0';
   }
 
   static double getSimpleNumber(String s) {
","
 
   static boolean isSimpleNumber(String s) {
     int len = s.length();
    if (len == 0) {
      return false;
    }
     for (int index = 0; index < len; index++) {
       char c = s.charAt(index);
       if (c < '0' || c > '9') {
         return false;
       }
     }
    return len == 1 || s.charAt(0) != '0';
   }
 
   static double getSimpleNumber(String s) {
"
155,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/math/NumberUtils.java","@@ -590,18 +590,22 @@ public static Number createNumber(final String str) throws NumberFormatException
         //Must be a Float, Double, BigDecimal
         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
         try {
                 final Float f = createFloat(str);
                 if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                     return f;
                 }
         } catch (final NumberFormatException nfe) { // NOPMD
             // ignore the bad number
         }
         try {
                 final Double d = createDouble(str);
                 if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                     return d;
                 }
         } catch (final NumberFormatException nfe) { // NOPMD
             // ignore the bad number
         }
","@@ -590,18 +590,22 @@ public static Number createNumber(final String str) throws NumberFormatException
         //Must be a Float, Double, BigDecimal
         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
         try {
          if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float
                 final Float f = createFloat(str);
                 if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                     return f;
                 }
          }
         } catch (final NumberFormatException nfe) { // NOPMD
             // ignore the bad number
         }
         try {
          if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double
                 final Double d = createDouble(str);
                 if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                     return d;
                 }
          }
         } catch (final NumberFormatException nfe) { // NOPMD
             // ignore the bad number
         }
","
                  final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
         try {
                 final Float f = createFloat(str);
                 if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                     return f;
                 }
         } catch (final NumberFormatException nfe) {                       }
         try {
                 final Double d = createDouble(str);
                 if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                     return d;
                 }
         } catch (final NumberFormatException nfe) {                       }
","
                  final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);
         try {
            if(numDecimals <= 7){                 final Float f = createFloat(str);
                 if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {
                     return f;
                 }
            }
         } catch (final NumberFormatException nfe) {                       }
         try {
            if(numDecimals <= 16){                 final Double d = createDouble(str);
                 if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {
                     return d;
                 }
            }
         } catch (final NumberFormatException nfe) {                       }
"
156,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/LocaleUtils.java","@@ -89,6 +89,9 @@ public static Locale toLocale(final String str) {
         if (str == null) {
             return null;
         }
         final int len = str.length();
         if (len < 2) {
             throw new IllegalArgumentException(""Invalid locale format: "" + str);
","@@ -89,6 +89,9 @@ public static Locale toLocale(final String str) {
         if (str == null) {
             return null;
         }
      if (str.contains(""#"")) { // LANG-879 - Cannot handle Java 7 script & extensions
          throw new IllegalArgumentException(""Invalid locale format: "" + str);
      }
         final int len = str.length();
         if (len < 2) {
             throw new IllegalArgumentException(""Invalid locale format: "" + str);
","
         if (str == null) {
             return null;
         }
         final int len = str.length();
         if (len < 2) {
             throw new IllegalArgumentException(""Invalid locale format: "" + str);
","
         if (str == null) {
             return null;
         }
        if (str.contains(""#"")) {             throw new IllegalArgumentException(""Invalid locale format: "" + str);
        }
         final int len = str.length();
         if (len < 2) {
             throw new IllegalArgumentException(""Invalid locale format: "" + str);
"
157,"java.lang.IllegalArgumentException","/src/main/java/org/apache/commons/lang3/LocaleUtils.java","@@ -94,6 +94,26 @@ public static Locale toLocale(final String str) {
             throw new IllegalArgumentException(""Invalid locale format: "" + str);
         }
         final char ch0 = str.charAt(0);
             final char ch1 = str.charAt(1);
             if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
@@ -125,6 +145,7 @@ public static Locale toLocale(final String str) {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
             }
             return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
     }
 
     //-----------------------------------------------------------------------
","@@ -94,6 +94,26 @@ public static Locale toLocale(final String str) {
             throw new IllegalArgumentException(""Invalid locale format: "" + str);
         }
         final char ch0 = str.charAt(0);
      if (ch0 == '_') {
          if (len < 3) {
              throw new IllegalArgumentException(""Invalid locale format: "" + str);
          }
          final char ch1 = str.charAt(1);
          final char ch2 = str.charAt(2);
          if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {
              throw new IllegalArgumentException(""Invalid locale format: "" + str);
          }
          if (len == 3) {
              return new Locale("""", str.substring(1, 3));
          }
          if (len < 5) {
              throw new IllegalArgumentException(""Invalid locale format: "" + str);
          }
          if (str.charAt(3) != '_') {
              throw new IllegalArgumentException(""Invalid locale format: "" + str);
          }
          return new Locale("""", str.substring(1, 3), str.substring(4));
      } else {
             final char ch1 = str.charAt(1);
             if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
@@ -125,6 +145,7 @@ public static Locale toLocale(final String str) {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
             }
             return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
      }
     }
 
     //-----------------------------------------------------------------------
","
             throw new IllegalArgumentException(""Invalid locale format: "" + str);
         }
         final char ch0 = str.charAt(0);
             final char ch1 = str.charAt(1);
             if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);

                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
             }
             return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
     }
 
     ","
             throw new IllegalArgumentException(""Invalid locale format: "" + str);
         }
         final char ch0 = str.charAt(0);
        if (ch0 == '_') {
            if (len < 3) {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            final char ch1 = str.charAt(1);
            final char ch2 = str.charAt(2);
            if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (len == 3) {
                return new Locale("""", str.substring(1, 3));
            }
            if (len < 5) {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            if (str.charAt(3) != '_') {
                throw new IllegalArgumentException(""Invalid locale format: "" + str);
            }
            return new Locale("""", str.substring(1, 3), str.substring(4));
        } else {
             final char ch1 = str.charAt(1);
             if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);

                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
             }
             return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
        }
     }
 
     "
158,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/CollapseProperties.java","@@ -169,7 +169,7 @@ private void inlineAliases(GlobalNamespace namespace) {
         continue;
       }
 
    if (name.globalSets == 1 && name.localSets == 0 &&
           name.aliasingGets > 0) {
         // {@code name} meets condition (b). Find all of its local aliases
         // and try to inline them.
","@@ -169,7 +169,7 @@ private void inlineAliases(GlobalNamespace namespace) {
         continue;
       }
 
    if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 &&
           name.aliasingGets > 0) {
         // {@code name} meets condition (b). Find all of its local aliases
         // and try to inline them.
","
         continue;
       }
 
      if (name.globalSets == 1 && name.localSets == 0 &&
           name.aliasingGets > 0) {
                  ","
         continue;
       }
 
      if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 &&
           name.aliasingGets > 0) {
                  "
159,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/text/translate/LookupTranslator.java","@@ -28,7 +28,7 @@
  */
 public class LookupTranslator extends CharSequenceTranslator {
 
  private final HashMap<CharSequence, CharSequence> lookupMap;
     private final int shortest;
     private final int longest;
 
@@ -43,12 +43,12 @@
      * @param lookup CharSequence[][] table of size [*][2]
      */
     public LookupTranslator(final CharSequence[]... lookup) {
      lookupMap = new HashMap<CharSequence, CharSequence>();
         int _shortest = Integer.MAX_VALUE;
         int _longest = 0;
         if (lookup != null) {
             for (final CharSequence[] seq : lookup) {
              this.lookupMap.put(seq[0], seq[1]);
                 final int sz = seq[0].length();
                 if (sz < _shortest) {
                     _shortest = sz;
@@ -74,7 +74,7 @@ public int translate(final CharSequence input, final int index, final Writer out
         // descend so as to get a greedy algorithm
         for (int i = max; i >= shortest; i--) {
             final CharSequence subSeq = input.subSequence(index, index + i);
          final CharSequence result = lookupMap.get(subSeq);
             if (result != null) {
                 out.write(result.toString());
                 return i;
","@@ -28,7 +28,7 @@
  */
 public class LookupTranslator extends CharSequenceTranslator {
 
  private final HashMap<String, CharSequence> lookupMap;
     private final int shortest;
     private final int longest;
 
@@ -43,12 +43,12 @@
      * @param lookup CharSequence[][] table of size [*][2]
      */
     public LookupTranslator(final CharSequence[]... lookup) {
      lookupMap = new HashMap<String, CharSequence>();
         int _shortest = Integer.MAX_VALUE;
         int _longest = 0;
         if (lookup != null) {
             for (final CharSequence[] seq : lookup) {
              this.lookupMap.put(seq[0].toString(), seq[1]);
                 final int sz = seq[0].length();
                 if (sz < _shortest) {
                     _shortest = sz;
@@ -74,7 +74,7 @@ public int translate(final CharSequence input, final int index, final Writer out
         // descend so as to get a greedy algorithm
         for (int i = max; i >= shortest; i--) {
             final CharSequence subSeq = input.subSequence(index, index + i);
          final CharSequence result = lookupMap.get(subSeq.toString());
             if (result != null) {
                 out.write(result.toString());
                 return i;
","
 public class LookupTranslator extends CharSequenceTranslator {
 
    private final HashMap<CharSequence, CharSequence> lookupMap;
     private final int shortest;
     private final int longest;
 

     public LookupTranslator(final CharSequence[]... lookup) {
        lookupMap = new HashMap<CharSequence, CharSequence>();
         int _shortest = Integer.MAX_VALUE;
         int _longest = 0;
         if (lookup != null) {
             for (final CharSequence[] seq : lookup) {
                this.lookupMap.put(seq[0], seq[1]);
                 final int sz = seq[0].length();
                 if (sz < _shortest) {
                     _shortest = sz;

                  for (int i = max; i >= shortest; i--) {
             final CharSequence subSeq = input.subSequence(index, index + i);
            final CharSequence result = lookupMap.get(subSeq);
             if (result != null) {
                 out.write(result.toString());
                 return i;
","
 public class LookupTranslator extends CharSequenceTranslator {
 
    private final HashMap<String, CharSequence> lookupMap;
     private final int shortest;
     private final int longest;
 

     public LookupTranslator(final CharSequence[]... lookup) {
        lookupMap = new HashMap<String, CharSequence>();
         int _shortest = Integer.MAX_VALUE;
         int _longest = 0;
         if (lookup != null) {
             for (final CharSequence[] seq : lookup) {
                this.lookupMap.put(seq[0].toString(), seq[1]);
                 final int sz = seq[0].length();
                 if (sz < _shortest) {
                     _shortest = sz;

                  for (int i = max; i >= shortest; i--) {
             final CharSequence subSeq = input.subSequence(index, index + i);
            final CharSequence result = lookupMap.get(subSeq.toString());
             if (result != null) {
                 out.write(result.toString());
                 return i;
"
160,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/PrepareAst.java","@@ -163,6 +163,9 @@ private void annotateCalls(Node n) {
       Node first = n.getFirstChild();
 
       // ignore cast nodes.
 
       if (!NodeUtil.isGet(first)) {
         n.putBooleanProp(Node.FREE_CALL, true);
","@@ -163,6 +163,9 @@ private void annotateCalls(Node n) {
       Node first = n.getFirstChild();
 
       // ignore cast nodes.
    while (first.isCast()) {
      first = first.getFirstChild();
    }
 
       if (!NodeUtil.isGet(first)) {
         n.putBooleanProp(Node.FREE_CALL, true);
","
       Node first = n.getFirstChild();
 
        
       if (!NodeUtil.isGet(first)) {
         n.putBooleanProp(Node.FREE_CALL, true);
","
       Node first = n.getFirstChild();
 
             while (first.isCast()) {
        first = first.getFirstChild();
      }
 
       if (!NodeUtil.isGet(first)) {
         n.putBooleanProp(Node.FREE_CALL, true);
"
161,"java.lang.NumberFormatException","/src/main/java/org/apache/commons/lang3/math/NumberUtils.java","@@ -464,11 +464,20 @@ public static Number createNumber(final String str) throws NumberFormatException
             }
         }
         if (pfxLen > 0) { // we have a hex number
             final int hexDigits = str.length() - pfxLen;
          if (hexDigits > 16) { // too many for Long
                 return createBigInteger(str);
             }
          if (hexDigits > 8) { // too many for an int
                 return createLong(str);
             }
             return createInteger(str);
","@@ -464,11 +464,20 @@ public static Number createNumber(final String str) throws NumberFormatException
             }
         }
         if (pfxLen > 0) { // we have a hex number
          char firstSigDigit = 0; // strip leading zeroes
          for(int i = pfxLen; i < str.length(); i++) {
              firstSigDigit = str.charAt(i);
              if (firstSigDigit == '0') { // count leading zeroes
                  pfxLen++;
              } else {
                  break;
              }
          }
             final int hexDigits = str.length() - pfxLen;
          if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { // too many for Long
                 return createBigInteger(str);
             }
          if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { // too many for an int
                 return createLong(str);
             }
             return createInteger(str);
","
             }
         }
         if (pfxLen > 0) {              final int hexDigits = str.length() - pfxLen;
            if (hexDigits > 16) {                  return createBigInteger(str);
             }
            if (hexDigits > 8) {                  return createLong(str);
             }
             return createInteger(str);
","
             }
         }
         if (pfxLen > 0) {             char firstSigDigit = 0;             for(int i = pfxLen; i < str.length(); i++) {
                firstSigDigit = str.charAt(i);
                if (firstSigDigit == '0') {                     pfxLen++;
                } else {
                    break;
                }
            }
             final int hexDigits = str.length() - pfxLen;
            if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) {                  return createBigInteger(str);
             }
            if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) {                  return createLong(str);
             }
             return createInteger(str);
"
162,"junit.framework.AssertionFailedError","/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java","@@ -779,7 +779,9 @@ private Node tryMinimizeIf(Node n) {
               // evaluates LHS before cond]
               // NOTE - there are some circumstances where we can
               // proceed even if there are side effects...
            !mayEffectMutableState(lhs)) {
 
             n.removeChild(cond);
             Node assignName = thenOp.removeFirstChild();
","@@ -779,7 +779,9 @@ private Node tryMinimizeIf(Node n) {
               // evaluates LHS before cond]
               // NOTE - there are some circumstances where we can
               // proceed even if there are side effects...
            !mayEffectMutableState(lhs) &&
            (!mayHaveSideEffects(cond) ||
                (thenOp.isAssign() && thenOp.getFirstChild().isName()))) {
 
             n.removeChild(cond);
             Node assignName = thenOp.removeFirstChild();
","
                                                           !mayEffectMutableState(lhs)) {
 
             n.removeChild(cond);
             Node assignName = thenOp.removeFirstChild();
","
                                                           !mayEffectMutableState(lhs) &&
              (!mayHaveSideEffects(cond) ||
                  (thenOp.isAssign() && thenOp.getFirstChild().isName()))) {
 
             n.removeChild(cond);
             Node assignName = thenOp.removeFirstChild();
"
163,"java.lang.StringIndexOutOfBoundsException","/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java","@@ -92,7 +92,7 @@ public final void translate(CharSequence input, Writer out) throws IOException {
 //          // contract with translators is that they have to understand codepoints 
 //          // and they just took care of a surrogate pair
             for (int pt = 0; pt < consumed; pt++) {
              pos += Character.charCount(Character.codePointAt(input, pos));
             }
         }
     }
","@@ -92,7 +92,7 @@ public final void translate(CharSequence input, Writer out) throws IOException {
 //          // contract with translators is that they have to understand codepoints 
 //          // and they just took care of a surrogate pair
             for (int pt = 0; pt < consumed; pt++) {
              pos += Character.charCount(Character.codePointAt(input, pt));
             }
         }
     }
","
               for (int pt = 0; pt < consumed; pt++) {
                pos += Character.charCount(Character.codePointAt(input, pos));
             }
         }
     }
","
               for (int pt = 0; pt < consumed; pt++) {
                pos += Character.charCount(Character.codePointAt(input, pt));
             }
         }
     }
"
164,"java.lang.IllegalStateException","/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java","@@ -2398,6 +2398,7 @@ private void skipEOLs() {
    */
   private String getRemainingJSDocLine() {
     String result = stream.getRemainingJSDocLine();
     return result;
   }
 
","@@ -2398,6 +2398,7 @@ private void skipEOLs() {
    */
   private String getRemainingJSDocLine() {
     String result = stream.getRemainingJSDocLine();
  unreadToken = NO_UNREAD_TOKEN;
     return result;
   }
 
","
   private String getRemainingJSDocLine() {
     String result = stream.getRemainingJSDocLine();
     return result;
   }
 
","
   private String getRemainingJSDocLine() {
     String result = stream.getRemainingJSDocLine();
    unreadToken = NO_UNREAD_TOKEN;
     return result;
   }
 
"
165,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/math/NumberUtils.java","@@ -449,9 +449,6 @@ public static Number createNumber(String str) throws NumberFormatException {
         if (StringUtils.isBlank(str)) {
             throw new NumberFormatException(""A blank string is not a valid number"");
         }  
      if (str.startsWith(""--"")) {
          return null;
      }
         if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) {
             int hexDigits = str.length() - 2; // drop 0x
             if (str.startsWith(""-"")) { // drop -
@@ -718,10 +715,13 @@ public static BigDecimal createBigDecimal(String str) {
         if (StringUtils.isBlank(str)) {
             throw new NumberFormatException(""A blank string is not a valid number"");
         }
             // this is protection for poorness in java.lang.BigDecimal.
             // it accepts this as a legal value, but it does not appear 
             // to be in specification of class. OS X Java parses it to 
             // a wrong value.
         return new BigDecimal(str);
     }
 
","@@ -449,9 +449,6 @@ public static Number createNumber(String str) throws NumberFormatException {
         if (StringUtils.isBlank(str)) {
             throw new NumberFormatException(""A blank string is not a valid number"");
         }  
         if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) {
             int hexDigits = str.length() - 2; // drop 0x
             if (str.startsWith(""-"")) { // drop -
@@ -718,10 +715,13 @@ public static BigDecimal createBigDecimal(String str) {
         if (StringUtils.isBlank(str)) {
             throw new NumberFormatException(""A blank string is not a valid number"");
         }
      if (str.trim().startsWith(""--"")) {
             // this is protection for poorness in java.lang.BigDecimal.
             // it accepts this as a legal value, but it does not appear 
             // to be in specification of class. OS X Java parses it to 
             // a wrong value.
          throw new NumberFormatException(str + "" is not a valid number."");
      }
         return new BigDecimal(str);
     }
 
","
         if (StringUtils.isBlank(str)) {
             throw new NumberFormatException(""A blank string is not a valid number"");
         }  
        if (str.startsWith(""--"")) {
            return null;
        }
         if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) {
             int hexDigits = str.length() - 2;              if (str.startsWith(""-"")) { 
         if (StringUtils.isBlank(str)) {
             throw new NumberFormatException(""A blank string is not a valid number"");
         }
                                                             return new BigDecimal(str);
     }
 
","
         if (StringUtils.isBlank(str)) {
             throw new NumberFormatException(""A blank string is not a valid number"");
         }  
         if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) {
             int hexDigits = str.length() - 2;              if (str.startsWith(""-"")) { 
         if (StringUtils.isBlank(str)) {
             throw new NumberFormatException(""A blank string is not a valid number"");
         }
        if (str.trim().startsWith(""--"")) {
                                                                throw new NumberFormatException(str + "" is not a valid number."");
        }
         return new BigDecimal(str);
     }
 
"
166,"junit.framework.AssertionFailedError","/src/com/google/javascript/rhino/TokenStream.java","@@ -191,12 +191,13 @@ public static boolean isJSIdentifier(String s) {
       int length = s.length();
 
       if (length == 0 ||
           !Character.isJavaIdentifierStart(s.charAt(0))) {
         return false;
       }
 
       for (int i = 1; i < length; i++) {
      if (
             !Character.isJavaIdentifierPart(s.charAt(i))) {
           return false;
         }
","@@ -191,12 +191,13 @@ public static boolean isJSIdentifier(String s) {
       int length = s.length();
 
       if (length == 0 ||
        Character.isIdentifierIgnorable(s.charAt(0)) ||
           !Character.isJavaIdentifierStart(s.charAt(0))) {
         return false;
       }
 
       for (int i = 1; i < length; i++) {
      if (Character.isIdentifierIgnorable(s.charAt(i)) ||
             !Character.isJavaIdentifierPart(s.charAt(i))) {
           return false;
         }
","
       int length = s.length();
 
       if (length == 0 ||
           !Character.isJavaIdentifierStart(s.charAt(0))) {
         return false;
       }
 
       for (int i = 1; i < length; i++) {
        if (
             !Character.isJavaIdentifierPart(s.charAt(i))) {
           return false;
         }
","
       int length = s.length();
 
       if (length == 0 ||
          Character.isIdentifierIgnorable(s.charAt(0)) ||
           !Character.isJavaIdentifierStart(s.charAt(0))) {
         return false;
       }
 
       for (int i = 1; i < length; i++) {
        if (Character.isIdentifierIgnorable(s.charAt(i)) ||
             !Character.isJavaIdentifierPart(s.charAt(i))) {
           return false;
         }
"
167,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java","@@ -1095,7 +1095,6 @@ static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Local
     private static class TimeZoneNameRule implements Rule {
         private final Locale mLocale;
         private final int mStyle;
      private final TimeZone zone;
         private final String mStandard;
         private final String mDaylight;
 
@@ -1109,7 +1108,6 @@ static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Local
         TimeZoneNameRule(TimeZone timeZone, Locale locale, int style) {
             mLocale = locale;
             mStyle = style;
          zone = timeZone;
             
             mStandard = getTimeZoneDisplay(timeZone, false, style, locale);
             mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);
@@ -1131,6 +1129,7 @@ public int estimateLength() {
          */
         @Override
         public void appendTo(StringBuffer buffer, Calendar calendar) {
             if (zone.useDaylightTime()
                     && calendar.get(Calendar.DST_OFFSET) != 0) {
                 buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));
","@@ -1095,7 +1095,6 @@ static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Local
     private static class TimeZoneNameRule implements Rule {
         private final Locale mLocale;
         private final int mStyle;
         private final String mStandard;
         private final String mDaylight;
 
@@ -1109,7 +1108,6 @@ static String getTimeZoneDisplay(TimeZone tz, boolean daylight, int style, Local
         TimeZoneNameRule(TimeZone timeZone, Locale locale, int style) {
             mLocale = locale;
             mStyle = style;
             
             mStandard = getTimeZoneDisplay(timeZone, false, style, locale);
             mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);
@@ -1131,6 +1129,7 @@ public int estimateLength() {
          */
         @Override
         public void appendTo(StringBuffer buffer, Calendar calendar) {
          TimeZone zone = calendar.getTimeZone();
             if (zone.useDaylightTime()
                     && calendar.get(Calendar.DST_OFFSET) != 0) {
                 buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));
","
     private static class TimeZoneNameRule implements Rule {
         private final Locale mLocale;
         private final int mStyle;
        private final TimeZone zone;
         private final String mStandard;
         private final String mDaylight;
 

         TimeZoneNameRule(TimeZone timeZone, Locale locale, int style) {
             mLocale = locale;
             mStyle = style;
            zone = timeZone;
             
             mStandard = getTimeZoneDisplay(timeZone, false, style, locale);
             mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);

         @Override
         public void appendTo(StringBuffer buffer, Calendar calendar) {
             if (zone.useDaylightTime()
                     && calendar.get(Calendar.DST_OFFSET) != 0) {
                 buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));
","
     private static class TimeZoneNameRule implements Rule {
         private final Locale mLocale;
         private final int mStyle;
         private final String mStandard;
         private final String mDaylight;
 

         TimeZoneNameRule(TimeZone timeZone, Locale locale, int style) {
             mLocale = locale;
             mStyle = style;
             
             mStandard = getTimeZoneDisplay(timeZone, false, style, locale);
             mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);

         @Override
         public void appendTo(StringBuffer buffer, Calendar calendar) {
            TimeZone zone = calendar.getTimeZone();
             if (zone.useDaylightTime()
                     && calendar.get(Calendar.DST_OFFSET) != 0) {
                 buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));
"
168,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/time/FastDateParser.java","@@ -301,17 +301,8 @@ public Date parse(String source, ParsePosition pos) {
      * @return The <code>StringBuilder</code>
      */
     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {
      boolean wasWhite= false;
         for(int i= 0; i<value.length(); ++i) {
             char c= value.charAt(i);
          if(Character.isWhitespace(c)) {
              if(!wasWhite) {
                  wasWhite= true;
                  regex.append(""\\s*+"");
              }
              continue;
          }
          wasWhite= false;
             switch(c) {
             case '\'':
                 if(unquote) {
","@@ -301,17 +301,8 @@ public Date parse(String source, ParsePosition pos) {
      * @return The <code>StringBuilder</code>
      */
     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {
         for(int i= 0; i<value.length(); ++i) {
             char c= value.charAt(i);
             switch(c) {
             case '\'':
                 if(unquote) {
","
        boolean wasWhite= false;
         for(int i= 0; i<value.length(); ++i) {
             char c= value.charAt(i);
            if(Character.isWhitespace(c)) {
                if(!wasWhite) {
                    wasWhite= true;
                    regex.append(""\\s*+"");
                }
                continue;
            }
            wasWhite= false;
             switch(c) {
             case '\'':
                 if(unquote) {
","
     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {
         for(int i= 0; i<value.length(); ++i) {
             char c= value.charAt(i);
             switch(c) {
             case '\'':
                 if(unquote) {
"
169,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/RandomStringUtils.java","@@ -242,6 +242,10 @@ public static String random(int count, int start, int end, boolean letters, bool
                     start = ' ';                
                 }
             }
         }
 
         char[] buffer = new char[count];
","@@ -242,6 +242,10 @@ public static String random(int count, int start, int end, boolean letters, bool
                     start = ' ';                
                 }
             }
      } else {
          if (end <= start) {
              throw new IllegalArgumentException(""Parameter end ("" + end + "") must be greater than start ("" + start + "")"");
          }
         }
 
         char[] buffer = new char[count];
","
                     start = ' ';                
                 }
             }
         }
 
         char[] buffer = new char[count];
","
                     start = ' ';                
                 }
             }
        } else {
            if (end <= start) {
                throw new IllegalArgumentException(""Parameter end ("" + end + "") must be greater than start ("" + start + "")"");
            }
         }
 
         char[] buffer = new char[count];
"
170,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/time/FastDateParser.java","@@ -141,6 +141,9 @@ private void init() {
             currentFormatField= nextFormatField;
             currentStrategy= nextStrategy;
         }
         if(currentStrategy.addRegex(this, regex)) {
             collector.add(currentStrategy);
         }
","@@ -141,6 +141,9 @@ private void init() {
             currentFormatField= nextFormatField;
             currentStrategy= nextStrategy;
         }
      if (patternMatcher.regionStart() != patternMatcher.regionEnd()) {
          throw new IllegalArgumentException(""Failed to parse \""""+pattern+""\"" ; gave up at index ""+patternMatcher.regionStart());
      }
         if(currentStrategy.addRegex(this, regex)) {
             collector.add(currentStrategy);
         }
","
             currentFormatField= nextFormatField;
             currentStrategy= nextStrategy;
         }
         if(currentStrategy.addRegex(this, regex)) {
             collector.add(currentStrategy);
         }
","
             currentFormatField= nextFormatField;
             currentStrategy= nextStrategy;
         }
        if (patternMatcher.regionStart() != patternMatcher.regionEnd()) {
            throw new IllegalArgumentException(""Failed to parse \""""+pattern+""\"" ; gave up at index ""+patternMatcher.regionStart());
        }
         if(currentStrategy.addRegex(this, regex)) {
             collector.add(currentStrategy);
         }
"
171,"org.apache.commons.lang3.SerializationException","/src/main/java/org/apache/commons/lang3/SerializationUtils.java","@@ -217,58 +217,77 @@ public static Object deserialize(InputStream inputStream) {
     public static Object deserialize(byte[] objectData) {
         if (objectData == null) {
             throw new IllegalArgumentException(""The byte[] must not be null"");
         }
         ByteArrayInputStream bais = new ByteArrayInputStream(objectData);
         return deserialize(bais);
     }
 
     /**
      * <p>Custom specialization of the standard JDK {@link java.io.ObjectInputStream}
      * that uses a custom  <code>ClassLoader</code> to resolve a class.
      * If the specified <code>ClassLoader</code> is not able to resolve the class,
      * the context classloader of the current thread will be used.
      * This way, the standard deserialization work also in web-application
      * containers and application servers, no matter in which of the
      * <code>ClassLoader</code> the particular class that encapsulates
      * serialization/deserialization lives. </p>
      * 
      * <p>For more in-depth information about the problem for which this
      * class here is a workaround, see the JIRA issue LANG-626. </p>
      */
      static class ClassLoaderAwareObjectInputStream extends ObjectInputStream {
         private ClassLoader classLoader;
         
         /**
          * Constructor.
          * @param in The <code>InputStream</code>.
          * @param classLoader classloader to use
          * @throws IOException if an I/O error occurs while reading stream header.
          * @see java.io.ObjectInputStream
          */
         public ClassLoaderAwareObjectInputStream(InputStream in, ClassLoader classLoader) throws IOException {
             super(in);
             this.classLoader = classLoader;
 
         }
 
         /**
          * Overriden version that uses the parametrized <code>ClassLoader</code> or the <code>ClassLoader</code>
          * of the current <code>Thread</code> to resolve the class.
          * @param desc An instance of class <code>ObjectStreamClass</code>.
          * @return A <code>Class</code> object corresponding to <code>desc</code>.
          * @throws IOException Any of the usual Input/Output exceptions.
          * @throws ClassNotFoundException If class of a serialized object cannot be found.
          */
         @Override
         protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
             String name = desc.getName();
             try {
                 return Class.forName(name, false, classLoader);
             } catch (ClassNotFoundException ex) {
                     return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
             }
         }
 
     }
 
 }
","@@ -217,58 +217,77 @@ public static Object deserialize(InputStream inputStream) {
     public static Object deserialize(byte[] objectData) {
         if (objectData == null) {
             throw new IllegalArgumentException(""The byte[] must not be null"");
         }
         ByteArrayInputStream bais = new ByteArrayInputStream(objectData);
         return deserialize(bais);
     }
 
     /**
      * <p>Custom specialization of the standard JDK {@link java.io.ObjectInputStream}
      * that uses a custom  <code>ClassLoader</code> to resolve a class.
      * If the specified <code>ClassLoader</code> is not able to resolve the class,
      * the context classloader of the current thread will be used.
      * This way, the standard deserialization work also in web-application
      * containers and application servers, no matter in which of the
      * <code>ClassLoader</code> the particular class that encapsulates
      * serialization/deserialization lives. </p>
      * 
      * <p>For more in-depth information about the problem for which this
      * class here is a workaround, see the JIRA issue LANG-626. </p>
      */
      static class ClassLoaderAwareObjectInputStream extends ObjectInputStream {
      private static final Map<String, Class<?>> primitiveTypes = 
              new HashMap<String, Class<?>>();
         private ClassLoader classLoader;
         
         /**
          * Constructor.
          * @param in The <code>InputStream</code>.
          * @param classLoader classloader to use
          * @throws IOException if an I/O error occurs while reading stream header.
          * @see java.io.ObjectInputStream
          */
         public ClassLoaderAwareObjectInputStream(InputStream in, ClassLoader classLoader) throws IOException {
             super(in);
             this.classLoader = classLoader;
 
          primitiveTypes.put(""byte"", byte.class);
          primitiveTypes.put(""short"", short.class);
          primitiveTypes.put(""int"", int.class);
          primitiveTypes.put(""long"", long.class);
          primitiveTypes.put(""float"", float.class);
          primitiveTypes.put(""double"", double.class);
          primitiveTypes.put(""boolean"", boolean.class);
          primitiveTypes.put(""char"", char.class);
          primitiveTypes.put(""void"", void.class);
         }
 
         /**
          * Overriden version that uses the parametrized <code>ClassLoader</code> or the <code>ClassLoader</code>
          * of the current <code>Thread</code> to resolve the class.
          * @param desc An instance of class <code>ObjectStreamClass</code>.
          * @return A <code>Class</code> object corresponding to <code>desc</code>.
          * @throws IOException Any of the usual Input/Output exceptions.
          * @throws ClassNotFoundException If class of a serialized object cannot be found.
          */
         @Override
         protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
             String name = desc.getName();
             try {
                 return Class.forName(name, false, classLoader);
             } catch (ClassNotFoundException ex) {
              try {
                     return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
              } catch (ClassNotFoundException cnfe) {
                  Class<?> cls = primitiveTypes.get(name);
                  if (cls != null)
                      return cls;
                  else
                      throw cnfe;
              }
             }
         }
 
     }
 
 }
","
     public static Object deserialize(byte[] objectData) {
         if (objectData == null) {
             throw new IllegalArgumentException(""The byte[] must not be null"");
         }
         ByteArrayInputStream bais = new ByteArrayInputStream(objectData);
         return deserialize(bais);
     }
       static class ClassLoaderAwareObjectInputStream extends ObjectInputStream {
         private ClassLoader classLoader;         public ClassLoaderAwareObjectInputStream(InputStream in, ClassLoader classLoader) throws IOException {
             super(in);
             this.classLoader = classLoader;
 
         }         @Override
         protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
             String name = desc.getName();
             try {
                 return Class.forName(name, false, classLoader);
             } catch (ClassNotFoundException ex) {
                     return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
             }
         }
 
     }
 
 }
","
     public static Object deserialize(byte[] objectData) {
         if (objectData == null) {
             throw new IllegalArgumentException(""The byte[] must not be null"");
         }
         ByteArrayInputStream bais = new ByteArrayInputStream(objectData);
         return deserialize(bais);
     }      static class ClassLoaderAwareObjectInputStream extends ObjectInputStream {
        private static final Map<String, Class<?>> primitiveTypes = 
                new HashMap<String, Class<?>>();
         private ClassLoader classLoader;
         public ClassLoaderAwareObjectInputStream(InputStream in, ClassLoader classLoader) throws IOException {
             super(in);
             this.classLoader = classLoader;
 
            primitiveTypes.put(""byte"", byte.class);
            primitiveTypes.put(""short"", short.class);
            primitiveTypes.put(""int"", int.class);
            primitiveTypes.put(""long"", long.class);
            primitiveTypes.put(""float"", float.class);
            primitiveTypes.put(""double"", double.class);
            primitiveTypes.put(""boolean"", boolean.class);
            primitiveTypes.put(""char"", char.class);
            primitiveTypes.put(""void"", void.class);
         }
 
         @Override
         protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
             String name = desc.getName();
             try {
                 return Class.forName(name, false, classLoader);
             } catch (ClassNotFoundException ex) {
                try {
                     return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
                } catch (ClassNotFoundException cnfe) {
                    Class<?> cls = primitiveTypes.get(name);
                    if (cls != null)
                        return cls;
                    else
                        throw cnfe;
                }
             }
         }
 
     }
 
 }
"
172,"java.lang.ArrayIndexOutOfBoundsException","/src/main/java/org/apache/commons/lang3/RandomStringUtils.java","@@ -227,14 +227,21 @@ public static String random(int count, int start, int end, boolean letters, bool
         } else if (count < 0) {
             throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0."");
         }
 
         if (start == 0 && end == 0) {
                 if (!letters && !numbers) {
                     end = Integer.MAX_VALUE;
                 } else {
                     end = 'z' + 1;
                     start = ' ';                
                 }
         }
 
         char[] buffer = new char[count];
","@@ -227,14 +227,21 @@ public static String random(int count, int start, int end, boolean letters, bool
         } else if (count < 0) {
             throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0."");
         }
      if (chars != null && chars.length == 0) {
          throw new IllegalArgumentException(""The chars array must not be empty"");
      }
 
         if (start == 0 && end == 0) {
          if (chars != null) {
              end = chars.length;
          } else {
                 if (!letters && !numbers) {
                     end = Integer.MAX_VALUE;
                 } else {
                     end = 'z' + 1;
                     start = ' ';                
                 }
          }
         }
 
         char[] buffer = new char[count];
","
         } else if (count < 0) {
             throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0."");
         }
 
         if (start == 0 && end == 0) {
                 if (!letters && !numbers) {
                     end = Integer.MAX_VALUE;
                 } else {
                     end = 'z' + 1;
                     start = ' ';                
                 }
         }
 
         char[] buffer = new char[count];
","
         } else if (count < 0) {
             throw new IllegalArgumentException(""Requested random string length "" + count + "" is less than 0."");
         }
        if (chars != null && chars.length == 0) {
            throw new IllegalArgumentException(""The chars array must not be empty"");
        }
 
         if (start == 0 && end == 0) {
            if (chars != null) {
                end = chars.length;
            } else {
                 if (!letters && !numbers) {
                     end = Integer.MAX_VALUE;
                 } else {
                     end = 'z' + 1;
                     start = ' ';                
                 }
            }
         }
 
         char[] buffer = new char[count];
"
173,"junit.framework.ComparisonFailure","/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java","@@ -492,10 +492,10 @@ private void init() {
                 rule = new TextField(Calendar.ERA, ERAs);
                 break;
             case 'y': // year (number)
              if (tokenLen >= 4) {
                  rule = selectNumberRule(Calendar.YEAR, tokenLen);
              } else {
                     rule = TwoDigitYearField.INSTANCE;
                 }
                 break;
             case 'M': // month in year (text and number)
","@@ -492,10 +492,10 @@ private void init() {
                 rule = new TextField(Calendar.ERA, ERAs);
                 break;
             case 'y': // year (number)
              if (tokenLen == 2) {
                     rule = TwoDigitYearField.INSTANCE;
              } else {
                  rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen);
                 }
                 break;
             case 'M': // month in year (text and number)
","
                 rule = new TextField(Calendar.ERA, ERAs);
                 break;
             case 'y':                 if (tokenLen >= 4) {
                    rule = selectNumberRule(Calendar.YEAR, tokenLen);
                } else {
                     rule = TwoDigitYearField.INSTANCE;
                 }
                 break;
             case 'M': ","
                 rule = new TextField(Calendar.ERA, ERAs);
                 break;
             case 'y':                 if (tokenLen == 2) {
                     rule = TwoDigitYearField.INSTANCE;
                } else {
                    rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen);
                 }
                 break;
             case 'M': "
174,"junit.framework.ComparisonFailure","/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java","@@ -80,26 +80,20 @@ public final void translate(CharSequence input, Writer out) throws IOException {
             return;
         }
         int pos = 0;
      int len = Character.codePointCount(input, 0, input.length());
         while (pos < len) {
             int consumed = translate(input, pos, out);
             if (consumed == 0) {
                 char[] c = Character.toChars(Character.codePointAt(input, pos));
                 out.write(c);
             }
          else {
 //          // contract with translators is that they have to understand codepoints 
 //          // and they just took care of a surrogate pair
             for (int pt = 0; pt < consumed; pt++) {
                  if (pos < len - 2) {
                 pos += Character.charCount(Character.codePointAt(input, pos));
                  } else {
                      pos++;
                  }
              }
              pos--;
             }
          pos++;
         }
     }
 
","@@ -80,26 +80,20 @@ public final void translate(CharSequence input, Writer out) throws IOException {
             return;
         }
         int pos = 0;
      int len = input.length();
         while (pos < len) {
             int consumed = translate(input, pos, out);
             if (consumed == 0) {
                 char[] c = Character.toChars(Character.codePointAt(input, pos));
                 out.write(c);
              pos+= c.length;
              continue;
             }
 //          // contract with translators is that they have to understand codepoints 
 //          // and they just took care of a surrogate pair
             for (int pt = 0; pt < consumed; pt++) {
                 pos += Character.charCount(Character.codePointAt(input, pos));
             }
         }
     }
 
","
             return;
         }
         int pos = 0;
        int len = Character.codePointCount(input, 0, input.length());
         while (pos < len) {
             int consumed = translate(input, pos, out);
             if (consumed == 0) {
                 char[] c = Character.toChars(Character.codePointAt(input, pos));
                 out.write(c);
             }
            else {
               for (int pt = 0; pt < consumed; pt++) {
                    if (pos < len - 2) {
                 pos += Character.charCount(Character.codePointAt(input, pos));
                    } else {
                        pos++;
                    }
                }
                pos--;
             }
            pos++;
         }
     }
 
","
             return;
         }
         int pos = 0;
        int len = input.length();
         while (pos < len) {
             int consumed = translate(input, pos, out);
             if (consumed == 0) {
                 char[] c = Character.toChars(Character.codePointAt(input, pos));
                 out.write(c);
                pos+= c.length;
                continue;
             }
               for (int pt = 0; pt < consumed; pt++) {
                 pos += Character.charCount(Character.codePointAt(input, pos));
             }
         }
     }
 
"
175,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/StringUtils.java","@@ -785,7 +785,10 @@ public static boolean equals(CharSequence cs1, CharSequence cs2) {
         if (cs1 == null || cs2 == null) {
             return false;
         }
             return cs1.equals(cs2);
     }
 
     /**
","@@ -785,7 +785,10 @@ public static boolean equals(CharSequence cs1, CharSequence cs2) {
         if (cs1 == null || cs2 == null) {
             return false;
         }
      if (cs1 instanceof String && cs2 instanceof String) {
             return cs1.equals(cs2);
      }
      return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));
     }
 
     /**
","
         if (cs1 == null || cs2 == null) {
             return false;
         }
             return cs1.equals(cs2);
     }
 
","
         if (cs1 == null || cs2 == null) {
             return false;
         }
        if (cs1 instanceof String && cs2 instanceof String) {
             return cs1.equals(cs2);
        }
        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));
     }
 
"
176,"java.lang.NumberFormatException","/src/main/java/org/apache/commons/lang3/math/NumberUtils.java","@@ -455,7 +455,7 @@ public static Number createNumber(String str) throws NumberFormatException {
             // a wrong value.
             return null;
         }
      if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
             return createInteger(str);
         }   
         char lastChar = str.charAt(str.length() - 1);
","@@ -455,7 +455,7 @@ public static Number createNumber(String str) throws NumberFormatException {
             // a wrong value.
             return null;
         }
      if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) {
             return createInteger(str);
         }   
         char lastChar = str.charAt(str.length() - 1);
","
                          return null;
         }
        if (str.startsWith(""0x"") || str.startsWith(""-0x"")) {
             return createInteger(str);
         }   
         char lastChar = str.charAt(str.length() - 1);
","
                          return null;
         }
        if (str.startsWith(""0x"") || str.startsWith(""-0x"") || str.startsWith(""0X"") || str.startsWith(""-0X"")) {
             return createInteger(str);
         }   
         char lastChar = str.charAt(str.length() - 1);
"
177,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java","@@ -216,9 +216,9 @@ private static boolean isAssignable(Type type, ParameterizedType toParameterized
                 toClass, typeVarAssigns);
 
         // now to check each type argument
      for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {
          Type toTypeArg = entry.getValue();
          Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());
 
             // parameters must either be absent from the subject type, within
             // the bounds of the wildcard type, or be an exact match to the
@@ -672,7 +672,7 @@ private static Type substituteTypeVariables(Type type, Map<TypeVariable<?>, Type
                 : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);
 
         // has target class been reached?
      if (cls.getTypeParameters().length > 0 || toClass.equals(cls)) {
             return typeVarAssigns;
         }
 
","@@ -216,9 +216,9 @@ private static boolean isAssignable(Type type, ParameterizedType toParameterized
                 toClass, typeVarAssigns);
 
         // now to check each type argument
      for (TypeVariable<?> var : toTypeVarAssigns.keySet()) {
          Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns);
          Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns);
 
             // parameters must either be absent from the subject type, within
             // the bounds of the wildcard type, or be an exact match to the
@@ -672,7 +672,7 @@ private static Type substituteTypeVariables(Type type, Map<TypeVariable<?>, Type
                 : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);
 
         // has target class been reached?
      if (toClass.equals(cls)) {
             return typeVarAssigns;
         }
 
","
                 toClass, typeVarAssigns);
 
                 for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {
            Type toTypeArg = entry.getValue();
            Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());
 
                          
                 : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);
 
                 if (cls.getTypeParameters().length > 0 || toClass.equals(cls)) {
             return typeVarAssigns;
         }
 
","
                 toClass, typeVarAssigns);
 
                 for (TypeVariable<?> var : toTypeVarAssigns.keySet()) {
            Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns);
            Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns);
 
                          
                 : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);
 
                 if (toClass.equals(cls)) {
             return typeVarAssigns;
         }
 
"
178,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/time/DateUtils.java","@@ -262,7 +262,7 @@ public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {
         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&
                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&
                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&
              cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&
                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&
                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&
                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&
","@@ -262,7 +262,7 @@ public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {
         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&
                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&
                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&
              cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&
                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&
                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&
                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&
","
         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&
                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&
                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&
                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&
                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&
                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&
                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&
","
         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&
                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&
                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&
                cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&
                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&
                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&
                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&
"
179,"java.lang.StringIndexOutOfBoundsException","/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java","@@ -37,7 +37,7 @@
     public int translate(CharSequence input, int index, Writer out) throws IOException {
         int seqEnd = input.length();
         // Uses -2 to ensure there is something after the &#
      if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
             int start = index + 2;
             boolean isHex = false;
 
@@ -47,11 +47,16 @@ public int translate(CharSequence input, int index, Writer out) throws IOExcepti
                 isHex = true;
 
                 // Check there's more than just an x after the &#
             }
 
             int end = start;
             // Note that this supports character codes without a ; on the end
          while(input.charAt(end) != ';') 
             {
                 end++;
             }
@@ -76,8 +81,9 @@ public int translate(CharSequence input, int index, Writer out) throws IOExcepti
                 out.write(entityValue);
             }
 
 
          return 2 + (end - start) + (isHex ? 1 : 0) + 1;
         }
         return 0;
     }
","@@ -37,7 +37,7 @@
     public int translate(CharSequence input, int index, Writer out) throws IOException {
         int seqEnd = input.length();
         // Uses -2 to ensure there is something after the &#
      if(input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {
             int start = index + 2;
             boolean isHex = false;
 
@@ -47,11 +47,16 @@ public int translate(CharSequence input, int index, Writer out) throws IOExcepti
                 isHex = true;
 
                 // Check there's more than just an x after the &#
              if(start == seqEnd) {
                  return 0;
              }
             }
 
             int end = start;
             // Note that this supports character codes without a ; on the end
          while(end < seqEnd && ( (input.charAt(end) >= '0' && input.charAt(end) <= '9') ||
                                  (input.charAt(end) >= 'a' && input.charAt(end) <= 'f') ||
                                  (input.charAt(end) >= 'A' && input.charAt(end) <= 'F') ) )
             {
                 end++;
             }
@@ -76,8 +81,9 @@ public int translate(CharSequence input, int index, Writer out) throws IOExcepti
                 out.write(entityValue);
             }
 
          boolean semiNext = (end != seqEnd) && (input.charAt(end) == ';');
 
          return 2 + (end - start) + (isHex ? 1 : 0) + (semiNext ? 1 : 0);
         }
         return 0;
     }
","
     public int translate(CharSequence input, int index, Writer out) throws IOException {
         int seqEnd = input.length();
                 if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {
             int start = index + 2;
             boolean isHex = false;
 

                 isHex = true;
 
                              }
 
             int end = start;
                         while(input.charAt(end) != ';') 
             {
                 end++;
             }

                 out.write(entityValue);
             }
 
 
            return 2 + (end - start) + (isHex ? 1 : 0) + 1;
         }
         return 0;
     }
","
     public int translate(CharSequence input, int index, Writer out) throws IOException {
         int seqEnd = input.length();
                 if(input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {
             int start = index + 2;
             boolean isHex = false;
 

                 isHex = true;
 
                                 if(start == seqEnd) {
                    return 0;
                }
             }
 
             int end = start;
                         while(end < seqEnd && ( (input.charAt(end) >= '0' && input.charAt(end) <= '9') ||
                                    (input.charAt(end) >= 'a' && input.charAt(end) <= 'f') ||
                                    (input.charAt(end) >= 'A' && input.charAt(end) <= 'F') ) )
             {
                 end++;
             }

                 out.write(entityValue);
             }
 
            boolean semiNext = (end != seqEnd) && (input.charAt(end) == ';');
 
            return 2 + (end - start) + (isHex ? 1 : 0) + (semiNext ? 1 : 0);
         }
         return 0;
     }
"
180,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java","@@ -70,6 +70,7 @@
  */
 public class ExtendedMessageFormat extends MessageFormat {
     private static final long serialVersionUID = -2362048321261811743L;
 
     private static final String DUMMY_PATTERN = """";
     private static final String ESCAPED_QUOTE = ""''"";
@@ -260,12 +261,42 @@ public void setFormatsByArgumentIndex(Format[] newFormats) {
      * @param obj the object to compare to
      * @return true if this object equals the other, otherwise false
      */
 
     /**
      * Return the hashcode.
      *
      * @return the hashcode
      */
 
     /**
      * Get a custom format from a format description.
","@@ -70,6 +70,7 @@
  */
 public class ExtendedMessageFormat extends MessageFormat {
     private static final long serialVersionUID = -2362048321261811743L;
  private static final int HASH_SEED = 31;
 
     private static final String DUMMY_PATTERN = """";
     private static final String ESCAPED_QUOTE = ""''"";
@@ -260,12 +261,42 @@ public void setFormatsByArgumentIndex(Format[] newFormats) {
      * @param obj the object to compare to
      * @return true if this object equals the other, otherwise false
      */
  @Override
  public boolean equals(Object obj) {
      if (obj == this) {
          return true;
      }
      if (obj == null) {
          return false;
      }
      if (!super.equals(obj)) {
          return false;
      }
      if (ObjectUtils.notEqual(getClass(), obj.getClass())) {
        return false;
      }
      ExtendedMessageFormat rhs = (ExtendedMessageFormat)obj;
      if (ObjectUtils.notEqual(toPattern, rhs.toPattern)) {
          return false;
      }
      if (ObjectUtils.notEqual(registry, rhs.registry)) {
          return false;
      }
      return true;
  }
 
     /**
      * Return the hashcode.
      *
      * @return the hashcode
      */
  @Override
  public int hashCode() {
      int result = super.hashCode();
      result = HASH_SEED * result + ObjectUtils.hashCode(registry);
      result = HASH_SEED * result + ObjectUtils.hashCode(toPattern);
      return result;
  }
 
     /**
      * Get a custom format from a format description.
","
 public class ExtendedMessageFormat extends MessageFormat {
     private static final long serialVersionUID = -2362048321261811743L;
 
     private static final String DUMMY_PATTERN = """";
     private static final String ESCAPED_QUOTE = ""''"";

","
 public class ExtendedMessageFormat extends MessageFormat {
     private static final long serialVersionUID = -2362048321261811743L;
    private static final int HASH_SEED = 31;
 
     private static final String DUMMY_PATTERN = """";
     private static final String ESCAPED_QUOTE = ""''"";

    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (!super.equals(obj)) {
            return false;
        }
        if (ObjectUtils.notEqual(getClass(), obj.getClass())) {
          return false;
        }
        ExtendedMessageFormat rhs = (ExtendedMessageFormat)obj;
        if (ObjectUtils.notEqual(toPattern, rhs.toPattern)) {
            return false;
        }
        if (ObjectUtils.notEqual(registry, rhs.registry)) {
            return false;
        }
        return true;
    }
 
    @Override
    public int hashCode() {
        int result = super.hashCode();
        result = HASH_SEED * result + ObjectUtils.hashCode(registry);
        result = HASH_SEED * result + ObjectUtils.hashCode(toPattern);
        return result;
    }
 
"
181,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/math/Fraction.java","@@ -580,8 +580,14 @@ public Fraction pow(int power) {
      */
     private static int greatestCommonDivisor(int u, int v) {
         // From Commons Math:
         //if either operand is abs 1, return 1:
      if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {
             return 1;
         }
         // keep u and v negative, as negative integers range down to
","@@ -580,8 +580,14 @@ public Fraction pow(int power) {
      */
     private static int greatestCommonDivisor(int u, int v) {
         // From Commons Math:
      if ((u == 0) || (v == 0)) {
          if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {
              throw new ArithmeticException(""overflow: gcd is 2^31"");
          }
          return Math.abs(u) + Math.abs(v);
      }
         //if either operand is abs 1, return 1:
      if (Math.abs(u) == 1 || Math.abs(v) == 1) {
             return 1;
         }
         // keep u and v negative, as negative integers range down to
","
     private static int greatestCommonDivisor(int u, int v) {
                          if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {
             return 1;
         }
         ","
     private static int greatestCommonDivisor(int u, int v) {
                 if ((u == 0) || (v == 0)) {
            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {
                throw new ArithmeticException(""overflow: gcd is 2^31"");
            }
            return Math.abs(u) + Math.abs(v);
        }
                 if (Math.abs(u) == 1 || Math.abs(v) == 1) {
             return 1;
         }
         "
182,"java.lang.NullPointerException","/src/main/java/org/apache/commons/lang3/StringUtils.java","@@ -3295,7 +3295,7 @@ public static String join(Object[] array, char separator, int startIndex, int en
             return EMPTY;
         }
         
      StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);
 
         for (int i = startIndex; i < endIndex; i++) {
             if (i > startIndex) {
@@ -3380,7 +3380,7 @@ public static String join(Object[] array, String separator, int startIndex, int
             return EMPTY;
         }
 
      StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());
 
         for (int i = startIndex; i < endIndex; i++) {
             if (i > startIndex) {
","@@ -3295,7 +3295,7 @@ public static String join(Object[] array, char separator, int startIndex, int en
             return EMPTY;
         }
         
      StringBuilder buf = new StringBuilder(noOfItems * 16);
 
         for (int i = startIndex; i < endIndex; i++) {
             if (i > startIndex) {
@@ -3380,7 +3380,7 @@ public static String join(Object[] array, String separator, int startIndex, int
             return EMPTY;
         }
 
      StringBuilder buf = new StringBuilder(noOfItems * 16);
 
         for (int i = startIndex; i < endIndex; i++) {
             if (i > startIndex) {
","
             return EMPTY;
         }
         
        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);
 
         for (int i = startIndex; i < endIndex; i++) {
             if (i > startIndex) {

             return EMPTY;
         }
 
        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());
 
         for (int i = startIndex; i < endIndex; i++) {
             if (i > startIndex) {
","
             return EMPTY;
         }
         
        StringBuilder buf = new StringBuilder(noOfItems * 16);
 
         for (int i = startIndex; i < endIndex; i++) {
             if (i > startIndex) {

             return EMPTY;
         }
 
        StringBuilder buf = new StringBuilder(noOfItems * 16);
 
         for (int i = startIndex; i < endIndex; i++) {
             if (i > startIndex) {
"
183,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/math/NumberUtils.java","@@ -1410,7 +1410,7 @@ public static boolean isNumber(String str) {
             if (chars[i] == 'l'
                 || chars[i] == 'L') {
                 // not allowing L with an exponent or decimal point
              return foundDigit && !hasExp;
             }
             // last character is illegal
             return false;
","@@ -1410,7 +1410,7 @@ public static boolean isNumber(String str) {
             if (chars[i] == 'l'
                 || chars[i] == 'L') {
                 // not allowing L with an exponent or decimal point
              return foundDigit && !hasExp && !hasDecPoint;
             }
             // last character is illegal
             return false;
","
             if (chars[i] == 'l'
                 || chars[i] == 'L') {
                                 return foundDigit && !hasExp;
             }
                          return false;
","
             if (chars[i] == 'l'
                 || chars[i] == 'L') {
                                 return foundDigit && !hasExp && !hasDecPoint;
             }
                          return false;
"
184,"junit.framework.ComparisonFailure","/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java","@@ -817,7 +817,7 @@ public String format(long millis) {
      * @return the formatted string
      */
     public String format(Date date) {
      Calendar c = new GregorianCalendar(mTimeZone);
         c.setTime(date);
         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
     }
","@@ -817,7 +817,7 @@ public String format(long millis) {
      * @return the formatted string
      */
     public String format(Date date) {
      Calendar c = new GregorianCalendar(mTimeZone, mLocale);
         c.setTime(date);
         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
     }
","
        Calendar c = new GregorianCalendar(mTimeZone);
         c.setTime(date);
         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
     }
","
     public String format(Date date) {
        Calendar c = new GregorianCalendar(mTimeZone, mLocale);
         c.setTime(date);
         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();
     }
"
185,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java","@@ -71,33 +71,33 @@
         {""\u00C7"", ""&Ccedil;""}, // � - uppercase C, cedilla
         {""\u00C8"", ""&Egrave;""}, // � - uppercase E, grave accent
         {""\u00C9"", ""&Eacute;""}, // � - uppercase E, acute accent
      {""\u00CB"", ""&Ecirc;""}, // � - uppercase E, circumflex accent
      {""\u00CC"", ""&Euml;""}, // � - uppercase E, umlaut
      {""\u00CD"", ""&Igrave;""}, // � - uppercase I, grave accent
      {""\u00CE"", ""&Iacute;""}, // � - uppercase I, acute accent
      {""\u00CF"", ""&Icirc;""}, // � - uppercase I, circumflex accent
      {""\u00D0"", ""&Iuml;""}, // � - uppercase I, umlaut
      {""\u00D1"", ""&ETH;""}, // � - uppercase Eth, Icelandic
      {""\u00D2"", ""&Ntilde;""}, // � - uppercase N, tilde
      {""\u00D3"", ""&Ograve;""}, // � - uppercase O, grave accent
      {""\u00D4"", ""&Oacute;""}, // � - uppercase O, acute accent
      {""\u00D5"", ""&Ocirc;""}, // � - uppercase O, circumflex accent
      {""\u00D6"", ""&Otilde;""}, // � - uppercase O, tilde
      {""\u00D7"", ""&Ouml;""}, // � - uppercase O, umlaut
      {""\u00D8"", ""&times;""}, // multiplication sign
      {""\u00D9"", ""&Oslash;""}, // � - uppercase O, slash
      {""\u00DA"", ""&Ugrave;""}, // � - uppercase U, grave accent
      {""\u00DB"", ""&Uacute;""}, // � - uppercase U, acute accent
      {""\u00DC"", ""&Ucirc;""}, // � - uppercase U, circumflex accent
      {""\u00DD"", ""&Uuml;""}, // � - uppercase U, umlaut
      {""\u00DE"", ""&Yacute;""}, // � - uppercase Y, acute accent
      {""\u00DF"", ""&THORN;""}, // � - uppercase THORN, Icelandic
      {""\u00E0"", ""&szlig;""}, // � - lowercase sharps, German
      {""\u00E1"", ""&agrave;""}, // � - lowercase a, grave accent
      {""\u00E2"", ""&aacute;""}, // � - lowercase a, acute accent
      {""\u00E3"", ""&acirc;""}, // � - lowercase a, circumflex accent
      {""\u00E4"", ""&atilde;""}, // � - lowercase a, tilde
      {""\u00E5"", ""&auml;""}, // � - lowercase a, umlaut
         {""\u00E5"", ""&aring;""}, // � - lowercase a, ring
         {""\u00E6"", ""&aelig;""}, // � - lowercase ae
         {""\u00E7"", ""&ccedil;""}, // � - lowercase c, cedilla
","@@ -71,33 +71,33 @@
         {""\u00C7"", ""&Ccedil;""}, // � - uppercase C, cedilla
         {""\u00C8"", ""&Egrave;""}, // � - uppercase E, grave accent
         {""\u00C9"", ""&Eacute;""}, // � - uppercase E, acute accent
      {""\u00CA"", ""&Ecirc;""}, // � - uppercase E, circumflex accent
      {""\u00CB"", ""&Euml;""}, // � - uppercase E, umlaut
      {""\u00CC"", ""&Igrave;""}, // � - uppercase I, grave accent
      {""\u00CD"", ""&Iacute;""}, // � - uppercase I, acute accent
      {""\u00CE"", ""&Icirc;""}, // � - uppercase I, circumflex accent
      {""\u00CF"", ""&Iuml;""}, // � - uppercase I, umlaut
      {""\u00D0"", ""&ETH;""}, // � - uppercase Eth, Icelandic
      {""\u00D1"", ""&Ntilde;""}, // � - uppercase N, tilde
      {""\u00D2"", ""&Ograve;""}, // � - uppercase O, grave accent
      {""\u00D3"", ""&Oacute;""}, // � - uppercase O, acute accent
      {""\u00D4"", ""&Ocirc;""}, // � - uppercase O, circumflex accent
      {""\u00D5"", ""&Otilde;""}, // � - uppercase O, tilde
      {""\u00D6"", ""&Ouml;""}, // � - uppercase O, umlaut
      {""\u00D7"", ""&times;""}, // multiplication sign
      {""\u00D8"", ""&Oslash;""}, // � - uppercase O, slash
      {""\u00D9"", ""&Ugrave;""}, // � - uppercase U, grave accent
      {""\u00DA"", ""&Uacute;""}, // � - uppercase U, acute accent
      {""\u00DB"", ""&Ucirc;""}, // � - uppercase U, circumflex accent
      {""\u00DC"", ""&Uuml;""}, // � - uppercase U, umlaut
      {""\u00DD"", ""&Yacute;""}, // � - uppercase Y, acute accent
      {""\u00DE"", ""&THORN;""}, // � - uppercase THORN, Icelandic
      {""\u00DF"", ""&szlig;""}, // � - lowercase sharps, German
      {""\u00E0"", ""&agrave;""}, // � - lowercase a, grave accent
      {""\u00E1"", ""&aacute;""}, // � - lowercase a, acute accent
      {""\u00E2"", ""&acirc;""}, // � - lowercase a, circumflex accent
      {""\u00E3"", ""&atilde;""}, // � - lowercase a, tilde
      {""\u00E4"", ""&auml;""}, // � - lowercase a, umlaut
         {""\u00E5"", ""&aring;""}, // � - lowercase a, ring
         {""\u00E6"", ""&aelig;""}, // � - lowercase ae
         {""\u00E7"", ""&ccedil;""}, // � - lowercase c, cedilla
","
         {""\u00C7"", ""&Ccedil;""},          {""\u00C8"", ""&Egrave;""},          {""\u00C9"", ""&Eacute;""},         {""\u00CB"", ""&Ecirc;""},         {""\u00CC"", ""&Euml;""},         {""\u00CD"", ""&Igrave;""},         {""\u00CE"", ""&Iacute;""},         {""\u00CF"", ""&Icirc;""},         {""\u00D0"", ""&Iuml;""},         {""\u00D1"", ""&ETH;""},         {""\u00D2"", ""&Ntilde;""},         {""\u00D3"", ""&Ograve;""},         {""\u00D4"", ""&Oacute;""},         {""\u00D5"", ""&Ocirc;""},         {""\u00D6"", ""&Otilde;""},         {""\u00D7"", ""&Ouml;""},         {""\u00D8"", ""&times;""},         {""\u00D9"", ""&Oslash;""},         {""\u00DA"", ""&Ugrave;""},         {""\u00DB"", ""&Uacute;""},         {""\u00DC"", ""&Ucirc;""},         {""\u00DD"", ""&Uuml;""},         {""\u00DE"", ""&Yacute;""},         {""\u00DF"", ""&THORN;""},         {""\u00E0"", ""&szlig;""},         {""\u00E1"", ""&agrave;""},         {""\u00E2"", ""&aacute;""},         {""\u00E3"", ""&acirc;""},         {""\u00E4"", ""&atilde;""},         {""\u00E5"", ""&auml;""},          {""\u00E5"", ""&aring;""},          {""\u00E6"", ""&aelig;""},          {""\u00E7"", ""&ccedil;""}, ","
         {""\u00C7"", ""&Ccedil;""},          {""\u00C8"", ""&Egrave;""},          {""\u00C9"", ""&Eacute;""},         {""\u00CA"", ""&Ecirc;""},         {""\u00CB"", ""&Euml;""},         {""\u00CC"", ""&Igrave;""},         {""\u00CD"", ""&Iacute;""},         {""\u00CE"", ""&Icirc;""},         {""\u00CF"", ""&Iuml;""},         {""\u00D0"", ""&ETH;""},         {""\u00D1"", ""&Ntilde;""},         {""\u00D2"", ""&Ograve;""},         {""\u00D3"", ""&Oacute;""},         {""\u00D4"", ""&Ocirc;""},         {""\u00D5"", ""&Otilde;""},         {""\u00D6"", ""&Ouml;""},         {""\u00D7"", ""&times;""},         {""\u00D8"", ""&Oslash;""},         {""\u00D9"", ""&Ugrave;""},         {""\u00DA"", ""&Uacute;""},         {""\u00DB"", ""&Ucirc;""},         {""\u00DC"", ""&Uuml;""},         {""\u00DD"", ""&Yacute;""},         {""\u00DE"", ""&THORN;""},         {""\u00DF"", ""&szlig;""},         {""\u00E0"", ""&agrave;""},         {""\u00E1"", ""&aacute;""},         {""\u00E2"", ""&acirc;""},         {""\u00E3"", ""&atilde;""},         {""\u00E4"", ""&auml;""},          {""\u00E5"", ""&aring;""},          {""\u00E6"", ""&aelig;""},          {""\u00E7"", ""&ccedil;""}, "
186,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/SystemUtils.java","@@ -1669,7 +1669,7 @@ static float toJavaVersionFloat(String version) {
      * 
      * @return the version, for example 131 for Java 1.3.1
      */
  static float toJavaVersionInt(String version) {
         return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));
     }
 
","@@ -1669,7 +1669,7 @@ static float toJavaVersionFloat(String version) {
      * 
      * @return the version, for example 131 for Java 1.3.1
      */
  static int toJavaVersionInt(String version) {
         return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));
     }
 
","
         return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));
     }
 
","
    static int toJavaVersionInt(String version) {
         return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));
     }
 
"
187,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/StringUtils.java","@@ -1373,13 +1373,21 @@ public static int indexOfAny(CharSequence cs, char[] searchChars) {
             return INDEX_NOT_FOUND;
         }
         int csLen = cs.length();
         int searchLen = searchChars.length;
         for (int i = 0; i < csLen; i++) {
             char ch = cs.charAt(i);
             for (int j = 0; j < searchLen; j++) {
                 if (searchChars[j] == ch) {
                         // ch is a supplementary character
                         return i;
                 }
             }
         }
@@ -1440,7 +1448,7 @@ public static int indexOfAny(CharSequence cs, String searchChars) {
      * <code>false</code> if no match or null input
      * @since 2.4
      */
  public static boolean containsAny(CharSequence cs, char[] searchChars) {
         if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
             return false;
         }
@@ -1452,9 +1460,12 @@ public static boolean containsAny(CharSequence cs, char[] searchChars) {
             char ch = cs.charAt(i);
             for (int j = 0; j < searchLength; j++) {
                 if (searchChars[j] == ch) {
                  if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {
                             // missing low surrogate, fine, like String.indexOf(String)
                      if (searchChars[j + 1] == cs.charAt(i + 1)) {
                             return true;
                         }
                     } else {
@@ -1494,7 +1505,7 @@ public static boolean containsAny(CharSequence cs, char[] searchChars) {
      * @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input
      * @since 2.4
      */
  public static boolean containsAny(CharSequence cs, String searchChars) {
         if (searchChars == null) {
             return false;
         }
@@ -1530,13 +1541,21 @@ public static int indexOfAnyBut(CharSequence cs, char[] searchChars) {
             return INDEX_NOT_FOUND;
         }
         int csLen = cs.length();
         int searchLen = searchChars.length;
         outer:
         for (int i = 0; i < csLen; i++) {
             char ch = cs.charAt(i);
             for (int j = 0; j < searchLen; j++) {
                 if (searchChars[j] == ch) {
                         continue outer;
                 }
             }
             return i;
@@ -1573,8 +1592,16 @@ public static int indexOfAnyBut(String str, String searchChars) {
         int strLen = str.length();
         for (int i = 0; i < strLen; i++) {
             char ch = str.charAt(i);
          if (searchChars.indexOf(ch) < 0) {
                     return i;
             }
         }
         return INDEX_NOT_FOUND;
@@ -1675,14 +1702,25 @@ public static boolean containsNone(CharSequence cs, char[] searchChars) {
             return true;
         }
         int csLen = cs.length();
         int searchLen = searchChars.length;
         for (int i = 0; i < csLen; i++) {
             char ch = cs.charAt(i);
             for (int j = 0; j < searchLen; j++) {
                 if (searchChars[j] == ch) {
                             // missing low surrogate, fine, like String.indexOf(String)
                         // ch is in the Basic Multilingual Plane
                         return false;
                 }
             }
         }
","@@ -1373,13 +1373,21 @@ public static int indexOfAny(CharSequence cs, char[] searchChars) {
             return INDEX_NOT_FOUND;
         }
         int csLen = cs.length();
      int csLast = csLen - 1;
         int searchLen = searchChars.length;
      int searchLast = searchLen - 1;
         for (int i = 0; i < csLen; i++) {
             char ch = cs.charAt(i);
             for (int j = 0; j < searchLen; j++) {
                 if (searchChars[j] == ch) {
                  if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {
                         // ch is a supplementary character
                      if (searchChars[j + 1] == cs.charAt(i + 1)) {
                          return i;
                      }
                  } else {
                         return i;
                  }
                 }
             }
         }
@@ -1440,7 +1448,7 @@ public static int indexOfAny(CharSequence cs, String searchChars) {
      * <code>false</code> if no match or null input
      * @since 2.4
      */
  public static boolean containsAny(String cs, char[] searchChars) {
         if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
             return false;
         }
@@ -1452,9 +1460,12 @@ public static boolean containsAny(CharSequence cs, char[] searchChars) {
             char ch = cs.charAt(i);
             for (int j = 0; j < searchLength; j++) {
                 if (searchChars[j] == ch) {
                  if (Character.isHighSurrogate(ch)) {
                      if (j == searchLast) {
                             // missing low surrogate, fine, like String.indexOf(String)
                          return true;
                      }
                      if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {
                             return true;
                         }
                     } else {
@@ -1494,7 +1505,7 @@ public static boolean containsAny(CharSequence cs, char[] searchChars) {
      * @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input
      * @since 2.4
      */
  public static boolean containsAny(String cs, String searchChars) {
         if (searchChars == null) {
             return false;
         }
@@ -1530,13 +1541,21 @@ public static int indexOfAnyBut(CharSequence cs, char[] searchChars) {
             return INDEX_NOT_FOUND;
         }
         int csLen = cs.length();
      int csLast = csLen - 1;
         int searchLen = searchChars.length;
      int searchLast = searchLen - 1;
         outer:
         for (int i = 0; i < csLen; i++) {
             char ch = cs.charAt(i);
             for (int j = 0; j < searchLen; j++) {
                 if (searchChars[j] == ch) {
                  if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {
                      if (searchChars[j + 1] == cs.charAt(i + 1)) {
                          continue outer;
                      }
                  } else {
                         continue outer;
                  }
                 }
             }
             return i;
@@ -1573,8 +1592,16 @@ public static int indexOfAnyBut(String str, String searchChars) {
         int strLen = str.length();
         for (int i = 0; i < strLen; i++) {
             char ch = str.charAt(i);
          boolean chFound = searchChars.indexOf(ch) >= 0;
          if (i + 1 < strLen && Character.isHighSurrogate(ch)) {
              char ch2 = str.charAt(i + 1);
              if (chFound && searchChars.indexOf(ch2) < 0) {
                     return i;
              }
          } else {
              if (!chFound) {
                  return i;
              }
             }
         }
         return INDEX_NOT_FOUND;
@@ -1675,14 +1702,25 @@ public static boolean containsNone(CharSequence cs, char[] searchChars) {
             return true;
         }
         int csLen = cs.length();
      int csLast = csLen - 1;
         int searchLen = searchChars.length;
      int searchLast = searchLen - 1;
         for (int i = 0; i < csLen; i++) {
             char ch = cs.charAt(i);
             for (int j = 0; j < searchLen; j++) {
                 if (searchChars[j] == ch) {
                  if (Character.isHighSurrogate(ch)) {
                      if (j == searchLast) {
                             // missing low surrogate, fine, like String.indexOf(String)
                          return false;
                      }
                      if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {
                          return false;
                      }
                  } else {
                         // ch is in the Basic Multilingual Plane
                         return false;
                  }
                 }
             }
         }
","
             return INDEX_NOT_FOUND;
         }
         int csLen = cs.length();
         int searchLen = searchChars.length;
         for (int i = 0; i < csLen; i++) {
             char ch = cs.charAt(i);
             for (int j = 0; j < searchLen; j++) {
                 if (searchChars[j] == ch) {
                                                  return i;
                 }
             }
         }

    public static boolean containsAny(CharSequence cs, char[] searchChars) {
         if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
             return false;
         }

             char ch = cs.charAt(i);
             for (int j = 0; j < searchLength; j++) {
                 if (searchChars[j] == ch) {
                    if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {
                                                     if (searchChars[j + 1] == cs.charAt(i + 1)) {
                             return true;
                         }
                     } else {

    public static boolean containsAny(CharSequence cs, String searchChars) {
         if (searchChars == null) {
             return false;
         }

             return INDEX_NOT_FOUND;
         }
         int csLen = cs.length();
         int searchLen = searchChars.length;
         outer:
         for (int i = 0; i < csLen; i++) {
             char ch = cs.charAt(i);
             for (int j = 0; j < searchLen; j++) {
                 if (searchChars[j] == ch) {
                         continue outer;
                 }
             }
             return i;

         int strLen = str.length();
         for (int i = 0; i < strLen; i++) {
             char ch = str.charAt(i);
            if (searchChars.indexOf(ch) < 0) {
                     return i;
             }
         }
         return INDEX_NOT_FOUND;

             return true;
         }
         int csLen = cs.length();
         int searchLen = searchChars.length;
         for (int i = 0; i < csLen; i++) {
             char ch = cs.charAt(i);
             for (int j = 0; j < searchLen; j++) {
                 if (searchChars[j] == ch) {
                                                                               return false;
                 }
             }
         }
","
             return INDEX_NOT_FOUND;
         }
         int csLen = cs.length();
        int csLast = csLen - 1;
         int searchLen = searchChars.length;
        int searchLast = searchLen - 1;
         for (int i = 0; i < csLen; i++) {
             char ch = cs.charAt(i);
             for (int j = 0; j < searchLen; j++) {
                 if (searchChars[j] == ch) {
                    if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {
                                                 if (searchChars[j + 1] == cs.charAt(i + 1)) {
                            return i;
                        }
                    } else {
                         return i;
                    }
                 }
             }
         }

    public static boolean containsAny(String cs, char[] searchChars) {
         if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
             return false;
         }

             char ch = cs.charAt(i);
             for (int j = 0; j < searchLength; j++) {
                 if (searchChars[j] == ch) {
                    if (Character.isHighSurrogate(ch)) {
                        if (j == searchLast) {
                                                         return true;
                        }
                        if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {
                             return true;
                         }
                     } else {

    public static boolean containsAny(String cs, String searchChars) {
         if (searchChars == null) {
             return false;
         }

             return INDEX_NOT_FOUND;
         }
         int csLen = cs.length();
        int csLast = csLen - 1;
         int searchLen = searchChars.length;
        int searchLast = searchLen - 1;
         outer:
         for (int i = 0; i < csLen; i++) {
             char ch = cs.charAt(i);
             for (int j = 0; j < searchLen; j++) {
                 if (searchChars[j] == ch) {
                    if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {
                        if (searchChars[j + 1] == cs.charAt(i + 1)) {
                            continue outer;
                        }
                    } else {
                         continue outer;
                    }
                 }
             }
             return i;

         int strLen = str.length();
         for (int i = 0; i < strLen; i++) {
             char ch = str.charAt(i);
            boolean chFound = searchChars.indexOf(ch) >= 0;
            if (i + 1 < strLen && Character.isHighSurrogate(ch)) {
                char ch2 = str.charAt(i + 1);
                if (chFound && searchChars.indexOf(ch2) < 0) {
                     return i;
                }
            } else {
                if (!chFound) {
                    return i;
                }
             }
         }
         return INDEX_NOT_FOUND;

             return true;
         }
         int csLen = cs.length();
        int csLast = csLen - 1;
         int searchLen = searchChars.length;
        int searchLast = searchLen - 1;
         for (int i = 0; i < csLen; i++) {
             char ch = cs.charAt(i);
             for (int j = 0; j < searchLen; j++) {
                 if (searchChars[j] == ch) {
                    if (Character.isHighSurrogate(ch)) {
                        if (j == searchLast) {
                                                         return false;
                        }
                        if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {
                            return false;
                        }
                    } else {
                                                  return false;
                    }
                 }
             }
         }
"
188,"junit.framework.ComparisonFailure","/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java","@@ -60,7 +60,13 @@ public int translate(CharSequence input, int index, Writer out) throws IOExcepti
                 return 0;
             }
 
                 out.write(entityValue);
             return 2 + (end - start) + (isHex ? 1 : 0) + 1;
         }
         return 0;
","@@ -60,7 +60,13 @@ public int translate(CharSequence input, int index, Writer out) throws IOExcepti
                 return 0;
             }
 
          if(entityValue > 0xFFFF) {
              char[] chrs = Character.toChars(entityValue);
              out.write(chrs[0]);
              out.write(chrs[1]);
          } else {
                 out.write(entityValue);
          }
             return 2 + (end - start) + (isHex ? 1 : 0) + 1;
         }
         return 0;
","
                 return 0;
             }
 
                 out.write(entityValue);
             return 2 + (end - start) + (isHex ? 1 : 0) + 1;
         }
         return 0;
","
                 return 0;
             }
 
            if(entityValue > 0xFFFF) {
                char[] chrs = Character.toChars(entityValue);
                out.write(chrs[0]);
                out.write(chrs[1]);
            } else {
                 out.write(entityValue);
            }
             return 2 + (end - start) + (isHex ? 1 : 0) + 1;
         }
         return 0;
"
189,"java.lang.StringIndexOutOfBoundsException","/src/main/java/org/apache/commons/lang3/math/NumberUtils.java","@@ -476,7 +476,7 @@ public static Number createNumber(String str) throws NumberFormatException {
         if (decPos > -1) {
 
             if (expPos > -1) {
              if (expPos < decPos) {
                     throw new NumberFormatException(str + "" is not a valid number."");
                 }
                 dec = str.substring(decPos + 1, expPos);
@@ -486,6 +486,9 @@ public static Number createNumber(String str) throws NumberFormatException {
             mant = str.substring(0, decPos);
         } else {
             if (expPos > -1) {
                 mant = str.substring(0, expPos);
             } else {
                 mant = str;
","@@ -476,7 +476,7 @@ public static Number createNumber(String str) throws NumberFormatException {
         if (decPos > -1) {
 
             if (expPos > -1) {
              if (expPos < decPos || expPos > str.length()) {
                     throw new NumberFormatException(str + "" is not a valid number."");
                 }
                 dec = str.substring(decPos + 1, expPos);
@@ -486,6 +486,9 @@ public static Number createNumber(String str) throws NumberFormatException {
             mant = str.substring(0, decPos);
         } else {
             if (expPos > -1) {
              if (expPos > str.length()) {
                  throw new NumberFormatException(str + "" is not a valid number."");
              }
                 mant = str.substring(0, expPos);
             } else {
                 mant = str;
","
         if (decPos > -1) {
 
             if (expPos > -1) {
                if (expPos < decPos) {
                     throw new NumberFormatException(str + "" is not a valid number."");
                 }
                 dec = str.substring(decPos + 1, expPos);

             mant = str.substring(0, decPos);
         } else {
             if (expPos > -1) {
                 mant = str.substring(0, expPos);
             } else {
                 mant = str;
","
         if (decPos > -1) {
 
             if (expPos > -1) {
                if (expPos < decPos || expPos > str.length()) {
                     throw new NumberFormatException(str + "" is not a valid number."");
                 }
                 dec = str.substring(decPos + 1, expPos);

             mant = str.substring(0, decPos);
         } else {
             if (expPos > -1) {
                if (expPos > str.length()) {
                    throw new NumberFormatException(str + "" is not a valid number."");
                }
                 mant = str.substring(0, expPos);
             } else {
                 mant = str;
"
190,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/StringUtils.java","@@ -1443,13 +1443,21 @@ public static boolean containsAny(CharSequence cs, char[] searchChars) {
 		}
 		int csLength = cs.length();
 		int searchLength = searchChars.length;
 		for (int i = 0; i < csLength; i++) {
 			char ch = cs.charAt(i);
 			for (int j = 0; j < searchLength; j++) {
 				if (searchChars[j] == ch) {
 						// ch is a supplementary character
 						// ch is in the Basic Multilingual Plane
 						return true;
 				}
 			}
 		}
","@@ -1443,13 +1443,21 @@ public static boolean containsAny(CharSequence cs, char[] searchChars) {
 		}
 		int csLength = cs.length();
 		int searchLength = searchChars.length;
		int csLastIndex = csLength - 1;
		int searchLastIndex = searchLength - 1;
 		for (int i = 0; i < csLength; i++) {
 			char ch = cs.charAt(i);
 			for (int j = 0; j < searchLength; j++) {
 				if (searchChars[j] == ch) {
					if (i < csLastIndex && j < searchLastIndex && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {
 						// ch is a supplementary character
						if (searchChars[j + 1] == cs.charAt(i + 1)) {
							return true;
						}
					} else {
 						// ch is in the Basic Multilingual Plane
 						return true;
					}
 				}
 			}
 		}
","
 		}
 		int csLength = cs.length();
 		int searchLength = searchChars.length;
 		for (int i = 0; i < csLength; i++) {
 			char ch = cs.charAt(i);
 			for (int j = 0; j < searchLength; j++) {
 				if (searchChars[j] == ch) {
 						 						return true;
 				}
 			}
 		}
","
 		}
 		int csLength = cs.length();
 		int searchLength = searchChars.length;
		int csLastIndex = csLength - 1;
		int searchLastIndex = searchLength - 1;
 		for (int i = 0; i < csLength; i++) {
 			char ch = cs.charAt(i);
 			for (int j = 0; j < searchLength; j++) {
 				if (searchChars[j] == ch) {
					if (i < csLastIndex && j < searchLastIndex && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {
												if (searchChars[j + 1] == cs.charAt(i + 1)) {
							return true;
						}
					} else {
 						 						return true;
					}
 				}
 			}
 		}
"
191,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java","@@ -101,12 +101,7 @@
      * 
      * @since 2.3
      */
  private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {
      @Override
      protected Set<IDKey> initialValue() {
          return new HashSet<IDKey>();
      }
  };
 
     /*
      * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()
@@ -149,7 +144,8 @@
      * @since 2.3
      */
     static boolean isRegistered(Object value) {
      return getRegistry().contains(new IDKey(value));
     }
 
     /**
@@ -519,6 +515,11 @@ public static int reflectionHashCode(Object object, String[] excludeFields) {
      *            The object to register.
      */
     static void register(Object value) {
         getRegistry().add(new IDKey(value));
     }
 
@@ -535,7 +536,15 @@ static void register(Object value) {
      * @since 2.3
      */
     static void unregister(Object value) {
      getRegistry().remove(new IDKey(value));
     }
 
     /**
","@@ -101,12 +101,7 @@
      * 
      * @since 2.3
      */
  private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>();
 
     /*
      * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()
@@ -149,7 +144,8 @@
      * @since 2.3
      */
     static boolean isRegistered(Object value) {
      Set<IDKey> registry = getRegistry();
      return registry != null && registry.contains(new IDKey(value));
     }
 
     /**
@@ -519,6 +515,11 @@ public static int reflectionHashCode(Object object, String[] excludeFields) {
      *            The object to register.
      */
     static void register(Object value) {
      synchronized (HashCodeBuilder.class) {
          if (getRegistry() == null) {
              REGISTRY.set(new HashSet<IDKey>());
          }
      }
         getRegistry().add(new IDKey(value));
     }
 
@@ -535,7 +536,15 @@ static void register(Object value) {
      * @since 2.3
      */
     static void unregister(Object value) {
      Set<IDKey> s = getRegistry();
      if (s != null) {
          s.remove(new IDKey(value));
          synchronized (HashCodeBuilder.class) {
              if (s.isEmpty()) {
                  REGISTRY.remove();
              }
          }
      }
     }
 
     /**
","
    private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {
        @Override
        protected Set<IDKey> initialValue() {
            return new HashSet<IDKey>();
        }
    };
 

     static boolean isRegistered(Object value) {
        return getRegistry().contains(new IDKey(value));
     }
 

     static void register(Object value) {
         getRegistry().add(new IDKey(value));
     }
 

     static void unregister(Object value) {
        getRegistry().remove(new IDKey(value));
     }
 
","
    private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>();
 

     static boolean isRegistered(Object value) {
        Set<IDKey> registry = getRegistry();
        return registry != null && registry.contains(new IDKey(value));
     }
 

     static void register(Object value) {
        synchronized (HashCodeBuilder.class) {
            if (getRegistry() == null) {
                REGISTRY.set(new HashSet<IDKey>());
            }
        }
         getRegistry().add(new IDKey(value));
     }
 

     static void unregister(Object value) {
        Set<IDKey> s = getRegistry();
        if (s != null) {
            s.remove(new IDKey(value));
            synchronized (HashCodeBuilder.class) {
                if (s.isEmpty()) {
                    REGISTRY.remove();
                }
            }
        }
     }
 
"
192,"java.lang.NullPointerException","/src/main/java/org/apache/commons/lang3/ClassUtils.java","@@ -907,7 +907,7 @@ private static String toCanonicalName(String className) {
         }
         Class<?>[] classes = new Class[array.length];
         for (int i = 0; i < array.length; i++) {
          classes[i] = array[i].getClass();
         }
         return classes;
     }
","@@ -907,7 +907,7 @@ private static String toCanonicalName(String className) {
         }
         Class<?>[] classes = new Class[array.length];
         for (int i = 0; i < array.length; i++) {
          classes[i] = array[i] == null ? null : array[i].getClass();
         }
         return classes;
     }
","
         }
         Class<?>[] classes = new Class[array.length];
         for (int i = 0; i < array.length; i++) {
            classes[i] = array[i].getClass();
         }
         return classes;
     }
","
         }
         Class<?>[] classes = new Class[array.length];
         for (int i = 0; i < array.length; i++) {
            classes[i] = array[i] == null ? null : array[i].getClass();
         }
         return classes;
     }
"
193,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java","@@ -145,7 +145,7 @@
      * @return Set the registry of objects being traversed
      */
     static Map<Object, Object> getRegistry() {
      return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();
     }
 
     /**
@@ -161,7 +161,7 @@
      */
     static boolean isRegistered(Object value) {
         Map<Object, Object> m = getRegistry();
      return m.containsKey(value);
     }
 
     /**
","@@ -145,7 +145,7 @@
      * @return Set the registry of objects being traversed
      */
     static Map<Object, Object> getRegistry() {
      return REGISTRY.get();
     }
 
     /**
@@ -161,7 +161,7 @@
      */
     static boolean isRegistered(Object value) {
         Map<Object, Object> m = getRegistry();
      return m != null && m.containsKey(value);
     }
 
     /**
","
    
     static Map<Object, Object> getRegistry() {
        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();
     }
 

     static boolean isRegistered(Object value) {
         Map<Object, Object> m = getRegistry();
        return m.containsKey(value);
     }
 
","
     static Map<Object, Object> getRegistry() {
        return REGISTRY.get();
     }
 

     static boolean isRegistered(Object value) {
         Map<Object, Object> m = getRegistry();
        return m != null && m.containsKey(value);
     }
 
"
194,"java.lang.ArrayStoreException","/src/java/org/apache/commons/lang3/ArrayUtils.java","@@ -2959,8 +2959,16 @@ public static boolean isEmpty(boolean[] array) {
         final Class<?> type1 = array1.getClass().getComponentType();
         T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);
         System.arraycopy(array1, 0, joinedArray, 0, array1.length);
             System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
             // Check if problem is incompatible types
         return joinedArray;
     }
 
","@@ -2959,8 +2959,16 @@ public static boolean isEmpty(boolean[] array) {
         final Class<?> type1 = array1.getClass().getComponentType();
         T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);
         System.arraycopy(array1, 0, joinedArray, 0, array1.length);
      try {
             System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
      } catch (ArrayStoreException ase) {
             // Check if problem is incompatible types
          final Class<?> type2 = array2.getClass().getComponentType();
          if (!type1.isAssignableFrom(type2)){
              throw new IllegalArgumentException(""Cannot store ""+type2.getName()+"" in an array of ""+type1.getName());
          }
          throw ase; // No, so rethrow original
      }
         return joinedArray;
     }
 
","
         final Class<?> type1 = array1.getClass().getComponentType();
         T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);
         System.arraycopy(array1, 0, joinedArray, 0, array1.length);
             System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
                      return joinedArray;
     }
 
","
         final Class<?> type1 = array1.getClass().getComponentType();
         T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);
         System.arraycopy(array1, 0, joinedArray, 0, array1.length);
        try {
             System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);
        } catch (ArrayStoreException ase) {
                         final Class<?> type2 = array2.getClass().getComponentType();
            if (!type1.isAssignableFrom(type2)){
                throw new IllegalArgumentException(""Cannot store ""+type2.getName()+"" in an array of ""+type1.getName());
            }
            throw ase;         }
         return joinedArray;
     }
 
"
195,"java.lang.ClassCastException","/src/main/java/org/apache/commons/lang3/ArrayUtils.java","@@ -3292,7 +3292,7 @@ public static boolean isEmpty(boolean[] array) {
         } else if (element != null) {
             type = element.getClass();
         } else {
          type = Object.class;
         }
         @SuppressWarnings(""unchecked"") // type must be T
         T[] newArray = (T[]) copyArrayGrow1(array, type);
@@ -3571,7 +3571,7 @@ private static Object copyArrayGrow1(Object array, Class<?> newArrayComponentTyp
         } else if (element != null) {
             clss = element.getClass();
         } else {
          return (T[]) new Object[] { null };
         }
         @SuppressWarnings(""unchecked"") // the add method creates an array of type clss, which is type T
         final T[] newArray = (T[]) add(array, index, element, clss);
","@@ -3292,7 +3292,7 @@ public static boolean isEmpty(boolean[] array) {
         } else if (element != null) {
             type = element.getClass();
         } else {
          throw new IllegalArgumentException(""Arguments cannot both be null"");            
         }
         @SuppressWarnings(""unchecked"") // type must be T
         T[] newArray = (T[]) copyArrayGrow1(array, type);
@@ -3571,7 +3571,7 @@ private static Object copyArrayGrow1(Object array, Class<?> newArrayComponentTyp
         } else if (element != null) {
             clss = element.getClass();
         } else {
          throw new IllegalArgumentException(""Array and element cannot both be null"");            
         }
         @SuppressWarnings(""unchecked"") // the add method creates an array of type clss, which is type T
         final T[] newArray = (T[]) add(array, index, element, clss);
","
         } else if (element != null) {
             type = element.getClass();
         } else {
            type = Object.class;
         }
         @SuppressWarnings(""unchecked"")          T[] newArray = (T[]) copyArrayGrow1(array, type);

         } else if (element != null) {
             clss = element.getClass();
         } else {
            return (T[]) new Object[] { null };
         }
         @SuppressWarnings(""unchecked"")          final T[] newArray = (T[]) add(array, index, element, clss);
","
         } else if (element != null) {
             type = element.getClass();
         } else {
            throw new IllegalArgumentException(""Arguments cannot both be null"");            
         }
         @SuppressWarnings(""unchecked"")          T[] newArray = (T[]) copyArrayGrow1(array, type);

         } else if (element != null) {
             clss = element.getClass();
         } else {
            throw new IllegalArgumentException(""Array and element cannot both be null"");            
         }
         @SuppressWarnings(""unchecked"")          final T[] newArray = (T[]) add(array, index, element, clss);
"
196,"junit.framework.ComparisonFailure","/src/java/org/apache/commons/lang3/time/FastDateFormat.java","@@ -869,6 +869,7 @@ public StringBuffer format(Date date, StringBuffer buf) {
      */
     public StringBuffer format(Calendar calendar, StringBuffer buf) {
         if (mTimeZoneForced) {
             calendar = (Calendar) calendar.clone();
             calendar.setTimeZone(mTimeZone);
         }
","@@ -869,6 +869,7 @@ public StringBuffer format(Date date, StringBuffer buf) {
      */
     public StringBuffer format(Calendar calendar, StringBuffer buf) {
         if (mTimeZoneForced) {
          calendar.getTime(); /// LANG-538
             calendar = (Calendar) calendar.clone();
             calendar.setTimeZone(mTimeZone);
         }
","
      
     public StringBuffer format(Calendar calendar, StringBuffer buf) {
         if (mTimeZoneForced) {
             calendar = (Calendar) calendar.clone();
             calendar.setTimeZone(mTimeZone);
         }
","
      
     public StringBuffer format(Calendar calendar, StringBuffer buf) {
         if (mTimeZoneForced) {
            calendar.getTime();              calendar = (Calendar) calendar.clone();
             calendar.setTimeZone(mTimeZone);
         }
"
197,"junit.framework.ComparisonFailure","/src/java/org/apache/commons/lang/Entities.java","@@ -825,10 +825,15 @@ public String escape(String str) {
     public void escape(Writer writer, String str) throws IOException {
         int len = str.length();
         for (int i = 0; i < len; i++) {
          char c = str.charAt(i);
             String entityName = this.entityName(c);
             if (entityName == null) {
              if (c > 0x7F) {
                     writer.write(""&#"");
                     writer.write(Integer.toString(c, 10));
                     writer.write(';');
","@@ -825,10 +825,15 @@ public String escape(String str) {
     public void escape(Writer writer, String str) throws IOException {
         int len = str.length();
         for (int i = 0; i < len; i++) {
          int c = Character.codePointAt(str, i); 
             String entityName = this.entityName(c);
             if (entityName == null) {
              if (c >= 0x010000 && i < len - 1) {
                  writer.write(""&#"");
                  writer.write(Integer.toString(c, 10));
                  writer.write(';');
                  i++;
              } else if (c > 0x7F) { 
                     writer.write(""&#"");
                     writer.write(Integer.toString(c, 10));
                     writer.write(';');
","
     public void escape(Writer writer, String str) throws IOException {
         int len = str.length();
         for (int i = 0; i < len; i++) {
            char c = str.charAt(i);
             String entityName = this.entityName(c);
             if (entityName == null) {
                if (c > 0x7F) {
                     writer.write(""&#"");
                     writer.write(Integer.toString(c, 10));
                     writer.write(';');
","
     public void escape(Writer writer, String str) throws IOException {
         int len = str.length();
         for (int i = 0; i < len; i++) {
            int c = Character.codePointAt(str, i); 
             String entityName = this.entityName(c);
             if (entityName == null) {
                if (c >= 0x010000 && i < len - 1) {
                    writer.write(""&#"");
                    writer.write(Integer.toString(c, 10));
                    writer.write(';');
                    i++;
                } else if (c > 0x7F) { 
                     writer.write(""&#"");
                     writer.write(Integer.toString(c, 10));
                     writer.write(';');
"
198,"java.lang.OutOfMemoryError","/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java","@@ -419,6 +419,7 @@ private StringBuffer appendQuotedString(String pattern, ParsePosition pos,
         int start = pos.getIndex();
         char[] c = pattern.toCharArray();
         if (escapingOn && c[start] == QUOTE) {
             return appendTo == null ? null : appendTo.append(QUOTE);
         }
         int lastHold = start;
","@@ -419,6 +419,7 @@ private StringBuffer appendQuotedString(String pattern, ParsePosition pos,
         int start = pos.getIndex();
         char[] c = pattern.toCharArray();
         if (escapingOn && c[start] == QUOTE) {
          next(pos);
             return appendTo == null ? null : appendTo.append(QUOTE);
         }
         int lastHold = start;
","
         int start = pos.getIndex();
         char[] c = pattern.toCharArray();
         if (escapingOn && c[start] == QUOTE) {
             return appendTo == null ? null : appendTo.append(QUOTE);
         }
         int lastHold = start;
","
         int start = pos.getIndex();
         char[] c = pattern.toCharArray();
         if (escapingOn && c[start] == QUOTE) {
            next(pos);
             return appendTo == null ? null : appendTo.append(QUOTE);
         }
         int lastHold = start;
"
199,"java.lang.NumberFormatException","/src/java/org/apache/commons/lang3/math/NumberUtils.java","@@ -488,7 +488,7 @@ public static Number createNumber(String str) throws NumberFormatException {
             }
             dec = null;
         }
      if (!Character.isDigit(lastChar)) {
             if (expPos > -1 && expPos < str.length() - 1) {
                 exp = str.substring(expPos + 1, str.length() - 1);
             } else {
@@ -1385,6 +1385,14 @@ public static boolean isNumber(String str) {
                 // can't have an E at the last byte
                 return false;
             }
             if (!allowSigns
                 && (chars[i] == 'd'
                     || chars[i] == 'D'
","@@ -488,7 +488,7 @@ public static Number createNumber(String str) throws NumberFormatException {
             }
             dec = null;
         }
      if (!Character.isDigit(lastChar) && lastChar != '.') {
             if (expPos > -1 && expPos < str.length() - 1) {
                 exp = str.substring(expPos + 1, str.length() - 1);
             } else {
@@ -1385,6 +1385,14 @@ public static boolean isNumber(String str) {
                 // can't have an E at the last byte
                 return false;
             }
          if (chars[i] == '.') {
              if (hasDecPoint || hasExp) {
                  // two decimal points or dec in exponent
                  return false;
              }
              // single trailing decimal point after non-exponent is ok
              return foundDigit;
          }
             if (!allowSigns
                 && (chars[i] == 'd'
                     || chars[i] == 'D'
","
             }
             dec = null;
         }
        if (!Character.isDigit(lastChar)) {
             if (expPos > -1 && expPos < str.length() - 1) {
                 exp = str.substring(expPos + 1, str.length() - 1);
             } else {

                                  return false;
             }
             if (!allowSigns
                 && (chars[i] == 'd'
                     || chars[i] == 'D'
","
             }
             dec = null;
         }
        if (!Character.isDigit(lastChar) && lastChar != '.') {
             if (expPos > -1 && expPos < str.length() - 1) {
                 exp = str.substring(expPos + 1, str.length() - 1);
             } else {

                                  return false;
             }
            if (chars[i] == '.') {
                if (hasDecPoint || hasExp) {
                                        return false;
                }
                                return foundDigit;
            }
             if (!allowSigns
                 && (chars[i] == 'd'
                     || chars[i] == 'D'
"
200,"java.lang.NullPointerException","/src/java/org/apache/commons/lang3/StringUtils.java","@@ -3673,6 +3673,9 @@ private static String replaceEach(String text, String[] searchList, String[] rep
 
         // count the replacement text elements that are larger than their corresponding text being replaced
         for (int i = 0; i < searchList.length; i++) {
             int greater = replacementList[i].length() - searchList[i].length();
             if (greater > 0) {
                 increase += 3 * greater; // assume 3 matches
","@@ -3673,6 +3673,9 @@ private static String replaceEach(String text, String[] searchList, String[] rep
 
         // count the replacement text elements that are larger than their corresponding text being replaced
         for (int i = 0; i < searchList.length; i++) {
          if (searchList[i] == null || replacementList[i] == null) {
              continue;
          }
             int greater = replacementList[i].length() - searchList[i].length();
             if (greater > 0) {
                 increase += 3 * greater; // assume 3 matches
","
 
                  for (int i = 0; i < searchList.length; i++) {
             int greater = replacementList[i].length() - searchList[i].length();
             if (greater > 0) {
                 increase += 3 * greater; ","
 
                  for (int i = 0; i < searchList.length; i++) {
            if (searchList[i] == null || replacementList[i] == null) {
                continue;
            }
             int greater = replacementList[i].length() - searchList[i].length();
             if (greater > 0) {
                 increase += 3 * greater; "
201,"junit.framework.ComparisonFailure","/src/java/org/apache/commons/lang/ClassUtils.java","@@ -188,10 +188,23 @@ public static String getShortClassName(String className) {
             return StringUtils.EMPTY;
         }
 
 
         // Handle array encoding
             // Strip Object type encoding
 
 
         int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
         int innerIdx = className.indexOf(
@@ -200,7 +213,7 @@ public static String getShortClassName(String className) {
         if (innerIdx != -1) {
             out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
         }
      return out;
     }
 
     // Package name
@@ -242,12 +255,18 @@ public static String getPackageName(Class<?> cls) {
      * @return the package name or an empty string
      */
     public static String getPackageName(String className) {
      if (className == null) {
             return StringUtils.EMPTY;
         }
 
         // Strip array encoding
         // Strip Object type encoding
 
         int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
         if (i == -1) {
","@@ -188,10 +188,23 @@ public static String getShortClassName(String className) {
             return StringUtils.EMPTY;
         }
 
      StringBuffer arrayPrefix = new StringBuffer();
 
         // Handle array encoding
      if (className.startsWith(""["")) {
          while (className.charAt(0) == '[') {
              className = className.substring(1);
              arrayPrefix.append(""[]"");
          }
             // Strip Object type encoding
          if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {
              className = className.substring(1, className.length() - 1);
          }
      }
 
      if (reverseAbbreviationMap.containsKey(className)) {
          className = reverseAbbreviationMap.get(className);
      }
 
         int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
         int innerIdx = className.indexOf(
@@ -200,7 +213,7 @@ public static String getShortClassName(String className) {
         if (innerIdx != -1) {
             out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
         }
      return out + arrayPrefix;
     }
 
     // Package name
@@ -242,12 +255,18 @@ public static String getPackageName(Class<?> cls) {
      * @return the package name or an empty string
      */
     public static String getPackageName(String className) {
      if (className == null || className.length() == 0) {
             return StringUtils.EMPTY;
         }
 
         // Strip array encoding
      while (className.charAt(0) == '[') {
          className = className.substring(1);
      }
         // Strip Object type encoding
      if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {
          className = className.substring(1);
      }
 
         int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
         if (i == -1) {
","
             return StringUtils.EMPTY;
         }
 
 
                       
 
         int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
         int innerIdx = className.indexOf(

         if (innerIdx != -1) {
             out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
         }
        return out;
     }
 
     
        if (className == null) {
             return StringUtils.EMPTY;
         }
 
                   
         int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
         if (i == -1) {
","
             return StringUtils.EMPTY;
         }
 
        StringBuffer arrayPrefix = new StringBuffer();
 
                 if (className.startsWith(""["")) {
            while (className.charAt(0) == '[') {
                className = className.substring(1);
                arrayPrefix.append(""[]"");
            }
                         if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {
                className = className.substring(1, className.length() - 1);
            }
        }
 
        if (reverseAbbreviationMap.containsKey(className)) {
            className = reverseAbbreviationMap.get(className);
        }
 
         int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
         int innerIdx = className.indexOf(

         if (innerIdx != -1) {
             out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);
         }
        return out + arrayPrefix;
     }
 
     
    
     public static String getPackageName(String className) {
        if (className == null || className.length() == 0) {
             return StringUtils.EMPTY;
         }
 
                 while (className.charAt(0) == '[') {
            className = className.substring(1);
        }
                 if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {
            className = className.substring(1);
        }
 
         int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);
         if (i == -1) {
"
202,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/lang/StringUtils.java","@@ -1045,7 +1045,14 @@ public static boolean containsIgnoreCase(String str, String searchStr) {
         if (str == null || searchStr == null) {
             return false;
         }
      return contains(str.toUpperCase(), searchStr.toUpperCase());
     }
 
     // IndexOfAny chars
","@@ -1045,7 +1045,14 @@ public static boolean containsIgnoreCase(String str, String searchStr) {
         if (str == null || searchStr == null) {
             return false;
         }
      int len = searchStr.length();
      int max = str.length() - len;
      for (int i = 0; i <= max; i++) {
          if (str.regionMatches(true, i, searchStr, 0, len)) {
              return true;
          }
      }
      return false;
     }
 
     // IndexOfAny chars
","
         if (str == null || searchStr == null) {
             return false;
         }
        return contains(str.toUpperCase(), searchStr.toUpperCase());
     }
 
     ","
         if (str == null || searchStr == null) {
             return false;
         }
        int len = searchStr.length();
        int max = str.length() - len;
        for (int i = 0; i <= max; i++) {
            if (str.regionMatches(true, i, searchStr, 0, len)) {
                return true;
            }
        }
        return false;
     }
 
     "
203,"java.lang.StringIndexOutOfBoundsException","/src/java/org/apache/commons/lang/NumberUtils.java","@@ -142,6 +142,9 @@ public static Number createNumber(String val) throws NumberFormatException {
         if (val.length() == 0) {
             throw new NumberFormatException(""\""\"" is not a valid number."");
         }
         if (val.startsWith(""--"")) {
             // this is protection for poorness in java.lang.BigDecimal.
             // it accepts this as a legal value, but it does not appear 
","@@ -142,6 +142,9 @@ public static Number createNumber(String val) throws NumberFormatException {
         if (val.length() == 0) {
             throw new NumberFormatException(""\""\"" is not a valid number."");
         }
      if (val.length() == 1 && !Character.isDigit(val.charAt(0))) {
          throw new NumberFormatException(val + "" is not a valid number."");
      }
         if (val.startsWith(""--"")) {
             // this is protection for poorness in java.lang.BigDecimal.
             // it accepts this as a legal value, but it does not appear 
","
         if (val.length() == 0) {
             throw new NumberFormatException(""\""\"" is not a valid number."");
         }
         if (val.startsWith(""--"")) {
                          ","
         if (val.length() == 0) {
             throw new NumberFormatException(""\""\"" is not a valid number."");
         }
        if (val.length() == 1 && !Character.isDigit(val.charAt(0))) {
            throw new NumberFormatException(val + "" is not a valid number."");
        }
         if (val.startsWith(""--"")) {
                          "
204,"java.lang.StringIndexOutOfBoundsException","/src/java/org/apache/commons/lang/WordUtils.java","@@ -613,6 +613,9 @@ public static String abbreviate(String str, int lower, int upper, String appendT
 
         // if the lower value is greater than the length of the string,
         // set to the length of the string
         // if the upper value is -1 (i.e. no limit) or is greater
         // than the length of the string, set to the length of the string
         if (upper == -1 || upper > str.length()) {
","@@ -613,6 +613,9 @@ public static String abbreviate(String str, int lower, int upper, String appendT
 
         // if the lower value is greater than the length of the string,
         // set to the length of the string
      if (lower > str.length()) {
          lower = str.length();    
      }
         // if the upper value is -1 (i.e. no limit) or is greater
         // than the length of the string, set to the length of the string
         if (upper == -1 || upper > str.length()) {
","
 
                                             if (upper == -1 || upper > str.length()) {
","
 
                          if (lower > str.length()) {
            lower = str.length();    
        }
                           if (upper == -1 || upper > str.length()) {
"
205,"java.lang.NullPointerException","/src/java/org/apache/commons/lang/text/StrBuilder.java","@@ -1183,6 +1183,9 @@ public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {
         if (width > 0) {
             ensureCapacity(size + width);
             String str = (obj == null ? getNullText() : obj.toString());
             int strLen = str.length();
             if (strLen >= width) {
                 str.getChars(strLen - width, strLen, buffer, size);
@@ -1227,6 +1230,9 @@ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar)
         if (width > 0) {
             ensureCapacity(size + width);
             String str = (obj == null ? getNullText() : obj.toString());
             int strLen = str.length();
             if (strLen >= width) {
                 str.getChars(0, width, buffer, size);
","@@ -1183,6 +1183,9 @@ public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {
         if (width > 0) {
             ensureCapacity(size + width);
             String str = (obj == null ? getNullText() : obj.toString());
          if (str == null) {
              str = """";
          }
             int strLen = str.length();
             if (strLen >= width) {
                 str.getChars(strLen - width, strLen, buffer, size);
@@ -1227,6 +1230,9 @@ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar)
         if (width > 0) {
             ensureCapacity(size + width);
             String str = (obj == null ? getNullText() : obj.toString());
          if (str == null) {
              str = """";
          }
             int strLen = str.length();
             if (strLen >= width) {
                 str.getChars(0, width, buffer, size);
","
         if (width > 0) {
             ensureCapacity(size + width);
             String str = (obj == null ? getNullText() : obj.toString());
             int strLen = str.length();
             if (strLen >= width) {
                 str.getChars(strLen - width, strLen, buffer, size);

         if (width > 0) {
             ensureCapacity(size + width);
             String str = (obj == null ? getNullText() : obj.toString());
             int strLen = str.length();
             if (strLen >= width) {
                 str.getChars(0, width, buffer, size);
","
         if (width > 0) {
             ensureCapacity(size + width);
             String str = (obj == null ? getNullText() : obj.toString());
            if (str == null) {
                str = """";
            }
             int strLen = str.length();
             if (strLen >= width) {
                 str.getChars(strLen - width, strLen, buffer, size);

         if (width > 0) {
             ensureCapacity(size + width);
             String str = (obj == null ? getNullText() : obj.toString());
            if (str == null) {
                str = """";
            }
             int strLen = str.length();
             if (strLen >= width) {
                 str.getChars(0, width, buffer, size);
"
206,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/lang/builder/EqualsBuilder.java","@@ -377,8 +377,12 @@ public EqualsBuilder append(Object lhs, Object rhs) {
         }
         Class lhsClass = lhs.getClass();
         if (!lhsClass.isArray()) {
                 // The simple case, not an array, just test the element
                 isEquals = lhs.equals(rhs);
         } else if (lhs.getClass() != rhs.getClass()) {
             // Here when we compare different dimensions, for example: a boolean[][] to a boolean[] 
             this.setEquals(false);
","@@ -377,8 +377,12 @@ public EqualsBuilder append(Object lhs, Object rhs) {
         }
         Class lhsClass = lhs.getClass();
         if (!lhsClass.isArray()) {
          if (lhs instanceof java.math.BigDecimal) {
              isEquals = (((java.math.BigDecimal)lhs).compareTo(rhs) == 0);
          } else {
                 // The simple case, not an array, just test the element
                 isEquals = lhs.equals(rhs);
          }
         } else if (lhs.getClass() != rhs.getClass()) {
             // Here when we compare different dimensions, for example: a boolean[][] to a boolean[] 
             this.setEquals(false);
","
         }
         Class lhsClass = lhs.getClass();
         if (!lhsClass.isArray()) {
                                  isEquals = lhs.equals(rhs);
         } else if (lhs.getClass() != rhs.getClass()) {
                          this.setEquals(false);
","
         }
         Class lhsClass = lhs.getClass();
         if (!lhsClass.isArray()) {
            if (lhs instanceof java.math.BigDecimal) {
                isEquals = (((java.math.BigDecimal)lhs).compareTo(rhs) == 0);
            } else {
                                  isEquals = lhs.equals(rhs);
            }
         } else if (lhs.getClass() != rhs.getClass()) {
                          this.setEquals(false);
"
207,"junit.framework.ComparisonFailure","/src/java/org/apache/commons/lang/StringEscapeUtils.java","@@ -233,6 +233,10 @@ private static void escapeJavaStyleString(Writer out, String str, boolean escape
                         out.write('\\');
                         out.write('\\');
                         break;
                     default :
                         out.write(ch);
                         break;
","@@ -233,6 +233,10 @@ private static void escapeJavaStyleString(Writer out, String str, boolean escape
                         out.write('\\');
                         out.write('\\');
                         break;
                  case '/':
                      out.write('\\');
                      out.write('/');
                      break;
                     default :
                         out.write(ch);
                         break;
","
                         out.write('\\');
                         out.write('\\');
                         break;
                     default :
                         out.write(ch);
                         break;
","
                         out.write('\\');
                         out.write('\\');
                         break;
                    case '/':
                        out.write('\\');
                        out.write('/');
                        break;
                     default :
                         out.write(ch);
                         break;
"
208,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/lang/time/DateUtils.java","@@ -640,18 +640,18 @@ private static void modify(Calendar val, int field, boolean round) {
         int millisecs = val.get(Calendar.MILLISECOND);
         if (!round || millisecs < 500) {
             time = time - millisecs;
         if (field == Calendar.SECOND) {
             done = true;
          }
         }
 
         // truncate seconds
         int seconds = val.get(Calendar.SECOND);
         if (!done && (!round || seconds < 30)) {
             time = time - (seconds * 1000L);
         if (field == Calendar.MINUTE) {
             done = true;
          }
         }
 
         // truncate minutes
","@@ -640,18 +640,18 @@ private static void modify(Calendar val, int field, boolean round) {
         int millisecs = val.get(Calendar.MILLISECOND);
         if (!round || millisecs < 500) {
             time = time - millisecs;
      }
         if (field == Calendar.SECOND) {
             done = true;
         }
 
         // truncate seconds
         int seconds = val.get(Calendar.SECOND);
         if (!done && (!round || seconds < 30)) {
             time = time - (seconds * 1000L);
      }
         if (field == Calendar.MINUTE) {
             done = true;
         }
 
         // truncate minutes
","
         int millisecs = val.get(Calendar.MILLISECOND);
         if (!round || millisecs < 500) {
             time = time - millisecs;
         if (field == Calendar.SECOND) {
             done = true;
            }
         }
 
                  int seconds = val.get(Calendar.SECOND);
         if (!done && (!round || seconds < 30)) {
             time = time - (seconds * 1000L);
         if (field == Calendar.MINUTE) {
             done = true;
            }
         }
 
         ","
         int millisecs = val.get(Calendar.MILLISECOND);
         if (!round || millisecs < 500) {
             time = time - millisecs;
        }
         if (field == Calendar.SECOND) {
             done = true;
         }
 
                  int seconds = val.get(Calendar.SECOND);
         if (!done && (!round || seconds < 30)) {
             time = time - (seconds * 1000L);
        }
         if (field == Calendar.MINUTE) {
             done = true;
         }
 
         "
209,"junit.framework.ComparisonFailure","/src/java/org/apache/commons/lang/StringEscapeUtils.java","@@ -83,7 +83,7 @@ public StringEscapeUtils() {
      * @return String with escaped values, <code>null</code> if null string input
      */
     public static String escapeJava(String str) {
      return escapeJavaStyleString(str, false);
     }
 
     /**
@@ -99,7 +99,7 @@ public static String escapeJava(String str) {
      * @throws IOException if error occurs on underlying Writer
      */
     public static void escapeJava(Writer out, String str) throws IOException {
      escapeJavaStyleString(out, str, false);
     }
 
     /**
@@ -124,7 +124,7 @@ public static void escapeJava(Writer out, String str) throws IOException {
      * @return String with escaped values, <code>null</code> if null string input
      */
     public static String escapeJavaScript(String str) {
      return escapeJavaStyleString(str, true);
     }
 
     /**
@@ -140,7 +140,7 @@ public static String escapeJavaScript(String str) {
      * @throws IOException if error occurs on underlying Writer
      **/
     public static void escapeJavaScript(Writer out, String str) throws IOException {
      escapeJavaStyleString(out, str, true);
     }
 
     /**
@@ -151,13 +151,13 @@ public static void escapeJavaScript(Writer out, String str) throws IOException {
      * @param escapeForwardSlash TODO
      * @return the escaped string
      */
  private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) {
         if (str == null) {
             return null;
         }
         try {
             StringWriter writer = new StringWriter(str.length() * 2);
          escapeJavaStyleString(writer, str, escapeSingleQuotes);
             return writer.toString();
         } catch (IOException ioe) {
             // this should never ever happen while writing to a StringWriter
@@ -175,7 +175,8 @@ private static String escapeJavaStyleString(String str, boolean escapeSingleQuot
      * @param escapeForwardSlash TODO
      * @throws IOException if an IOException occurs
      */
  private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {
         if (out == null) {
             throw new IllegalArgumentException(""The Writer must not be null"");
         }
@@ -241,7 +242,9 @@ private static void escapeJavaStyleString(Writer out, String str, boolean escape
                         out.write('\\');
                         break;
                     case '/' :
                             out.write('\\');
                         out.write('/');
                         break;
                     default :
","@@ -83,7 +83,7 @@ public StringEscapeUtils() {
      * @return String with escaped values, <code>null</code> if null string input
      */
     public static String escapeJava(String str) {
      return escapeJavaStyleString(str, false, false);
     }
 
     /**
@@ -99,7 +99,7 @@ public static String escapeJava(String str) {
      * @throws IOException if error occurs on underlying Writer
      */
     public static void escapeJava(Writer out, String str) throws IOException {
      escapeJavaStyleString(out, str, false, false);
     }
 
     /**
@@ -124,7 +124,7 @@ public static void escapeJava(Writer out, String str) throws IOException {
      * @return String with escaped values, <code>null</code> if null string input
      */
     public static String escapeJavaScript(String str) {
      return escapeJavaStyleString(str, true, true);
     }
 
     /**
@@ -140,7 +140,7 @@ public static String escapeJavaScript(String str) {
      * @throws IOException if error occurs on underlying Writer
      **/
     public static void escapeJavaScript(Writer out, String str) throws IOException {
      escapeJavaStyleString(out, str, true, true);
     }
 
     /**
@@ -151,13 +151,13 @@ public static void escapeJavaScript(Writer out, String str) throws IOException {
      * @param escapeForwardSlash TODO
      * @return the escaped string
      */
  private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes, boolean escapeForwardSlash) {
         if (str == null) {
             return null;
         }
         try {
             StringWriter writer = new StringWriter(str.length() * 2);
          escapeJavaStyleString(writer, str, escapeSingleQuotes, escapeForwardSlash);
             return writer.toString();
         } catch (IOException ioe) {
             // this should never ever happen while writing to a StringWriter
@@ -175,7 +175,8 @@ private static String escapeJavaStyleString(String str, boolean escapeSingleQuot
      * @param escapeForwardSlash TODO
      * @throws IOException if an IOException occurs
      */
  private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote,
          boolean escapeForwardSlash) throws IOException {
         if (out == null) {
             throw new IllegalArgumentException(""The Writer must not be null"");
         }
@@ -241,7 +242,9 @@ private static void escapeJavaStyleString(Writer out, String str, boolean escape
                         out.write('\\');
                         break;
                     case '/' :
                      if (escapeForwardSlash) {
                             out.write('\\');
                      }
                         out.write('/');
                         break;
                     default :
","
     public static String escapeJava(String str) {
        return escapeJavaStyleString(str, false);
     }
 

     public static void escapeJava(Writer out, String str) throws IOException {
        escapeJavaStyleString(out, str, false);
     }
 

     public static String escapeJavaScript(String str) {
        return escapeJavaStyleString(str, true);
     }
 

     public static void escapeJavaScript(Writer out, String str) throws IOException {
        escapeJavaStyleString(out, str, true);
     }
 

    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) {
         if (str == null) {
             return null;
         }
         try {
             StringWriter writer = new StringWriter(str.length() * 2);
            escapeJavaStyleString(writer, str, escapeSingleQuotes);
             return writer.toString();
         } catch (IOException ioe) {
             
    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {
         if (out == null) {
             throw new IllegalArgumentException(""The Writer must not be null"");
         }

                         out.write('\\');
                         break;
                     case '/' :
                             out.write('\\');
                         out.write('/');
                         break;
                     default :
","
     public static String escapeJava(String str) {
        return escapeJavaStyleString(str, false, false);
     }
 

     public static void escapeJava(Writer out, String str) throws IOException {
        escapeJavaStyleString(out, str, false, false);
     }
 

     public static String escapeJavaScript(String str) {
        return escapeJavaStyleString(str, true, true);
     }
 

     public static void escapeJavaScript(Writer out, String str) throws IOException {
        escapeJavaStyleString(out, str, true, true);
     }
 
    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes, boolean escapeForwardSlash) {
         if (str == null) {
             return null;
         }
         try {
             StringWriter writer = new StringWriter(str.length() * 2);
            escapeJavaStyleString(writer, str, escapeSingleQuotes, escapeForwardSlash);
             return writer.toString();
         } catch (IOException ioe) {
             
    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote,
            boolean escapeForwardSlash) throws IOException {
         if (out == null) {
             throw new IllegalArgumentException(""The Writer must not be null"");
         }

                         out.write('\\');
                         break;
                     case '/' :
                        if (escapeForwardSlash) {
                             out.write('\\');
                        }
                         out.write('/');
                         break;
                     default :
"
210,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/lang/time/FastDateFormat.java","@@ -282,16 +282,14 @@ public static synchronized FastDateFormat getDateInstance(int style, TimeZone ti
             key = new Pair(key, timeZone);
         }
 
      if (locale != null) {
          key = new Pair(key, locale);
         }
 
 
         FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);
         if (format == null) {
          if (locale == null) {
              locale = Locale.getDefault();
          }
             try {
                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);
                 String pattern = formatter.toPattern();
@@ -462,15 +460,13 @@ public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int
         if (timeZone != null) {
             key = new Pair(key, timeZone);
         }
      if (locale != null) {
          key = new Pair(key, locale);
         }
 
         FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);
         if (format == null) {
          if (locale == null) {
              locale = Locale.getDefault();
          }
             try {
                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle,
                         locale);
","@@ -282,16 +282,14 @@ public static synchronized FastDateFormat getDateInstance(int style, TimeZone ti
             key = new Pair(key, timeZone);
         }
 
      if (locale == null) {
          locale = Locale.getDefault();
         }
 
      key = new Pair(key, locale);
 
         FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);
         if (format == null) {
             try {
                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);
                 String pattern = formatter.toPattern();
@@ -462,15 +460,13 @@ public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int
         if (timeZone != null) {
             key = new Pair(key, timeZone);
         }
      if (locale == null) {
          locale = Locale.getDefault();
         }
      key = new Pair(key, locale);
 
         FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);
         if (format == null) {
             try {
                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle,
                         locale);
","
             key = new Pair(key, timeZone);
         }
 
        if (locale != null) {
            key = new Pair(key, locale);
         }
 
 
         FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);
         if (format == null) {
            if (locale == null) {
                locale = Locale.getDefault();
            }
             try {
                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);
                 String pattern = formatter.toPattern();

         if (timeZone != null) {
             key = new Pair(key, timeZone);
         }
        if (locale != null) {
            key = new Pair(key, locale);
         }
 
         FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);
         if (format == null) {
            if (locale == null) {
                locale = Locale.getDefault();
            }
             try {
                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle,
                         locale);
","
             key = new Pair(key, timeZone);
         }
 
        if (locale == null) {
            locale = Locale.getDefault();
         }
 
        key = new Pair(key, locale);
 
         FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);
         if (format == null) {
             try {
                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);
                 String pattern = formatter.toPattern();

         if (timeZone != null) {
             key = new Pair(key, timeZone);
         }
        if (locale == null) {
            locale = Locale.getDefault();
         }
        key = new Pair(key, locale);
 
         FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);
         if (format == null) {
             try {
                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle,
                         locale);
"
211,"java.lang.StringIndexOutOfBoundsException","/src/java/org/apache/commons/lang/BooleanUtils.java","@@ -679,6 +679,7 @@ public static boolean toBoolean(String str) {
                         (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&
                         (str.charAt(2) == 'S' || str.charAt(2) == 's');
                 }
             }
             case 4: {
                 char ch = str.charAt(0);
","@@ -679,6 +679,7 @@ public static boolean toBoolean(String str) {
                         (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&
                         (str.charAt(2) == 'S' || str.charAt(2) == 's');
                 }
              return false;
             }
             case 4: {
                 char ch = str.charAt(0);
","
                         (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&
                         (str.charAt(2) == 'S' || str.charAt(2) == 's');
                 }
             }
             case 4: {
                 char ch = str.charAt(0);
","
                         (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&
                         (str.charAt(2) == 'S' || str.charAt(2) == 's');
                 }
                return false;
             }
             case 4: {
                 char ch = str.charAt(0);
"
212,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/lang/math/Fraction.java","@@ -463,6 +463,9 @@ public double doubleValue() {
      * @return a new reduced fraction instance, or this if no simplification possible
      */
     public Fraction reduce() {
         int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);
         if (gcd == 1) {
             return this;
","@@ -463,6 +463,9 @@ public double doubleValue() {
      * @return a new reduced fraction instance, or this if no simplification possible
      */
     public Fraction reduce() {
      if (numerator == 0) {
          return equals(ZERO) ? this : ZERO;
      }
         int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);
         if (gcd == 1) {
             return this;
","
     public Fraction reduce() {
         int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);
         if (gcd == 1) {
             return this;
","
     public Fraction reduce() {
        if (numerator == 0) {
            return equals(ZERO) ? this : ZERO;
        }
         int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);
         if (gcd == 1) {
             return this;
"
213,"java.lang.IllegalArgumentException","/src/java/org/apache/commons/lang/LocaleUtils.java","@@ -111,6 +111,9 @@ public static Locale toLocale(String str) {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
             }
             char ch3 = str.charAt(3);
             char ch4 = str.charAt(4);
             if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
","@@ -111,6 +111,9 @@ public static Locale toLocale(String str) {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
             }
             char ch3 = str.charAt(3);
          if (ch3 == '_') {
              return new Locale(str.substring(0, 2), """", str.substring(4));
          }
             char ch4 = str.charAt(4);
             if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
","
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
             }
             char ch3 = str.charAt(3);
             char ch4 = str.charAt(4);
             if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
","
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
             }
             char ch3 = str.charAt(3);
            if (ch3 == '_') {
                return new Locale(str.substring(0, 2), """", str.substring(4));
            }
             char ch4 = str.charAt(4);
             if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {
                 throw new IllegalArgumentException(""Invalid locale format: "" + str);
"
214,"java.lang.NullPointerException","/src/java/org/apache/commons/lang/LocaleUtils.java","@@ -220,7 +220,7 @@ public static Set availableLocaleSet() {
      * @return true if the locale is a known locale
      */
     public static boolean isAvailableLocale(Locale locale) {
      return cAvailableLocaleSet.contains(locale);
     }
 
     //-----------------------------------------------------------------------
","@@ -220,7 +220,7 @@ public static Set availableLocaleSet() {
      * @return true if the locale is a known locale
      */
     public static boolean isAvailableLocale(Locale locale) {
      return availableLocaleList().contains(locale);
     }
 
     //-----------------------------------------------------------------------
","
     public static boolean isAvailableLocale(Locale locale) {
        return cAvailableLocaleSet.contains(locale);
     }
 
","
     public static boolean isAvailableLocale(Locale locale) {
        return availableLocaleList().contains(locale);
     }
 
"
215,"java.lang.NumberFormatException","/src/java/org/apache/commons/lang/math/NumberUtils.java","@@ -451,8 +451,7 @@ public static Number createNumber(String str) throws NumberFormatException {
                 case 'L' :
                     if (dec == null
                         && exp == null
                      && isDigits(numeric.substring(1))
                      && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {
                         try {
                             return createLong(numeric);
                         } catch (NumberFormatException nfe) {
","@@ -451,8 +451,7 @@ public static Number createNumber(String str) throws NumberFormatException {
                 case 'L' :
                     if (dec == null
                         && exp == null
                      && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                         try {
                             return createLong(numeric);
                         } catch (NumberFormatException nfe) {
","
                 case 'L' :
                     if (dec == null
                         && exp == null
                        && isDigits(numeric.substring(1))
                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {
                         try {
                             return createLong(numeric);
                         } catch (NumberFormatException nfe) {
","
                 case 'L' :
                     if (dec == null
                         && exp == null
                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {
                         try {
                             return createLong(numeric);
                         } catch (NumberFormatException nfe) {
"
216,"org.apache.commons.lang.SerializationException","/src/java/org/apache/commons/lang/time/FastDateFormat.java","@@ -1,152 +1,152 @@
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the ""License""); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an ""AS IS"" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package org.apache.commons.lang.time;
 
 import java.io.IOException;
 import java.io.ObjectInputStream;
 
 import java.text.DateFormat;
 import java.text.DateFormatSymbols;
 import java.text.FieldPosition;
 import java.text.Format;
 import java.text.ParsePosition;
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.GregorianCalendar;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 import java.util.TimeZone;
 
 import org.apache.commons.lang.Validate;
 
 /**
  * <p>FastDateFormat is a fast and thread-safe version of
  * {@link java.text.SimpleDateFormat}.</p>
  * 
  * <p>This class can be used as a direct replacement to
  * <code>SimpleDateFormat</code> in most formatting situations.
  * This class is especially useful in multi-threaded server environments.
  * <code>SimpleDateFormat</code> is not thread-safe in any JDK version,
  * nor will it be as Sun have closed the bug/RFE.
  * </p>
  *
  * <p>Only formatting is supported, but all patterns are compatible with
  * SimpleDateFormat (except time zones - see below).</p>
  *
  * <p>Java 1.4 introduced a new pattern letter, <code>'Z'</code>, to represent
  * time zones in RFC822 format (eg. <code>+0800</code> or <code>-1100</code>).
  * This pattern letter can be used here (on all JDK versions).</p>
  *
  * <p>In addition, the pattern <code>'ZZ'</code> has been made to represent
  * ISO8601 full format time zones (eg. <code>+08:00</code> or <code>-11:00</code>).
  * This introduces a minor incompatibility with Java 1.4, but at a gain of
  * useful functionality.</p>
  *
  * @author TeaTrove project
  * @author Brian S O'Neill
  * @author Sean Schofield
  * @author Gary Gregory
  * @author Stephen Colebourne
  * @author Nikolay Metchev
  * @since 2.0
  * @version $Id$
  */
 public class FastDateFormat extends Format {
     // A lot of the speed in this class comes from caching, but some comes
     // from the special int to StringBuffer conversion.
     //
     // The following produces a padded 2 digit number:
     //   buffer.append((char)(value / 10 + '0'));
     //   buffer.append((char)(value % 10 + '0'));
     //
     // Note that the fastest append to StringBuffer is a single char (used here).
     // Note that Integer.toString() is not called, the conversion is simply
     // taking the value and adding (mathematically) the ASCII value for '0'.
     // So, don't change this code! It works and is very fast.
     
     /**
      * Required for serialization support.
      * 
      * @see java.io.Serializable
      */
     private static final long serialVersionUID = 1L;
 
     /**
      * FULL locale dependent date or time style.
      */
     public static final int FULL = DateFormat.FULL;
     /**
      * LONG locale dependent date or time style.
      */
     public static final int LONG = DateFormat.LONG;
     /**
      * MEDIUM locale dependent date or time style.
      */
     public static final int MEDIUM = DateFormat.MEDIUM;
     /**
      * SHORT locale dependent date or time style.
      */
     public static final int SHORT = DateFormat.SHORT;
     
     private static String cDefaultPattern;
 
     private static Map cInstanceCache = new HashMap(7);
     private static Map cDateInstanceCache = new HashMap(7);
     private static Map cTimeInstanceCache = new HashMap(7);
     private static Map cDateTimeInstanceCache = new HashMap(7);
     private static Map cTimeZoneDisplayCache = new HashMap(7);
 
     /**
      * The pattern.
      */
     private final String mPattern;
     /**
      * The time zone.
      */
     private final TimeZone mTimeZone;
     /**
      * Whether the time zone overrides any on Calendars.
      */
     private final boolean mTimeZoneForced;
     /**
      * The locale.
      */
     private final Locale mLocale;
     /**
      * Whether the locale overrides the default.
      */
     private final boolean mLocaleForced;
     /**
      * The parsed rules.
      */
  private Rule[] mRules;
     /**
      * The estimated maximum length.
      */
  private int mMaxLengthEstimate;
 
     //-----------------------------------------------------------------------
     /**
      * <p>Gets a formatter instance using the default pattern in the
      * default locale.</p>
      * 
      * @return a date/time formatter
      */
@@ -1016,37 +1016,41 @@ public int hashCode() {
     public String toString() {
         return ""FastDateFormat["" + mPattern + ""]"";
     }
 
     // Serializing
     //-----------------------------------------------------------------------
     
     // Rules
     //-----------------------------------------------------------------------
     /**
      * <p>Inner class defining a rule.</p>
      */
     private interface Rule {
         /**
          * Returns the estimated lentgh of the result.
          * 
          * @return the estimated length
          */
         int estimateLength();
         
         /**
          * Appends the value of the specified calendar to the output buffer based on the rule implementation.
          * 
          * @param buffer the output buffer
          * @param calendar calendar to be appended
          */
         void appendTo(StringBuffer buffer, Calendar calendar);
     }
 
     /**
      * <p>Inner class defining a numeric rule.</p>
      */
     private interface NumberRule extends Rule {
         /**
          * Appends the specified value to the output buffer based on the rule implementation.
          * 
          * @param buffer the output buffer
","@@ -1,152 +1,152 @@
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the ""License""); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
  * 
  *      http://www.apache.org/licenses/LICENSE-2.0
  * 
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an ""AS IS"" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package org.apache.commons.lang.time;
 
 import java.io.IOException;
 import java.io.ObjectInputStream;
 
 import java.text.DateFormat;
 import java.text.DateFormatSymbols;
 import java.text.FieldPosition;
 import java.text.Format;
 import java.text.ParsePosition;
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.GregorianCalendar;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 import java.util.TimeZone;
 
 import org.apache.commons.lang.Validate;
 
 /**
  * <p>FastDateFormat is a fast and thread-safe version of
  * {@link java.text.SimpleDateFormat}.</p>
  * 
  * <p>This class can be used as a direct replacement to
  * <code>SimpleDateFormat</code> in most formatting situations.
  * This class is especially useful in multi-threaded server environments.
  * <code>SimpleDateFormat</code> is not thread-safe in any JDK version,
  * nor will it be as Sun have closed the bug/RFE.
  * </p>
  *
  * <p>Only formatting is supported, but all patterns are compatible with
  * SimpleDateFormat (except time zones - see below).</p>
  *
  * <p>Java 1.4 introduced a new pattern letter, <code>'Z'</code>, to represent
  * time zones in RFC822 format (eg. <code>+0800</code> or <code>-1100</code>).
  * This pattern letter can be used here (on all JDK versions).</p>
  *
  * <p>In addition, the pattern <code>'ZZ'</code> has been made to represent
  * ISO8601 full format time zones (eg. <code>+08:00</code> or <code>-11:00</code>).
  * This introduces a minor incompatibility with Java 1.4, but at a gain of
  * useful functionality.</p>
  *
  * @author TeaTrove project
  * @author Brian S O'Neill
  * @author Sean Schofield
  * @author Gary Gregory
  * @author Stephen Colebourne
  * @author Nikolay Metchev
  * @since 2.0
  * @version $Id$
  */
 public class FastDateFormat extends Format {
     // A lot of the speed in this class comes from caching, but some comes
     // from the special int to StringBuffer conversion.
     //
     // The following produces a padded 2 digit number:
     //   buffer.append((char)(value / 10 + '0'));
     //   buffer.append((char)(value % 10 + '0'));
     //
     // Note that the fastest append to StringBuffer is a single char (used here).
     // Note that Integer.toString() is not called, the conversion is simply
     // taking the value and adding (mathematically) the ASCII value for '0'.
     // So, don't change this code! It works and is very fast.
     
     /**
      * Required for serialization support.
      * 
      * @see java.io.Serializable
      */
     private static final long serialVersionUID = 1L;
 
     /**
      * FULL locale dependent date or time style.
      */
     public static final int FULL = DateFormat.FULL;
     /**
      * LONG locale dependent date or time style.
      */
     public static final int LONG = DateFormat.LONG;
     /**
      * MEDIUM locale dependent date or time style.
      */
     public static final int MEDIUM = DateFormat.MEDIUM;
     /**
      * SHORT locale dependent date or time style.
      */
     public static final int SHORT = DateFormat.SHORT;
     
     private static String cDefaultPattern;
 
     private static Map cInstanceCache = new HashMap(7);
     private static Map cDateInstanceCache = new HashMap(7);
     private static Map cTimeInstanceCache = new HashMap(7);
     private static Map cDateTimeInstanceCache = new HashMap(7);
     private static Map cTimeZoneDisplayCache = new HashMap(7);
 
     /**
      * The pattern.
      */
     private final String mPattern;
     /**
      * The time zone.
      */
     private final TimeZone mTimeZone;
     /**
      * Whether the time zone overrides any on Calendars.
      */
     private final boolean mTimeZoneForced;
     /**
      * The locale.
      */
     private final Locale mLocale;
     /**
      * Whether the locale overrides the default.
      */
     private final boolean mLocaleForced;
     /**
      * The parsed rules.
      */
  private transient Rule[] mRules;
     /**
      * The estimated maximum length.
      */
  private transient int mMaxLengthEstimate;
 
     //-----------------------------------------------------------------------
     /**
      * <p>Gets a formatter instance using the default pattern in the
      * default locale.</p>
      * 
      * @return a date/time formatter
      */
@@ -1016,37 +1016,41 @@ public int hashCode() {
     public String toString() {
         return ""FastDateFormat["" + mPattern + ""]"";
     }
 
     // Serializing
     //-----------------------------------------------------------------------
  private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
      in.defaultReadObject();
      init();
  }
     
     // Rules
     //-----------------------------------------------------------------------
     /**
      * <p>Inner class defining a rule.</p>
      */
     private interface Rule {
         /**
          * Returns the estimated lentgh of the result.
          * 
          * @return the estimated length
          */
         int estimateLength();
         
         /**
          * Appends the value of the specified calendar to the output buffer based on the rule implementation.
          * 
          * @param buffer the output buffer
          * @param calendar calendar to be appended
          */
         void appendTo(StringBuffer buffer, Calendar calendar);
     }
 
     /**
      * <p>Inner class defining a numeric rule.</p>
      */
     private interface NumberRule extends Rule {
         /**
          * Appends the specified value to the output buffer based on the rule implementation.
          * 
          * @param buffer the output buffer
","
 package org.apache.commons.lang.time;
 
 import java.io.IOException;
 import java.io.ObjectInputStream;
 
 import java.text.DateFormat;
 import java.text.DateFormatSymbols;
 import java.text.FieldPosition;
 import java.text.Format;
 import java.text.ParsePosition;
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.GregorianCalendar;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 import java.util.TimeZone;
 
 import org.apache.commons.lang.Validate;
 
 public class FastDateFormat extends Format {
                                                        
     private static final long serialVersionUID = 1L;
 
     public static final int FULL = DateFormat.FULL;
     public static final int LONG = DateFormat.LONG;
     public static final int MEDIUM = DateFormat.MEDIUM;
     public static final int SHORT = DateFormat.SHORT;
     
     private static String cDefaultPattern;
 
     private static Map cInstanceCache = new HashMap(7);
     private static Map cDateInstanceCache = new HashMap(7);
     private static Map cTimeInstanceCache = new HashMap(7);
     private static Map cDateTimeInstanceCache = new HashMap(7);
     private static Map cTimeZoneDisplayCache = new HashMap(7);
 
     private final String mPattern;
     private final TimeZone mTimeZone;
     private final boolean mTimeZoneForced;
     private final Locale mLocale;
     private final boolean mLocaleForced;
    private Rule[] mRules;
    private int mMaxLengthEstimate;

     public String toString() {
         return ""FastDateFormat["" + mPattern + ""]"";
     }
     private interface Rule {
         int estimateLength();
         void appendTo(StringBuffer buffer, Calendar calendar);
     }
 
     private interface NumberRule extends Rule {
","
 package org.apache.commons.lang.time;
 
 import java.io.IOException;
 import java.io.ObjectInputStream;
 
 import java.text.DateFormat;
 import java.text.DateFormatSymbols;
 import java.text.FieldPosition;
 import java.text.Format;
 import java.text.ParsePosition;
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.GregorianCalendar;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 import java.util.TimeZone;
 
 import org.apache.commons.lang.Validate;
 public class FastDateFormat extends Format {
                                                            
     private static final long serialVersionUID = 1L;
 
     public static final int FULL = DateFormat.FULL;
     public static final int LONG = DateFormat.LONG;
     public static final int MEDIUM = DateFormat.MEDIUM;
     public static final int SHORT = DateFormat.SHORT;
     
     private static String cDefaultPattern;
 
     private static Map cInstanceCache = new HashMap(7);
     private static Map cDateInstanceCache = new HashMap(7);
     private static Map cTimeInstanceCache = new HashMap(7);
     private static Map cDateTimeInstanceCache = new HashMap(7);
     private static Map cTimeZoneDisplayCache = new HashMap(7);
 
     private final String mPattern;
     private final TimeZone mTimeZone;
     private final boolean mTimeZoneForced;
     private final Locale mLocale;
     private final boolean mLocaleForced;
    private transient Rule[] mRules;
    private transient int mMaxLengthEstimate;

     public String toString() {
         return ""FastDateFormat["" + mPattern + ""]"";
     }
 
              private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
        in.defaultReadObject();
        init();
    }
     private interface Rule {
         int estimateLength();
         void appendTo(StringBuffer buffer, Calendar calendar);
     }
"
217,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/lang/enums/ValuedEnum.java","@@ -180,6 +180,16 @@ public final int getValue() {
      * @throws NullPointerException if other is <code>null</code>
      */
     public int compareTo(Object other) {
         return iValue - ((ValuedEnum) other).iValue;
     }
 
@@ -189,9 +199,20 @@ public int compareTo(Object other) {
      * @param other  the object to determine the value for
      * @return the value
      */
             // ignore - should never happen
             // ignore - should never happen
             // ignore - should never happen
 
     /**
      * <p>Human readable description of this <code>Enum</code> item.</p>
","@@ -180,6 +180,16 @@ public final int getValue() {
      * @throws NullPointerException if other is <code>null</code>
      */
     public int compareTo(Object other) {
      if (other == this) {
          return 0;
      }
      if (other.getClass() != this.getClass()) {
          if (other.getClass().getName().equals(this.getClass().getName())) {
              return iValue - getValueInOtherClassLoader(other);
          }
          throw new ClassCastException(
                  ""Different enum class '"" + ClassUtils.getShortClassName(other.getClass()) + ""'"");
      }
         return iValue - ((ValuedEnum) other).iValue;
     }
 
@@ -189,9 +199,20 @@ public int compareTo(Object other) {
      * @param other  the object to determine the value for
      * @return the value
      */
  private int getValueInOtherClassLoader(Object other) {
      try {
          Method mth = other.getClass().getMethod(""getValue"", null);
          Integer value = (Integer) mth.invoke(other, null);
          return value.intValue();
      } catch (NoSuchMethodException e) {
             // ignore - should never happen
      } catch (IllegalAccessException e) {
             // ignore - should never happen
      } catch (InvocationTargetException e) {
             // ignore - should never happen
      }
      throw new IllegalStateException(""This should not happen"");
  }
 
     /**
      * <p>Human readable description of this <code>Enum</code> item.</p>
","
     
     public int compareTo(Object other) {
         return iValue - ((ValuedEnum) other).iValue;
     }
 

","
     public int compareTo(Object other) {
        if (other == this) {
            return 0;
        }
        if (other.getClass() != this.getClass()) {
            if (other.getClass().getName().equals(this.getClass().getName())) {
                return iValue - getValueInOtherClassLoader(other);
            }
            throw new ClassCastException(
                    ""Different enum class '"" + ClassUtils.getShortClassName(other.getClass()) + ""'"");
        }
         return iValue - ((ValuedEnum) other).iValue;
     }
 

    private int getValueInOtherClassLoader(Object other) {
        try {
            Method mth = other.getClass().getMethod(""getValue"", null);
            Integer value = (Integer) mth.invoke(other, null);
            return value.intValue();
        } catch (NoSuchMethodException e) {
                     } catch (IllegalAccessException e) {
                     } catch (InvocationTargetException e) {
                     }
        throw new IllegalStateException(""This should not happen"");
    }
"
218,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/lang/time/StopWatch.java","@@ -115,7 +115,9 @@ public void stop() {
         if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {
             throw new IllegalStateException(""Stopwatch is not running. "");
         }
             stopTime = System.currentTimeMillis();
         this.runningState = STATE_STOPPED;
     }
 
","@@ -115,7 +115,9 @@ public void stop() {
         if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {
             throw new IllegalStateException(""Stopwatch is not running. "");
         }
      if(this.runningState == STATE_RUNNING) {
             stopTime = System.currentTimeMillis();
      }
         this.runningState = STATE_STOPPED;
     }
 
","
         if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {
             throw new IllegalStateException(""Stopwatch is not running. "");
         }
             stopTime = System.currentTimeMillis();
         this.runningState = STATE_STOPPED;
     }
 
","
         if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {
             throw new IllegalStateException(""Stopwatch is not running. "");
         }
        if(this.runningState == STATE_RUNNING) {
             stopTime = System.currentTimeMillis();
        }
         this.runningState = STATE_STOPPED;
     }
 
"
219,"java.lang.ArrayIndexOutOfBoundsException","/src/java/org/apache/commons/lang/text/StrBuilder.java","@@ -881,7 +881,7 @@ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar)
             String str = (obj == null ? getNullText() : obj.toString());
             int strLen = str.length();
             if (strLen >= width) {
              str.getChars(0, strLen, buffer, size);
             } else {
                 int padLen = width - strLen;
                 str.getChars(0, strLen, buffer, size);
","@@ -881,7 +881,7 @@ public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar)
             String str = (obj == null ? getNullText() : obj.toString());
             int strLen = str.length();
             if (strLen >= width) {
              str.getChars(0, width, buffer, size);
             } else {
                 int padLen = width - strLen;
                 str.getChars(0, strLen, buffer, size);
","
             String str = (obj == null ? getNullText() : obj.toString());
             int strLen = str.length();
             if (strLen >= width) {
                str.getChars(0, strLen, buffer, size);
             } else {
                 int padLen = width - strLen;
                 str.getChars(0, strLen, buffer, size);
","
             String str = (obj == null ? getNullText() : obj.toString());
             int strLen = str.length();
             if (strLen >= width) {
                str.getChars(0, width, buffer, size);
             } else {
                 int padLen = width - strLen;
                 str.getChars(0, strLen, buffer, size);
"
220,"junit.framework.ComparisonFailure","/src/java/org/apache/commons/lang/Entities.java","@@ -847,6 +847,9 @@ public String unescape(String str) {
                             } else {
                                 entityValue = Integer.parseInt(entityName.substring(1));
                             }
                         } catch (NumberFormatException ex) {
                             entityValue = -1;
                         }
@@ -917,12 +920,17 @@ public void unescape(Writer writer, String string) throws IOException {
                                     case 'X' :
                                     case 'x' : {
                                         entityValue = Integer.parseInt(entityContent.substring(2), 16);
                                     }
                                     default : {
                                         entityValue = Integer.parseInt(entityContent.substring(1), 10);
                                     }
                                 }
                             } catch (NumberFormatException e) {
                             }
                         }
                     } else { //escaped value content is an entity name
","@@ -847,6 +847,9 @@ public String unescape(String str) {
                             } else {
                                 entityValue = Integer.parseInt(entityName.substring(1));
                             }
                          if (entityValue > 0xFFFF) {
                              entityValue = -1;
                          }
                         } catch (NumberFormatException ex) {
                             entityValue = -1;
                         }
@@ -917,12 +920,17 @@ public void unescape(Writer writer, String string) throws IOException {
                                     case 'X' :
                                     case 'x' : {
                                         entityValue = Integer.parseInt(entityContent.substring(2), 16);
                                      break;
                                     }
                                     default : {
                                         entityValue = Integer.parseInt(entityContent.substring(1), 10);
                                     }
                                 }
                              if (entityValue > 0xFFFF) {
                                  entityValue = -1;
                              }
                             } catch (NumberFormatException e) {
                              entityValue = -1;
                             }
                         }
                     } else { //escaped value content is an entity name
","
                             } else {
                                 entityValue = Integer.parseInt(entityName.substring(1));
                             }
                         } catch (NumberFormatException ex) {
                             entityValue = -1;
                         }

                                     case 'X' :
                                     case 'x' : {
                                         entityValue = Integer.parseInt(entityContent.substring(2), 16);
                                     }
                                     default : {
                                         entityValue = Integer.parseInt(entityContent.substring(1), 10);
                                     }
                                 }
                             } catch (NumberFormatException e) {
                             }
                         }
                     } else { ","
                             } else {
                                 entityValue = Integer.parseInt(entityName.substring(1));
                             }
                            if (entityValue > 0xFFFF) {
                                entityValue = -1;
                            }
                         } catch (NumberFormatException ex) {
                             entityValue = -1;
                         }

                                     case 'X' :
                                     case 'x' : {
                                         entityValue = Integer.parseInt(entityContent.substring(2), 16);
                                        break;
                                     }
                                     default : {
                                         entityValue = Integer.parseInt(entityContent.substring(1), 10);
                                     }
                                 }
                                if (entityValue > 0xFFFF) {
                                    entityValue = -1;
                                }
                             } catch (NumberFormatException e) {
                                entityValue = -1;
                             }
                         }
                     } else { "
221,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/lang/text/StrBuilder.java","@@ -1670,7 +1670,7 @@ public String midString(int index, int length) {
      */
     public boolean contains(char ch) {
         char[] thisBuf = buffer;
      for (int i = 0; i < thisBuf.length; i++) {
             if (thisBuf[i] == ch) {
                 return true;
             }
@@ -1727,7 +1727,7 @@ public int indexOf(char ch, int startIndex) {
             return -1;
         }
         char[] thisBuf = buffer;
      for (int i = startIndex; i < thisBuf.length; i++) {
             if (thisBuf[i] == ch) {
                 return i;
             }
","@@ -1670,7 +1670,7 @@ public String midString(int index, int length) {
      */
     public boolean contains(char ch) {
         char[] thisBuf = buffer;
      for (int i = 0; i < this.size; i++) {
             if (thisBuf[i] == ch) {
                 return true;
             }
@@ -1727,7 +1727,7 @@ public int indexOf(char ch, int startIndex) {
             return -1;
         }
         char[] thisBuf = buffer;
      for (int i = startIndex; i < size; i++) {
             if (thisBuf[i] == ch) {
                 return i;
             }
","
      
     public boolean contains(char ch) {
         char[] thisBuf = buffer;
        for (int i = 0; i < thisBuf.length; i++) {
             if (thisBuf[i] == ch) {
                 return true;
             }

             return -1;
         }
         char[] thisBuf = buffer;
        for (int i = startIndex; i < thisBuf.length; i++) {
             if (thisBuf[i] == ch) {
                 return i;
             }
","
      
     public boolean contains(char ch) {
         char[] thisBuf = buffer;
        for (int i = 0; i < this.size; i++) {
             if (thisBuf[i] == ch) {
                 return true;
             }

             return -1;
         }
         char[] thisBuf = buffer;
        for (int i = startIndex; i < size; i++) {
             if (thisBuf[i] == ch) {
                 return i;
             }
"
222,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/lang/text/StrBuilder.java","@@ -1773,7 +1773,7 @@ public int indexOf(String str, int startIndex) {
             return -1;
         }
         char[] thisBuf = buffer;
      int len = thisBuf.length - strLen;
         outer:
         for (int i = startIndex; i < len; i++) {
             for (int j = 0; j < strLen; j++) {
","@@ -1773,7 +1773,7 @@ public int indexOf(String str, int startIndex) {
             return -1;
         }
         char[] thisBuf = buffer;
      int len = size - strLen + 1;
         outer:
         for (int i = startIndex; i < len; i++) {
             for (int j = 0; j < strLen; j++) {
","
             return -1;
         }
         char[] thisBuf = buffer;
        int len = thisBuf.length - strLen;
         outer:
         for (int i = startIndex; i < len; i++) {
             for (int j = 0; j < strLen; j++) {
","
             return -1;
         }
         char[] thisBuf = buffer;
        int len = size - strLen + 1;
         outer:
         for (int i = startIndex; i < len; i++) {
             for (int j = 0; j < strLen; j++) {
"
223,"junit.framework.ComparisonFailure","/src/java/org/apache/commons/lang/time/DurationFormatUtils.java","@@ -303,25 +303,20 @@ public static String formatPeriod(long startMillis, long endMillis, String forma
             days -= 1;
         }
         while (days < 0) {
          days += 31;
 //days += 31; // TODO: Need tests to show this is bad and the new code is good.
 // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is 
 // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.
 // Also it's contextual - if asked for no M in the format then I should probably 
 // be doing no calculating here.
             months -= 1;
         }
         while (months < 0) {
             months += 12;
             years -= 1;
         }
      milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);
      seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);
      minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);
      hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);
      days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);
      months -= reduceAndCorrect(start, end, Calendar.MONTH, months);
      years -= reduceAndCorrect(start, end, Calendar.YEAR, years);
 
         // This next block of code adds in values that 
         // aren't requested. This allows the user to ask for the 
@@ -429,18 +424,6 @@ static String format(Token[] tokens, int years, int months, int days, int hours,
         }
         return buffer.toString();
     }
  static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {
      end.add( field, -1 * difference );
      int endValue = end.get(field);
      int startValue = start.get(field);
      if (endValue < startValue) {
          int newdiff = startValue - endValue;
          end.add( field, newdiff );
          return newdiff;
      } else {
          return 0;
      }
  }
 
     static final Object y = ""y"";
     static final Object M = ""M"";
","@@ -303,25 +303,20 @@ public static String formatPeriod(long startMillis, long endMillis, String forma
             days -= 1;
         }
         while (days < 0) {
          end.add(Calendar.MONTH, -1);
          days += end.getActualMaximum(Calendar.DAY_OF_MONTH);
 //days += 31; // TODO: Need tests to show this is bad and the new code is good.
 // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is 
 // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.
 // Also it's contextual - if asked for no M in the format then I should probably 
 // be doing no calculating here.
             months -= 1;
          end.add(Calendar.MONTH, 1);
         }
         while (months < 0) {
             months += 12;
             years -= 1;
         }
 
         // This next block of code adds in values that 
         // aren't requested. This allows the user to ask for the 
@@ -429,18 +424,6 @@ static String format(Token[] tokens, int years, int months, int days, int hours,
         }
         return buffer.toString();
     }
 
     static final Object y = ""y"";
     static final Object M = ""M"";
","
             days -= 1;
         }
         while (days < 0) {
            days += 31;
                  months -= 1;
         }
         while (months < 0) {
             months += 12;
             years -= 1;
         }
        milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);
        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);
        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);
        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);
        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);
        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);
        years -= reduceAndCorrect(start, end, Calendar.YEAR, years);
 
                  
         }
         return buffer.toString();
     }
    static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {
        end.add( field, -1 * difference );
        int endValue = end.get(field);
        int startValue = start.get(field);
        if (endValue < startValue) {
            int newdiff = startValue - endValue;
            end.add( field, newdiff );
            return newdiff;
        } else {
            return 0;
        }
    }
 
     static final Object y = ""y"";
     static final Object M = ""M"";
","
             days -= 1;
         }
         while (days < 0) {
            end.add(Calendar.MONTH, -1);
            days += end.getActualMaximum(Calendar.DAY_OF_MONTH);
                  months -= 1;
            end.add(Calendar.MONTH, 1);
         }
         while (months < 0) {
             months += 12;
             years -= 1;
         }
 
                  
         }
         return buffer.toString();
     }
 
     static final Object y = ""y"";
     static final Object M = ""M"";
"
224,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/lang/time/DateUtils.java","@@ -621,6 +621,9 @@ private static void modify(Calendar val, int field, boolean round) {
             throw new ArithmeticException(""Calendar value too large for accurate calculations"");
         }
         
 
         // ----------------- Fix for LANG-59 ---------------------- START ---------------
         // see http://issues.apache.org/jira/browse/LANG-59
@@ -628,14 +631,39 @@ private static void modify(Calendar val, int field, boolean round) {
         // Manually truncate milliseconds, seconds and minutes, rather than using
         // Calendar methods.
 
 
         // truncate milliseconds
 
         // truncate seconds
 
         // truncate minutes
 
         // reset time
         // ----------------- Fix for LANG-59 ----------------------- END ----------------
 
         boolean roundUp = false;
@@ -706,7 +734,9 @@ private static void modify(Calendar val, int field, boolean round) {
                 roundUp = offset > ((max - min) / 2);
             }
             //We need to remove this field
                 val.set(fields[i][0], val.get(fields[i][0]) - offset);
         }
         throw new IllegalArgumentException(""The field "" + field + "" is not supported"");
 
","@@ -621,6 +621,9 @@ private static void modify(Calendar val, int field, boolean round) {
             throw new ArithmeticException(""Calendar value too large for accurate calculations"");
         }
         
      if (field == Calendar.MILLISECOND) {
          return;
      }
 
         // ----------------- Fix for LANG-59 ---------------------- START ---------------
         // see http://issues.apache.org/jira/browse/LANG-59
@@ -628,14 +631,39 @@ private static void modify(Calendar val, int field, boolean round) {
         // Manually truncate milliseconds, seconds and minutes, rather than using
         // Calendar methods.
 
      Date date = val.getTime();
      long time = date.getTime();
      boolean done = false;
 
         // truncate milliseconds
      int millisecs = val.get(Calendar.MILLISECOND);
      if (!round || millisecs < 500) {
          time = time - millisecs;
          if (field == Calendar.SECOND) {
              done = true;
          }
      }
 
         // truncate seconds
      int seconds = val.get(Calendar.SECOND);
      if (!done && (!round || seconds < 30)) {
          time = time - (seconds * 1000L);
          if (field == Calendar.MINUTE) {
              done = true;
          }
      }
 
         // truncate minutes
      int minutes = val.get(Calendar.MINUTE);
      if (!done && (!round || minutes < 30)) {
          time = time - (minutes * 60000L);
      }
 
         // reset time
      if (date.getTime() != time) {
          date.setTime(time);
          val.setTime(date);
      }
         // ----------------- Fix for LANG-59 ----------------------- END ----------------
 
         boolean roundUp = false;
@@ -706,7 +734,9 @@ private static void modify(Calendar val, int field, boolean round) {
                 roundUp = offset > ((max - min) / 2);
             }
             //We need to remove this field
          if (offset != 0) {
                 val.set(fields[i][0], val.get(fields[i][0]) - offset);
          }
         }
         throw new IllegalArgumentException(""The field "" + field + "" is not supported"");
 
","
             throw new ArithmeticException(""Calendar value too large for accurate calculations"");
         }
         
 
                  
                   
 
          
          
          
                   
         boolean roundUp = false;

                 roundUp = offset > ((max - min) / 2);
             }
                              val.set(fields[i][0], val.get(fields[i][0]) - offset);
         }
         throw new IllegalArgumentException(""The field "" + field + "" is not supported"");
 
","
             throw new ArithmeticException(""Calendar value too large for accurate calculations"");
         }
         
        if (field == Calendar.MILLISECOND) {
            return;
        }
 
                  
                   
        Date date = val.getTime();
        long time = date.getTime();
        boolean done = false;
 
                 int millisecs = val.get(Calendar.MILLISECOND);
        if (!round || millisecs < 500) {
            time = time - millisecs;
            if (field == Calendar.SECOND) {
                done = true;
            }
        }
 
                 int seconds = val.get(Calendar.SECOND);
        if (!done && (!round || seconds < 30)) {
            time = time - (seconds * 1000L);
            if (field == Calendar.MINUTE) {
                done = true;
            }
        }
 
                 int minutes = val.get(Calendar.MINUTE);
        if (!done && (!round || minutes < 30)) {
            time = time - (minutes * 60000L);
        }
 
                 if (date.getTime() != time) {
            date.setTime(time);
            val.setTime(date);
        }
          
         boolean roundUp = false;

                 roundUp = offset > ((max - min) / 2);
             }
                         if (offset != 0) {
                 val.set(fields[i][0], val.get(fields[i][0]) - offset);
            }
         }
         throw new IllegalArgumentException(""The field "" + field + "" is not supported"");
 
"
225,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java","@@ -265,7 +265,7 @@ private double innerCumulativeProbability(int x0, int x1, int dx) {
      * size {@code n}, the mean is {@code n * m / N}.
      */
     public double getNumericalMean() {
      return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();
     }
 
     /**
","@@ -265,7 +265,7 @@ private double innerCumulativeProbability(int x0, int x1, int dx) {
      * size {@code n}, the mean is {@code n * m / N}.
      */
     public double getNumericalMean() {
      return getSampleSize() * (getNumberOfSuccesses() / (double) getPopulationSize());
     }
 
     /**
","
   
     public double getNumericalMean() {
        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();
     }
 
","
    
     public double getNumericalMean() {
        return getSampleSize() * (getNumberOfSuccesses() / (double) getPopulationSize());
     }
 
"
226,"org.apache.commons.math3.fraction.FractionConversionException","/src/main/java/org/apache/commons/math3/fraction/BigFraction.java","@@ -303,6 +303,9 @@ private BigFraction(final double value, final double epsilon,
             if ((p2 > overflow) || (q2 > overflow)) {
                 // in maxDenominator mode, if the last fraction was very close to the actual value
                 // q2 may overflow in the next iteration; in this case return the last one.
                 throw new FractionConversionException(value, p2, q2);
             }
 
/src/main/java/org/apache/commons/math3/fraction/Fraction.java @@ -212,6 +212,9 @@ private Fraction(double value, double epsilon, int maxDenominator, int maxIterat
             if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {
                 // in maxDenominator mode, if the last fraction was very close to the actual value
                 // q2 may overflow in the next iteration; in this case return the last one.
                 throw new FractionConversionException(value, p2, q2);
             }
 
","@@ -303,6 +303,9 @@ private BigFraction(final double value, final double epsilon,
             if ((p2 > overflow) || (q2 > overflow)) {
                 // in maxDenominator mode, if the last fraction was very close to the actual value
                 // q2 may overflow in the next iteration; in this case return the last one.
              if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) {
                  break;
              }
                 throw new FractionConversionException(value, p2, q2);
             }
 
/src/main/java/org/apache/commons/math3/fraction/Fraction.java @@ -212,6 +212,9 @@ private Fraction(double value, double epsilon, int maxDenominator, int maxIterat
             if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {
                 // in maxDenominator mode, if the last fraction was very close to the actual value
                 // q2 may overflow in the next iteration; in this case return the last one.
              if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) {
                  break;
              }
                 throw new FractionConversionException(value, p2, q2);
             }
 
","
             if ((p2 > overflow) || (q2 > overflow)) {
                                                   throw new FractionConversionException(value, p2, q2);
             }
 

             if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {
                                                   throw new FractionConversionException(value, p2, q2);
             }
 
","
             if ((p2 > overflow) || (q2 > overflow)) {
                                                  if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) {
                    break;
                }
                 throw new FractionConversionException(value, p2, q2);
             }
 

             if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {
                                                  if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) {
                    break;
                }
                 throw new FractionConversionException(value, p2, q2);
             }
 
"
227,"java.lang.ArrayIndexOutOfBoundsException","/src/main/java/org/apache/commons/math3/util/MathArrays.java","@@ -818,7 +818,10 @@ public static double linearCombination(final double[] a, final double[] b)
             throw new DimensionMismatchException(len, b.length);
         }
 
             // Revert to scalar multiplication.
 
         final double[] prodHigh = new double[len];
         double prodLowSum = 0;
","@@ -818,7 +818,10 @@ public static double linearCombination(final double[] a, final double[] b)
             throw new DimensionMismatchException(len, b.length);
         }
 
      if (len == 1) {
             // Revert to scalar multiplication.
          return a[0] * b[0];
      }
 
         final double[] prodHigh = new double[len];
         double prodLowSum = 0;
","
             throw new DimensionMismatchException(len, b.length);
         }
 
              
         final double[] prodHigh = new double[len];
         double prodLowSum = 0;
","
             throw new DimensionMismatchException(len, b.length);
         }
 
        if (len == 1) {
                         return a[0] * b[0];
        }
 
         final double[] prodHigh = new double[len];
         double prodLowSum = 0;
"
228,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/complex/Complex.java","@@ -302,7 +302,7 @@ public Complex reciprocal() {
         }
 
         if (real == 0.0 && imaginary == 0.0) {
          return NaN;
         }
 
         if (isInfinite) {
","@@ -302,7 +302,7 @@ public Complex reciprocal() {
         }
 
         if (real == 0.0 && imaginary == 0.0) {
          return INF;
         }
 
         if (isInfinite) {
","
         }
 
         if (real == 0.0 && imaginary == 0.0) {
            return NaN;
         }
 
         if (isInfinite) {
","
         }
 
         if (real == 0.0 && imaginary == 0.0) {
            return INF;
         }
 
         if (isInfinite) {
"
229,"java.lang.ArrayStoreException","/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java","@@ -178,13 +178,13 @@ public T sample() {
      * @throws NotStrictlyPositiveException if {@code sampleSize} is not
      * positive.
      */
  public T[] sample(int sampleSize) throws NotStrictlyPositiveException {
         if (sampleSize <= 0) {
             throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,
                     sampleSize);
         }
 
      final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);
 
         for (int i = 0; i < sampleSize; i++) {
             out[i] = sample();
","@@ -178,13 +178,13 @@ public T sample() {
      * @throws NotStrictlyPositiveException if {@code sampleSize} is not
      * positive.
      */
  public Object[] sample(int sampleSize) throws NotStrictlyPositiveException {
         if (sampleSize <= 0) {
             throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,
                     sampleSize);
         }
 
      final Object[] out = new Object[sampleSize];
 
         for (int i = 0; i < sampleSize; i++) {
             out[i] = sample();
","
         if (sampleSize <= 0) {
             throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,
                     sampleSize);
         }
 
        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);
 
         for (int i = 0; i < sampleSize; i++) {
             out[i] = sample();
","
  
    public Object[] sample(int sampleSize) throws NotStrictlyPositiveException {
         if (sampleSize <= 0) {
             throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,
                     sampleSize);
         }
 
        final Object[] out = new Object[sampleSize];
 
         for (int i = 0; i < sampleSize; i++) {
             out[i] = sample();
"
230,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java","@@ -180,7 +180,7 @@ public double density(final double[] vals) throws DimensionMismatchException {
             throw new DimensionMismatchException(vals.length, dim);
         }
 
      return FastMath.pow(2 * FastMath.PI, -dim / 2) *
             FastMath.pow(covarianceMatrixDeterminant, -0.5) *
             getExponentTerm(vals);
     }
","@@ -180,7 +180,7 @@ public double density(final double[] vals) throws DimensionMismatchException {
             throw new DimensionMismatchException(vals.length, dim);
         }
 
      return FastMath.pow(2 * FastMath.PI, -0.5 * dim) *
             FastMath.pow(covarianceMatrixDeterminant, -0.5) *
             getExponentTerm(vals);
     }
","
             throw new DimensionMismatchException(vals.length, dim);
         }
 
        return FastMath.pow(2 * FastMath.PI, -dim / 2) *
             FastMath.pow(covarianceMatrixDeterminant, -0.5) *
             getExponentTerm(vals);
     }
","
             throw new DimensionMismatchException(vals.length, dim);
         }
 
        return FastMath.pow(2 * FastMath.PI, -0.5 * dim) *
             FastMath.pow(covarianceMatrixDeterminant, -0.5) *
             getExponentTerm(vals);
     }
"
231,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java","@@ -48,7 +48,7 @@ protected BaseOptimizer(ConvergenceChecker<PAIR> checker) {
         this.checker = checker;
 
         evaluations = new Incrementor(0, new MaxEvalCallback());
      iterations = new Incrementor(0, new MaxIterCallback());
     }
 
     /**
/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java @@ -211,16 +211,15 @@ protected PointValuePair doOptimize() {
         }
 
         PointValuePair current = null;
      int iter = 0;
         int maxEval = getMaxEvaluations();
         while (true) {
          ++iter;
 
             final double objective = computeObjectiveValue(point);
             PointValuePair previous = current;
             current = new PointValuePair(point, objective);
             if (previous != null) {
              if (checker.converged(iter, previous, current)) {
                     // We have found an optimum.
                     return current;
                 }
@@ -274,7 +273,7 @@ protected PointValuePair doOptimize() {
             steepestDescent = newSteepestDescent;
 
             // Compute conjugate search direction.
          if (iter % n == 0 ||
                 beta < 0) {
                 // Break conjugation: reset search direction.
                 searchDirection = steepestDescent.clone();
/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java @@ -385,6 +385,7 @@ protected PointValuePair doOptimize() {
 
         generationLoop:
         for (iterations = 1; iterations <= maxIterations; iterations++) {
 
             // Generate and evaluate lambda offspring
             final RealMatrix arz = randn1(dimension, lambda);
/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java @@ -188,9 +188,8 @@ protected PointValuePair doOptimize() {
         double[] x = guess;
         double fVal = computeObjectiveValue(x);
         double[] x1 = x.clone();
      int iter = 0;
         while (true) {
          ++iter;
 
             double fX = fVal;
             double fX2 = 0;
@@ -224,7 +223,7 @@ protected PointValuePair doOptimize() {
             final PointValuePair current = new PointValuePair(x, fVal);
             if (!stop) { // User-defined stopping criteria.
                 if (checker != null) {
                  stop = checker.converged(iter, previous, current);
                 }
             }
             if (stop) {
/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java @@ -155,7 +155,7 @@ public int compare(final PointValuePair o1,
         int iteration = 0;
         final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
         while (true) {
          if (iteration > 0) {
                 boolean converged = true;
                 for (int i = 0; i < simplex.getSize(); i++) {
                     PointValuePair prev = previous[i];
@@ -172,7 +172,7 @@ public int compare(final PointValuePair o1,
             previous = simplex.getPoints();
             simplex.iterate(evalFunc, comparator);
 
		++iteration;
         }
     }
 
/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java @@ -103,9 +103,8 @@ public PointVectorValuePair doOptimize() {
 
         // iterate until convergence is reached
         PointVectorValuePair current = null;
      int iter = 0;
         for (boolean converged = false; !converged;) {
          ++iter;
 
             // evaluate the objective function and its jacobian
             PointVectorValuePair previous = current;
@@ -157,7 +156,7 @@ public PointVectorValuePair doOptimize() {
 
             // Check convergence.
             if (previous != null) {
              converged = checker.converged(iter, previous, current);
                 if (converged) {
                     setCost(computeCost(currentResiduals));
                     return current;
/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java @@ -319,10 +319,10 @@ protected PointVectorValuePair doOptimize() {
         // Outer loop.
         lmPar = 0;
         boolean firstIteration = true;
      int iter = 0;
         final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();
         while (true) {
          ++iter;

             final PointVectorValuePair previous = current;
 
             // QR decomposition of the jacobian matrix
@@ -486,7 +486,7 @@ protected PointVectorValuePair doOptimize() {
                     // tests for convergence.
                     if (checker != null) {
                         // we use the vectorial convergence checker
                      if (checker.converged(iter, previous, current)) {
                             setCost(currentCost);
                             return current;
                         }
","@@ -48,7 +48,7 @@ protected BaseOptimizer(ConvergenceChecker<PAIR> checker) {
         this.checker = checker;
 
         evaluations = new Incrementor(0, new MaxEvalCallback());
      iterations = new Incrementor(Integer.MAX_VALUE, new MaxIterCallback());
     }
 
     /**
/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java @@ -211,16 +211,15 @@ protected PointValuePair doOptimize() {
         }
 
         PointValuePair current = null;
         int maxEval = getMaxEvaluations();
         while (true) {
          incrementIterationCount();
 
             final double objective = computeObjectiveValue(point);
             PointValuePair previous = current;
             current = new PointValuePair(point, objective);
             if (previous != null) {
              if (checker.converged(getIterations(), previous, current)) {
                     // We have found an optimum.
                     return current;
                 }
@@ -274,7 +273,7 @@ protected PointValuePair doOptimize() {
             steepestDescent = newSteepestDescent;
 
             // Compute conjugate search direction.
          if (getIterations() % n == 0 ||
                 beta < 0) {
                 // Break conjugation: reset search direction.
                 searchDirection = steepestDescent.clone();
/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java @@ -385,6 +385,7 @@ protected PointValuePair doOptimize() {
 
         generationLoop:
         for (iterations = 1; iterations <= maxIterations; iterations++) {
          incrementIterationCount();
 
             // Generate and evaluate lambda offspring
             final RealMatrix arz = randn1(dimension, lambda);
/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java @@ -188,9 +188,8 @@ protected PointValuePair doOptimize() {
         double[] x = guess;
         double fVal = computeObjectiveValue(x);
         double[] x1 = x.clone();
         while (true) {
          incrementIterationCount();
 
             double fX = fVal;
             double fX2 = 0;
@@ -224,7 +223,7 @@ protected PointValuePair doOptimize() {
             final PointValuePair current = new PointValuePair(x, fVal);
             if (!stop) { // User-defined stopping criteria.
                 if (checker != null) {
                  stop = checker.converged(getIterations(), previous, current);
                 }
             }
             if (stop) {
/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java @@ -155,7 +155,7 @@ public int compare(final PointValuePair o1,
         int iteration = 0;
         final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
         while (true) {
          if (getIterations() > 0) {
                 boolean converged = true;
                 for (int i = 0; i < simplex.getSize(); i++) {
                     PointValuePair prev = previous[i];
@@ -172,7 +172,7 @@ public int compare(final PointValuePair o1,
             previous = simplex.getPoints();
             simplex.iterate(evalFunc, comparator);
 
          incrementIterationCount();
         }
     }
 
/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java @@ -103,9 +103,8 @@ public PointVectorValuePair doOptimize() {
 
         // iterate until convergence is reached
         PointVectorValuePair current = null;
         for (boolean converged = false; !converged;) {
          incrementIterationCount();
 
             // evaluate the objective function and its jacobian
             PointVectorValuePair previous = current;
@@ -157,7 +156,7 @@ public PointVectorValuePair doOptimize() {
 
             // Check convergence.
             if (previous != null) {
              converged = checker.converged(getIterations(), previous, current);
                 if (converged) {
                     setCost(computeCost(currentResiduals));
                     return current;
/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java @@ -319,10 +319,10 @@ protected PointVectorValuePair doOptimize() {
         // Outer loop.
         lmPar = 0;
         boolean firstIteration = true;
         final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();
         while (true) {
          incrementIterationCount();

             final PointVectorValuePair previous = current;
 
             // QR decomposition of the jacobian matrix
@@ -486,7 +486,7 @@ protected PointVectorValuePair doOptimize() {
                     // tests for convergence.
                     if (checker != null) {
                         // we use the vectorial convergence checker
                      if (checker.converged(getIterations(), previous, current)) {
                             setCost(currentCost);
                             return current;
                         }
","
         this.checker = checker;
 
         evaluations = new Incrementor(0, new MaxEvalCallback());
        iterations = new Incrementor(0, new MaxIterCallback());
     }
 

         }
 
         PointValuePair current = null;
        int iter = 0;
         int maxEval = getMaxEvaluations();
         while (true) {
            ++iter;
 
             final double objective = computeObjectiveValue(point);
             PointValuePair previous = current;
             current = new PointValuePair(point, objective);
             if (previous != null) {
                if (checker.converged(iter, previous, current)) {
                                          return current;
                 }

             steepestDescent = newSteepestDescent;
 
                         if (iter % n == 0 ||
                 beta < 0) {
                                  searchDirection = steepestDescent.clone();

 
         generationLoop:
         for (iterations = 1; iterations <= maxIterations; iterations++) {
 
                          final RealMatrix arz = randn1(dimension, lambda);

         double[] x = guess;
         double fVal = computeObjectiveValue(x);
         double[] x1 = x.clone();
        int iter = 0;
         while (true) {
            ++iter;
 
             double fX = fVal;
             double fX2 = 0;

             final PointValuePair current = new PointValuePair(x, fVal);
             if (!stop) {                  if (checker != null) {
                    stop = checker.converged(iter, previous, current);
                 }
             }
             if (stop) {

         int iteration = 0;
         final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
         while (true) {
            if (iteration > 0) {
                 boolean converged = true;
                 for (int i = 0; i < simplex.getSize(); i++) {
                     PointValuePair prev = previous[i];

             previous = simplex.getPoints();
             simplex.iterate(evalFunc, comparator);
 
-			++iteration;
         }
     }
 

 
                  PointVectorValuePair current = null;
        int iter = 0;
         for (boolean converged = false; !converged;) {
            ++iter;
 
                          PointVectorValuePair previous = current;

 
                          if (previous != null) {
                converged = checker.converged(iter, previous, current);
                 if (converged) {
                     setCost(computeCost(currentResiduals));
                     return current;

                  lmPar = 0;
         boolean firstIteration = true;
        int iter = 0;
         final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();
         while (true) {
            ++iter;
+
             final PointVectorValuePair previous = current;
 
             
                                          if (checker != null) {
                                                 if (checker.converged(iter, previous, current)) {
                             setCost(currentCost);
                             return current;
                         }
","
         this.checker = checker;
 
         evaluations = new Incrementor(0, new MaxEvalCallback());
        iterations = new Incrementor(Integer.MAX_VALUE, new MaxIterCallback());
     }
 

         }
 
         PointValuePair current = null;
         int maxEval = getMaxEvaluations();
         while (true) {
            incrementIterationCount();
 
             final double objective = computeObjectiveValue(point);
             PointValuePair previous = current;
             current = new PointValuePair(point, objective);
             if (previous != null) {
                if (checker.converged(getIterations(), previous, current)) {
                                          return current;
                 }

             steepestDescent = newSteepestDescent;
 
                         if (getIterations() % n == 0 ||
                 beta < 0) {
                                  searchDirection = steepestDescent.clone();

 
         generationLoop:
         for (iterations = 1; iterations <= maxIterations; iterations++) {
            incrementIterationCount();
 
                          final RealMatrix arz = randn1(dimension, lambda);

         double[] x = guess;
         double fVal = computeObjectiveValue(x);
         double[] x1 = x.clone();
         while (true) {
            incrementIterationCount();
 
             double fX = fVal;
             double fX2 = 0;

             final PointValuePair current = new PointValuePair(x, fVal);
             if (!stop) {                  if (checker != null) {
                    stop = checker.converged(getIterations(), previous, current);
                 }
             }
             if (stop) {

         int iteration = 0;
         final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
         while (true) {
            if (getIterations() > 0) {
                 boolean converged = true;
                 for (int i = 0; i < simplex.getSize(); i++) {
                     PointValuePair prev = previous[i];

             previous = simplex.getPoints();
             simplex.iterate(evalFunc, comparator);
 
-			++iteration;
            incrementIterationCount();
         }
     }
 

 
                  PointVectorValuePair current = null;
         for (boolean converged = false; !converged;) {
            incrementIterationCount();
 
                          PointVectorValuePair previous = current;

 
                          if (previous != null) {
                converged = checker.converged(getIterations(), previous, current);
                 if (converged) {
                     setCost(computeCost(currentResiduals));
                     return current;

                  lmPar = 0;
         boolean firstIteration = true;
         final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();
         while (true) {
            incrementIterationCount();
+
             final PointVectorValuePair previous = current;
 
             
                                          if (checker != null) {
                                                 if (checker.converged(getIterations(), previous, current)) {
                             setCost(currentCost);
                             return current;
                         }
"
232,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java","@@ -1416,6 +1416,7 @@ public void atan2(final double[] y, final int yOffset,
         }
 
         // fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly
 
     }
 
","@@ -1416,6 +1416,7 @@ public void atan2(final double[] y, final int yOffset,
         }
 
         // fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly
      result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset]);
 
     }
 
","
         }
 
          
     }
 
","
         }
 
                 result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset]);
 
     }
 
"
233,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java","@@ -343,8 +343,10 @@ public int compare(EventState es0, EventState es1) {
                 final double[] eventY = interpolator.getInterpolatedState().clone();
 
                 // advance all event states to current time
              currentEvent.stepAccepted(eventT, eventY);
              isLastStep = currentEvent.stop();
 
                 // handle the first part of the step, up to the event
                 for (final StepHandler handler : stepHandlers) {
@@ -354,22 +356,19 @@ public int compare(EventState es0, EventState es1) {
                 if (isLastStep) {
                     // the event asked to stop integration
                     System.arraycopy(eventY, 0, y, 0, y.length);
                  for (final EventState remaining : occuringEvents) {
                      remaining.stepAccepted(eventT, eventY);
                  }
                     return eventT;
                 }
 
              boolean needReset = currentEvent.reset(eventT, eventY);
                 if (needReset) {
                     // some event handler has triggered changes that
                     // invalidate the derivatives, we need to recompute them
                     System.arraycopy(eventY, 0, y, 0, y.length);
                     computeDerivatives(eventT, y, yDot);
                     resetOccurred = true;
                  for (final EventState remaining : occuringEvents) {
                      remaining.stepAccepted(eventT, eventY);
                  }
                     return eventT;
                 }
 
","@@ -343,8 +343,10 @@ public int compare(EventState es0, EventState es1) {
                 final double[] eventY = interpolator.getInterpolatedState().clone();
 
                 // advance all event states to current time
              for (final EventState state : eventsStates) {
                  state.stepAccepted(eventT, eventY);
                  isLastStep = isLastStep || state.stop();
              }
 
                 // handle the first part of the step, up to the event
                 for (final StepHandler handler : stepHandlers) {
@@ -354,22 +356,19 @@ public int compare(EventState es0, EventState es1) {
                 if (isLastStep) {
                     // the event asked to stop integration
                     System.arraycopy(eventY, 0, y, 0, y.length);
                     return eventT;
                 }
 
              boolean needReset = false;
              for (final EventState state : eventsStates) {
                  needReset =  needReset || state.reset(eventT, eventY);
              }
                 if (needReset) {
                     // some event handler has triggered changes that
                     // invalidate the derivatives, we need to recompute them
                     System.arraycopy(eventY, 0, y, 0, y.length);
                     computeDerivatives(eventT, y, yDot);
                     resetOccurred = true;
                     return eventT;
                 }
 
","
                 final double[] eventY = interpolator.getInterpolatedState().clone();
 
                                 currentEvent.stepAccepted(eventT, eventY);
                isLastStep = currentEvent.stop();
 
                                  for (final StepHandler handler : stepHandlers) {

                 if (isLastStep) {
                                          System.arraycopy(eventY, 0, y, 0, y.length);
                    for (final EventState remaining : occuringEvents) {
                        remaining.stepAccepted(eventT, eventY);
                    }
                     return eventT;
                 }
 
                boolean needReset = currentEvent.reset(eventT, eventY);
                 if (needReset) {
                                                               System.arraycopy(eventY, 0, y, 0, y.length);
                     computeDerivatives(eventT, y, yDot);
                     resetOccurred = true;
                    for (final EventState remaining : occuringEvents) {
                        remaining.stepAccepted(eventT, eventY);
                    }
                     return eventT;
                 }
 
","
                 final double[] eventY = interpolator.getInterpolatedState().clone();
 
                                 for (final EventState state : eventsStates) {
                    state.stepAccepted(eventT, eventY);
                    isLastStep = isLastStep || state.stop();
                }
 
                                  for (final StepHandler handler : stepHandlers) {

                 if (isLastStep) {
                                          System.arraycopy(eventY, 0, y, 0, y.length);
                     return eventT;
                 }
 
                boolean needReset = false;
                for (final EventState state : eventsStates) {
                    needReset =  needReset || state.reset(eventT, eventY);
                }
                 if (needReset) {
                                                               System.arraycopy(eventY, 0, y, 0, y.length);
                     computeDerivatives(eventT, y, yDot);
                     resetOccurred = true;
                     return eventT;
                 }
 
"
234,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java","@@ -16,6 +16,7 @@
  */
 package org.apache.commons.math3.random;
 
 import java.io.Serializable;
 
 import org.apache.commons.math3.exception.NotStrictlyPositiveException;
 import org.apache.commons.math3.util.FastMath;
@@ -26,8 +27,10 @@
  * @since 2.0
  */
 public abstract class BitsStreamGenerator
  implements RandomGenerator {
     /** Serializable version identifier */
     /** Next gaussian. */
     private double nextGaussian;
 
","@@ -16,6 +16,7 @@
  */
 package org.apache.commons.math3.random;
 
 import java.io.Serializable;
 
 import org.apache.commons.math3.exception.NotStrictlyPositiveException;
 import org.apache.commons.math3.util.FastMath;
@@ -26,8 +27,10 @@
  * @since 2.0
  */
 public abstract class BitsStreamGenerator
  implements RandomGenerator,
             Serializable {
     /** Serializable version identifier */
  private static final long serialVersionUID = 20130104L;
     /** Next gaussian. */
     private double nextGaussian;
 
","
 package org.apache.commons.math3.random;
 
 import java.io.Serializable;
 
 import org.apache.commons.math3.exception.NotStrictlyPositiveException;
 import org.apache.commons.math3.util.FastMath;

    implements RandomGenerator {
     private double nextGaussian;
 
","
  
 package org.apache.commons.math3.random;
 
 import java.io.Serializable;
 
 import org.apache.commons.math3.exception.NotStrictlyPositiveException;
 import org.apache.commons.math3.util.FastMath;

 public abstract class BitsStreamGenerator
    implements RandomGenerator,
               Serializable {
     
    private static final long serialVersionUID = 20130104L;
          private double nextGaussian;
 
"
235,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java","@@ -84,7 +84,8 @@ public void reset(final Vector3D p1, final Vector3D p2) throws MathIllegalArgume
      * @return a new instance, with reversed direction
      */
     public Line revert() {
      final Line reverted = new Line(zero, zero.subtract(direction));
         return reverted;
     }
 
","@@ -84,7 +84,8 @@ public void reset(final Vector3D p1, final Vector3D p2) throws MathIllegalArgume
      * @return a new instance, with reversed direction
      */
     public Line revert() {
      final Line reverted = new Line(this);
      reverted.direction = reverted.direction.negate();
         return reverted;
     }
 
","
        final Line reverted = new Line(zero, zero.subtract(direction));
         return reverted;
     }
 
","
    
     public Line revert() {
        final Line reverted = new Line(this);
        reverted.direction = reverted.direction.negate();
         return reverted;
     }
 
"
236,"java.lang.NullPointerException","/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java","@@ -111,6 +111,9 @@ public Vector3D intersection(final SubLine subLine, final boolean includeEndPoin
 
         // compute the intersection on infinite line
         Vector3D v1D = line.intersection(subLine.line);
 
         // check location of point with respect to first sub-line
         Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));
/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java @@ -115,6 +115,9 @@ public Vector2D intersection(final SubLine subLine, final boolean includeEndPoin
 
         // compute the intersection on infinite line
         Vector2D v2D = line1.intersection(line2);
 
         // check location of point with respect to first sub-line
         Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));
","@@ -111,6 +111,9 @@ public Vector3D intersection(final SubLine subLine, final boolean includeEndPoin
 
         // compute the intersection on infinite line
         Vector3D v1D = line.intersection(subLine.line);
      if (v1D == null) {
          return null;
      }
 
         // check location of point with respect to first sub-line
         Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));
/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/SubLine.java @@ -115,6 +115,9 @@ public Vector2D intersection(final SubLine subLine, final boolean includeEndPoin
 
         // compute the intersection on infinite line
         Vector2D v2D = line1.intersection(line2);
      if (v2D == null) {
          return null;
      }
 
         // check location of point with respect to first sub-line
         Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));
","
 
                  Vector3D v1D = line.intersection(subLine.line);
 
                  Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));

 
                  Vector2D v2D = line1.intersection(line2);
 
                  Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));
","
 
                  Vector3D v1D = line.intersection(subLine.line);
        if (v1D == null) {
            return null;
        }
 
                  Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));

 
                  Vector2D v2D = line1.intersection(line2);
        if (v2D == null) {
            return null;
        }
 
                  Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));
"
237,"java.lang.OutOfMemoryError","/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java","@@ -559,7 +559,16 @@ protected void setUp() {
      * @return the square-root of the weight matrix.
      */
     private RealMatrix squareRoot(RealMatrix m) {
             final EigenDecomposition dec = new EigenDecomposition(m);
             return dec.getSquareRoot();
     }
 }
","@@ -559,7 +559,16 @@ protected void setUp() {
      * @return the square-root of the weight matrix.
      */
     private RealMatrix squareRoot(RealMatrix m) {
      if (m instanceof DiagonalMatrix) {
          final int dim = m.getRowDimension();
          final RealMatrix sqrtM = new DiagonalMatrix(dim);
          for (int i = 0; i < dim; i++) {
             sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));
          }
          return sqrtM;
      } else {
             final EigenDecomposition dec = new EigenDecomposition(m);
             return dec.getSquareRoot();
      }
     }
 }
","
     
     private RealMatrix squareRoot(RealMatrix m) {
             final EigenDecomposition dec = new EigenDecomposition(m);
             return dec.getSquareRoot();
     }
 }
","
  
     private RealMatrix squareRoot(RealMatrix m) {
        if (m instanceof DiagonalMatrix) {
            final int dim = m.getRowDimension();
            final RealMatrix sqrtM = new DiagonalMatrix(dim);
            for (int i = 0; i < dim; i++) {
               sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));
            }
            return sqrtM;
        } else {
             final EigenDecomposition dec = new EigenDecomposition(m);
             return dec.getSquareRoot();
        }
     }
 }
"
238,"java.lang.OutOfMemoryError","/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/Weight.java","@@ -40,10 +40,7 @@
      */
     public Weight(double[] weight) {
         final int dim = weight.length;
      weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(dim, dim);
      for (int i = 0; i < dim; i++) {
          weightMatrix.setEntry(i, i, weight[i]);
      }
     }
 
     /**
/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java @@ -264,7 +264,16 @@ private void parseOptimizationData(OptimizationData... optData) {
      * @return the square-root of the weight matrix.
      */
     private RealMatrix squareRoot(RealMatrix m) {
             final EigenDecomposition dec = new EigenDecomposition(m);
             return dec.getSquareRoot();
     }
 }
","@@ -40,10 +40,7 @@
      */
     public Weight(double[] weight) {
         final int dim = weight.length;
      weightMatrix = new DiagonalMatrix(weight);
     }
 
     /**
/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java @@ -264,7 +264,16 @@ private void parseOptimizationData(OptimizationData... optData) {
      * @return the square-root of the weight matrix.
      */
     private RealMatrix squareRoot(RealMatrix m) {
      if (m instanceof DiagonalMatrix) {
          final int dim = m.getRowDimension();
          final RealMatrix sqrtM = new DiagonalMatrix(dim);
          for (int i = 0; i < dim; i++) {
              sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));
          }
          return sqrtM;
      } else {
             final EigenDecomposition dec = new EigenDecomposition(m);
             return dec.getSquareRoot();
      }
     }
 }
","
      
     public Weight(double[] weight) {
         final int dim = weight.length;
        weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(dim, dim);
        for (int i = 0; i < dim; i++) {
            weightMatrix.setEntry(i, i, weight[i]);
        }
     }
 

    
     private RealMatrix squareRoot(RealMatrix m) {
             final EigenDecomposition dec = new EigenDecomposition(m);
             return dec.getSquareRoot();
     }
 }
","
      
     public Weight(double[] weight) {
         final int dim = weight.length;
        weightMatrix = new DiagonalMatrix(weight);
     }
 

  
     private RealMatrix squareRoot(RealMatrix m) {
        if (m instanceof DiagonalMatrix) {
            final int dim = m.getRowDimension();
            final RealMatrix sqrtM = new DiagonalMatrix(dim);
            for (int i = 0; i < dim; i++) {
                sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));
            }
            return sqrtM;
        } else {
             final EigenDecomposition dec = new EigenDecomposition(m);
             return dec.getSquareRoot();
        }
     }
 }
"
239,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/util/FastMath.java","@@ -310,6 +310,7 @@
     /** 2^52 - double numbers this large must be integral (no fraction) or NaN or Infinite */
     private static final double TWO_POWER_52 = 4503599627370496.0;
     /** 2^53 - double numbers this large must be even. */
 
     /** Constant: {@value}. */
     private static final double F_1_3 = 1d / 3d;
@@ -1538,7 +1539,7 @@ public static double pow(double x, double y) {
         /* Handle special case x<0 */
         if (x < 0) {
             // y is an even integer in this case
          if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {
                 return pow(-x, y);
             }
 
","@@ -310,6 +310,7 @@
     /** 2^52 - double numbers this large must be integral (no fraction) or NaN or Infinite */
     private static final double TWO_POWER_52 = 4503599627370496.0;
     /** 2^53 - double numbers this large must be even. */
  private static final double TWO_POWER_53 = 2 * TWO_POWER_52;
 
     /** Constant: {@value}. */
     private static final double F_1_3 = 1d / 3d;
@@ -1538,7 +1539,7 @@ public static double pow(double x, double y) {
         /* Handle special case x<0 */
         if (x < 0) {
             // y is an even integer in this case
          if (y >= TWO_POWER_53 || y <= -TWO_POWER_53) {
                 return pow(-x, y);
             }
 
","
     private static final double TWO_POWER_52 = 4503599627370496.0;
 
     private static final double F_1_3 = 1d / 3d;

         if (x < 0) {
                         if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {
                 return pow(-x, y);
             }
 
","
     private static final double TWO_POWER_52 = 4503599627370496.0;
    private static final double TWO_POWER_53 = 2 * TWO_POWER_52;
 
     private static final double F_1_3 = 1d / 3d;

         if (x < 0) {
                         if (y >= TWO_POWER_53 || y <= -TWO_POWER_53) {
                 return pow(-x, y);
             }
 
"
240,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/dfp/Dfp.java","@@ -1600,7 +1600,11 @@ public Dfp multiply(final Dfp x) {
      * @return product of this and x
      */
     public Dfp multiply(final int x) {
             return multiplyFast(x);
     }
 
     /** Multiply this by a single digit 0&lt;=x&lt;radix.
","@@ -1600,7 +1600,11 @@ public Dfp multiply(final Dfp x) {
      * @return product of this and x
      */
     public Dfp multiply(final int x) {
      if (x >= 0 && x < RADIX) {
             return multiplyFast(x);
      } else {
          return multiply(newInstance(x));
      }
     }
 
     /** Multiply this by a single digit 0&lt;=x&lt;radix.
","
             return multiplyFast(x);
     }
 
","
  
     public Dfp multiply(final int x) {
        if (x >= 0 && x < RADIX) {
             return multiplyFast(x);
        } else {
            return multiply(newInstance(x));
        }
     }
 
"
241,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/distribution/FDistribution.java","@@ -272,7 +272,7 @@ public double getSupportUpperBound() {
 
     /** {@inheritDoc} */
     public boolean isSupportLowerBoundInclusive() {
      return true;
     }
 
     /** {@inheritDoc} */
/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java @@ -181,7 +181,7 @@ public boolean isSupportLowerBoundInclusive() {
 
     /** {@inheritDoc} */
     public boolean isSupportUpperBoundInclusive() {
      return false;
     }
 
     /**
","@@ -272,7 +272,7 @@ public double getSupportUpperBound() {
 
     /** {@inheritDoc} */
     public boolean isSupportLowerBoundInclusive() {
      return false;
     }
 
     /** {@inheritDoc} */
/src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java @@ -181,7 +181,7 @@ public boolean isSupportLowerBoundInclusive() {
 
     /** {@inheritDoc} */
     public boolean isSupportUpperBoundInclusive() {
      return true;
     }
 
     /**
","
 
     public boolean isSupportLowerBoundInclusive() {
        return true;
     }
 

 
     public boolean isSupportUpperBoundInclusive() {
        return false;
     }
 
","
 
     public boolean isSupportLowerBoundInclusive() {
        return false;
     }
 

 
     public boolean isSupportUpperBoundInclusive() {
        return true;
     }
 
"
242,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/util/FastMath.java","@@ -79,6 +79,7 @@
  */
 public class FastMath {
     /** StrictMath.log(Double.MAX_VALUE): {@value} */
 
     /** Archimede's constant PI, ratio of circle circumference to diameter. */
     public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;
@@ -391,12 +392,21 @@ public static double cosh(double x) {
       // exp(-z) can be ignored in comparison with exp(z)
 
       if (x > 20) {
               // Avoid overflow (MATH-905).
               return 0.5 * exp(x);
           }
    if (x < -20) {
               // Avoid overflow (MATH-905).
               return 0.5 * exp(-x);
       }
 
       final double hiPrec[] = new double[2];
@@ -452,12 +462,21 @@ public static double sinh(double x) {
       // exp(-z) can be ignored in comparison with exp(z)
 
       if (x > 20) {
               // Avoid overflow (MATH-905).
               return 0.5 * exp(x);
           }
    if (x < -20) {
               // Avoid overflow (MATH-905).
               return -0.5 * exp(-x);
       }
 
       if (x == 0) {
","@@ -79,6 +79,7 @@
  */
 public class FastMath {
     /** StrictMath.log(Double.MAX_VALUE): {@value} */
  private static final double LOG_MAX_VALUE = StrictMath.log(Double.MAX_VALUE);
 
     /** Archimede's constant PI, ratio of circle circumference to diameter. */
     public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;
@@ -391,12 +392,21 @@ public static double cosh(double x) {
       // exp(-z) can be ignored in comparison with exp(z)
 
       if (x > 20) {
        if (x >= LOG_MAX_VALUE) {
               // Avoid overflow (MATH-905).
            final double t = exp(0.5 * x);
            return (0.5 * t) * t;
        } else {
               return 0.5 * exp(x);
           }
    } else if (x < -20) {
        if (x <= -LOG_MAX_VALUE) {
               // Avoid overflow (MATH-905).
            final double t = exp(-0.5 * x);
            return (0.5 * t) * t;
        } else {
               return 0.5 * exp(-x);
        }
       }
 
       final double hiPrec[] = new double[2];
@@ -452,12 +462,21 @@ public static double sinh(double x) {
       // exp(-z) can be ignored in comparison with exp(z)
 
       if (x > 20) {
        if (x >= LOG_MAX_VALUE) {
               // Avoid overflow (MATH-905).
            final double t = exp(0.5 * x);
            return (0.5 * t) * t;
        } else {
               return 0.5 * exp(x);
           }
    } else if (x < -20) {
        if (x <= -LOG_MAX_VALUE) {
               // Avoid overflow (MATH-905).
            final double t = exp(-0.5 * x);
            return (-0.5 * t) * t;
        } else {
               return -0.5 * exp(-x);
        }
       }
 
       if (x == 0) {
","
  
 public class FastMath {
     public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;

        
       if (x > 20) {
                              return 0.5 * exp(x);
           }
      if (x < -20) {
                              return 0.5 * exp(-x);
       }
 
       final double hiPrec[] = new double[2];

        
       if (x > 20) {
                              return 0.5 * exp(x);
           }
      if (x < -20) {
                              return -0.5 * exp(-x);
       }
 
       if (x == 0) {
","
  
 public class FastMath {
    private static final double LOG_MAX_VALUE = StrictMath.log(Double.MAX_VALUE);
 
     public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;

        
       if (x > 20) {
          if (x >= LOG_MAX_VALUE) {
                             final double t = exp(0.5 * x);
              return (0.5 * t) * t;
          } else {
               return 0.5 * exp(x);
           }
      } else if (x < -20) {
          if (x <= -LOG_MAX_VALUE) {
                             final double t = exp(-0.5 * x);
              return (0.5 * t) * t;
          } else {
               return 0.5 * exp(-x);
          }
       }
 
       final double hiPrec[] = new double[2];

        
       if (x > 20) {
          if (x >= LOG_MAX_VALUE) {
                             final double t = exp(0.5 * x);
              return (0.5 * t) * t;
          } else {
               return 0.5 * exp(x);
           }
      } else if (x < -20) {
          if (x <= -LOG_MAX_VALUE) {
                             final double t = exp(-0.5 * x);
              return (-0.5 * t) * t;
          } else {
               return -0.5 * exp(-x);
          }
       }
 
       if (x == 0) {
"
243,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java","@@ -929,7 +929,7 @@ public FitnessFunction() {
             double[] res = new double[x.length];
             for (int i = 0; i < x.length; i++) {
                 double diff = boundaries[1][i] - boundaries[0][i];
              res[i] = (x[i] - boundaries[0][i]) / diff;
             }
             return res;
         }
@@ -955,7 +955,7 @@ public FitnessFunction() {
             double[] res = new double[x.length];
             for (int i = 0; i < x.length; i++) {
                 double diff = boundaries[1][i] - boundaries[0][i];
              res[i] = diff * x[i] + boundaries[0][i];
             }
             return res;
         }
@@ -987,12 +987,14 @@ public boolean isFeasible(final double[] x) {
                 return true;
             }
 
 
             for (int i = 0; i < x.length; i++) {
              if (x[i] < 0) {
                     return false;
                 }
              if (x[i] > 1.0) {
                     return false;
                 }
             }
","@@ -929,7 +929,7 @@ public FitnessFunction() {
             double[] res = new double[x.length];
             for (int i = 0; i < x.length; i++) {
                 double diff = boundaries[1][i] - boundaries[0][i];
              res[i] = x[i] / diff;
             }
             return res;
         }
@@ -955,7 +955,7 @@ public FitnessFunction() {
             double[] res = new double[x.length];
             for (int i = 0; i < x.length; i++) {
                 double diff = boundaries[1][i] - boundaries[0][i];
              res[i] = diff * x[i];
             }
             return res;
         }
@@ -987,12 +987,14 @@ public boolean isFeasible(final double[] x) {
                 return true;
             }
 
          final double[] bLoEnc = encode(boundaries[0]);
          final double[] bHiEnc = encode(boundaries[1]);
 
             for (int i = 0; i < x.length; i++) {
              if (x[i] < bLoEnc[i]) {
                     return false;
                 }
              if (x[i] > bHiEnc[i]) {
                     return false;
                 }
             }
","
             double[] res = new double[x.length];
             for (int i = 0; i < x.length; i++) {
                 double diff = boundaries[1][i] - boundaries[0][i];
                res[i] = (x[i] - boundaries[0][i]) / diff;
             }
             return res;
         }

             double[] res = new double[x.length];
             for (int i = 0; i < x.length; i++) {
                 double diff = boundaries[1][i] - boundaries[0][i];
                res[i] = diff * x[i] + boundaries[0][i];
             }
             return res;
         }

                 return true;
             }
 
 
             for (int i = 0; i < x.length; i++) {
                if (x[i] < 0) {
                     return false;
                 }
                if (x[i] > 1.0) {
                     return false;
                 }
             }
","
             double[] res = new double[x.length];
             for (int i = 0; i < x.length; i++) {
                 double diff = boundaries[1][i] - boundaries[0][i];
                res[i] = x[i] / diff;
             }
             return res;
         }

             double[] res = new double[x.length];
             for (int i = 0; i < x.length; i++) {
                 double diff = boundaries[1][i] - boundaries[0][i];
                res[i] = diff * x[i];
             }
             return res;
         }

                 return true;
             }
 
            final double[] bLoEnc = encode(boundaries[0]);
            final double[] bHiEnc = encode(boundaries[1]);
 
             for (int i = 0; i < x.length; i++) {
                if (x[i] < bLoEnc[i]) {
                     return false;
                 }
                if (x[i] > bHiEnc[i]) {
                     return false;
                 }
             }
"
244,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java","@@ -918,7 +918,8 @@ public FitnessFunction() {
          * @return the original objective variables, possibly repaired.
          */
         public double[] repairAndDecode(final double[] x) {
          return
                 decode(x);
         }
 
","@@ -918,7 +918,8 @@ public FitnessFunction() {
          * @return the original objective variables, possibly repaired.
          */
         public double[] repairAndDecode(final double[] x) {
          return boundaries != null && isRepairMode ?
              decode(repair(x)) :
                 decode(x);
         }
 
","
       
         public double[] repairAndDecode(final double[] x) {
            return
                 decode(x);
         }
 
","
      
         public double[] repairAndDecode(final double[] x) {
            return boundaries != null && isRepairMode ?
                decode(repair(x)) :
                 decode(x);
         }
 
"
245,"java.lang.Exception","/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java","@@ -537,6 +537,19 @@ private void checkParameters() {
                 boundaries[1] = uB;
 
                 // Abort early if the normalization will overflow (cf. ""encode"" method).

             }
         } else {
             // Convert API to internal handling of boundaries.
","@@ -537,6 +537,19 @@ private void checkParameters() {
                 boundaries[1] = uB;
 
                 // Abort early if the normalization will overflow (cf. ""encode"" method).
              for (int i = 0; i < lB.length; i++) {
                  if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {
                      final double max = Double.MAX_VALUE + boundaries[0][i];
                      final NumberIsTooLargeException e
                          = new NumberIsTooLargeException(boundaries[1][i],
                                                          max,
                                                          true);
                      e.getContext().addMessage(LocalizedFormats.OVERFLOW);
                      e.getContext().addMessage(LocalizedFormats.INDEX, i);

                      throw e;
                  }
              }
             }
         } else {
             // Convert API to internal handling of boundaries.
","
                 boundaries[1] = uB;
 
                 +
             }
         } else {
             ","
                 boundaries[1] = uB;
 
                                 for (int i = 0; i < lB.length; i++) {
                    if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {
                        final double max = Double.MAX_VALUE + boundaries[0][i];
                        final NumberIsTooLargeException e
                            = new NumberIsTooLargeException(boundaries[1][i],
                                                            max,
                                                            true);
                        e.getContext().addMessage(LocalizedFormats.OVERFLOW);
                        e.getContext().addMessage(LocalizedFormats.INDEX, i);
+
                        throw e;
                    }
                }
             }
         } else {
             "
246,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java","@@ -148,6 +148,7 @@ protected UnivariatePointValuePair doOptimize() {
         UnivariatePointValuePair current
             = new UnivariatePointValuePair(x, isMinim ? fx : -fx);
         // Best point encountered so far (which is the initial guess).
 
         int iter = 0;
         while (true) {
@@ -231,10 +232,15 @@ protected UnivariatePointValuePair doOptimize() {
                 // User-defined convergence checker.
                 previous = current;
                 current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);
 
                 if (checker != null) {
                     if (checker.converged(iter, previous, current)) {
                      return best(current, previous, isMinim);
                     }
                 }
 
@@ -271,9 +277,10 @@ protected UnivariatePointValuePair doOptimize() {
                     }
                 }
             } else { // Default termination (Brent's criterion).
              return
                             best(current,
                                  previous,
                             isMinim);
             }
             ++iter;
","@@ -148,6 +148,7 @@ protected UnivariatePointValuePair doOptimize() {
         UnivariatePointValuePair current
             = new UnivariatePointValuePair(x, isMinim ? fx : -fx);
         // Best point encountered so far (which is the initial guess).
      UnivariatePointValuePair best = current;
 
         int iter = 0;
         while (true) {
@@ -231,10 +232,15 @@ protected UnivariatePointValuePair doOptimize() {
                 // User-defined convergence checker.
                 previous = current;
                 current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);
              best = best(best,
                          best(current,
                               previous,
                               isMinim),
                          isMinim);
 
                 if (checker != null) {
                     if (checker.converged(iter, previous, current)) {
                      return best;
                     }
                 }
 
@@ -271,9 +277,10 @@ protected UnivariatePointValuePair doOptimize() {
                     }
                 }
             } else { // Default termination (Brent's criterion).
              return best(best,
                             best(current,
                                  previous,
                               isMinim),
                             isMinim);
             }
             ++iter;
","
         UnivariatePointValuePair current
             = new UnivariatePointValuePair(x, isMinim ? fx : -fx);
          
         int iter = 0;
         while (true) {

                                  previous = current;
                 current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);
 
                 if (checker != null) {
                     if (checker.converged(iter, previous, current)) {
                        return best(current, previous, isMinim);
                     }
                 }
 

                     }
                 }
             } else {                 return
                             best(current,
                                  previous,
                             isMinim);
             }
             ++iter;
","
         UnivariatePointValuePair current
             = new UnivariatePointValuePair(x, isMinim ? fx : -fx);
                 UnivariatePointValuePair best = current;
 
         int iter = 0;
         while (true) {

                                  previous = current;
                 current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);
                best = best(best,
                            best(current,
                                 previous,
                                 isMinim),
                            isMinim);
 
                 if (checker != null) {
                     if (checker.converged(iter, previous, current)) {
                        return best;
                     }
                 }
 

                     }
                 }
             } else {                 return best(best,
                             best(current,
                                  previous,
                                 isMinim),
                             isMinim);
             }
             ++iter;
"
247,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java","@@ -66,7 +66,6 @@ public RectangularCholeskyDecomposition(RealMatrix matrix, double small)
         final double[][] c = matrix.getData();
         final double[][] b = new double[order][order];
 
      int[] swap  = new int[order];
         int[] index = new int[order];
         for (int i = 0; i < order; ++i) {
             index[i] = i;
@@ -76,21 +75,24 @@ public RectangularCholeskyDecomposition(RealMatrix matrix, double small)
         for (boolean loop = true; loop;) {
 
             // find maximal diagonal element
          swap[r] = r;
             for (int i = r + 1; i < order; ++i) {
                 int ii  = index[i];
              int isi = index[swap[i]];
              if (c[ii][ii] > c[isi][isi]) {
                  swap[r] = i;
                 }
             }
 
 
             // swap elements
          if (swap[r] != r) {
              int tmp = index[r];
              index[r] = index[swap[r]];
              index[swap[r]] = tmp;
             }
 
             // check diagonal element
@@ -121,11 +123,12 @@ public RectangularCholeskyDecomposition(RealMatrix matrix, double small)
                 final double sqrt = FastMath.sqrt(c[ir][ir]);
                 b[r][r] = sqrt;
                 final double inverse  = 1 / sqrt;
                 for (int i = r + 1; i < order; ++i) {
                     final int ii = index[i];
                     final double e = inverse * c[ii][ir];
                     b[i][r] = e;
                  c[ii][ii] -= e * e;
                     for (int j = r + 1; j < i; ++j) {
                         final int ij = index[j];
                         final double f = c[ii][ij] - e * b[j][r];
","@@ -66,7 +66,6 @@ public RectangularCholeskyDecomposition(RealMatrix matrix, double small)
         final double[][] c = matrix.getData();
         final double[][] b = new double[order][order];
 
         int[] index = new int[order];
         for (int i = 0; i < order; ++i) {
             index[i] = i;
@@ -76,21 +75,24 @@ public RectangularCholeskyDecomposition(RealMatrix matrix, double small)
         for (boolean loop = true; loop;) {
 
             // find maximal diagonal element
          int swapR = r;
             for (int i = r + 1; i < order; ++i) {
                 int ii  = index[i];
              int isr = index[swapR];
              if (c[ii][ii] > c[isr][isr]) {
                  swapR = i;
                 }
             }
 
 
             // swap elements
          if (swapR != r) {
              final int tmpIndex    = index[r];
              index[r]              = index[swapR];
              index[swapR]          = tmpIndex;
              final double[] tmpRow = b[r];
              b[r]                  = b[swapR];
              b[swapR]              = tmpRow;
             }
 
             // check diagonal element
@@ -121,11 +123,12 @@ public RectangularCholeskyDecomposition(RealMatrix matrix, double small)
                 final double sqrt = FastMath.sqrt(c[ir][ir]);
                 b[r][r] = sqrt;
                 final double inverse  = 1 / sqrt;
              final double inverse2 = 1 / c[ir][ir];
                 for (int i = r + 1; i < order; ++i) {
                     final int ii = index[i];
                     final double e = inverse * c[ii][ir];
                     b[i][r] = e;
                  c[ii][ii] -= c[ii][ir] * c[ii][ir] * inverse2;
                     for (int j = r + 1; j < i; ++j) {
                         final int ij = index[j];
                         final double f = c[ii][ij] - e * b[j][r];
","
         final double[][] c = matrix.getData();
         final double[][] b = new double[order][order];
 
        int[] swap  = new int[order];
         int[] index = new int[order];
         for (int i = 0; i < order; ++i) {
             index[i] = i;

         for (boolean loop = true; loop;) {
 
                         swap[r] = r;
             for (int i = r + 1; i < order; ++i) {
                 int ii  = index[i];
                int isi = index[swap[i]];
                if (c[ii][ii] > c[isi][isi]) {
                    swap[r] = i;
                 }
             }
 
 
                         if (swap[r] != r) {
                int tmp = index[r];
                index[r] = index[swap[r]];
                index[swap[r]] = tmp;
             }
 
             
                 final double sqrt = FastMath.sqrt(c[ir][ir]);
                 b[r][r] = sqrt;
                 final double inverse  = 1 / sqrt;
                 for (int i = r + 1; i < order; ++i) {
                     final int ii = index[i];
                     final double e = inverse * c[ii][ir];
                     b[i][r] = e;
                    c[ii][ii] -= e * e;
                     for (int j = r + 1; j < i; ++j) {
                         final int ij = index[j];
                         final double f = c[ii][ij] - e * b[j][r];
","
         final double[][] c = matrix.getData();
         final double[][] b = new double[order][order];
 
         int[] index = new int[order];
         for (int i = 0; i < order; ++i) {
             index[i] = i;

         for (boolean loop = true; loop;) {
 
                         int swapR = r;
             for (int i = r + 1; i < order; ++i) {
                 int ii  = index[i];
                int isr = index[swapR];
                if (c[ii][ii] > c[isr][isr]) {
                    swapR = i;
                 }
             }
 
 
                         if (swapR != r) {
                final int tmpIndex    = index[r];
                index[r]              = index[swapR];
                index[swapR]          = tmpIndex;
                final double[] tmpRow = b[r];
                b[r]                  = b[swapR];
                b[swapR]              = tmpRow;
             }
 
             
                 final double sqrt = FastMath.sqrt(c[ir][ir]);
                 b[r][r] = sqrt;
                 final double inverse  = 1 / sqrt;
                final double inverse2 = 1 / c[ir][ir];
                 for (int i = r + 1; i < order; ++i) {
                     final int ii = index[i];
                     final double e = inverse * c[ii][ir];
                     b[i][r] = e;
                    c[ii][ii] -= c[ii][ir] * c[ii][ir] * inverse2;
                     for (int j = r + 1; j < i; ++j) {
                         final int ij = index[j];
                         final double f = c[ii][ij] - e * b[j][r];
"
248,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java","@@ -227,7 +227,7 @@ protected UnivariatePointValuePair doOptimize() {
 
                 if (checker != null) {
                     if (checker.converged(iter, previous, current)) {
                      return current;
                     }
                 }
 
@@ -264,7 +264,7 @@ protected UnivariatePointValuePair doOptimize() {
                     }
                 }
             } else { // Default termination (Brent's criterion).
              return current;
             }
             ++iter;
         }
","@@ -227,7 +227,7 @@ protected UnivariatePointValuePair doOptimize() {
 
                 if (checker != null) {
                     if (checker.converged(iter, previous, current)) {
                      return best(current, previous, isMinim);
                     }
                 }
 
@@ -264,7 +264,7 @@ protected UnivariatePointValuePair doOptimize() {
                     }
                 }
             } else { // Default termination (Brent's criterion).
              return best(current, previous, isMinim);
             }
             ++iter;
         }
","
 
                 if (checker != null) {
                     if (checker.converged(iter, previous, current)) {
                        return current;
                     }
                 }
 

                     }
                 }
             } else {                 return current;
             }
             ++iter;
         }
","
 
                 if (checker != null) {
                     if (checker.converged(iter, previous, current)) {
                        return best(current, previous, isMinim);
                     }
                 }
 

                     }
                 }
             } else {                 return best(current, previous, isMinim);
             }
             ++iter;
         }
"
249,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java","@@ -170,7 +170,7 @@ private double calculateAsymptoticPValue(final double Umin,
                                              final int n2)
         throws ConvergenceException, MaxCountExceededException {
 
      final int n1n2prod = n1 * n2;
 
         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation
         final double EU = n1n2prod / 2.0;
","@@ -170,7 +170,7 @@ private double calculateAsymptoticPValue(final double Umin,
                                              final int n2)
         throws ConvergenceException, MaxCountExceededException {
 
      final double n1n2prod = n1 * n2;
 
         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation
         final double EU = n1n2prod / 2.0;
","
                                              final int n2)
         throws ConvergenceException, MaxCountExceededException {
 
        final int n1n2prod = n1 * n2;
 
                  final double EU = n1n2prod / 2.0;
","
                                              final int n2)
         throws ConvergenceException, MaxCountExceededException {
 
        final double n1n2prod = n1 * n2;
 
                  final double EU = n1n2prod / 2.0;
"
250,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java","@@ -320,8 +320,11 @@ private void guessAOmega() {
                 }
                 a = 0.5 * (yMax - yMin);
             } else {
                     // In some ill-conditioned cases (cf. MATH-844), the guesser
                     // procedure cannot produce sensible results.
 
                 a = FastMath.sqrt(c1 / c2);
                 omega = FastMath.sqrt(c2 / c3);
","@@ -320,8 +320,11 @@ private void guessAOmega() {
                 }
                 a = 0.5 * (yMax - yMin);
             } else {
              if (c2 == 0) {
                     // In some ill-conditioned cases (cf. MATH-844), the guesser
                     // procedure cannot produce sensible results.
                  throw new MathIllegalStateException(LocalizedFormats.ZERO_DENOMINATOR);
              }
 
                 a = FastMath.sqrt(c1 / c2);
                 omega = FastMath.sqrt(c2 / c3);
","
                 }
                 a = 0.5 * (yMax - yMin);
             } else {
                                           
                 a = FastMath.sqrt(c1 / c2);
                 omega = FastMath.sqrt(c2 / c3);
","
                 }
                 a = 0.5 * (yMax - yMin);
             } else {
                if (c2 == 0) {
                                                              throw new MathIllegalStateException(LocalizedFormats.ZERO_DENOMINATOR);
                }
 
                 a = FastMath.sqrt(c1 / c2);
                 omega = FastMath.sqrt(c2 / c3);
"
251,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/fraction/Fraction.java","@@ -178,7 +178,7 @@ private Fraction(double value, double epsilon, int maxDenominator, int maxIterat
         long overflow = Integer.MAX_VALUE;
         double r0 = value;
         long a0 = (long)FastMath.floor(r0);
      if (a0 > overflow) {
             throw new FractionConversionException(value, a0, 1l);
         }
 
@@ -206,7 +206,7 @@ private Fraction(double value, double epsilon, int maxDenominator, int maxIterat
             long a1 = (long)FastMath.floor(r1);
             p2 = (a1 * p1) + p0;
             q2 = (a1 * q1) + q0;
          if ((p2 > overflow) || (q2 > overflow)) {
                 throw new FractionConversionException(value, p2, q2);
             }
 
","@@ -178,7 +178,7 @@ private Fraction(double value, double epsilon, int maxDenominator, int maxIterat
         long overflow = Integer.MAX_VALUE;
         double r0 = value;
         long a0 = (long)FastMath.floor(r0);
      if (FastMath.abs(a0) > overflow) {
             throw new FractionConversionException(value, a0, 1l);
         }
 
@@ -206,7 +206,7 @@ private Fraction(double value, double epsilon, int maxDenominator, int maxIterat
             long a1 = (long)FastMath.floor(r1);
             p2 = (a1 * p1) + p0;
             q2 = (a1 * q1) + q0;
          if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {
                 throw new FractionConversionException(value, p2, q2);
             }
 
","
         long overflow = Integer.MAX_VALUE;
         double r0 = value;
         long a0 = (long)FastMath.floor(r0);
        if (a0 > overflow) {
             throw new FractionConversionException(value, a0, 1l);
         }
 

             long a1 = (long)FastMath.floor(r1);
             p2 = (a1 * p1) + p0;
             q2 = (a1 * q1) + q0;
            if ((p2 > overflow) || (q2 > overflow)) {
                 throw new FractionConversionException(value, p2, q2);
             }
 
","
         long overflow = Integer.MAX_VALUE;
         double r0 = value;
         long a0 = (long)FastMath.floor(r0);
        if (FastMath.abs(a0) > overflow) {
             throw new FractionConversionException(value, a0, 1l);
         }
 

             long a1 = (long)FastMath.floor(r1);
             p2 = (a1 * p1) + p0;
             q2 = (a1 * q1) + q0;
            if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {
                 throw new FractionConversionException(value, p2, q2);
             }
 
"
252,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/fraction/Fraction.java","@@ -594,7 +594,7 @@ public Fraction divide(final int i) {
      * @return the fraction percentage as a <tt>double</tt>.
      */
     public double percentageValue() {
      return multiply(100).doubleValue();
     }
 
     /**
","@@ -594,7 +594,7 @@ public Fraction divide(final int i) {
      * @return the fraction percentage as a <tt>double</tt>.
      */
     public double percentageValue() {
      return 100 * doubleValue();
     }
 
     /**
","
    
     public double percentageValue() {
        return multiply(100).doubleValue();
     }
 
","
     
     public double percentageValue() {
        return 100 * doubleValue();
     }
 
"
253,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java","@@ -346,10 +346,9 @@ public OpenMapRealVector ebeDivide(RealVector v) {
          * this only. Indeed, if this[i] = 0d and v[i] = 0d, then
          * this[i] / v[i] = NaN, and not 0d.
          */
      Iterator iter = entries.iterator();
      while (iter.hasNext()) {
          iter.advance();
          res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));
         }
         return res;
     }
@@ -371,6 +370,18 @@ public OpenMapRealVector ebeMultiply(RealVector v) {
          *
          * These special cases are handled below.
          */
         return res;
     }
 
","@@ -346,10 +346,9 @@ public OpenMapRealVector ebeDivide(RealVector v) {
          * this only. Indeed, if this[i] = 0d and v[i] = 0d, then
          * this[i] / v[i] = NaN, and not 0d.
          */
      final int n = getDimension();
      for (int i = 0; i < n; i++) {
          res.setEntry(i, this.getEntry(i) / v.getEntry(i));
         }
         return res;
     }
@@ -371,6 +370,18 @@ public OpenMapRealVector ebeMultiply(RealVector v) {
          *
          * These special cases are handled below.
          */
      if (v.isNaN() || v.isInfinite()) {
          final int n = getDimension();
          for (int i = 0; i < n; i++) {
              final double y = v.getEntry(i);
              if (Double.isNaN(y)) {
                  res.setEntry(i, Double.NaN);
              } else if (Double.isInfinite(y)) {
                  final double x = this.getEntry(i);
                  res.setEntry(i, x * y);
              }
          }
      }
         return res;
     }
 
","
  
        Iterator iter = entries.iterator();
        while (iter.hasNext()) {
            iter.advance();
            res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));
         }
         return res;
     }

      
         return res;
     }
 
","
      
        final int n = getDimension();
        for (int i = 0; i < n; i++) {
            res.setEntry(i, this.getEntry(i) / v.getEntry(i));
         }
         return res;
     }

      
        if (v.isNaN() || v.isInfinite()) {
            final int n = getDimension();
            for (int i = 0; i < n; i++) {
                final double y = v.getEntry(i);
                if (Double.isNaN(y)) {
                    res.setEntry(i, Double.NaN);
                } else if (Double.isInfinite(y)) {
                    final double x = this.getEntry(i);
                    res.setEntry(i, x * y);
                }
            }
        }
         return res;
     }
 
"
254,"org.apache.commons.math3.exception.MaxCountExceededException","/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java","@@ -116,6 +116,7 @@ private Integer getPivotRow(SimplexTableau tableau, final int col) {
             // there's a degeneracy as indicated by a tie in the minimum ratio test
 
             // 1. check if there's an artificial variable that can be forced out of the basis
                 for (Integer row : minRatioPositions) {
                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {
                         int column = i + tableau.getArtificialVariableOffset();
@@ -125,6 +126,7 @@ private Integer getPivotRow(SimplexTableau tableau, final int col) {
                         }
                     }
                 }
 
             // 2. apply Bland's rule to prevent cycling:
             //    take the row for which the corresponding basic variable has the smallest index
@@ -135,6 +137,7 @@ private Integer getPivotRow(SimplexTableau tableau, final int col) {
             // Additional heuristic: if we did not get a solution after half of maxIterations
             //                       revert to the simple case of just returning the top-most row
             // This heuristic is based on empirical data gathered while investigating MATH-828.
                 Integer minRow = null;
                 int minIndex = tableau.getWidth();
                 for (Integer row : minRatioPositions) {
@@ -149,6 +152,7 @@ private Integer getPivotRow(SimplexTableau tableau, final int col) {
                     }
                 }
                 return minRow;
         }
         return minRatioPositions.get(0);
     }
","@@ -116,6 +116,7 @@ private Integer getPivotRow(SimplexTableau tableau, final int col) {
             // there's a degeneracy as indicated by a tie in the minimum ratio test
 
             // 1. check if there's an artificial variable that can be forced out of the basis
          if (tableau.getNumArtificialVariables() > 0) {
                 for (Integer row : minRatioPositions) {
                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {
                         int column = i + tableau.getArtificialVariableOffset();
@@ -125,6 +126,7 @@ private Integer getPivotRow(SimplexTableau tableau, final int col) {
                         }
                     }
                 }
          }
 
             // 2. apply Bland's rule to prevent cycling:
             //    take the row for which the corresponding basic variable has the smallest index
@@ -135,6 +137,7 @@ private Integer getPivotRow(SimplexTableau tableau, final int col) {
             // Additional heuristic: if we did not get a solution after half of maxIterations
             //                       revert to the simple case of just returning the top-most row
             // This heuristic is based on empirical data gathered while investigating MATH-828.
          if (getIterations() < getMaxIterations() / 2) {
                 Integer minRow = null;
                 int minIndex = tableau.getWidth();
                 for (Integer row : minRatioPositions) {
@@ -149,6 +152,7 @@ private Integer getPivotRow(SimplexTableau tableau, final int col) {
                     }
                 }
                 return minRow;
          }
         }
         return minRatioPositions.get(0);
     }
","
              
                              for (Integer row : minRatioPositions) {
                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {
                         int column = i + tableau.getArtificialVariableOffset();

                         }
                     }
                 }
 
                          
                                                        Integer minRow = null;
                 int minIndex = tableau.getWidth();
                 for (Integer row : minRatioPositions) {

                     }
                 }
                 return minRow;
         }
         return minRatioPositions.get(0);
     }
","
              
                         if (tableau.getNumArtificialVariables() > 0) {
                 for (Integer row : minRatioPositions) {
                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {
                         int column = i + tableau.getArtificialVariableOffset();

                         }
                     }
                 }
            }
 
                          
                                                   if (getIterations() < getMaxIterations() / 2) {
                 Integer minRow = null;
                 int minIndex = tableau.getWidth();
                 for (Integer row : minRatioPositions) {

                     }
                 }
                 return minRow;
            }
         }
         return minRatioPositions.get(0);
     }
"
255,"org.apache.commons.math3.exception.ConvergenceException","/src/main/java/org/apache/commons/math3/util/ContinuedFraction.java","@@ -131,8 +131,6 @@ public double evaluate(double x, double epsilon, int maxIterations) {
 
         int n = 1;
         double dPrev = 0.0;
      double p0 = 1.0;
      double q1 = 1.0;
         double cPrev = hPrev;
         double hN = hPrev;
 
@@ -140,34 +138,18 @@ public double evaluate(double x, double epsilon, int maxIterations) {
             final double a = getA(n, x);
             final double b = getB(n, x);
 
          double cN = a * hPrev + b * p0;
          double q2 = a * q1 + b * dPrev;
          if (Double.isInfinite(cN) || Double.isInfinite(q2)) {
              double scaleFactor = 1d;
              double lastScaleFactor = 1d;
              final int maxPower = 5;
              final double scale = FastMath.max(a,b);
              if (scale <= 0) {  // Can't scale
                  throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);
              }
              for (int i = 0; i < maxPower; i++) {
                  lastScaleFactor = scaleFactor;
                  scaleFactor *= scale;
                  if (a != 0.0 && a > b) {
                      cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);
                      q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);
                  } else if (b != 0) {
                      cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;
                      q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;
                  }
                  if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {
                      break;
                  }
              }
             }
 
          final double deltaN = cN / q2 / cPrev;
          hN = cPrev * deltaN;
 
             if (Double.isInfinite(hN)) {
                 throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,
@@ -182,11 +164,9 @@ public double evaluate(double x, double epsilon, int maxIterations) {
                 break;
             }
 
          dPrev = q1;
          cPrev = cN / q2;
          p0 = hPrev;
          hPrev = cN;
          q1 = q2;
             n++;
         }
 
","@@ -131,8 +131,6 @@ public double evaluate(double x, double epsilon, int maxIterations) {
 
         int n = 1;
         double dPrev = 0.0;
         double cPrev = hPrev;
         double hN = hPrev;
 
@@ -140,34 +138,18 @@ public double evaluate(double x, double epsilon, int maxIterations) {
             final double a = getA(n, x);
             final double b = getB(n, x);
 
          double dN = a + b * dPrev;
          if (Precision.equals(dN, 0.0, small)) {
              dN = small;
          }
          double cN = a + b / cPrev;
          if (Precision.equals(cN, 0.0, small)) {
              cN = small;
             }
 
          dN = 1 / dN;
          final double deltaN = cN * dN;
          hN = hPrev * deltaN;
 
             if (Double.isInfinite(hN)) {
                 throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,
@@ -182,11 +164,9 @@ public double evaluate(double x, double epsilon, int maxIterations) {
                 break;
             }
 
          dPrev = dN;
          cPrev = cN;
          hPrev = hN;
             n++;
         }
 
","
 
         int n = 1;
         double dPrev = 0.0;
        double p0 = 1.0;
        double q1 = 1.0;
         double cPrev = hPrev;
         double hN = hPrev;
 

             final double a = getA(n, x);
             final double b = getB(n, x);
 
            double cN = a * hPrev + b * p0;
            double q2 = a * q1 + b * dPrev;
            if (Double.isInfinite(cN) || Double.isInfinite(q2)) {
                double scaleFactor = 1d;
                double lastScaleFactor = 1d;
                final int maxPower = 5;
                final double scale = FastMath.max(a,b);
                if (scale <= 0) {                      throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);
                }
                for (int i = 0; i < maxPower; i++) {
                    lastScaleFactor = scaleFactor;
                    scaleFactor *= scale;
                    if (a != 0.0 && a > b) {
                        cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);
                        q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);
                    } else if (b != 0) {
                        cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;
                        q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;
                    }
                    if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {
                        break;
                    }
                }
             }
 
            final double deltaN = cN / q2 / cPrev;
            hN = cPrev * deltaN;
 
             if (Double.isInfinite(hN)) {
                 throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,

                 break;
             }
 
            dPrev = q1;
            cPrev = cN / q2;
            p0 = hPrev;
            hPrev = cN;
            q1 = q2;
             n++;
         }
 
","
 
         int n = 1;
         double dPrev = 0.0;
         double cPrev = hPrev;
         double hN = hPrev;
 

             final double a = getA(n, x);
             final double b = getB(n, x);
 
            double dN = a + b * dPrev;
            if (Precision.equals(dN, 0.0, small)) {
                dN = small;
            }
            double cN = a + b / cPrev;
            if (Precision.equals(cN, 0.0, small)) {
                cN = small;
             }
 
            dN = 1 / dN;
            final double deltaN = cN * dN;
            hN = hPrev * deltaN;
 
             if (Double.isInfinite(hN)) {
                 throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,

                 break;
             }
 
            dPrev = dN;
            cPrev = cN;
            hPrev = hN;
             n++;
         }
 
"
256,"java.lang.ClassCastException","/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java","@@ -133,7 +133,7 @@ protected void computeGeometricalProperties() {
 
         if (v.length == 0) {
             final BSPTree<Euclidean2D> tree = getTree(false);
          if ((Boolean) tree.getAttribute()) {
                 // the instance covers the whole space
                 setSize(Double.POSITIVE_INFINITY);
                 setBarycenter(Vector2D.NaN);
","@@ -133,7 +133,7 @@ protected void computeGeometricalProperties() {
 
         if (v.length == 0) {
             final BSPTree<Euclidean2D> tree = getTree(false);
          if (tree.getCut() == null && (Boolean) tree.getAttribute()) {
                 // the instance covers the whole space
                 setSize(Double.POSITIVE_INFINITY);
                 setBarycenter(Vector2D.NaN);
","
 
         if (v.length == 0) {
             final BSPTree<Euclidean2D> tree = getTree(false);
            if ((Boolean) tree.getAttribute()) {
                                  setSize(Double.POSITIVE_INFINITY);
                 setBarycenter(Vector2D.NaN);
","
 
         if (v.length == 0) {
             final BSPTree<Euclidean2D> tree = getTree(false);
            if (tree.getCut() == null && (Boolean) tree.getAttribute()) {
                                  setSize(Double.POSITIVE_INFINITY);
                 setBarycenter(Vector2D.NaN);
"
257,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java","@@ -48,7 +48,7 @@ public ElitisticListPopulation(final List<Chromosome> chromosomes,
                                    final int populationLimit,
                                    final double elitismRate) {
         super(chromosomes, populationLimit);
      this.elitismRate = elitismRate;
     }
 
     /**
@@ -62,7 +62,7 @@ public ElitisticListPopulation(final List<Chromosome> chromosomes,
      */
     public ElitisticListPopulation(final int populationLimit, final double elitismRate) {
         super(populationLimit);
      this.elitismRate = elitismRate;
     }
 
     /**
","@@ -48,7 +48,7 @@ public ElitisticListPopulation(final List<Chromosome> chromosomes,
                                    final int populationLimit,
                                    final double elitismRate) {
         super(chromosomes, populationLimit);
      setElitismRate(elitismRate);
     }
 
     /**
@@ -62,7 +62,7 @@ public ElitisticListPopulation(final List<Chromosome> chromosomes,
      */
     public ElitisticListPopulation(final int populationLimit, final double elitismRate) {
         super(populationLimit);
      setElitismRate(elitismRate);
     }
 
     /**
","
                                    final int populationLimit,
                                    final double elitismRate) {
         super(chromosomes, populationLimit);
        this.elitismRate = elitismRate;
     }
 

     public ElitisticListPopulation(final int populationLimit, final double elitismRate) {
         super(populationLimit);
        this.elitismRate = elitismRate;
     }
 
","
                                    final int populationLimit,
                                    final double elitismRate) {
         super(chromosomes, populationLimit);
        setElitismRate(elitismRate);
     }
 

     public ElitisticListPopulation(final int populationLimit, final double elitismRate) {
         super(populationLimit);
        setElitismRate(elitismRate);
     }
 
"
258,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java","@@ -335,7 +335,7 @@ protected void dropPhase1Objective() {
         // positive cost non-artificial variables
         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {
             final double entry = tableau.getEntry(0, i);
          if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
                 columnsToDrop.add(i);
             }
         }
","@@ -335,7 +335,7 @@ protected void dropPhase1Objective() {
         // positive cost non-artificial variables
         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {
             final double entry = tableau.getEntry(0, i);
          if (Precision.compareTo(entry, 0d, epsilon) > 0) {
                 columnsToDrop.add(i);
             }
         }
","
                  for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {
             final double entry = tableau.getEntry(0, i);
            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {
                 columnsToDrop.add(i);
             }
         }
","
                  for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {
             final double entry = tableau.getEntry(0, i);
            if (Precision.compareTo(entry, 0d, epsilon) > 0) {
                 columnsToDrop.add(i);
             }
         }
"
259,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/complex/Complex.java","@@ -1015,9 +1015,15 @@ public Complex sqrt1z() {
      * @since 1.2
      */
     public Complex tan() {
      if (isNaN) {
             return NaN;
         }
 
         double real2 = 2.0 * real;
         double imaginary2 = 2.0 * imaginary;
@@ -1060,9 +1066,15 @@ public Complex tan() {
      * @since 1.2
      */
     public Complex tanh() {
      if (isNaN) {
             return NaN;
         }
         double real2 = 2.0 * real;
         double imaginary2 = 2.0 * imaginary;
         double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);
","@@ -1015,9 +1015,15 @@ public Complex sqrt1z() {
      * @since 1.2
      */
     public Complex tan() {
      if (isNaN || Double.isInfinite(real)) {
             return NaN;
         }
      if (imaginary > 20.0) {
          return createComplex(0.0, 1.0);
      }
      if (imaginary < -20.0) {
          return createComplex(0.0, -1.0);
      }
 
         double real2 = 2.0 * real;
         double imaginary2 = 2.0 * imaginary;
@@ -1060,9 +1066,15 @@ public Complex tan() {
      * @since 1.2
      */
     public Complex tanh() {
      if (isNaN || Double.isInfinite(imaginary)) {
             return NaN;
         }
      if (real > 20.0) {
          return createComplex(1.0, 0.0);
      }
      if (real < -20.0) {
          return createComplex(-1.0, 0.0);
      }
         double real2 = 2.0 * real;
         double imaginary2 = 2.0 * imaginary;
         double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);
","
     
     public Complex tan() {
        if (isNaN) {
             return NaN;
         }
 
         double real2 = 2.0 * real;
         double imaginary2 = 2.0 * imaginary;

  
     public Complex tanh() {
        if (isNaN) {
             return NaN;
         }
         double real2 = 2.0 * real;
         double imaginary2 = 2.0 * imaginary;
         double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);
","
  
     public Complex tan() {
        if (isNaN || Double.isInfinite(real)) {
             return NaN;
         }
        if (imaginary > 20.0) {
            return createComplex(0.0, 1.0);
        }
        if (imaginary < -20.0) {
            return createComplex(0.0, -1.0);
        }
 
         double real2 = 2.0 * real;
         double imaginary2 = 2.0 * imaginary;

   
     public Complex tanh() {
        if (isNaN || Double.isInfinite(imaginary)) {
             return NaN;
         }
        if (real > 20.0) {
            return createComplex(1.0, 0.0);
        }
        if (real < -20.0) {
            return createComplex(-1.0, 0.0);
        }
         double real2 = 2.0 * real;
         double imaginary2 = 2.0 * imaginary;
         double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);
"
260,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java","@@ -206,6 +206,6 @@ public String toString() {
      * @return chromosome iterator
      */
     public Iterator<Chromosome> iterator() {
      return chromosomes.iterator();
     }
 }
","@@ -206,6 +206,6 @@ public String toString() {
      * @return chromosome iterator
      */
     public Iterator<Chromosome> iterator() {
      return getChromosomes().iterator();
     }
 }
","
   
     public Iterator<Chromosome> iterator() {
        return chromosomes.iterator();
     }
 }
","
   
     public Iterator<Chromosome> iterator() {
        return getChromosomes().iterator();
     }
 }
"
261,"org.apache.commons.math.exception.TooManyEvaluationsException","/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java","@@ -232,10 +232,16 @@ protected double doSolve() {
             double targetY;
             if (agingA >= MAXIMAL_AGING) {
                 // we keep updating the high bracket, try to compensate this
              targetY = -REDUCTION_FACTOR * yB;
             } else if (agingB >= MAXIMAL_AGING) {
                 // we keep updating the low bracket, try to compensate this
              targetY = -REDUCTION_FACTOR * yA;
             } else {
                 // bracketing is balanced, try to find the root itself
                 targetY = 0;
","@@ -232,10 +232,16 @@ protected double doSolve() {
             double targetY;
             if (agingA >= MAXIMAL_AGING) {
                 // we keep updating the high bracket, try to compensate this
              final int p = agingA - MAXIMAL_AGING;
              final double weightA = (1 << p) - 1;
              final double weightB = p + 1;
              targetY = (weightA * yA - weightB * REDUCTION_FACTOR * yB) / (weightA + weightB);
             } else if (agingB >= MAXIMAL_AGING) {
                 // we keep updating the low bracket, try to compensate this
              final int p = agingB - MAXIMAL_AGING;
              final double weightA = p + 1;
              final double weightB = (1 << p) - 1;
              targetY = (weightB * yB - weightA * REDUCTION_FACTOR * yA) / (weightA + weightB);
             } else {
                 // bracketing is balanced, try to find the root itself
                 targetY = 0;
","
             double targetY;
             if (agingA >= MAXIMAL_AGING) {
                                 targetY = -REDUCTION_FACTOR * yB;
             } else if (agingB >= MAXIMAL_AGING) {
                                 targetY = -REDUCTION_FACTOR * yA;
             } else {
                                  targetY = 0;
","
             double targetY;
             if (agingA >= MAXIMAL_AGING) {
                                 final int p = agingA - MAXIMAL_AGING;
                final double weightA = (1 << p) - 1;
                final double weightB = p + 1;
                targetY = (weightA * yA - weightB * REDUCTION_FACTOR * yB) / (weightA + weightB);
             } else if (agingB >= MAXIMAL_AGING) {
                                 final int p = agingB - MAXIMAL_AGING;
                final double weightA = p + 1;
                final double weightB = (1 << p) - 1;
                targetY = (weightB * yB - weightA * REDUCTION_FACTOR * yA) / (weightA + weightB);
             } else {
                                  targetY = 0;
"
262,"org.apache.commons.math.optimization.direct.BOBYQAOptimizer$PathIsExploredException","/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java","@@ -1657,10 +1657,10 @@ private void prelim(double[] lowerBound,
                     final int tmp2 = jpt;
                     jpt = ipt - n;
                     ipt = tmp2;
                  throw new PathIsExploredException(); // XXX
                 }
              final int iptMinus1 = ipt;
              final int jptMinus1 = jpt;
                 interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));
                 interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));
             }
@@ -1749,7 +1749,7 @@ private void prelim(double[] lowerBound,
                 final int ih = ipt * (ipt - 1) / 2 + jpt - 1;
                 final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);
                 modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);
              throw new PathIsExploredException(); 
             }
         } while (getEvaluations() < npt);
     } // prelim
","@@ -1657,10 +1657,10 @@ private void prelim(double[] lowerBound,
                     final int tmp2 = jpt;
                     jpt = ipt - n;
                     ipt = tmp2;
                 }
              final int iptMinus1 = ipt - 1;
              final int jptMinus1 = jpt - 1;
                 interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));
                 interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));
             }
@@ -1749,7 +1749,7 @@ private void prelim(double[] lowerBound,
                 final int ih = ipt * (ipt - 1) / 2 + jpt - 1;
                 final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);
                 modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);
             }
         } while (getEvaluations() < npt);
     } // prelim
","
                     final int tmp2 = jpt;
                     jpt = ipt - n;
                     ipt = tmp2;
                    throw new PathIsExploredException(); +                 }
                final int iptMinus1 = ipt;
                final int jptMinus1 = jpt;
                 interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));
                 interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));
             }

                 final int ih = ipt * (ipt - 1) / 2 + jpt - 1;
                 final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);
                 modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);
                throw new PathIsExploredException(); +             }
         } while (getEvaluations() < npt);
     } ","
                     final int tmp2 = jpt;
                     jpt = ipt - n;
                     ipt = tmp2;
+                 }
                final int iptMinus1 = ipt - 1;
                final int jptMinus1 = jpt - 1;
                 interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));
                 interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));
             }

                 final int ih = ipt * (ipt - 1) / 2 + jpt - 1;
                 final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);
                 modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);
+             }
         } while (getEvaluations() < npt);
     } "
263,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java","@@ -247,6 +247,15 @@ public void integrate(final ExpandableStatefulODE equations, final double t)
         }
 
         stepSize = hNew;
 
         // next stages
         for (int k = 1; k < stages; ++k) {
","@@ -247,6 +247,15 @@ public void integrate(final ExpandableStatefulODE equations, final double t)
         }
 
         stepSize = hNew;
      if (forward) {
          if (stepStart + stepSize >= t) {
              stepSize = t - stepStart;
          }
      } else {
          if (stepStart + stepSize <= t) {
              stepSize = t - stepStart;
          }
      }
 
         // next stages
         for (int k = 1; k < stages; ++k) {
","
         }
 
         stepSize = hNew;
 
                  for (int k = 1; k < stages; ++k) {
","
         }
 
         stepSize = hNew;
        if (forward) {
            if (stepStart + stepSize >= t) {
                stepSize = t - stepStart;
            }
        } else {
            if (stepStart + stepSize <= t) {
                stepSize = t - stepStart;
            }
        }
 
                  for (int k = 1; k < stages; ++k) {
"
264,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/fraction/BigFraction.java","@@ -683,8 +683,14 @@ public BigFraction divide(final BigFraction fraction) {
     @Override
     public double doubleValue() {
         double result = numerator.doubleValue() / denominator.doubleValue();
             // Numerator and/or denominator must be out of range:
             // Calculate how far to shift them to put them in range.
         return result;
     }
 
@@ -730,8 +736,14 @@ public boolean equals(final Object other) {
     @Override
     public float floatValue() {
         float result = numerator.floatValue() / denominator.floatValue();
             // Numerator and/or denominator must be out of range:
             // Calculate how far to shift them to put them in range.
         return result;
     }
 
","@@ -683,8 +683,14 @@ public BigFraction divide(final BigFraction fraction) {
     @Override
     public double doubleValue() {
         double result = numerator.doubleValue() / denominator.doubleValue();
      if (Double.isNaN(result)) {
             // Numerator and/or denominator must be out of range:
             // Calculate how far to shift them to put them in range.
          int shift = Math.max(numerator.bitLength(),
                               denominator.bitLength()) - Double.MAX_EXPONENT;
          result = numerator.shiftRight(shift).doubleValue() /
              denominator.shiftRight(shift).doubleValue();
      }
         return result;
     }
 
@@ -730,8 +736,14 @@ public boolean equals(final Object other) {
     @Override
     public float floatValue() {
         float result = numerator.floatValue() / denominator.floatValue();
      if (Double.isNaN(result)) {
             // Numerator and/or denominator must be out of range:
             // Calculate how far to shift them to put them in range.
          int shift = Math.max(numerator.bitLength(),
                               denominator.bitLength()) - Float.MAX_EXPONENT;
          result = numerator.shiftRight(shift).floatValue() /
              denominator.shiftRight(shift).floatValue();
      }
         return result;
     }
 
","
     @Override
     public double doubleValue() {
         double result = numerator.doubleValue() / denominator.doubleValue();
                                   return result;
     }
 

     @Override
     public float floatValue() {
         float result = numerator.floatValue() / denominator.floatValue();
                                   return result;
     }
 
","
     @Override
     public double doubleValue() {
         double result = numerator.doubleValue() / denominator.doubleValue();
        if (Double.isNaN(result)) {
                                      int shift = Math.max(numerator.bitLength(),
                                 denominator.bitLength()) - Double.MAX_EXPONENT;
            result = numerator.shiftRight(shift).doubleValue() /
                denominator.shiftRight(shift).doubleValue();
        }
         return result;
     }
 

     @Override
     public float floatValue() {
         float result = numerator.floatValue() / denominator.floatValue();
        if (Double.isNaN(result)) {
                                      int shift = Math.max(numerator.bitLength(),
                                 denominator.bitLength()) - Float.MAX_EXPONENT;
            result = numerator.shiftRight(shift).floatValue() /
                denominator.shiftRight(shift).floatValue();
        }
         return result;
     }
 
"
265,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java","@@ -407,10 +407,12 @@ protected RealPointValuePair getSolution() {
             continue;
           }
           Integer basicRow = getBasicRow(colIndex);
               // if the basic row is found to be the objective function row
               // set the coefficient to 0 -> this case handles unconstrained 
               // variables that are still part of the objective function
        if (basicRows.contains(basicRow)) {
               // if multiple variables can take a given value
               // then we choose the first and set the rest equal to 0
               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);
","@@ -407,10 +407,12 @@ protected RealPointValuePair getSolution() {
             continue;
           }
           Integer basicRow = getBasicRow(colIndex);
        if (basicRow != null && basicRow == 0) {
               // if the basic row is found to be the objective function row
               // set the coefficient to 0 -> this case handles unconstrained 
               // variables that are still part of the objective function
            coefficients[i] = 0;
        } else if (basicRows.contains(basicRow)) {
               // if multiple variables can take a given value
               // then we choose the first and set the rest equal to 0
               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);
","
             continue;
           }
           Integer basicRow = getBasicRow(colIndex);
                                                       if (basicRows.contains(basicRow)) {
                                             coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);
","
             continue;
           }
           Integer basicRow = getBasicRow(colIndex);
          if (basicRow != null && basicRow == 0) {
                                                           coefficients[i] = 0;
          } else if (basicRows.contains(basicRow)) {
                                             coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);
"
266,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java","@@ -517,7 +517,7 @@ public double evaluate(final double[] values, final double[] weights,
                 }
 
                 double sumWts = 0;
              for (int i = 0; i < weights.length; i++) {
                     sumWts += weights[i];
                 }
 
","@@ -517,7 +517,7 @@ public double evaluate(final double[] values, final double[] weights,
                 }
 
                 double sumWts = 0;
              for (int i = begin; i < begin + length; i++) {
                     sumWts += weights[i];
                 }
 
","
                 }
 
                 double sumWts = 0;
                for (int i = 0; i < weights.length; i++) {
                     sumWts += weights[i];
                 }
 
","
                 }
 
                 double sumWts = 0;
                for (int i = begin; i < begin + length; i++) {
                     sumWts += weights[i];
                 }
 
"
267,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java","@@ -277,7 +277,6 @@ protected double acceptStep(final AbstractStepInterpolator interpolator,
 
             double previousT = interpolator.getGlobalPreviousTime();
             final double currentT = interpolator.getGlobalCurrentTime();
          resetOccurred = false;
 
             // initialize the events states if needed
             if (! statesInitialized) {
@@ -331,6 +330,9 @@ public int compare(EventState es0, EventState es1) {
                 if (isLastStep) {
                     // the event asked to stop integration
                     System.arraycopy(eventY, 0, y, 0, y.length);
                     return eventT;
                 }
 
@@ -340,6 +342,9 @@ public int compare(EventState es0, EventState es1) {
                     System.arraycopy(eventY, 0, y, 0, y.length);
                     computeDerivatives(eventT, y, yDot);
                     resetOccurred = true;
                     return eventT;
                 }
 
","@@ -277,7 +277,6 @@ protected double acceptStep(final AbstractStepInterpolator interpolator,
 
             double previousT = interpolator.getGlobalPreviousTime();
             final double currentT = interpolator.getGlobalCurrentTime();
 
             // initialize the events states if needed
             if (! statesInitialized) {
@@ -331,6 +330,9 @@ public int compare(EventState es0, EventState es1) {
                 if (isLastStep) {
                     // the event asked to stop integration
                     System.arraycopy(eventY, 0, y, 0, y.length);
                  for (final EventState remaining : occuringEvents) {
                      remaining.stepAccepted(eventT, eventY);
                  }
                     return eventT;
                 }
 
@@ -340,6 +342,9 @@ public int compare(EventState es0, EventState es1) {
                     System.arraycopy(eventY, 0, y, 0, y.length);
                     computeDerivatives(eventT, y, yDot);
                     resetOccurred = true;
                  for (final EventState remaining : occuringEvents) {
                      remaining.stepAccepted(eventT, eventY);
                  }
                     return eventT;
                 }
 
","
 
             double previousT = interpolator.getGlobalPreviousTime();
             final double currentT = interpolator.getGlobalCurrentTime();
            resetOccurred = false;
 
                          if (! statesInitialized) {

                 if (isLastStep) {
                                          System.arraycopy(eventY, 0, y, 0, y.length);
                     return eventT;
                 }
 

                     System.arraycopy(eventY, 0, y, 0, y.length);
                     computeDerivatives(eventT, y, yDot);
                     resetOccurred = true;
                     return eventT;
                 }
 
","
 
             double previousT = interpolator.getGlobalPreviousTime();
             final double currentT = interpolator.getGlobalCurrentTime();
 
                          if (! statesInitialized) {

                 if (isLastStep) {
                                          System.arraycopy(eventY, 0, y, 0, y.length);
                    for (final EventState remaining : occuringEvents) {
                        remaining.stepAccepted(eventT, eventY);
                    }
                     return eventT;
                 }
 

                     System.arraycopy(eventY, 0, y, 0, y.length);
                     computeDerivatives(eventT, y, yDot);
                     resetOccurred = true;
                    for (final EventState remaining : occuringEvents) {
                        remaining.stepAccepted(eventT, eventY);
                    }
                     return eventT;
                 }
 
"
268,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java","@@ -155,13 +155,13 @@ public void addValue(double value) {
         secondMoment.increment(value);
         // If mean, variance or geomean have been overridden,
         // need to increment these
      if (!(meanImpl instanceof Mean)) {
             meanImpl.increment(value);
         }
      if (!(varianceImpl instanceof Variance)) {
             varianceImpl.increment(value);
         }
      if (!(geoMeanImpl instanceof GeometricMean)) {
             geoMeanImpl.increment(value);
         }
         n++;
","@@ -155,13 +155,13 @@ public void addValue(double value) {
         secondMoment.increment(value);
         // If mean, variance or geomean have been overridden,
         // need to increment these
      if (meanImpl != mean) {
             meanImpl.increment(value);
         }
      if (varianceImpl != variance) {
             varianceImpl.increment(value);
         }
      if (geoMeanImpl != geoMean) {
             geoMeanImpl.increment(value);
         }
         n++;
","
         secondMoment.increment(value);
                          if (!(meanImpl instanceof Mean)) {
             meanImpl.increment(value);
         }
        if (!(varianceImpl instanceof Variance)) {
             varianceImpl.increment(value);
         }
        if (!(geoMeanImpl instanceof GeometricMean)) {
             geoMeanImpl.increment(value);
         }
         n++;
","
         secondMoment.increment(value);
                          if (meanImpl != mean) {
             meanImpl.increment(value);
         }
        if (varianceImpl != variance) {
             varianceImpl.increment(value);
         }
        if (geoMeanImpl != geoMean) {
             geoMeanImpl.increment(value);
         }
         n++;
"
269,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/complex/Complex.java","@@ -1,87 +1,88 @@
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the ""License""); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an ""AS IS"" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package org.apache.commons.math.complex;
 
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.List;
 
 import org.apache.commons.math.FieldElement;
 import org.apache.commons.math.exception.NullArgumentException;
 import org.apache.commons.math.exception.NotPositiveException;
 import org.apache.commons.math.exception.util.LocalizedFormats;
 import org.apache.commons.math.util.MathUtils;
 import org.apache.commons.math.util.FastMath;
 
 /**
  * Representation of a Complex number, i.e. a number which has both a
  * real and imaginary part.
  * <br/>
  * Implementations of arithmetic operations handle {@code NaN} and
  * infinite values according to the rules for {@link java.lang.Double}, i.e.
  * {@link #equals} is an equivalence relation for all instances that have
  * a {@code NaN} in either real or imaginary part, e.g. the following are
  * considered equal:
  * <ul>
  *  <li>{@code 1 + NaNi}</li>
  *  <li>{@code NaN + i}</li>
  *  <li>{@code NaN + NaNi}</li>
  * </ul>
  * Note that this is in contradiction with the IEEE-754 standard for floating
  * point numbers (according to which the test {@code x == x} must fail if
  * {@code x} is {@code NaN}). The method
  * {@link MathUtils#equals(double,double,int) equals for primitive double} in
  * {@link MathUtils} conforms with IEEE-754 while this class conforms with
  * the standard behavior for Java object types.
  * <br/>
  * Implements Serializable since 2.0
  *
  * @version $Id$
  */
 public class Complex implements FieldElement<Complex>, Serializable  {
     /** The square root of -1. A number representing ""0.0 + 1.0i"" */
     public static final Complex I = new Complex(0.0, 1.0);
     // CHECKSTYLE: stop ConstantName
     /** A complex number representing ""NaN + NaNi"" */
     public static final Complex NaN = new Complex(Double.NaN, Double.NaN);
     // CHECKSTYLE: resume ConstantName
     /** A complex number representing ""+INF + INFi"" */
     public static final Complex INF = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);
     /** A complex number representing ""1.0 + 0.0i"" */
     public static final Complex ONE = new Complex(1.0, 0.0);
     /** A complex number representing ""0.0 + 0.0i"" */
     public static final Complex ZERO = new Complex(0.0, 0.0);
 
     /** Serializable version identifier */
     private static final long serialVersionUID = -6195664516687396620L;
 
     /** The imaginary part. */
     private final double imaginary;
     /** The real part. */
     private final double real;
     /** Record whether this complex number is equal to NaN. */
     private final transient boolean isNaN;
     /** Record whether this complex number is infinite. */
     private final transient boolean isInfinite;
     /** Record whether this complex number is zero. */
 
     /**
      * Create a complex number given only the real part.
      *
      * @param real Real part.
      */
@@ -98,17 +99,18 @@ public Complex(double real) {
     public Complex(double real, double imaginary) {
         this.real = real;
         this.imaginary = imaginary;
 
         isNaN = Double.isNaN(real) || Double.isNaN(imaginary);
         isInfinite = !isNaN &&
             (Double.isInfinite(real) || Double.isInfinite(imaginary));
     }
 
     /**
      * Return the absolute value of this complex number.
      * Returns {@code NaN} if either real or imaginary part is {@code NaN}
      * and {@code Double.POSITIVE_INFINITY} if neither part is {@code NaN},
      * but at least one part is infinite.
      *
      * @return the absolute value.
      */
@@ -249,60 +251,60 @@ public Complex conjugate() {
     public Complex divide(Complex divisor)
         throws NullArgumentException {
         MathUtils.checkNotNull(divisor);
         if (isNaN || divisor.isNaN) {
             return NaN;
         }
 
      if (divisor.getReal() == 0.0 && divisor.getImaginary() == 0.0) {
          return NaN;
         }
 
         if (divisor.isInfinite() && !isInfinite()) {
             return ZERO;
         }
 
         final double c = divisor.getReal();
         final double d = divisor.getImaginary();
 
         if (FastMath.abs(c) < FastMath.abs(d)) {
             double q = c / d;
             double denominator = c * q + d;
             return createComplex((real * q + imaginary) / denominator,
                 (imaginary * q - real) / denominator);
         } else {
             double q = d / c;
             double denominator = d * q + c;
             return createComplex((imaginary * q + real) / denominator,
                 (imaginary - real * q) / denominator);
         }
     }
 
     /**
      * Returns a {@code Complex} whose value is {@code (this / divisor)},
      * with {@code divisor} interpreted as a real number.
      *
      * @param  divisor Value by which this {@code Complex} is to be divided.
      * @return {@code this / divisor}.
      * @see #divide(Complex)
      */
     public Complex divide(double divisor) {
         if (isNaN || Double.isNaN(divisor)) {
             return NaN;
         }
         if (divisor == 0d) {
          return NaN;
         }
         if (Double.isInfinite(divisor)) {
             return !isInfinite() ? ZERO : NaN;
         }
         return createComplex(real / divisor,
                              imaginary  / divisor);
     }
 
     /**
      * Test for the equality of two Complex objects.
      * If both the real and imaginary parts of two complex numbers
      * are exactly the same, and neither is {@code Double.NaN}, the two
      * Complex objects are considered to be equal.
      * All {@code NaN} values are considered to be equal - i.e, if either
      * (or both) real and imaginary parts of the complex number are equal
","@@ -1,87 +1,88 @@
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the ""License""); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an ""AS IS"" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package org.apache.commons.math.complex;
 
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.List;
 
 import org.apache.commons.math.FieldElement;
 import org.apache.commons.math.exception.NullArgumentException;
 import org.apache.commons.math.exception.NotPositiveException;
 import org.apache.commons.math.exception.util.LocalizedFormats;
 import org.apache.commons.math.util.MathUtils;
 import org.apache.commons.math.util.FastMath;
 
 /**
  * Representation of a Complex number, i.e. a number which has both a
  * real and imaginary part.
  * <br/>
  * Implementations of arithmetic operations handle {@code NaN} and
  * infinite values according to the rules for {@link java.lang.Double}, i.e.
  * {@link #equals} is an equivalence relation for all instances that have
  * a {@code NaN} in either real or imaginary part, e.g. the following are
  * considered equal:
  * <ul>
  *  <li>{@code 1 + NaNi}</li>
  *  <li>{@code NaN + i}</li>
  *  <li>{@code NaN + NaNi}</li>
  * </ul>
  * Note that this is in contradiction with the IEEE-754 standard for floating
  * point numbers (according to which the test {@code x == x} must fail if
  * {@code x} is {@code NaN}). The method
  * {@link MathUtils#equals(double,double,int) equals for primitive double} in
  * {@link MathUtils} conforms with IEEE-754 while this class conforms with
  * the standard behavior for Java object types.
  * <br/>
  * Implements Serializable since 2.0
  *
  * @version $Id$
  */
 public class Complex implements FieldElement<Complex>, Serializable  {
     /** The square root of -1. A number representing ""0.0 + 1.0i"" */
     public static final Complex I = new Complex(0.0, 1.0);
     // CHECKSTYLE: stop ConstantName
     /** A complex number representing ""NaN + NaNi"" */
     public static final Complex NaN = new Complex(Double.NaN, Double.NaN);
     // CHECKSTYLE: resume ConstantName
     /** A complex number representing ""+INF + INFi"" */
     public static final Complex INF = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);
     /** A complex number representing ""1.0 + 0.0i"" */
     public static final Complex ONE = new Complex(1.0, 0.0);
     /** A complex number representing ""0.0 + 0.0i"" */
     public static final Complex ZERO = new Complex(0.0, 0.0);
 
     /** Serializable version identifier */
     private static final long serialVersionUID = -6195664516687396620L;
 
     /** The imaginary part. */
     private final double imaginary;
     /** The real part. */
     private final double real;
     /** Record whether this complex number is equal to NaN. */
     private final transient boolean isNaN;
     /** Record whether this complex number is infinite. */
     private final transient boolean isInfinite;
     /** Record whether this complex number is zero. */
  private final transient boolean isZero;
 
     /**
      * Create a complex number given only the real part.
      *
      * @param real Real part.
      */
@@ -98,17 +99,18 @@ public Complex(double real) {
     public Complex(double real, double imaginary) {
         this.real = real;
         this.imaginary = imaginary;
 
         isNaN = Double.isNaN(real) || Double.isNaN(imaginary);
         isInfinite = !isNaN &&
             (Double.isInfinite(real) || Double.isInfinite(imaginary));
      isZero = real == 0 && imaginary == 0;
     }
 
     /**
      * Return the absolute value of this complex number.
      * Returns {@code NaN} if either real or imaginary part is {@code NaN}
      * and {@code Double.POSITIVE_INFINITY} if neither part is {@code NaN},
      * but at least one part is infinite.
      *
      * @return the absolute value.
      */
@@ -249,60 +251,60 @@ public Complex conjugate() {
     public Complex divide(Complex divisor)
         throws NullArgumentException {
         MathUtils.checkNotNull(divisor);
         if (isNaN || divisor.isNaN) {
             return NaN;
         }
 
      if (divisor.isZero) {
          return isZero ? NaN : INF;
         }
 
         if (divisor.isInfinite() && !isInfinite()) {
             return ZERO;
         }
 
         final double c = divisor.getReal();
         final double d = divisor.getImaginary();
 
         if (FastMath.abs(c) < FastMath.abs(d)) {
             double q = c / d;
             double denominator = c * q + d;
             return createComplex((real * q + imaginary) / denominator,
                 (imaginary * q - real) / denominator);
         } else {
             double q = d / c;
             double denominator = d * q + c;
             return createComplex((imaginary * q + real) / denominator,
                 (imaginary - real * q) / denominator);
         }
     }
 
     /**
      * Returns a {@code Complex} whose value is {@code (this / divisor)},
      * with {@code divisor} interpreted as a real number.
      *
      * @param  divisor Value by which this {@code Complex} is to be divided.
      * @return {@code this / divisor}.
      * @see #divide(Complex)
      */
     public Complex divide(double divisor) {
         if (isNaN || Double.isNaN(divisor)) {
             return NaN;
         }
         if (divisor == 0d) {
          return isZero ? NaN : INF;
         }
         if (Double.isInfinite(divisor)) {
             return !isInfinite() ? ZERO : NaN;
         }
         return createComplex(real / divisor,
                              imaginary  / divisor);
     }
 
     /**
      * Test for the equality of two Complex objects.
      * If both the real and imaginary parts of two complex numbers
      * are exactly the same, and neither is {@code Double.NaN}, the two
      * Complex objects are considered to be equal.
      * All {@code NaN} values are considered to be equal - i.e, if either
      * (or both) real and imaginary parts of the complex number are equal
","
 package org.apache.commons.math.complex;
 
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.List;
 
 import org.apache.commons.math.FieldElement;
 import org.apache.commons.math.exception.NullArgumentException;
 import org.apache.commons.math.exception.NotPositiveException;
 import org.apache.commons.math.exception.util.LocalizedFormats;
 import org.apache.commons.math.util.MathUtils;
 import org.apache.commons.math.util.FastMath;
 
 public class Complex implements FieldElement<Complex>, Serializable  {
     public static final Complex I = new Complex(0.0, 1.0);
     public static final Complex NaN = new Complex(Double.NaN, Double.NaN);
     public static final Complex INF = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);
     public static final Complex ONE = new Complex(1.0, 0.0);
     public static final Complex ZERO = new Complex(0.0, 0.0);
     private static final long serialVersionUID = -6195664516687396620L;
     private final double imaginary;
     private final double real;
     private final transient boolean isNaN;
     private final transient boolean isInfinite;
     public Complex(double real, double imaginary) {
         this.real = real;
         this.imaginary = imaginary;
 
         isNaN = Double.isNaN(real) || Double.isNaN(imaginary);
         isInfinite = !isNaN &&
             (Double.isInfinite(real) || Double.isInfinite(imaginary));
     }
     public Complex divide(Complex divisor)
         throws NullArgumentException {
         MathUtils.checkNotNull(divisor);
         if (isNaN || divisor.isNaN) {
             return NaN;
         }
 
        if (divisor.getReal() == 0.0 && divisor.getImaginary() == 0.0) {
            return NaN;
         }
 
         if (divisor.isInfinite() && !isInfinite()) {
             return ZERO;
         }
 
         final double c = divisor.getReal();
         final double d = divisor.getImaginary();
 
         if (FastMath.abs(c) < FastMath.abs(d)) {
             double q = c / d;
             double denominator = c * q + d;
             return createComplex((real * q + imaginary) / denominator,
                 (imaginary * q - real) / denominator);
         } else {
             double q = d / c;
             double denominator = d * q + c;
             return createComplex((imaginary * q + real) / denominator,
                 (imaginary - real * q) / denominator);
         }
     }
      public Complex divide(double divisor) {
         if (isNaN || Double.isNaN(divisor)) {
             return NaN;
         }
         if (divisor == 0d) {
            return NaN;
         }
         if (Double.isInfinite(divisor)) {
             return !isInfinite() ? ZERO : NaN;
         }
         return createComplex(real / divisor,
                              imaginary  / divisor);
     }
 ","
 package org.apache.commons.math.complex;
 
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.List;
 
 import org.apache.commons.math.FieldElement;
 import org.apache.commons.math.exception.NullArgumentException;
 import org.apache.commons.math.exception.NotPositiveException;
 import org.apache.commons.math.exception.util.LocalizedFormats;
 import org.apache.commons.math.util.MathUtils;
 import org.apache.commons.math.util.FastMath;
  public class Complex implements FieldElement<Complex>, Serializable  {
     public static final Complex I = new Complex(0.0, 1.0);
     public static final Complex NaN = new Complex(Double.NaN, Double.NaN);
     public static final Complex INF = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);
     public static final Complex ONE = new Complex(1.0, 0.0);
     public static final Complex ZERO = new Complex(0.0, 0.0);
 
     private static final long serialVersionUID = -6195664516687396620L;
 
     private final double imaginary;
     private final double real;
     private final transient boolean isNaN;
     private final transient boolean isInfinite;
    private final transient boolean isZero;
     public Complex(double real, double imaginary) {
         this.real = real;
         this.imaginary = imaginary;
 
         isNaN = Double.isNaN(real) || Double.isNaN(imaginary);
         isInfinite = !isNaN &&
             (Double.isInfinite(real) || Double.isInfinite(imaginary));
        isZero = real == 0 && imaginary == 0;
     }
 
     public Complex divide(Complex divisor)
         throws NullArgumentException {
         MathUtils.checkNotNull(divisor);
         if (isNaN || divisor.isNaN) {
             return NaN;
         }
 
        if (divisor.isZero) {
            return isZero ? NaN : INF;
         }
 
         if (divisor.isInfinite() && !isInfinite()) {
             return ZERO;
         }
 
         final double c = divisor.getReal();
         final double d = divisor.getImaginary();
 
         if (FastMath.abs(c) < FastMath.abs(d)) {
             double q = c / d;
             double denominator = c * q + d;
             return createComplex((real * q + imaginary) / denominator,
                 (imaginary * q - real) / denominator);
         } else {
             double q = d / c;
             double denominator = d * q + c;
             return createComplex((imaginary * q + real) / denominator,
                 (imaginary - real * q) / denominator);
         }
     }
      public Complex divide(double divisor) {
         if (isNaN || Double.isNaN(divisor)) {
             return NaN;
         }
         if (divisor == 0d) {
            return isZero ? NaN : INF;
         }
         if (Double.isInfinite(divisor)) {
             return !isInfinite() ? ZERO : NaN;
         }
         return createComplex(real / divisor,
                              imaginary  / divisor);
     }
 "
270,"java.lang.Exception","/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java","@@ -186,6 +186,9 @@ protected final double doSolve() {
                 case REGULA_FALSI:
                     // Detect early that algorithm is stuck, instead of waiting
                     // for the maximum number of iterations to be exceeded.
                     break;
                 default:
                     // Should never happen.
","@@ -186,6 +186,9 @@ protected final double doSolve() {
                 case REGULA_FALSI:
                     // Detect early that algorithm is stuck, instead of waiting
                     // for the maximum number of iterations to be exceeded.
                  if (x == x1) {
                      throw new ConvergenceException();
                  }
                     break;
                 default:
                     // Should never happen.
","
                 case REGULA_FALSI:
                                                               break;
                 default:
                     ","
                 case REGULA_FALSI:
                                                              if (x == x1) {
                        throw new ConvergenceException();
                    }
                     break;
                 default:
                     "
271,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java","@@ -184,10 +184,6 @@ protected final double doSolve() {
                     break;
                 case REGULA_FALSI:
                     // Nothing.
                  if (x == x1) {
                      x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));
                      f0 = computeObjectiveValue(x0);
                  }
                     break;
                 default:
                     // Should never happen.
","@@ -184,10 +184,6 @@ protected final double doSolve() {
                     break;
                 case REGULA_FALSI:
                     // Nothing.
                     break;
                 default:
                     // Should never happen.
","
                     break;
                 case REGULA_FALSI:
                                         if (x == x1) {
                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));
                        f0 = computeObjectiveValue(x0);
                    }
                     break;
                 default:
                     ","
                     break;
                 case REGULA_FALSI:
                                          break;
                 default:
                     "
272,"org.apache.commons.math.MathRuntimeException$6","/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java","@@ -342,7 +342,7 @@ public double dotProduct(RealVector v) {
     public OpenMapRealVector ebeDivide(RealVector v) {
         checkVectorDimensions(v.getDimension());
         OpenMapRealVector res = new OpenMapRealVector(this);
      Iterator iter = res.entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));
@@ -355,7 +355,7 @@ public OpenMapRealVector ebeDivide(RealVector v) {
     public OpenMapRealVector ebeDivide(double[] v) {
         checkVectorDimensions(v.length);
         OpenMapRealVector res = new OpenMapRealVector(this);
      Iterator iter = res.entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             res.setEntry(iter.key(), iter.value() / v[iter.key()]);
@@ -367,7 +367,7 @@ public OpenMapRealVector ebeDivide(double[] v) {
     public OpenMapRealVector ebeMultiply(RealVector v) {
         checkVectorDimensions(v.getDimension());
         OpenMapRealVector res = new OpenMapRealVector(this);
      Iterator iter = res.entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));
@@ -380,7 +380,7 @@ public OpenMapRealVector ebeMultiply(RealVector v) {
     public OpenMapRealVector ebeMultiply(double[] v) {
         checkVectorDimensions(v.length);
         OpenMapRealVector res = new OpenMapRealVector(this);
      Iterator iter = res.entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             res.setEntry(iter.key(), iter.value() * v[iter.key()]);
","@@ -342,7 +342,7 @@ public double dotProduct(RealVector v) {
     public OpenMapRealVector ebeDivide(RealVector v) {
         checkVectorDimensions(v.getDimension());
         OpenMapRealVector res = new OpenMapRealVector(this);
      Iterator iter = entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));
@@ -355,7 +355,7 @@ public OpenMapRealVector ebeDivide(RealVector v) {
     public OpenMapRealVector ebeDivide(double[] v) {
         checkVectorDimensions(v.length);
         OpenMapRealVector res = new OpenMapRealVector(this);
      Iterator iter = entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             res.setEntry(iter.key(), iter.value() / v[iter.key()]);
@@ -367,7 +367,7 @@ public OpenMapRealVector ebeDivide(double[] v) {
     public OpenMapRealVector ebeMultiply(RealVector v) {
         checkVectorDimensions(v.getDimension());
         OpenMapRealVector res = new OpenMapRealVector(this);
      Iterator iter = entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));
@@ -380,7 +380,7 @@ public OpenMapRealVector ebeMultiply(RealVector v) {
     public OpenMapRealVector ebeMultiply(double[] v) {
         checkVectorDimensions(v.length);
         OpenMapRealVector res = new OpenMapRealVector(this);
      Iterator iter = entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             res.setEntry(iter.key(), iter.value() * v[iter.key()]);
","
     public OpenMapRealVector ebeDivide(RealVector v) {
         checkVectorDimensions(v.getDimension());
         OpenMapRealVector res = new OpenMapRealVector(this);
        Iterator iter = res.entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));

     public OpenMapRealVector ebeDivide(double[] v) {
         checkVectorDimensions(v.length);
         OpenMapRealVector res = new OpenMapRealVector(this);
        Iterator iter = res.entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             res.setEntry(iter.key(), iter.value() / v[iter.key()]);

     public OpenMapRealVector ebeMultiply(RealVector v) {
         checkVectorDimensions(v.getDimension());
         OpenMapRealVector res = new OpenMapRealVector(this);
        Iterator iter = res.entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));

     public OpenMapRealVector ebeMultiply(double[] v) {
         checkVectorDimensions(v.length);
         OpenMapRealVector res = new OpenMapRealVector(this);
        Iterator iter = res.entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             res.setEntry(iter.key(), iter.value() * v[iter.key()]);
","
     public OpenMapRealVector ebeDivide(RealVector v) {
         checkVectorDimensions(v.getDimension());
         OpenMapRealVector res = new OpenMapRealVector(this);
        Iterator iter = entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));

     public OpenMapRealVector ebeDivide(double[] v) {
         checkVectorDimensions(v.length);
         OpenMapRealVector res = new OpenMapRealVector(this);
        Iterator iter = entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             res.setEntry(iter.key(), iter.value() / v[iter.key()]);

     public OpenMapRealVector ebeMultiply(RealVector v) {
         checkVectorDimensions(v.getDimension());
         OpenMapRealVector res = new OpenMapRealVector(this);
        Iterator iter = entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));

     public OpenMapRealVector ebeMultiply(double[] v) {
         checkVectorDimensions(v.length);
         OpenMapRealVector res = new OpenMapRealVector(this);
        Iterator iter = entries.iterator();
         while (iter.hasNext()) {
             iter.advance();
             res.setEntry(iter.key(), iter.value() * v[iter.key()]);
"
273,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/complex/Complex.java","@@ -257,7 +257,7 @@ public Complex divide(Complex divisor)
 
         if (divisor.isZero) {
             // return isZero ? NaN : INF; // See MATH-657
          return isZero ? NaN : INF;
         }
 
         if (divisor.isInfinite() && !isInfinite()) {
@@ -294,7 +294,7 @@ public Complex divide(double divisor) {
         }
         if (divisor == 0d) {
             // return isZero ? NaN : INF; // See MATH-657
          return isZero ? NaN : INF;
         }
         if (Double.isInfinite(divisor)) {
             return !isInfinite() ? ZERO : NaN;
","@@ -257,7 +257,7 @@ public Complex divide(Complex divisor)
 
         if (divisor.isZero) {
             // return isZero ? NaN : INF; // See MATH-657
          return NaN;
         }
 
         if (divisor.isInfinite() && !isInfinite()) {
@@ -294,7 +294,7 @@ public Complex divide(double divisor) {
         }
         if (divisor == 0d) {
             // return isZero ? NaN : INF; // See MATH-657
          return NaN;
         }
         if (Double.isInfinite(divisor)) {
             return !isInfinite() ? ZERO : NaN;
","
 
         if (divisor.isZero) {
                         return isZero ? NaN : INF;
         }
 
         if (divisor.isInfinite() && !isInfinite()) {

         }
         if (divisor == 0d) {
                         return isZero ? NaN : INF;
         }
         if (Double.isInfinite(divisor)) {
             return !isInfinite() ? ZERO : NaN;
","
 
         if (divisor.isZero) {
                         return NaN;
         }
 
         if (divisor.isInfinite() && !isInfinite()) {

         }
         if (divisor == 0d) {
                         return NaN;
         }
         if (Double.isInfinite(divisor)) {
             return !isInfinite() ? ZERO : NaN;
"
274,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java","@@ -47,6 +47,11 @@
      */
     public OpenMapRealMatrix(int rowDimension, int columnDimension) {
         super(rowDimension, columnDimension);
         this.rows = rowDimension;
         this.columns = columnDimension;
         this.entries = new OpenIntToDoubleHashMap(0.0);
","@@ -47,6 +47,11 @@
      */
     public OpenMapRealMatrix(int rowDimension, int columnDimension) {
         super(rowDimension, columnDimension);
      long lRow = (long) rowDimension;
      long lCol = (long) columnDimension;
      if (lRow * lCol >= (long) Integer.MAX_VALUE) {
          throw new NumberIsTooLargeException(lRow * lCol, Integer.MAX_VALUE, false);
      }
         this.rows = rowDimension;
         this.columns = columnDimension;
         this.entries = new OpenIntToDoubleHashMap(0.0);
","
      
     public OpenMapRealMatrix(int rowDimension, int columnDimension) {
         super(rowDimension, columnDimension);
         this.rows = rowDimension;
         this.columns = columnDimension;
         this.entries = new OpenIntToDoubleHashMap(0.0);
","
      
     public OpenMapRealMatrix(int rowDimension, int columnDimension) {
         super(rowDimension, columnDimension);
        long lRow = (long) rowDimension;
        long lCol = (long) columnDimension;
        if (lRow * lCol >= (long) Integer.MAX_VALUE) {
            throw new NumberIsTooLargeException(lRow * lCol, Integer.MAX_VALUE, false);
        }
         this.rows = rowDimension;
         this.columns = columnDimension;
         this.entries = new OpenIntToDoubleHashMap(0.0);
"
275,"org.apache.commons.math.exception.TooManyEvaluationsException","/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java","@@ -182,10 +182,19 @@ protected final double doSolve() {
                 case PEGASUS:
                     f0 *= f1 / (f1 + fx);
                     break;
                         // Update formula cannot make any progress: Update the
                         // search interval.
                 default:
                     // Should never happen.
                 }
             }
             // Update from [x0, x1] to [x0, x].
","@@ -182,10 +182,19 @@ protected final double doSolve() {
                 case PEGASUS:
                     f0 *= f1 / (f1 + fx);
                     break;
              case REGULA_FALSI:
                  if (x == x1) {
                      final double delta = FastMath.max(rtol * FastMath.abs(x1),
                                                        atol);
                         // Update formula cannot make any progress: Update the
                         // search interval.
                      x0 = 0.5 * (x0 + x1 - delta);
                      f0 = computeObjectiveValue(x0);
                  }
                  break;
                 default:
                     // Should never happen.
                  throw new MathInternalError();
                 }
             }
             // Update from [x0, x1] to [x0, x].
","
                 case PEGASUS:
                     f0 *= f1 / (f1 + fx);
                     break;
                                                                   default:
                                      }
             }
             ","
                 case PEGASUS:
                     f0 *= f1 / (f1 + fx);
                     break;
                case REGULA_FALSI:
                    if (x == x1) {
                        final double delta = FastMath.max(rtol * FastMath.abs(x1),
                                                          atol);
                                                                          x0 = 0.5 * (x0 + x1 - delta);
                        f0 = computeObjectiveValue(x0);
                    }
                    break;
                 default:
                                         throw new MathInternalError();
                 }
             }
             "
276,"org.apache.commons.math.exception.NotStrictlyPositiveException","/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java","@@ -118,7 +118,7 @@ public double value(double x, double[] p) {
      */
     public double[] fit() {
         final double[] guess = (new ParameterGuesser(getObservations())).guess();
      return fit(new Gaussian.Parametric(), guess);
     }
 
     /**
","@@ -118,7 +118,7 @@ public double value(double x, double[] p) {
      */
     public double[] fit() {
         final double[] guess = (new ParameterGuesser(getObservations())).guess();
      return fit(guess);
     }
 
     /**
","
      
     public double[] fit() {
         final double[] guess = (new ParameterGuesser(getObservations())).guess();
        return fit(new Gaussian.Parametric(), guess);
     }
 
","
      
     public double[] fit() {
         final double[] guess = (new ParameterGuesser(getObservations())).guess();
        return fit(guess);
     }
 
"
277,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/util/FastMath.java","@@ -3479,7 +3479,7 @@ public static long max(final long a, final long b) {
      * @return b if a is lesser or equal to b, a otherwise
      */
     public static float max(final float a, final float b) {
      return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);
     }
 
     /** Compute the maximum of two values
","@@ -3479,7 +3479,7 @@ public static long max(final long a, final long b) {
      * @return b if a is lesser or equal to b, a otherwise
      */
     public static float max(final float a, final float b) {
      return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a);
     }
 
     /** Compute the maximum of two values
","
     public static float max(final float a, final float b) {
        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);
     }
 
","
      
     public static float max(final float a, final float b) {
        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a);
     }
 
"
278,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java","@@ -172,7 +172,7 @@ public KMeansPlusPlusClusterer(final Random random, final EmptyClusterStrategy e
         while (resultSet.size() < k) {
             // For each data point x, compute D(x), the distance between x and
             // the nearest center that has already been chosen.
          int sum = 0;
             for (int i = 0; i < pointSet.size(); i++) {
                 final T p = pointSet.get(i);
                 final Cluster<T> nearest = getNearestCluster(resultSet, p);
","@@ -172,7 +172,7 @@ public KMeansPlusPlusClusterer(final Random random, final EmptyClusterStrategy e
         while (resultSet.size() < k) {
             // For each data point x, compute D(x), the distance between x and
             // the nearest center that has already been chosen.
          double sum = 0;
             for (int i = 0; i < pointSet.size(); i++) {
                 final T p = pointSet.get(i);
                 final Cluster<T> nearest = getNearestCluster(resultSet, p);
","
         while (resultSet.size() < k) {
                                      int sum = 0;
             for (int i = 0; i < pointSet.size(); i++) {
                 final T p = pointSet.get(i);
                 final Cluster<T> nearest = getNearestCluster(resultSet, p);
","
         while (resultSet.size() < k) {
                                      double sum = 0;
             for (int i = 0; i < pointSet.size(); i++) {
                 final T p = pointSet.get(i);
                 final Cluster<T> nearest = getNearestCluster(resultSet, p);
"
279,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/complex/Complex.java","@@ -150,6 +150,9 @@ public double abs() {
     public Complex add(Complex rhs)
         throws NullArgumentException {
         MathUtils.checkNotNull(rhs);
         return createComplex(real + rhs.getReal(),
             imaginary + rhs.getImaginary());
     }
","@@ -150,6 +150,9 @@ public double abs() {
     public Complex add(Complex rhs)
         throws NullArgumentException {
         MathUtils.checkNotNull(rhs);
      if (isNaN || rhs.isNaN) {
          return NaN;
      }
         return createComplex(real + rhs.getReal(),
             imaginary + rhs.getImaginary());
     }
","
     public Complex add(Complex rhs)
         throws NullArgumentException {
         MathUtils.checkNotNull(rhs);
         return createComplex(real + rhs.getReal(),
             imaginary + rhs.getImaginary());
     }
","
     public Complex add(Complex rhs)
         throws NullArgumentException {
         MathUtils.checkNotNull(rhs);
        if (isNaN || rhs.isNaN) {
            return NaN;
        }
         return createComplex(real + rhs.getReal(),
             imaginary + rhs.getImaginary());
     }
"
280,"org.apache.commons.math.MathRuntimeException$4","/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java","@@ -19,7 +19,7 @@
 import java.io.Serializable;
 
 import org.apache.commons.math.MathException;
 import org.apache.commons.math.MathRuntimeException;
 import org.apache.commons.math.exception.NotStrictlyPositiveException;
 import org.apache.commons.math.exception.util.LocalizedFormats;
 import org.apache.commons.math.special.Gamma;
 import org.apache.commons.math.util.MathUtils;
@@ -91,7 +91,7 @@ public PoissonDistributionImpl(double p) {
      */
     public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {
         if (p <= 0) {
          throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);
         }
         mean = p;
         normal = new NormalDistributionImpl(p, FastMath.sqrt(p));
","@@ -19,7 +19,7 @@
 import java.io.Serializable;
 
 import org.apache.commons.math.MathException;
 import org.apache.commons.math.exception.NotStrictlyPositiveException;
 import org.apache.commons.math.exception.util.LocalizedFormats;
 import org.apache.commons.math.special.Gamma;
 import org.apache.commons.math.util.MathUtils;
@@ -91,7 +91,7 @@ public PoissonDistributionImpl(double p) {
      */
     public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {
         if (p <= 0) {
          throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, p);
         }
         mean = p;
         normal = new NormalDistributionImpl(p, FastMath.sqrt(p));
","
 import java.io.Serializable;
 
 import org.apache.commons.math.MathException;
 import org.apache.commons.math.MathRuntimeException;
 import org.apache.commons.math.exception.NotStrictlyPositiveException;
 import org.apache.commons.math.exception.util.LocalizedFormats;
 import org.apache.commons.math.special.Gamma;
 import org.apache.commons.math.util.MathUtils;

      
     public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {
         if (p <= 0) {
            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);
         }
         mean = p;
         normal = new NormalDistributionImpl(p, FastMath.sqrt(p));
","
 import java.io.Serializable;
 
 import org.apache.commons.math.MathException;
 import org.apache.commons.math.exception.NotStrictlyPositiveException;
 import org.apache.commons.math.exception.util.LocalizedFormats;
 import org.apache.commons.math.special.Gamma;
 import org.apache.commons.math.util.MathUtils;

      
     public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {
         if (p <= 0) {
            throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, p);
         }
         mean = p;
         normal = new NormalDistributionImpl(p, FastMath.sqrt(p));
"
281,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/geometry/Vector3D.java","@@ -456,9 +456,21 @@ public static double dotProduct(Vector3D v1, Vector3D v2) {
    */
   public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {
 
 
       // rescale both vectors without losing precision,
       // to ensure their norm are the same order of magnitude
 
       // we reduce cancellation errors by preconditioning,
       // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute
@@ -467,10 +479,15 @@ public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {
       // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf
 
       // compute rho as an 8 bits approximation of v1.v2 / v2.v2
 
 
       // compute cross product from v3 and v2 instead of v1 and v2
    return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);
 
   }
 
","@@ -456,9 +456,21 @@ public static double dotProduct(Vector3D v1, Vector3D v2) {
    */
   public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {
 
    final double n1 = v1.getNormSq();
    final double n2 = v2.getNormSq();
    if ((n1 * n2) < MathUtils.SAFE_MIN) {
        return ZERO;
    }
 
       // rescale both vectors without losing precision,
       // to ensure their norm are the same order of magnitude
    final int deltaExp = (FastMath.getExponent(n1) - FastMath.getExponent(n2)) / 4;
    final double x1    = FastMath.scalb(v1.x, -deltaExp);
    final double y1    = FastMath.scalb(v1.y, -deltaExp);
    final double z1    = FastMath.scalb(v1.z, -deltaExp);
    final double x2    = FastMath.scalb(v2.x,  deltaExp);
    final double y2    = FastMath.scalb(v2.y,  deltaExp);
    final double z2    = FastMath.scalb(v2.z,  deltaExp);
 
       // we reduce cancellation errors by preconditioning,
       // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute
@@ -467,10 +479,15 @@ public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {
       // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf
 
       // compute rho as an 8 bits approximation of v1.v2 / v2.v2
    final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp);
    final double rho   = FastMath.rint(256 * ratio) / 256;
 
    final double x3 = x1 - rho * x2;
    final double y3 = y1 - rho * y2;
    final double z3 = z1 - rho * z2;
 
       // compute cross product from v3 and v2 instead of v1 and v2
    return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2);
 
   }
 
","
    
   public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {
 
 
               
              
        
        
 
             return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);
 
   }
 
","
    
   public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {
 
      final double n1 = v1.getNormSq();
      final double n2 = v2.getNormSq();
      if ((n1 * n2) < MathUtils.SAFE_MIN) {
          return ZERO;
      }
 
                    final int deltaExp = (FastMath.getExponent(n1) - FastMath.getExponent(n2)) / 4;
      final double x1    = FastMath.scalb(v1.x, -deltaExp);
      final double y1    = FastMath.scalb(v1.y, -deltaExp);
      final double z1    = FastMath.scalb(v1.z, -deltaExp);
      final double x2    = FastMath.scalb(v2.x,  deltaExp);
      final double y2    = FastMath.scalb(v2.y,  deltaExp);
      final double z2    = FastMath.scalb(v2.z,  deltaExp);
 
              
        
             final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp);
      final double rho   = FastMath.rint(256 * ratio) / 256;
 
      final double x3 = x1 - rho * x2;
      final double y3 = y1 - rho * y2;
      final double z3 = z1 - rho * z2;
 
             return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2);
 
   }
 
"
282,"org.apache.commons.math.ConvergenceException","/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java","@@ -123,18 +123,11 @@ public double density(double x) {
      */
     public double cumulativeProbability(double x) throws MathException {
         final double dev = x - mean;
      try {
         return 0.5 * (1.0 + Erf.erf((dev) /
                     (standardDeviation * FastMath.sqrt(2.0))));
      } catch (MaxIterationsExceededException ex) {
          if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38
              return 0;
          } else if (x > (mean + 20 * standardDeviation)) {
              return 1;
          } else {
              throw ex;
          }
      }
     }
 
     /**
","@@ -123,18 +123,11 @@ public double density(double x) {
      */
     public double cumulativeProbability(double x) throws MathException {
         final double dev = x - mean;
      if (FastMath.abs(dev) > 40 * standardDeviation) { 
          return dev < 0 ? 0.0d : 1.0d;
      }
         return 0.5 * (1.0 + Erf.erf((dev) /
                     (standardDeviation * FastMath.sqrt(2.0))));
     }
 
     /**
","
      
     public double cumulativeProbability(double x) throws MathException {
         final double dev = x - mean;
        try {
         return 0.5 * (1.0 + Erf.erf((dev) /
                     (standardDeviation * FastMath.sqrt(2.0))));
        } catch (MaxIterationsExceededException ex) {
            if (x < (mean - 20 * standardDeviation)) {                 return 0;
            } else if (x > (mean + 20 * standardDeviation)) {
                return 1;
            } else {
                throw ex;
            }
        }
     }
 
","
      
     public double cumulativeProbability(double x) throws MathException {
         final double dev = x - mean;
        if (FastMath.abs(dev) > 40 * standardDeviation) { 
            return dev < 0 ? 0.0d : 1.0d;
        }
         return 0.5 * (1.0 + Erf.erf((dev) /
                     (standardDeviation * FastMath.sqrt(2.0))));
     }
 
"
283,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/dfp/Dfp.java","@@ -270,6 +270,9 @@ protected Dfp(final DfpField field, double x) {
             // Zero or sub-normal
             if (x == 0) {
                 // make sure 0 has the right sign
                 return;
             }
 
@@ -2316,7 +2319,10 @@ public double toDouble() {
 
         Dfp y = this;
         boolean negate = false;
      if (lessThan(getZero())) {
             y = negate();
             negate = true;
         }
","@@ -270,6 +270,9 @@ protected Dfp(final DfpField field, double x) {
             // Zero or sub-normal
             if (x == 0) {
                 // make sure 0 has the right sign
              if ((bits & 0x8000000000000000L) != 0) {
                  sign = -1;
              }
                 return;
             }
 
@@ -2316,7 +2319,10 @@ public double toDouble() {
 
         Dfp y = this;
         boolean negate = false;
      int cmp0 = compare(this, getZero());
      if (cmp0 == 0) {
          return sign < 0 ? -0.0 : +0.0;
      } else if (cmp0 < 0) {
             y = negate();
             negate = true;
         }
","
                          if (x == 0) {
                                  return;
             }
 

 
         Dfp y = this;
         boolean negate = false;
        if (lessThan(getZero())) {
             y = negate();
             negate = true;
         }
","
                          if (x == 0) {
                                 if ((bits & 0x8000000000000000L) != 0) {
                    sign = -1;
                }
                 return;
             }
 

 
         Dfp y = this;
         boolean negate = false;
        int cmp0 = compare(this, getZero());
        if (cmp0 == 0) {
            return sign < 0 ? -0.0 : +0.0;
        } else if (cmp0 < 0) {
             y = negate();
             negate = true;
         }
"
284,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java","@@ -234,13 +234,7 @@ public int getDimension() {
             indices[i] = idx;
         }
 
      int idx = 1;
      while (count < index) {
          count += idx;
          ++idx;
      }
      --idx;
      indices[last] = idx;
 
         return indices;
     }
","@@ -234,13 +234,7 @@ public int getDimension() {
             indices[i] = idx;
         }
 
      indices[last] = index - count;
 
         return indices;
     }
","
             indices[i] = idx;
         }
 
        int idx = 1;
        while (count < index) {
            count += idx;
            ++idx;
        }
        --idx;
        indices[last] = idx;
 
         return indices;
     }
","
             indices[i] = idx;
         }
 
        indices[last] = index - count;
 
         return indices;
     }
"
285,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java","@@ -341,7 +341,8 @@ public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {
   Vector3D k     = v1Su1.crossProduct(v2Su2);
   Vector3D u3    = u1.crossProduct(u2);
   double c       = k.dotProduct(u3);
if (c == 0) {
     // the (q1, q2, q3) vector is close to the (u1, u2) plane
     // we try other vectors
     Vector3D v3 = Vector3D.crossProduct(v1, v2);
@@ -350,13 +351,13 @@ public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {
     Vector3D u2Prime = u1.crossProduct(u3);
     c = k.dotProduct(u2Prime);
 
  if (c == 0) {
       // the (q1, q2, q3) vector is also close to the (u1, u3) plane,
       // it is almost aligned with u1: we try (u2, u3) and (v2, v3)
       k = v2Su2.crossProduct(v3Su3);;
       c = k.dotProduct(u2.crossProduct(u3));;
 
    if (c == 0) {
         // the (q1, q2, q3) vector is aligned with everything
         // this is really the identity rotation
         q0 = 1.0;
","@@ -341,7 +341,8 @@ public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {
   Vector3D k     = v1Su1.crossProduct(v2Su2);
   Vector3D u3    = u1.crossProduct(u2);
   double c       = k.dotProduct(u3);
final double inPlaneThreshold = 0.001;
if (c <= inPlaneThreshold * k.getNorm() * u3.getNorm()) {
     // the (q1, q2, q3) vector is close to the (u1, u2) plane
     // we try other vectors
     Vector3D v3 = Vector3D.crossProduct(v1, v2);
@@ -350,13 +351,13 @@ public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {
     Vector3D u2Prime = u1.crossProduct(u3);
     c = k.dotProduct(u2Prime);
 
  if (c <= inPlaneThreshold * k.getNorm() * u2Prime.getNorm()) {
       // the (q1, q2, q3) vector is also close to the (u1, u3) plane,
       // it is almost aligned with u1: we try (u2, u3) and (v2, v3)
       k = v2Su2.crossProduct(v3Su3);;
       c = k.dotProduct(u2.crossProduct(u3));;
 
    if (c <= 0) {
         // the (q1, q2, q3) vector is aligned with everything
         // this is really the identity rotation
         q0 = 1.0;
","
   Vector3D k     = v1Su1.crossProduct(v2Su2);
   Vector3D u3    = u1.crossProduct(u2);
   double c       = k.dotProduct(u3);
  if (c == 0) {
               Vector3D v3 = Vector3D.crossProduct(v1, v2);

     Vector3D u2Prime = u1.crossProduct(u3);
     c = k.dotProduct(u2Prime);
 
    if (c == 0) {
                     k = v2Su2.crossProduct(v3Su3);;
       c = k.dotProduct(u2.crossProduct(u3));;
 
      if (c == 0) {
                           q0 = 1.0;
","
   Vector3D k     = v1Su1.crossProduct(v2Su2);
   Vector3D u3    = u1.crossProduct(u2);
   double c       = k.dotProduct(u3);
  final double inPlaneThreshold = 0.001;
  if (c <= inPlaneThreshold * k.getNorm() * u3.getNorm()) {
               Vector3D v3 = Vector3D.crossProduct(v1, v2);

     Vector3D u2Prime = u1.crossProduct(u3);
     c = k.dotProduct(u2Prime);
 
    if (c <= inPlaneThreshold * k.getNorm() * u2Prime.getNorm()) {
                     k = v2Su2.crossProduct(v3Su3);;
       c = k.dotProduct(u2.crossProduct(u3));;
 
      if (c <= 0) {
                           q0 = 1.0;
"
286,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/util/MathUtils.java","@@ -414,7 +414,7 @@ public static double cosh(double x) {
      * @return {@code true} if the values are equal.
      */
     public static boolean equals(double x, double y) {
      return (Double.isNaN(x) && Double.isNaN(y)) || x == y;
     }
 
     /**
","@@ -414,7 +414,7 @@ public static double cosh(double x) {
      * @return {@code true} if the values are equal.
      */
     public static boolean equals(double x, double y) {
      return equals(x, y, 1);
     }
 
     /**
","
     
     public static boolean equals(double x, double y) {
        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;
     }
 
","
     
     public static boolean equals(double x, double y) {
        return equals(x, y, 1);
     }
 
"
287,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java","@@ -143,7 +143,7 @@ public UnivariateRealPointValuePair optimize(final FUNC f,
                                                  final GoalType goal,
                                                  final double min, final double max)
         throws FunctionEvaluationException {
      return optimize(f, goal, min, max, 0);
     }
 
     /** {@inheritDoc} */
@@ -157,9 +157,8 @@ public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal,
         // Multi-start loop.
         for (int i = 0; i < starts; ++i) {
             try {
              final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);
              final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);
              optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));
             } catch (FunctionEvaluationException fee) {
                 optima[i] = null;
             } catch (ConvergenceException ce) {
","@@ -143,7 +143,7 @@ public UnivariateRealPointValuePair optimize(final FUNC f,
                                                  final GoalType goal,
                                                  final double min, final double max)
         throws FunctionEvaluationException {
      return optimize(f, goal, min, max, min + 0.5 * (max - min));
     }
 
     /** {@inheritDoc} */
@@ -157,9 +157,8 @@ public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal,
         // Multi-start loop.
         for (int i = 0; i < starts; ++i) {
             try {
              final double s = (i == 0) ? startValue : min + generator.nextDouble() * (max - min);
              optima[i] = optimizer.optimize(f, goal, min, max, s);
             } catch (FunctionEvaluationException fee) {
                 optima[i] = null;
             } catch (ConvergenceException ce) {
","
                                                  final GoalType goal,
                                                  final double min, final double max)
         throws FunctionEvaluationException {
        return optimize(f, goal, min, max, 0);
     }
 

                  for (int i = 0; i < starts; ++i) {
             try {
                final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);
                final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);
                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));
             } catch (FunctionEvaluationException fee) {
                 optima[i] = null;
             } catch (ConvergenceException ce) {
","
                                                  final GoalType goal,
                                                  final double min, final double max)
         throws FunctionEvaluationException {
        return optimize(f, goal, min, max, min + 0.5 * (max - min));
     }
 

                  for (int i = 0; i < starts; ++i) {
             try {
                final double s = (i == 0) ? startValue : min + generator.nextDouble() * (max - min);
                optima[i] = optimizer.optimize(f, goal, min, max, s);
             } catch (FunctionEvaluationException fee) {
                 optima[i] = null;
             } catch (ConvergenceException ce) {
"
288,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java","@@ -41,10 +41,10 @@
      * Construct a solver.
      */
     public BrentOptimizer() {
      setMaxEvaluations(Integer.MAX_VALUE);
         setMaximalIterationCount(100);
      setAbsoluteAccuracy(1E-10);
      setRelativeAccuracy(1.0e-14);
     }
 
     /**
@@ -54,17 +54,10 @@ public BrentOptimizer() {
      */
     protected double doOptimize()
         throws MaxIterationsExceededException, FunctionEvaluationException {
      throw new UnsupportedOperationException();
  }
  public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {
      clearResult();
         return localMin(getGoalType() == GoalType.MINIMIZE,
                      f, goalType, min, startValue, max,
                         getRelativeAccuracy(), getAbsoluteAccuracy());
     }
  public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {
      return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min));
  }
 
     /**
      * Find the minimum of the function within the interval {@code (lo, hi)}.
@@ -91,8 +84,6 @@ public double optimize(final UnivariateRealFunction f, final GoalType goalType,
      * the function.
      */
     private double localMin(boolean isMinim,
                          UnivariateRealFunction f,
                          GoalType goalType,
                             double lo, double mid, double hi,
                             double eps, double t)
         throws MaxIterationsExceededException, FunctionEvaluationException {
@@ -116,15 +107,14 @@ private double localMin(boolean isMinim,
         double w = x;
         double d = 0;
         double e = 0;
      double fx = computeObjectiveValue(f, x);
      if (goalType == GoalType.MAXIMIZE) {
             fx = -fx;
         }
         double fv = fx;
         double fw = fx;
 
      int count = 0;
      while (count < maximalIterationCount) {
             double m = 0.5 * (a + b);
             final double tol1 = eps * Math.abs(x) + t;
             final double tol2 = 2 * tol1;
@@ -197,8 +187,8 @@ private double localMin(boolean isMinim,
                     u = x + d;
                 }
 
              double fu = computeObjectiveValue(f, u);
              if (goalType == GoalType.MAXIMIZE) {
                     fu = -fu;
                 }
 
@@ -235,11 +225,10 @@ private double localMin(boolean isMinim,
                     }
                 }
             } else { // termination
              setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);
                 return x;
             }
          ++count;
         }
      throw new MaxIterationsExceededException(maximalIterationCount);
     }
 }
","@@ -41,10 +41,10 @@
      * Construct a solver.
      */
     public BrentOptimizer() {
      setMaxEvaluations(1000);
         setMaximalIterationCount(100);
      setAbsoluteAccuracy(1e-11);
      setRelativeAccuracy(1e-9);
     }
 
     /**
@@ -54,17 +54,10 @@ public BrentOptimizer() {
      */
     protected double doOptimize()
         throws MaxIterationsExceededException, FunctionEvaluationException {
         return localMin(getGoalType() == GoalType.MINIMIZE,
                      getMin(), getStartValue(), getMax(),
                         getRelativeAccuracy(), getAbsoluteAccuracy());
     }
 
     /**
      * Find the minimum of the function within the interval {@code (lo, hi)}.
@@ -91,8 +84,6 @@ public double optimize(final UnivariateRealFunction f, final GoalType goalType,
      * the function.
      */
     private double localMin(boolean isMinim,
                             double lo, double mid, double hi,
                             double eps, double t)
         throws MaxIterationsExceededException, FunctionEvaluationException {
@@ -116,15 +107,14 @@ private double localMin(boolean isMinim,
         double w = x;
         double d = 0;
         double e = 0;
      double fx = computeObjectiveValue(x);
      if (!isMinim) {
             fx = -fx;
         }
         double fv = fx;
         double fw = fx;
 
      while (true) {
             double m = 0.5 * (a + b);
             final double tol1 = eps * Math.abs(x) + t;
             final double tol2 = 2 * tol1;
@@ -197,8 +187,8 @@ private double localMin(boolean isMinim,
                     u = x + d;
                 }
 
              double fu = computeObjectiveValue(u);
              if (!isMinim) {
                     fu = -fu;
                 }
 
@@ -235,11 +225,10 @@ private double localMin(boolean isMinim,
                     }
                 }
             } else { // termination
              setFunctionValue(isMinim ? fx : -fx);
                 return x;
             }
          incrementIterationsCounter();
         }
     }
 }
","
   
     public BrentOptimizer() {
        setMaxEvaluations(Integer.MAX_VALUE);
         setMaximalIterationCount(100);
        setAbsoluteAccuracy(1E-10);
        setRelativeAccuracy(1.0e-14);
     }
 

     protected double doOptimize()
         throws MaxIterationsExceededException, FunctionEvaluationException {
        throw new UnsupportedOperationException();
    }
    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {
        clearResult();
         return localMin(getGoalType() == GoalType.MINIMIZE,
                        f, goalType, min, startValue, max,
                         getRelativeAccuracy(), getAbsoluteAccuracy());
     }
    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {
        return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min));
    }
 
     

                            UnivariateRealFunction f,
                            GoalType goalType,
                             double lo, double mid, double hi,
                             double eps, double t)
         throws MaxIterationsExceededException, FunctionEvaluationException {

         double w = x;
         double d = 0;
         double e = 0;
        double fx = computeObjectiveValue(f, x);
        if (goalType == GoalType.MAXIMIZE) {
             fx = -fx;
         }
         double fv = fx;
         double fw = fx;
 
        int count = 0;
        while (count < maximalIterationCount) {
             double m = 0.5 * (a + b);
             final double tol1 = eps * Math.abs(x) + t;
             final double tol2 = 2 * tol1;

                     u = x + d;
                 }
 
                double fu = computeObjectiveValue(f, u);
                if (goalType == GoalType.MAXIMIZE) {
                     fu = -fu;
                 }
 

                     }
                 }
             } else {                 setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);
                 return x;
             }
            ++count;
         }
        throw new MaxIterationsExceededException(maximalIterationCount);
     }
 }
","
     public BrentOptimizer() {
        setMaxEvaluations(1000);
         setMaximalIterationCount(100);
        setAbsoluteAccuracy(1e-11);
        setRelativeAccuracy(1e-9);
     }
 

     protected double doOptimize()
         throws MaxIterationsExceededException, FunctionEvaluationException {
         return localMin(getGoalType() == GoalType.MINIMIZE,
                        getMin(), getStartValue(), getMax(),
                         getRelativeAccuracy(), getAbsoluteAccuracy());
     }
 

                             double lo, double mid, double hi,
                             double eps, double t)
         throws MaxIterationsExceededException, FunctionEvaluationException {

         double w = x;
         double d = 0;
         double e = 0;
        double fx = computeObjectiveValue(x);
        if (!isMinim) {
             fx = -fx;
         }
         double fv = fx;
         double fw = fx;
 
        while (true) {
             double m = 0.5 * (a + b);
             final double tol1 = eps * Math.abs(x) + t;
             final double tol2 = 2 * tol1;

                     u = x + d;
                 }
 
                double fu = computeObjectiveValue(u);
                if (!isMinim) {
                     fu = -fu;
                 }
 

                     }
                 }
             } else {                 setFunctionValue(isMinim ? fx : -fx);
                 return x;
             }
            incrementIterationsCounter();
         }
     }
 }
"
289,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java","@@ -239,30 +239,25 @@ protected void updateResidualsAndCost()
     public double getRMS() {
      double criterion = 0;
      for (int i = 0; i < rows; ++i) {
          final double residual = residuals[i];
          criterion += residual * residual * residualsWeights[i];
      }
      return Math.sqrt(criterion / rows);
     }
 
     /**
      * Get a Chi-Square-like value assuming the N residuals follow N
      * distinct normal distributions centered on 0 and whose variances are
      * the reciprocal of the weights.
      * @return chi-square value
      */
     public double getChiSquare() {
         double chiSquare = 0;
         for (int i = 0; i < rows; ++i) {
             final double residual = residuals[i];
          chiSquare += residual * residual / residualsWeights[i];
         }
         return chiSquare;
     }
 
     /**
      * Get the covariance matrix of optimized parameters.
      * @return covariance matrix
      * @exception FunctionEvaluationException if the function jacobian cannot
      * be evaluated
      * @exception OptimizationException if the covariance matrix
","@@ -239,30 +239,25 @@ protected void updateResidualsAndCost()
     public double getRMS() {
      return Math.sqrt(getChiSquare() / rows);
     }
 
     /**
      * Get a Chi-Square-like value assuming the N residuals follow N
      * distinct normal distributions centered on 0 and whose variances are
      * the reciprocal of the weights.
      * @return chi-square value
      */
     public double getChiSquare() {
         double chiSquare = 0;
         for (int i = 0; i < rows; ++i) {
             final double residual = residuals[i];
          chiSquare += residual * residual * residualsWeights[i];
         }
         return chiSquare;
     }
 
     /**
      * Get the covariance matrix of optimized parameters.
      * @return covariance matrix
      * @exception FunctionEvaluationException if the function jacobian cannot
      * be evaluated
      * @exception OptimizationException if the covariance matrix
","
     public double getRMS() {
        double criterion = 0;
        for (int i = 0; i < rows; ++i) {
            final double residual = residuals[i];
            criterion += residual * residual * residualsWeights[i];
        }
        return Math.sqrt(criterion / rows);
     }
     public double getChiSquare() {
         double chiSquare = 0;
         for (int i = 0; i < rows; ++i) {
             final double residual = residuals[i];
            chiSquare += residual * residual / residualsWeights[i];
         }
         return chiSquare;
     }
","
     public double getRMS() {
        return Math.sqrt(getChiSquare() / rows);
     }
     public double getChiSquare() {
         double chiSquare = 0;
         for (int i = 0; i < rows; ++i) {
             final double residual = residuals[i];
            chiSquare += residual * residual * residualsWeights[i];
         }
         return chiSquare;
     }
"
290,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java","@@ -255,6 +255,8 @@ protected VectorialPointValuePair doOptimize()
         double[] diag    = new double[cols];
         double[] oldX    = new double[cols];
         double[] oldRes  = new double[rows];
         double[] work1   = new double[cols];
         double[] work2   = new double[cols];
         double[] work3   = new double[cols];
@@ -267,6 +269,9 @@ protected VectorialPointValuePair doOptimize()
         boolean firstIteration = true;
         VectorialPointValuePair current = new VectorialPointValuePair(point, objective);
         while (true) {
             incrementIterationsCounter();
 
             // compute the Q.R. decomposition of the jacobian matrix
@@ -275,7 +280,7 @@ protected VectorialPointValuePair doOptimize()
             qrDecomposition();
 
             // compute Qt.res
          qTy(residuals);
             // now we don't need Q anymore,
             // so let jacobian contain the R matrix with its diagonal elements
             for (int k = 0; k < solvedCols; ++k) {
@@ -313,7 +318,7 @@ protected VectorialPointValuePair doOptimize()
                     if (s != 0) {
                         double sum = 0;
                         for (int i = 0; i <= j; ++i) {
                          sum += jacobian[i][pj] * residuals[i];
                         }
                         maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
                     }
@@ -321,6 +326,8 @@ protected VectorialPointValuePair doOptimize()
             }
             if (maxCosine <= orthoTolerance) {
                 // convergence has been reached
                 return current;
             }
 
@@ -341,9 +348,12 @@ protected VectorialPointValuePair doOptimize()
                 double[] tmpVec = residuals;
                 residuals = oldRes;
                 oldRes    = tmpVec;
 
                 // determine the Levenberg-Marquardt parameter
              determineLMParameter(oldRes, delta, diag, work1, work2, work3);
 
                 // compute the new point and the norm of the evolution direction
                 double lmNorm = 0;
@@ -362,7 +372,6 @@ protected VectorialPointValuePair doOptimize()
 
                 // evaluate the function at x + p and calculate its norm
                 updateResidualsAndCost();
              current = new VectorialPointValuePair(point, objective);
 
                 // compute the scaled actual reduction
                 double actRed = -1.0;
@@ -418,9 +427,15 @@ protected VectorialPointValuePair doOptimize()
                         xNorm    += xK * xK;
                     }
                     xNorm = Math.sqrt(xNorm);
 
                     // tests for convergence.
                     // we use the vectorial convergence checker
                 } else {
                     // failed iteration, reset the previous values
                     cost = previousCost;
@@ -431,6 +446,9 @@ protected VectorialPointValuePair doOptimize()
                     tmpVec    = residuals;
                     residuals = oldRes;
                     oldRes    = tmpVec;
                 }
                 if (checker==null) {
                 	if (((Math.abs(actRed) <= costRelativeTolerance) &&
@@ -439,10 +457,6 @@ protected VectorialPointValuePair doOptimize()
                        (delta <= parRelativeTolerance * xNorm)) {
                        return current;
                    }
              } else {
                  if (checker.converged(getIterations(), previous, current)) {
                      return current;
                  }
                 }
                 // tests for termination and stringent tolerances
                 // (2.2204e-16 is the machine epsilon for IEEE754)
","@@ -255,6 +255,8 @@ protected VectorialPointValuePair doOptimize()
         double[] diag    = new double[cols];
         double[] oldX    = new double[cols];
         double[] oldRes  = new double[rows];
      double[] oldObj  = new double[rows];
      double[] qtf     = new double[rows];
         double[] work1   = new double[cols];
         double[] work2   = new double[cols];
         double[] work3   = new double[cols];
@@ -267,6 +269,9 @@ protected VectorialPointValuePair doOptimize()
         boolean firstIteration = true;
         VectorialPointValuePair current = new VectorialPointValuePair(point, objective);
         while (true) {
          for (int i=0;i<rows;i++) {
              qtf[i]=residuals[i];
          }
             incrementIterationsCounter();
 
             // compute the Q.R. decomposition of the jacobian matrix
@@ -275,7 +280,7 @@ protected VectorialPointValuePair doOptimize()
             qrDecomposition();
 
             // compute Qt.res
          qTy(qtf);
             // now we don't need Q anymore,
             // so let jacobian contain the R matrix with its diagonal elements
             for (int k = 0; k < solvedCols; ++k) {
@@ -313,7 +318,7 @@ protected VectorialPointValuePair doOptimize()
                     if (s != 0) {
                         double sum = 0;
                         for (int i = 0; i <= j; ++i) {
                          sum += jacobian[i][pj] * qtf[i];
                         }
                         maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
                     }
@@ -321,6 +326,8 @@ protected VectorialPointValuePair doOptimize()
             }
             if (maxCosine <= orthoTolerance) {
                 // convergence has been reached
          	updateResidualsAndCost();
          	current = new VectorialPointValuePair(point, objective);
                 return current;
             }
 
@@ -341,9 +348,12 @@ protected VectorialPointValuePair doOptimize()
                 double[] tmpVec = residuals;
                 residuals = oldRes;
                 oldRes    = tmpVec;
              tmpVec    = objective;
              objective = oldObj;
              oldObj    = tmpVec;
 
                 // determine the Levenberg-Marquardt parameter
              determineLMParameter(qtf, delta, diag, work1, work2, work3);
 
                 // compute the new point and the norm of the evolution direction
                 double lmNorm = 0;
@@ -362,7 +372,6 @@ protected VectorialPointValuePair doOptimize()
 
                 // evaluate the function at x + p and calculate its norm
                 updateResidualsAndCost();
 
                 // compute the scaled actual reduction
                 double actRed = -1.0;
@@ -418,9 +427,15 @@ protected VectorialPointValuePair doOptimize()
                         xNorm    += xK * xK;
                     }
                     xNorm = Math.sqrt(xNorm);
                  current = new VectorialPointValuePair(point, objective);
 
                     // tests for convergence.
                  if (checker != null) {
                     // we use the vectorial convergence checker
                  	if (checker.converged(getIterations(), previous, current)) {
                  		return current;
                  	}
                  }
                 } else {
                     // failed iteration, reset the previous values
                     cost = previousCost;
@@ -431,6 +446,9 @@ protected VectorialPointValuePair doOptimize()
                     tmpVec    = residuals;
                     residuals = oldRes;
                     oldRes    = tmpVec;
                  tmpVec    = objective;
                  objective = oldObj;
                  oldObj    = tmpVec;
                 }
                 if (checker==null) {
                 	if (((Math.abs(actRed) <= costRelativeTolerance) &&
@@ -439,10 +457,6 @@ protected VectorialPointValuePair doOptimize()
                        (delta <= parRelativeTolerance * xNorm)) {
                        return current;
                    }
                 }
                 // tests for termination and stringent tolerances
                 // (2.2204e-16 is the machine epsilon for IEEE754)
","
         double[] diag    = new double[cols];
         double[] oldX    = new double[cols];
         double[] oldRes  = new double[rows];
         double[] work1   = new double[cols];
         double[] work2   = new double[cols];
         double[] work3   = new double[cols];

         boolean firstIteration = true;
         VectorialPointValuePair current = new VectorialPointValuePair(point, objective);
         while (true) {
             incrementIterationsCounter();
 
             
             qrDecomposition();
 
                         qTy(residuals);
                                       for (int k = 0; k < solvedCols; ++k) {

                     if (s != 0) {
                         double sum = 0;
                         for (int i = 0; i <= j; ++i) {
                            sum += jacobian[i][pj] * residuals[i];
                         }
                         maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
                     }

             }
             if (maxCosine <= orthoTolerance) {
                                  return current;
             }
 

                 double[] tmpVec = residuals;
                 residuals = oldRes;
                 oldRes    = tmpVec;
 
                                 determineLMParameter(oldRes, delta, diag, work1, work2, work3);
 
                                  double lmNorm = 0;

 
                                  updateResidualsAndCost();
                current = new VectorialPointValuePair(point, objective);
 
                                  double actRed = -1.0;

                         xNorm    += xK * xK;
                     }
                     xNorm = Math.sqrt(xNorm);
 
                                                           } else {
                                          cost = previousCost;

                     tmpVec    = residuals;
                     residuals = oldRes;
                     oldRes    = tmpVec;
                 }
                 if (checker==null) {
                 	if (((Math.abs(actRed) <= costRelativeTolerance) &&

                        (delta <= parRelativeTolerance * xNorm)) {
                        return current;
                    }
                } else {
                    if (checker.converged(getIterations(), previous, current)) {
                        return current;
                    }
                 }
                                  ","
         double[] diag    = new double[cols];
         double[] oldX    = new double[cols];
         double[] oldRes  = new double[rows];
        double[] oldObj  = new double[rows];
        double[] qtf     = new double[rows];
         double[] work1   = new double[cols];
         double[] work2   = new double[cols];
         double[] work3   = new double[cols];

         boolean firstIteration = true;
         VectorialPointValuePair current = new VectorialPointValuePair(point, objective);
         while (true) {
            for (int i=0;i<rows;i++) {
                qtf[i]=residuals[i];
            }
             incrementIterationsCounter();
 
             
             qrDecomposition();
 
                         qTy(qtf);
                                       for (int k = 0; k < solvedCols; ++k) {

                     if (s != 0) {
                         double sum = 0;
                         for (int i = 0; i <= j; ++i) {
                            sum += jacobian[i][pj] * qtf[i];
                         }
                         maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));
                     }

             }
             if (maxCosine <= orthoTolerance) {
                             	updateResidualsAndCost();
            	current = new VectorialPointValuePair(point, objective);
                 return current;
             }
 

                 double[] tmpVec = residuals;
                 residuals = oldRes;
                 oldRes    = tmpVec;
                tmpVec    = objective;
                objective = oldObj;
                oldObj    = tmpVec;
 
                                 determineLMParameter(qtf, delta, diag, work1, work2, work3);
 
                                  double lmNorm = 0;

 
                                  updateResidualsAndCost();
 
                                  double actRed = -1.0;

                         xNorm    += xK * xK;
                     }
                     xNorm = Math.sqrt(xNorm);
                    current = new VectorialPointValuePair(point, objective);
 
                                         if (checker != null) {
                                         	if (checker.converged(getIterations(), previous, current)) {
                    		return current;
                    	}
                    }
                 } else {
                                          cost = previousCost;

                     tmpVec    = residuals;
                     residuals = oldRes;
                     oldRes    = tmpVec;
                    tmpVec    = objective;
                    objective = oldObj;
                    oldObj    = tmpVec;
                 }
                 if (checker==null) {
                 	if (((Math.abs(actRed) <= costRelativeTolerance) &&

                        (delta <= parRelativeTolerance * xNorm)) {
                        return current;
                    }
                 }
                                  "
291,"java.lang.NullPointerException","/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java","@@ -69,7 +69,7 @@ public double solve(double min, double max)
     /** {@inheritDoc} */
     public double solve(final UnivariateRealFunction f, double min, double max, double initial)
         throws MaxIterationsExceededException, FunctionEvaluationException {
      return solve(min, max);
     }
 
     /** {@inheritDoc} */
","@@ -69,7 +69,7 @@ public double solve(double min, double max)
     /** {@inheritDoc} */
     public double solve(final UnivariateRealFunction f, double min, double max, double initial)
         throws MaxIterationsExceededException, FunctionEvaluationException {
      return solve(f, min, max);
     }
 
     /** {@inheritDoc} */
","
     public double solve(final UnivariateRealFunction f, double min, double max, double initial)
         throws MaxIterationsExceededException, FunctionEvaluationException {
        return solve(min, max);
     }
 
","
     public double solve(final UnivariateRealFunction f, double min, double max, double initial)
         throws MaxIterationsExceededException, FunctionEvaluationException {
        return solve(f, min, max);
     }
 
"
292,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java","@@ -163,6 +163,7 @@ public LevenbergMarquardtOptimizer() {
         setMaxIterations(1000);
 
         // default values for the tuning parameters
         setInitialStepBoundFactor(100.0);
         setCostRelativeTolerance(1.0e-10);
         setParRelativeTolerance(1.0e-10);
@@ -244,11 +245,13 @@ protected VectorialPointValuePair doOptimize()
         // outer loop
         lmPar = 0;
         boolean firstIteration = true;
         while (true) {
 
             incrementIterationsCounter();
 
             // compute the Q.R. decomposition of the jacobian matrix
             updateJacobian();
             qrDecomposition();
 
@@ -300,7 +303,7 @@ protected VectorialPointValuePair doOptimize()
             }
             if (maxCosine <= orthoTolerance) {
                 // convergence has been reached
              return new VectorialPointValuePair(point, objective);
             }
 
             // rescale if necessary
@@ -342,6 +345,7 @@ protected VectorialPointValuePair doOptimize()
 
                 // evaluate the function at x + p and calculate its norm
                 updateResidualsAndCost();
 
                 // compute the scaled actual reduction
                 double actRed = -1.0;
@@ -410,14 +414,20 @@ protected VectorialPointValuePair doOptimize()
                 }
 
                 // tests for convergence.
                     // we use the vectorial convergence checker
                     // we use the Levenberg-Marquardt specific convergence parameters
                     if (((Math.abs(actRed) <= costRelativeTolerance) &&
                          (preRed <= costRelativeTolerance) &&
                          (ratio <= 2.0)) ||
                         (delta <= parRelativeTolerance * xNorm)) {
                      return new VectorialPointValuePair(point, objective);
                     }
 
                 // tests for termination and stringent tolerances
                 // (2.2204e-16 is the machine epsilon for IEEE754)
","@@ -163,6 +163,7 @@ public LevenbergMarquardtOptimizer() {
         setMaxIterations(1000);
 
         // default values for the tuning parameters
      setConvergenceChecker(null);
         setInitialStepBoundFactor(100.0);
         setCostRelativeTolerance(1.0e-10);
         setParRelativeTolerance(1.0e-10);
@@ -244,11 +245,13 @@ protected VectorialPointValuePair doOptimize()
         // outer loop
         lmPar = 0;
         boolean firstIteration = true;
      VectorialPointValuePair current = new VectorialPointValuePair(point, objective);
         while (true) {
 
             incrementIterationsCounter();
 
             // compute the Q.R. decomposition of the jacobian matrix
          VectorialPointValuePair previous = current;
             updateJacobian();
             qrDecomposition();
 
@@ -300,7 +303,7 @@ protected VectorialPointValuePair doOptimize()
             }
             if (maxCosine <= orthoTolerance) {
                 // convergence has been reached
              return current;
             }
 
             // rescale if necessary
@@ -342,6 +345,7 @@ protected VectorialPointValuePair doOptimize()
 
                 // evaluate the function at x + p and calculate its norm
                 updateResidualsAndCost();
              current = new VectorialPointValuePair(point, objective);
 
                 // compute the scaled actual reduction
                 double actRed = -1.0;
@@ -410,14 +414,20 @@ protected VectorialPointValuePair doOptimize()
                 }
 
                 // tests for convergence.
              if (checker != null) {
                     // we use the vectorial convergence checker
                  if (checker.converged(getIterations(), previous, current)) {
                      return current;                        
                  }
              } else {
                     // we use the Levenberg-Marquardt specific convergence parameters
                     if (((Math.abs(actRed) <= costRelativeTolerance) &&
                          (preRed <= costRelativeTolerance) &&
                          (ratio <= 2.0)) ||
                         (delta <= parRelativeTolerance * xNorm)) {
                      return current;
                     }
              }
 
                 // tests for termination and stringent tolerances
                 // (2.2204e-16 is the machine epsilon for IEEE754)
","
         setMaxIterations(1000);
 
                  setInitialStepBoundFactor(100.0);
         setCostRelativeTolerance(1.0e-10);
         setParRelativeTolerance(1.0e-10);

                  lmPar = 0;
         boolean firstIteration = true;
         while (true) {
 
             incrementIterationsCounter();
 
                          updateJacobian();
             qrDecomposition();
 

             }
             if (maxCosine <= orthoTolerance) {
                                 return new VectorialPointValuePair(point, objective);
             }
 
             
 
                                  updateResidualsAndCost();
 
                                  double actRed = -1.0;

                 }
 
                                                                                if (((Math.abs(actRed) <= costRelativeTolerance) &&
                          (preRed <= costRelativeTolerance) &&
                          (ratio <= 2.0)) ||
                         (delta <= parRelativeTolerance * xNorm)) {
                        return new VectorialPointValuePair(point, objective);
                     }
 
                                  ","
         setMaxIterations(1000);
 
                 setConvergenceChecker(null);
         setInitialStepBoundFactor(100.0);
         setCostRelativeTolerance(1.0e-10);
         setParRelativeTolerance(1.0e-10);

                  lmPar = 0;
         boolean firstIteration = true;
        VectorialPointValuePair current = new VectorialPointValuePair(point, objective);
         while (true) {
 
             incrementIterationsCounter();
 
                         VectorialPointValuePair previous = current;
             updateJacobian();
             qrDecomposition();
 

             }
             if (maxCosine <= orthoTolerance) {
                                 return current;
             }
 
             
 
                                  updateResidualsAndCost();
                current = new VectorialPointValuePair(point, objective);
 
                                  double actRed = -1.0;

                 }
 
                                 if (checker != null) {
                                         if (checker.converged(getIterations(), previous, current)) {
                        return current;                        
                    }
                } else {
                                          if (((Math.abs(actRed) <= costRelativeTolerance) &&
                          (preRed <= costRelativeTolerance) &&
                          (ratio <= 2.0)) ||
                         (delta <= parRelativeTolerance * xNorm)) {
                        return current;
                     }
                }
 
                                  "
293,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java","@@ -168,7 +168,7 @@ public RealMatrix getCorrelationPValues() throws MathException {
                 } else {
                     double r = correlationMatrix.getEntry(i, j);
                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));
                  out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));
                 }
             }
         }
","@@ -168,7 +168,7 @@ public RealMatrix getCorrelationPValues() throws MathException {
                 } else {
                     double r = correlationMatrix.getEntry(i, j);
                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));
                  out[i][j] = 2 * tDistribution.cumulativeProbability(-t);
                 }
             }
         }
","
                 } else {
                     double r = correlationMatrix.getEntry(i, j);
                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));
                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));
                 }
             }
         }
","
                 } else {
                     double r = correlationMatrix.getEntry(i, j);
                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));
                    out[i][j] = 2 * tDistribution.cumulativeProbability(-t);
                 }
             }
         }
"
294,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java","@@ -297,6 +297,10 @@ public double integrate(final FirstOrderDifferentialEquations equations,
                   // it is so small (much probably exactly 0 due to limited accuracy)
                   // that the code above would fail handling it.
                   // So we set up an artificial 0 size step by copying states
                   loop     = false;
               } else {
                   // reject the step to match exactly the next switch time
/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java @@ -177,6 +177,9 @@ public double integrate(final FirstOrderDifferentialEquations equations,
                 // it is so small (much probably exactly 0 due to limited accuracy)
                 // that the code above would fail handling it.
                 // So we set up an artificial 0 size step by copying states
                 loop     = false;
             } else {
                 // reject the step to match exactly the next switch time
","@@ -297,6 +297,10 @@ public double integrate(final FirstOrderDifferentialEquations equations,
                   // it is so small (much probably exactly 0 due to limited accuracy)
                   // that the code above would fail handling it.
                   // So we set up an artificial 0 size step by copying states
                interpolator.storeTime(stepStart);
                System.arraycopy(y, 0, yTmp, 0, y0.length);
                hNew     = 0;
                stepSize = 0;
                   loop     = false;
               } else {
                   // reject the step to match exactly the next switch time
/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java @@ -177,6 +177,9 @@ public double integrate(final FirstOrderDifferentialEquations equations,
                 // it is so small (much probably exactly 0 due to limited accuracy)
                 // that the code above would fail handling it.
                 // So we set up an artificial 0 size step by copying states
              interpolator.storeTime(stepStart);
              System.arraycopy(y, 0, yTmp, 0, y0.length);
              stepSize = 0;
                 loop     = false;
             } else {
                 // reject the step to match exactly the next switch time
","
                                                                            loop     = false;
               } else {

                                                                    loop     = false;
             } else {
                 ","
                                                                           interpolator.storeTime(stepStart);
                  System.arraycopy(y, 0, yTmp, 0, y0.length);
                  hNew     = 0;
                  stepSize = 0;
                   loop     = false;
               } else {

                                                                   interpolator.storeTime(stepStart);
                System.arraycopy(y, 0, yTmp, 0, y0.length);
                stepSize = 0;
                 loop     = false;
             } else {
                 "
295,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java","@@ -112,7 +112,7 @@ public double solve(final UnivariateRealFunction f,
         // return the first endpoint if it is good enough
         double yMin = f.value(min);
         if (Math.abs(yMin) <= functionValueAccuracy) {
          setResult(yMin, 0);
             return result;
         }
 
@@ -124,7 +124,7 @@ public double solve(final UnivariateRealFunction f,
         // return the second endpoint if it is good enough
         double yMax = f.value(max);
         if (Math.abs(yMax) <= functionValueAccuracy) {
          setResult(yMax, 0);
             return result;
         }
 
","@@ -112,7 +112,7 @@ public double solve(final UnivariateRealFunction f,
         // return the first endpoint if it is good enough
         double yMin = f.value(min);
         if (Math.abs(yMin) <= functionValueAccuracy) {
          setResult(min, 0);
             return result;
         }
 
@@ -124,7 +124,7 @@ public double solve(final UnivariateRealFunction f,
         // return the second endpoint if it is good enough
         double yMax = f.value(max);
         if (Math.abs(yMax) <= functionValueAccuracy) {
          setResult(max, 0);
             return result;
         }
 
","
                  double yMin = f.value(min);
         if (Math.abs(yMin) <= functionValueAccuracy) {
            setResult(yMin, 0);
             return result;
         }
 

                  double yMax = f.value(max);
         if (Math.abs(yMax) <= functionValueAccuracy) {
            setResult(yMax, 0);
             return result;
         }
 
","
                  double yMin = f.value(min);
         if (Math.abs(yMin) <= functionValueAccuracy) {
            setResult(min, 0);
             return result;
         }
 

                  double yMax = f.value(max);
         if (Math.abs(yMax) <= functionValueAccuracy) {
            setResult(max, 0);
             return result;
         }
 
"
296,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java","@@ -89,12 +89,12 @@ public MultiStartUnivariateRealOptimizer(final UnivariateRealOptimizer optimizer
 
     /** {@inheritDoc} */
     public double getFunctionValue() {
      return optimizer.getFunctionValue();
     }
 
     /** {@inheritDoc} */
     public double getResult() {
      return optimizer.getResult();
     }
 
     /** {@inheritDoc} */
","@@ -89,12 +89,12 @@ public MultiStartUnivariateRealOptimizer(final UnivariateRealOptimizer optimizer
 
     /** {@inheritDoc} */
     public double getFunctionValue() {
      return optimaValues[0];
     }
 
     /** {@inheritDoc} */
     public double getResult() {
      return optima[0];
     }
 
     /** {@inheritDoc} */
","
 
     
     public double getFunctionValue() {
        return optimizer.getFunctionValue();
     }
 
     
     public double getResult() {
        return optimizer.getResult();
     }
 
     
","
 
     
     public double getFunctionValue() {
        return optimaValues[0];
     }
 
     
     public double getResult() {
        return optima[0];
     }
 
     
"
297,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java","@@ -133,6 +133,10 @@ public double solve(final UnivariateRealFunction f,
             return solve(f, initial, yInitial, max, yMax, initial, yInitial);
         }
 
 
         // full Brent algorithm starting with provided initial guess
         return solve(f, min, yMin, max, yMax, initial, yInitial);
","@@ -133,6 +133,10 @@ public double solve(final UnivariateRealFunction f,
             return solve(f, initial, yInitial, max, yMax, initial, yInitial);
         }
 
      if (yMin * yMax > 0) {
          throw MathRuntimeException.createIllegalArgumentException(
                NON_BRACKETING_MESSAGE, min, max, yMin, yMax);
      }
 
         // full Brent algorithm starting with provided initial guess
         return solve(f, min, yMin, max, yMax, initial, yInitial);
","
             return solve(f, initial, yInitial, max, yMax, initial, yInitial);
         }
 
 
                  return solve(f, min, yMin, max, yMax, initial, yInitial);
","
             return solve(f, initial, yInitial, max, yMax, initial, yInitial);
         }
 
        if (yMin * yMax > 0) {
            throw MathRuntimeException.createIllegalArgumentException(
                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);
        }
 
                  return solve(f, min, yMin, max, yMax, initial, yInitial);
"
298,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java","@@ -242,12 +242,15 @@ public double integrate(final FirstOrderDifferentialEquations equations,
         }
 
         if (firstTime) {
        final double[] scale;
           if (vecAbsoluteTolerance == null) {
            scale = new double[y0.length];
            java.util.Arrays.fill(scale, scalAbsoluteTolerance);
             } else {
            scale = vecAbsoluteTolerance;
             }
           hNew = initializeStep(equations, forward, getOrder(), scale,
                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);
","@@ -242,12 +242,15 @@ public double integrate(final FirstOrderDifferentialEquations equations,
         }
 
         if (firstTime) {
        final double[] scale = new double[y0.length];
           if (vecAbsoluteTolerance == null) {
            for (int i = 0; i < scale.length; ++i) {
              scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);
            }
             } else {
            for (int i = 0; i < scale.length; ++i) {
              scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);
            }
             }
           hNew = initializeStep(equations, forward, getOrder(), scale,
                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);
","
         }
 
         if (firstTime) {
          final double[] scale;
           if (vecAbsoluteTolerance == null) {
              scale = new double[y0.length];
              java.util.Arrays.fill(scale, scalAbsoluteTolerance);
             } else {
              scale = vecAbsoluteTolerance;
             }
           hNew = initializeStep(equations, forward, getOrder(), scale,
                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);
","
         }
 
         if (firstTime) {
          final double[] scale = new double[y0.length];
           if (vecAbsoluteTolerance == null) {
              for (int i = 0; i < scale.length; ++i) {
                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);
              }
             } else {
              for (int i = 0; i < scale.length; ++i) {
                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);
              }
             }
           hNew = initializeStep(equations, forward, getOrder(), scale,
                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);
"
299,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/stat/Frequency.java","@@ -300,7 +300,7 @@ public long getCount(char v) {
      */
     @Deprecated
     public double getPct(Object v) {
      return getCumPct((Comparable<?>) v);
     }
 
     /**
","@@ -300,7 +300,7 @@ public long getCount(char v) {
      */
     @Deprecated
     public double getPct(Object v) {
      return getPct((Comparable<?>) v);
     }
 
     /**
","
      
     @Deprecated
     public double getPct(Object v) {
        return getCumPct((Comparable<?>) v);
     }
 
","
      
     @Deprecated
     public double getPct(Object v) {
        return getPct((Comparable<?>) v);
     }
 
"
300,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java","@@ -718,7 +718,7 @@ public double getL1Norm() {
     public double getLInfNorm() {
         double max = 0;
         for (double a : data) {
          max += Math.max(max, Math.abs(a));
         }
         return max;
     }
/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java @@ -495,15 +495,6 @@ public double getL1Distance(double[] v) throws IllegalArgumentException {
         return max;
     }
 
  public double getLInfNorm() {
      double max = 0;
      Iterator iter = entries.iterator();
      while (iter.hasNext()) {
          iter.advance();
          max += iter.value();
      }
      return max;
  }
     /**
      * Optimized method to compute LInfDistance.
      * @param v The vector to compute from
","@@ -718,7 +718,7 @@ public double getL1Norm() {
     public double getLInfNorm() {
         double max = 0;
         for (double a : data) {
          max = Math.max(max, Math.abs(a));
         }
         return max;
     }
/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java @@ -495,15 +495,6 @@ public double getL1Distance(double[] v) throws IllegalArgumentException {
         return max;
     }
 
     /**
      * Optimized method to compute LInfDistance.
      * @param v The vector to compute from
","
     public double getLInfNorm() {
         double max = 0;
         for (double a : data) {
            max += Math.max(max, Math.abs(a));
         }
         return max;
     }

         return max;
     }
 
    public double getLInfNorm() {
        double max = 0;
        Iterator iter = entries.iterator();
        while (iter.hasNext()) {
            iter.advance();
            max += iter.value();
        }
        return max;
    }
","
     public double getLInfNorm() {
         double max = 0;
         for (double a : data) {
            max = Math.max(max, Math.abs(a));
         }
         return max;
     }

         return max;
     }
"
301,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java","@@ -79,7 +79,7 @@ private Integer getPivotRow(final int col, final SimplexTableau tableau) {
         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
             final double entry = tableau.getEntry(i, col);
          if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {
                 final double ratio = rhs / entry;
                 if (ratio < minRatio) {
                     minRatio = ratio;
","@@ -79,7 +79,7 @@ private Integer getPivotRow(final int col, final SimplexTableau tableau) {
         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
             final double entry = tableau.getEntry(i, col);
          if (MathUtils.compareTo(entry, 0, epsilon) > 0) {
                 final double ratio = rhs / entry;
                 if (ratio < minRatio) {
                     minRatio = ratio;
","
         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
             final double entry = tableau.getEntry(i, col);
            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {
                 final double ratio = rhs / entry;
                 if (ratio < minRatio) {
                     minRatio = ratio;
","
         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {
             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);
             final double entry = tableau.getEntry(i, col);
            if (MathUtils.compareTo(entry, 0, epsilon) > 0) {
                 final double ratio = rhs / entry;
                 if (ratio < minRatio) {
                     minRatio = ratio;
"
302,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java","@@ -159,24 +159,27 @@ public RealMatrix getU()
             if (m >= n) {
                 // the tridiagonal matrix is Bt.B, where B is upper bidiagonal
                 final RealMatrix e =
                  eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);
                 final double[][] eData = e.getData();
                 final double[][] wData = new double[m][p];
                 double[] ei1 = eData[0];
              for (int i = 0; i < p - 1; ++i) {
                     // compute W = B.E.S^(-1) where E is the eigenvectors matrix
                     final double mi = mainBidiagonal[i];
                     final double[] ei0 = ei1;
                     final double[] wi  = wData[i];
                         ei1 = eData[i + 1];
                         final double si = secondaryBidiagonal[i];
                         for (int j = 0; j < p; ++j) {
                             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
                         }
              }
                         for (int j = 0; j < p; ++j) {
                          wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];
                         }
 
                 for (int i = p; i < m; ++i) {
                     wData[i] = new double[p];
@@ -245,23 +248,26 @@ public RealMatrix getV()
                 // the tridiagonal matrix is B.Bt, where B is lower bidiagonal
                 // compute W = Bt.E.S^(-1) where E is the eigenvectors matrix
                 final RealMatrix e =
                  eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);
                 final double[][] eData = e.getData();
                 final double[][] wData = new double[n][p];
                 double[] ei1 = eData[0];
              for (int i = 0; i < p - 1; ++i) {
                     final double mi = mainBidiagonal[i];
                     final double[] ei0 = ei1;
                     final double[] wi  = wData[i];
                         ei1 = eData[i + 1];
                         final double si = secondaryBidiagonal[i];
                         for (int j = 0; j < p; ++j) {
                             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
                         }
              }
                         for (int j = 0; j < p; ++j) {
                          wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];
                         }
                 for (int i = p; i < n; ++i) {
                     wData[i] = new double[p];
                 }
","@@ -159,24 +159,27 @@ public RealMatrix getU()
             if (m >= n) {
                 // the tridiagonal matrix is Bt.B, where B is upper bidiagonal
                 final RealMatrix e =
                  eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);
                 final double[][] eData = e.getData();
                 final double[][] wData = new double[m][p];
                 double[] ei1 = eData[0];
              for (int i = 0; i < p; ++i) {
                     // compute W = B.E.S^(-1) where E is the eigenvectors matrix
                     final double mi = mainBidiagonal[i];
                     final double[] ei0 = ei1;
                     final double[] wi  = wData[i];
                  if (i < n - 1) {
                         ei1 = eData[i + 1];
                         final double si = secondaryBidiagonal[i];
                         for (int j = 0; j < p; ++j) {
                             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
                         }
                  } else {
                         for (int j = 0; j < p; ++j) {
                          wi[j] = mi * ei0[j] / singularValues[j];
                         }
                  }
              }
 
                 for (int i = p; i < m; ++i) {
                     wData[i] = new double[p];
@@ -245,23 +248,26 @@ public RealMatrix getV()
                 // the tridiagonal matrix is B.Bt, where B is lower bidiagonal
                 // compute W = Bt.E.S^(-1) where E is the eigenvectors matrix
                 final RealMatrix e =
                  eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);
                 final double[][] eData = e.getData();
                 final double[][] wData = new double[n][p];
                 double[] ei1 = eData[0];
              for (int i = 0; i < p; ++i) {
                     final double mi = mainBidiagonal[i];
                     final double[] ei0 = ei1;
                     final double[] wi  = wData[i];
                  if (i < m - 1) {
                         ei1 = eData[i + 1];
                         final double si = secondaryBidiagonal[i];
                         for (int j = 0; j < p; ++j) {
                             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
                         }
                  } else {
                         for (int j = 0; j < p; ++j) {
                          wi[j] = mi * ei0[j] / singularValues[j];
                         }
                  }
              }
                 for (int i = p; i < n; ++i) {
                     wData[i] = new double[p];
                 }
","
             if (m >= n) {
                                  final RealMatrix e =
                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);
                 final double[][] eData = e.getData();
                 final double[][] wData = new double[m][p];
                 double[] ei1 = eData[0];
                for (int i = 0; i < p - 1; ++i) {
                                          final double mi = mainBidiagonal[i];
                     final double[] ei0 = ei1;
                     final double[] wi  = wData[i];
                         ei1 = eData[i + 1];
                         final double si = secondaryBidiagonal[i];
                         for (int j = 0; j < p; ++j) {
                             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
                         }
                }
                         for (int j = 0; j < p; ++j) {
                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];
                         }
 
                 for (int i = p; i < m; ++i) {
                     wData[i] = new double[p];

                                                   final RealMatrix e =
                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);
                 final double[][] eData = e.getData();
                 final double[][] wData = new double[n][p];
                 double[] ei1 = eData[0];
                for (int i = 0; i < p - 1; ++i) {
                     final double mi = mainBidiagonal[i];
                     final double[] ei0 = ei1;
                     final double[] wi  = wData[i];
                         ei1 = eData[i + 1];
                         final double si = secondaryBidiagonal[i];
                         for (int j = 0; j < p; ++j) {
                             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
                         }
                }
                         for (int j = 0; j < p; ++j) {
                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];
                         }
                 for (int i = p; i < n; ++i) {
                     wData[i] = new double[p];
                 }
","
             if (m >= n) {
                                  final RealMatrix e =
                    eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);
                 final double[][] eData = e.getData();
                 final double[][] wData = new double[m][p];
                 double[] ei1 = eData[0];
                for (int i = 0; i < p; ++i) {
                                          final double mi = mainBidiagonal[i];
                     final double[] ei0 = ei1;
                     final double[] wi  = wData[i];
                    if (i < n - 1) {
                         ei1 = eData[i + 1];
                         final double si = secondaryBidiagonal[i];
                         for (int j = 0; j < p; ++j) {
                             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
                         }
                    } else {
                         for (int j = 0; j < p; ++j) {
                            wi[j] = mi * ei0[j] / singularValues[j];
                         }
                    }
                }
 
                 for (int i = p; i < m; ++i) {
                     wData[i] = new double[p];

                                                   final RealMatrix e =
                    eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);
                 final double[][] eData = e.getData();
                 final double[][] wData = new double[n][p];
                 double[] ei1 = eData[0];
                for (int i = 0; i < p; ++i) {
                     final double mi = mainBidiagonal[i];
                     final double[] ei0 = ei1;
                     final double[] wi  = wData[i];
                    if (i < m - 1) {
                         ei1 = eData[i + 1];
                         final double si = secondaryBidiagonal[i];
                         for (int j = 0; j < p; ++j) {
                             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];
                         }
                    } else {
                         for (int j = 0; j < p; ++j) {
                            wi[j] = mi * ei0[j] / singularValues[j];
                         }
                    }
                }
                 for (int i = p; i < n; ++i) {
                     wData[i] = new double[p];
                 }
"
303,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java","@@ -61,6 +61,7 @@ public MultiDirectional(final double khi, final double gamma) {
     protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)
         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
 
         while (true) {
 
             incrementIterationsCounter();
@@ -89,8 +90,16 @@ protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)
             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);
             if (comparator.compare(contracted, best) < 0) {
                 // accept the contracted simplex
 
             // check convergence
                 return;
             }
 
","@@ -61,6 +61,7 @@ public MultiDirectional(final double khi, final double gamma) {
     protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)
         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
 
      final RealConvergenceChecker checker = getConvergenceChecker();
         while (true) {
 
             incrementIterationsCounter();
@@ -89,8 +90,16 @@ protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)
             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);
             if (comparator.compare(contracted, best) < 0) {
                 // accept the contracted simplex
              return;
          }
 
             // check convergence
          final int iter = getIterations();
          boolean converged = true;
          for (int i = 0; i < simplex.length; ++i) {
              converged &= checker.converged(iter, original[i], simplex[i]);
          }
          if (converged) {
                 return;
             }
 
","
     protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)
         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
 
         while (true) {
 
             incrementIterationsCounter();

             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);
             if (comparator.compare(contracted, best) < 0) {
                  
                              return;
             }
 
","
     protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)
         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {
 
        final RealConvergenceChecker checker = getConvergenceChecker();
         while (true) {
 
             incrementIterationsCounter();

             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);
             if (comparator.compare(contracted, best) < 0) {
                                 return;
            }
 
                         final int iter = getIterations();
            boolean converged = true;
            for (int i = 0; i < simplex.length; ++i) {
                converged &= checker.converged(iter, original[i], simplex[i]);
            }
            if (converged) {
                 return;
             }
 
"
304,"java.lang.ArrayIndexOutOfBoundsException","/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java","@@ -600,6 +600,7 @@ private void computeGershgorinCircles() {
         lowerSpectra = Math.min(lowerSpectra, lower);
         final double upper = dCurrent + eCurrent;
         work[upperStart + m - 1] = upper;
         minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);
 
     }
@@ -902,8 +903,8 @@ private void processGeneralBlock(final int n)
                     diagMax    = work[4 * i0];
                     offDiagMin = work[4 * i0 + 2];
                     double previousEMin = work[4 * i0 + 3];
                  for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) {
                      if ((work[i + 3] <= TOLERANCE_2 * work[i]) &&
                             (work[i + 2] <= TOLERANCE_2 * sigma)) {
                             // insert a split
                             work[i + 2]  = -sigma;
@@ -1540,7 +1541,7 @@ private void computeShiftIncrement(final int start, final int end, final int def
                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);
 
                 // approximate contribution to norm squared from i < nn-2.
              if (end - start > 2) {
                     b2 = work[nn - 13] / work[nn - 15];
                     a2 = a2 + b2;
                     for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
","@@ -600,6 +600,7 @@ private void computeGershgorinCircles() {
         lowerSpectra = Math.min(lowerSpectra, lower);
         final double upper = dCurrent + eCurrent;
         work[upperStart + m - 1] = upper;
      upperSpectra = Math.max(upperSpectra, upper);
         minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);
 
     }
@@ -902,8 +903,8 @@ private void processGeneralBlock(final int n)
                     diagMax    = work[4 * i0];
                     offDiagMin = work[4 * i0 + 2];
                     double previousEMin = work[4 * i0 + 3];
                  for (int i = 4 * i0; i < 4 * n0 - 16; i += 4) {
                      if ((work[i + 3] <= TOLERANCE_2 * work[i]) ||
                             (work[i + 2] <= TOLERANCE_2 * sigma)) {
                             // insert a split
                             work[i + 2]  = -sigma;
@@ -1540,7 +1541,7 @@ private void computeShiftIncrement(final int start, final int end, final int def
                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);
 
                 // approximate contribution to norm squared from i < nn-2.
              if (end - start > 3) {
                     b2 = work[nn - 13] / work[nn - 15];
                     a2 = a2 + b2;
                     for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
","
         lowerSpectra = Math.min(lowerSpectra, lower);
         final double upper = dCurrent + eCurrent;
         work[upperStart + m - 1] = upper;
         minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);
 
     }

                     diagMax    = work[4 * i0];
                     offDiagMin = work[4 * i0 + 2];
                     double previousEMin = work[4 * i0 + 3];
                    for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) {
                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) &&
                             (work[i + 2] <= TOLERANCE_2 * sigma)) {
                                                          work[i + 2]  = -sigma;

                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);
 
                                 if (end - start > 2) {
                     b2 = work[nn - 13] / work[nn - 15];
                     a2 = a2 + b2;
                     for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
","
         lowerSpectra = Math.min(lowerSpectra, lower);
         final double upper = dCurrent + eCurrent;
         work[upperStart + m - 1] = upper;
        upperSpectra = Math.max(upperSpectra, upper);
         minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);
 
     }

                     diagMax    = work[4 * i0];
                     offDiagMin = work[4 * i0 + 2];
                     double previousEMin = work[4 * i0 + 3];
                    for (int i = 4 * i0; i < 4 * n0 - 16; i += 4) {
                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) ||
                             (work[i + 2] <= TOLERANCE_2 * sigma)) {
                                                          work[i + 2]  = -sigma;

                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);
 
                                 if (end - start > 3) {
                     b2 = work[nn - 13] / work[nn - 15];
                     a2 = a2 + b2;
                     for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {
"
305,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java","@@ -1132,7 +1132,7 @@ private int goodStep(final int start, final int end) {
     private boolean flipIfWarranted(final int n, final int step) {
         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {
             // flip array
          int j = 4 * n - 1;
             for (int i = 0; i < j; i += 4) {
                 for (int k = 0; k < 4; k += step) {
                     final double tmp = work[i + k];
","@@ -1132,7 +1132,7 @@ private int goodStep(final int start, final int end) {
     private boolean flipIfWarranted(final int n, final int step) {
         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {
             // flip array
          int j = 4 * (n - 1);
             for (int i = 0; i < j; i += 4) {
                 for (int k = 0; k < 4; k += step) {
                     final double tmp = work[i + k];
","
     private boolean flipIfWarranted(final int n, final int step) {
         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {
                         int j = 4 * n - 1;
             for (int i = 0; i < j; i += 4) {
                 for (int k = 0; k < 4; k += step) {
                     final double tmp = work[i + k];
","
     private boolean flipIfWarranted(final int n, final int step) {
         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {
                         int j = 4 * (n - 1);
             for (int i = 0; i < j; i += 4) {
                 for (int k = 0; k < 4; k += step) {
                     final double tmp = work[i + k];
"
306,"org.apache.commons.math.MathRuntimeException$4","/src/main/java/org/apache/commons/math/ode/events/EventState.java","@@ -188,6 +188,7 @@ public boolean evaluateStep(final StepInterpolator interpolator)
                 if (g0Positive ^ (gb >= 0)) {
                     // there is a sign change: an event is expected during this step
 
                         // this is a corner case:
                         // - there was an event near ta,
                         // - there is another event between ta and tb
@@ -195,7 +196,17 @@ public boolean evaluateStep(final StepInterpolator interpolator)
                         // this implies that the real sign of ga is the same as gb, so we need to slightly
                         // shift ta to make sure ga and gb get opposite signs and the solver won't complain
                         // about bracketing
                             // this should never happen
                          
                     // variation direction, with respect to the integration direction
                     increasing = gb >= ga;
","@@ -188,6 +188,7 @@ public boolean evaluateStep(final StepInterpolator interpolator)
                 if (g0Positive ^ (gb >= 0)) {
                     // there is a sign change: an event is expected during this step
 
                  if (ga * gb > 0) {
                         // this is a corner case:
                         // - there was an event near ta,
                         // - there is another event between ta and tb
@@ -195,7 +196,17 @@ public boolean evaluateStep(final StepInterpolator interpolator)
                         // this implies that the real sign of ga is the same as gb, so we need to slightly
                         // shift ta to make sure ga and gb get opposite signs and the solver won't complain
                         // about bracketing
                      final double epsilon = (forward ? 0.25 : -0.25) * convergence;
                      for (int k = 0; (k < 4) && (ga * gb > 0); ++k) {
                          ta += epsilon;
                          interpolator.setInterpolatedTime(ta);
                          ga = handler.g(ta, interpolator.getInterpolatedState());
                      }
                      if (ga * gb > 0) {
                             // this should never happen
                          throw MathRuntimeException.createInternalError(null);
                      }
                  }
                          
                     // variation direction, with respect to the integration direction
                     increasing = gb >= ga;
","
                 if (g0Positive ^ (gb >= 0)) {
                      
                                                                           
                                                                                                                                  
                                          increasing = gb >= ga;
","
                 if (g0Positive ^ (gb >= 0)) {
                      
                    if (ga * gb > 0) {
                                                                           
                                                                                                   final double epsilon = (forward ? 0.25 : -0.25) * convergence;
                        for (int k = 0; (k < 4) && (ga * gb > 0); ++k) {
                            ta += epsilon;
                            interpolator.setInterpolatedTime(ta);
                            ga = handler.g(ta, interpolator.getInterpolatedState());
                        }
                        if (ga * gb > 0) {
                                                         throw MathRuntimeException.createInternalError(null);
                        }
                    }
                          
                                          increasing = gb >= ga;
"
307,"junit.framework.AssertionFailedError","/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java","@@ -289,7 +289,7 @@ private Integer getBasicRowForSolution(final int col) {
      */
     private Integer getBasicRow(final int col, boolean ignoreObjectiveRows) {
         Integer row = null;
      int start = getNumObjectiveFunctions();
         for (int i = start; i < getHeight(); i++) {
             if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {
                 row = i;
@@ -338,11 +338,11 @@ private void copyArray(final double[] src, final double[] dest,
      */
     protected RealPointValuePair getSolution() {
       double[] coefficients = new double[getOriginalNumDecisionVariables()];
    Integer negativeVarBasicRow = getBasicRow(getNegativeDecisionVariableOffset());
       double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());
       Set<Integer> basicRows = new HashSet<Integer>();
       for (int i = 0; i < coefficients.length; i++) {
        Integer basicRow = getBasicRow(getNumObjectiveFunctions() + i);
           if (basicRows.contains(basicRow)) {
               // if multiple variables can take a given value 
               // then we choose the first and set the rest equal to 0
","@@ -289,7 +289,7 @@ private Integer getBasicRowForSolution(final int col) {
      */
     private Integer getBasicRow(final int col, boolean ignoreObjectiveRows) {
         Integer row = null;
      int start = ignoreObjectiveRows ? getNumObjectiveFunctions() : 0;
         for (int i = start; i < getHeight(); i++) {
             if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {
                 row = i;
@@ -338,11 +338,11 @@ private void copyArray(final double[] src, final double[] dest,
      */
     protected RealPointValuePair getSolution() {
       double[] coefficients = new double[getOriginalNumDecisionVariables()];
    Integer negativeVarBasicRow = getBasicRowForSolution(getNegativeDecisionVariableOffset());
       double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());
       Set<Integer> basicRows = new HashSet<Integer>();
       for (int i = 0; i < coefficients.length; i++) {
        Integer basicRow = getBasicRowForSolution(getNumObjectiveFunctions() + i);
           if (basicRows.contains(basicRow)) {
               // if multiple variables can take a given value 
               // then we choose the first and set the rest equal to 0
","
      
     private Integer getBasicRow(final int col, boolean ignoreObjectiveRows) {
         Integer row = null;
        int start = getNumObjectiveFunctions();
         for (int i = start; i < getHeight(); i++) {
             if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {
                 row = i;

      
     protected RealPointValuePair getSolution() {
       double[] coefficients = new double[getOriginalNumDecisionVariables()];
      Integer negativeVarBasicRow = getBasicRow(getNegativeDecisionVariableOffset());
       double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());
       Set<Integer> basicRows = new HashSet<Integer>();
       for (int i = 0; i < coefficients.length; i++) {
          Integer basicRow = getBasicRow(getNumObjectiveFunctions() + i);
           if (basicRows.contains(basicRow)) {
                              ","
      
     private Integer getBasicRow(final int col, boolean ignoreObjectiveRows) {
         Integer row = null;
        int start = ignoreObjectiveRows ? getNumObjectiveFunctions() : 0;
         for (int i = start; i < getHeight(); i++) {
             if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {
                 row = i;

      
     protected RealPointValuePair getSolution() {
       double[] coefficients = new double[getOriginalNumDecisionVariables()];
      Integer negativeVarBasicRow = getBasicRowForSolution(getNegativeDecisionVariableOffset());
       double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());
       Set<Integer> basicRows = new HashSet<Integer>();
       for (int i = 0; i < coefficients.length; i++) {
          Integer basicRow = getBasicRowForSolution(getNumObjectiveFunctions() + i);
           if (basicRows.contains(basicRow)) {
                              "
308,"java.lang.NullPointerException","/src/main/java/org/apache/commons/math/util/MathUtils.java","@@ -1621,9 +1621,9 @@ public static double distance(double[] p1, double[] p2) {
      * @return the L<sub>2</sub> distance between the two points
      */
     public static double distance(int[] p1, int[] p2) {
    int sum = 0;
       for (int i = 0; i < p1.length; i++) {
        final int dp = p1[i] - p2[i];
           sum += dp * dp;
       }
       return Math.sqrt(sum);
","@@ -1621,9 +1621,9 @@ public static double distance(double[] p1, double[] p2) {
      * @return the L<sub>2</sub> distance between the two points
      */
     public static double distance(int[] p1, int[] p2) {
    double sum = 0;
       for (int i = 0; i < p1.length; i++) {
        final double dp = p1[i] - p2[i];
           sum += dp * dp;
       }
       return Math.sqrt(sum);
","
    
     public static double distance(int[] p1, int[] p2) {
      int sum = 0;
       for (int i = 0; i < p1.length; i++) {
          final int dp = p1[i] - p2[i];
           sum += dp * dp;
       }
       return Math.sqrt(sum);
","
   
     public static double distance(int[] p1, int[] p2) {
      double sum = 0;
       for (int i = 0; i < p1.length; i++) {
          final double dp = p1[i] - p2[i];
           sum += dp * dp;
       }
       return Math.sqrt(sum);
"
309,"org.apache.commons.math.MathException","/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java","@@ -195,7 +195,7 @@ public static double solve(UnivariateRealFunction f, double x0, double x1,
         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && 
                 ((a > lowerBound) || (b < upperBound)));
    
      if (fa * fb >= 0.0 ) {
             throw new ConvergenceException(
                       ""number of iterations={0}, maximum iterations={1}, "" +
                       ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +
","@@ -195,7 +195,7 @@ public static double solve(UnivariateRealFunction f, double x0, double x1,
         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && 
                 ((a > lowerBound) || (b < upperBound)));
    
      if (fa * fb > 0.0 ) {
             throw new ConvergenceException(
                       ""number of iterations={0}, maximum iterations={1}, "" +
                       ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +
","
         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && 
                 ((a > lowerBound) || (b < upperBound)));
    
        if (fa * fb >= 0.0 ) {
             throw new ConvergenceException(
                       ""number of iterations={0}, maximum iterations={1}, "" +
                       ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +
","
         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && 
                 ((a > lowerBound) || (b < upperBound)));
    
        if (fa * fb > 0.0 ) {
             throw new ConvergenceException(
                       ""number of iterations={0}, maximum iterations={1}, "" +
                       ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" +
"
310,"java.lang.ClassCastException","/src/java/org/apache/commons/math/stat/Frequency.java","@@ -107,7 +107,11 @@ public String toString() {
      */
     @Deprecated
     public void addValue(Object v) {
             addValue((Comparable<?>) v);            
     }
     
     /**
","@@ -107,7 +107,11 @@ public String toString() {
      */
     @Deprecated
     public void addValue(Object v) {
      if (v instanceof Comparable<?>){
             addValue((Comparable<?>) v);            
      } else {
          throw new IllegalArgumentException(""Object must implement Comparable"");
      }
     }
     
     /**
","
      
     @Deprecated
     public void addValue(Object v) {
             addValue((Comparable<?>) v);            
     }
     
","
      
     @Deprecated
     public void addValue(Object v) {
        if (v instanceof Comparable<?>){
             addValue((Comparable<?>) v);            
        } else {
            throw new IllegalArgumentException(""Object must implement Comparable"");
        }
     }
     
"
311,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java","@@ -272,12 +272,10 @@ protected static double getInvertedCoeffiecientSum(final RealVector coefficients
     private Integer getBasicRow(final int col) {
         Integer row = null;
         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {
          if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {
              if (row == null) {
                 row = i;
              } else {
                 return null;
              }
             }
         }
         return row;
","@@ -272,12 +272,10 @@ protected static double getInvertedCoeffiecientSum(final RealVector coefficients
     private Integer getBasicRow(final int col) {
         Integer row = null;
         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {
          if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {
                 row = i;
          } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {
                 return null;
             }
         }
         return row;
","
     private Integer getBasicRow(final int col) {
         Integer row = null;
         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {
            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {
                if (row == null) {
                 row = i;
                } else {
                 return null;
                }
             }
         }
         return row;
","
     private Integer getBasicRow(final int col) {
         Integer row = null;
         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {
            if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {
                 row = i;
            } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {
                 return null;
             }
         }
         return row;
"
312,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java","@@ -111,9 +111,6 @@ public CholeskyDecompositionImpl(final RealMatrix matrix,
 
             final double[] lI = lTData[i];
 
          if (lTData[i][i] < absolutePositivityThreshold) {
              throw new NotPositiveDefiniteMatrixException();
          }
             // check off-diagonal elements (and reset them to 0)
             for (int j = i + 1; j < order; ++j) {
                 final double[] lJ = lTData[j];
@@ -134,6 +131,9 @@ public CholeskyDecompositionImpl(final RealMatrix matrix,
             final double[] ltI = lTData[i];
 
             // check diagonal element
 
             ltI[i] = Math.sqrt(ltI[i]);
             final double inverse = 1.0 / ltI[i];
","@@ -111,9 +111,6 @@ public CholeskyDecompositionImpl(final RealMatrix matrix,
 
             final double[] lI = lTData[i];
 
             // check off-diagonal elements (and reset them to 0)
             for (int j = i + 1; j < order; ++j) {
                 final double[] lJ = lTData[j];
@@ -134,6 +131,9 @@ public CholeskyDecompositionImpl(final RealMatrix matrix,
             final double[] ltI = lTData[i];
 
             // check diagonal element
          if (ltI[i] < absolutePositivityThreshold) {
              throw new NotPositiveDefiniteMatrixException();
          }
 
             ltI[i] = Math.sqrt(ltI[i]);
             final double inverse = 1.0 / ltI[i];
","
 
             final double[] lI = lTData[i];
 
            if (lTData[i][i] < absolutePositivityThreshold) {
                throw new NotPositiveDefiniteMatrixException();
            }
                          for (int j = i + 1; j < order; ++j) {
                 final double[] lJ = lTData[j];

             final double[] ltI = lTData[i];
 
              
             ltI[i] = Math.sqrt(ltI[i]);
             final double inverse = 1.0 / ltI[i];
","
 
             final double[] lI = lTData[i];
 
                          for (int j = i + 1; j < order; ++j) {
                 final double[] lJ = lTData[j];

             final double[] ltI = lTData[i];
 
                         if (ltI[i] < absolutePositivityThreshold) {
                throw new NotPositiveDefiniteMatrixException();
            }
 
             ltI[i] = Math.sqrt(ltI[i]);
             final double inverse = 1.0 / ltI[i];
"
313,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java","@@ -326,19 +326,18 @@ protected RealPointValuePair getSolution() {
         Integer basicRow =
             getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());
         double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());
         for (int i = 0; i < coefficients.length; i++) {
             basicRow = getBasicRow(getNumObjectiveFunctions() + i);
                 // if multiple variables can take a given value 
                 // then we choose the first and set the rest equal to 0
                 coefficients[i] =
                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
                     (restrictToNonNegative ? 0 : mostNegative);
          if (basicRow != null) {
              for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {
                  if (tableau.getEntry(basicRow, j) == 1) {
                       coefficients[i] = 0;
                  }
              }
             }
         }
         return new RealPointValuePair(coefficients, f.getValue(coefficients));
","@@ -326,19 +326,18 @@ protected RealPointValuePair getSolution() {
         Integer basicRow =
             getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());
         double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());
      Set<Integer> basicRows = new HashSet<Integer>();
         for (int i = 0; i < coefficients.length; i++) {
             basicRow = getBasicRow(getNumObjectiveFunctions() + i);
          if (basicRows.contains(basicRow)) {
                 // if multiple variables can take a given value 
                 // then we choose the first and set the rest equal to 0
              coefficients[i] = 0;
          } else {
              basicRows.add(basicRow);
                 coefficients[i] =
                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
                     (restrictToNonNegative ? 0 : mostNegative);
             }
         }
         return new RealPointValuePair(coefficients, f.getValue(coefficients));
","
         Integer basicRow =
             getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());
         double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());
         for (int i = 0; i < coefficients.length; i++) {
             basicRow = getBasicRow(getNumObjectiveFunctions() + i);
                                                   coefficients[i] =
                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
                     (restrictToNonNegative ? 0 : mostNegative);
            if (basicRow != null) {
                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {
                    if (tableau.getEntry(basicRow, j) == 1) {
                         coefficients[i] = 0;
                    }
                }
             }
         }
         return new RealPointValuePair(coefficients, f.getValue(coefficients));
","
         Integer basicRow =
             getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());
         double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());
        Set<Integer> basicRows = new HashSet<Integer>();
         for (int i = 0; i < coefficients.length; i++) {
             basicRow = getBasicRow(getNumObjectiveFunctions() + i);
            if (basicRows.contains(basicRow)) {
                                                  coefficients[i] = 0;
            } else {
                basicRows.add(basicRow);
                 coefficients[i] =
                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -
                     (restrictToNonNegative ? 0 : mostNegative);
             }
         }
         return new RealPointValuePair(coefficients, f.getValue(coefficients));
"
314,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/math/fraction/Fraction.java","@@ -256,8 +256,8 @@ public Fraction abs() {
      *         than <tt>object</tt>, 0 if they are equal.
      */
     public int compareTo(Fraction object) {
      double nOd = doubleValue();
      double dOn = object.doubleValue();
         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);
     }
     
","@@ -256,8 +256,8 @@ public Fraction abs() {
      *         than <tt>object</tt>, 0 if they are equal.
      */
     public int compareTo(Fraction object) {
      long nOd = ((long) numerator) * object.denominator;
      long dOn = ((long) denominator) * object.numerator;
         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);
     }
     
","
        double nOd = doubleValue();
        double dOn = object.doubleValue();
         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);
     }
     
","
        long nOd = ((long) numerator) * object.denominator;
        long dOn = ((long) denominator) * object.numerator;
         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);
     }
     
"
315,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/math/util/MathUtils.java","@@ -342,8 +342,10 @@ public static boolean equals(double[] x, double[] y) {
      * @throws IllegalArgumentException if n < 0
      */
     public static long factorial(final int n) {
      long result = Math.round(factorialDouble(n));
      if (result == Long.MAX_VALUE) {
             throw new ArithmeticException(
                     ""factorial value is too large to fit in a long"");
         }
@@ -374,6 +376,9 @@ public static double factorialDouble(final int n) {
         if (n < 0) {
             throw new IllegalArgumentException(""must have n >= 0 for n!"");
         }
         return Math.floor(Math.exp(factorialLog(n)) + 0.5);
     }
 
@@ -394,6 +399,9 @@ public static double factorialLog(final int n) {
         if (n < 0) {
             throw new IllegalArgumentException(""must have n > 0 for n!"");
         }
         double logSum = 0;
         for (int i = 2; i <= n; i++) {
             logSum += Math.log((double)i);
","@@ -342,8 +342,10 @@ public static boolean equals(double[] x, double[] y) {
      * @throws IllegalArgumentException if n < 0
      */
     public static long factorial(final int n) {
      if (n < 0) {
          throw new IllegalArgumentException(""must have n >= 0 for n!"");
      }
      if (n > 20) {
             throw new ArithmeticException(
                     ""factorial value is too large to fit in a long"");
         }
@@ -374,6 +376,9 @@ public static double factorialDouble(final int n) {
         if (n < 0) {
             throw new IllegalArgumentException(""must have n >= 0 for n!"");
         }
      if (n < 21) {
          return factorial(n);
      }
         return Math.floor(Math.exp(factorialLog(n)) + 0.5);
     }
 
@@ -394,6 +399,9 @@ public static double factorialLog(final int n) {
         if (n < 0) {
             throw new IllegalArgumentException(""must have n > 0 for n!"");
         }
      if (n < 21) {
          return Math.log(factorial(n));
      }
         double logSum = 0;
         for (int i = 2; i <= n; i++) {
             logSum += Math.log((double)i);
","
   
     public static long factorial(final int n) {
        long result = Math.round(factorialDouble(n));
        if (result == Long.MAX_VALUE) {
             throw new ArithmeticException(
                     ""factorial value is too large to fit in a long"");
         }

         if (n < 0) {
             throw new IllegalArgumentException(""must have n >= 0 for n!"");
         }
         return Math.floor(Math.exp(factorialLog(n)) + 0.5);
     }
 

         if (n < 0) {
             throw new IllegalArgumentException(""must have n > 0 for n!"");
         }
         double logSum = 0;
         for (int i = 2; i <= n; i++) {
             logSum += Math.log((double)i);
","
   
     public static long factorial(final int n) {
        if (n < 0) {
            throw new IllegalArgumentException(""must have n >= 0 for n!"");
        }
        if (n > 20) {
             throw new ArithmeticException(
                     ""factorial value is too large to fit in a long"");
         }

         if (n < 0) {
             throw new IllegalArgumentException(""must have n >= 0 for n!"");
         }
        if (n < 21) {
            return factorial(n);
        }
         return Math.floor(Math.exp(factorialLog(n)) + 0.5);
     }
 

         if (n < 0) {
             throw new IllegalArgumentException(""must have n > 0 for n!"");
         }
        if (n < 21) {
            return Math.log(factorial(n));
        }
         double logSum = 0;
         for (int i = 2; i <= n; i++) {
             logSum += Math.log((double)i);
"
316,"java.lang.IllegalArgumentException","/src/java/org/apache/commons/math/distribution/FDistributionImpl.java","@@ -141,10 +141,12 @@ protected double getDomainUpperBound(double p) {
      * @return initial domain value
      */
     protected double getInitialDomain(double p) {
      double ret;
         double d = getDenominatorDegreesOfFreedom();
             // use mean
             ret = d / (d - 2.0);
         return ret;
     }
     
","@@ -141,10 +141,12 @@ protected double getDomainUpperBound(double p) {
      * @return initial domain value
      */
     protected double getInitialDomain(double p) {
      double ret = 1.0;
         double d = getDenominatorDegreesOfFreedom();
      if (d > 2.0) {
             // use mean
             ret = d / (d - 2.0);
      }
         return ret;
     }
     
","
 
     protected double getInitialDomain(double p) {
        double ret;
         double d = getDenominatorDegreesOfFreedom();
                          ret = d / (d - 2.0);
         return ret;
     }
     
","
        double ret = 1.0;
         double d = getDenominatorDegreesOfFreedom();
        if (d > 2.0) {
                          ret = d / (d - 2.0);
        }
         return ret;
     }
     
"
317,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/math/util/MathUtils.java","@@ -409,7 +409,7 @@ public static double factorialLog(final int n) {
      * @since 1.1
      */
     public static int gcd(int u, int v) {
      if (u * v == 0) {
             return (Math.abs(u) + Math.abs(v));
         }
         // keep u and v negative, as negative integers range down to
","@@ -409,7 +409,7 @@ public static double factorialLog(final int n) {
      * @since 1.1
      */
     public static int gcd(int u, int v) {
      if ((u == 0) || (v == 0)) {
             return (Math.abs(u) + Math.abs(v));
         }
         // keep u and v negative, as negative integers range down to
","
   
     public static int gcd(int u, int v) {
        if (u * v == 0) {
             return (Math.abs(u) + Math.abs(v));
         }
         ","
    
     public static int gcd(int u, int v) {
        if ((u == 0) || (v == 0)) {
             return (Math.abs(u) + Math.abs(v));
         }
         "
318,"java.lang.IllegalArgumentException","/src/java/org/apache/commons/math/stat/Frequency.java","@@ -107,6 +107,8 @@ public String toString() {
      */
     @Deprecated
     public void addValue(Object v) {
     
     /**
      * Adds 1 to the frequency count for v.
@@ -118,6 +120,7 @@ public void addValue(Object v) {
      * @param v the value to add.
      * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries
      */
         Object obj = v;
         if (v instanceof Integer) {
            obj = Long.valueOf(((Integer) v).longValue());
","@@ -107,6 +107,8 @@ public String toString() {
      */
     @Deprecated
     public void addValue(Object v) {
      addValue((Comparable<?>) v);
  }
     
     /**
      * Adds 1 to the frequency count for v.
@@ -118,6 +120,7 @@ public void addValue(Object v) {
      * @param v the value to add.
      * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries
      */
  public void addValue(Comparable<?>v){
         Object obj = v;
         if (v instanceof Integer) {
            obj = Long.valueOf(((Integer) v).longValue());
","
      
     @Deprecated
     public void addValue(Object v) {
         Object obj = v;
         if (v instanceof Integer) {
            obj = Long.valueOf(((Integer) v).longValue());
","
      
     @Deprecated
     public void addValue(Object v) {
        addValue((Comparable<?>) v);
    }
    public void addValue(Comparable<?>v){
         Object obj = v;
         if (v instanceof Integer) {
            obj = Long.valueOf(((Integer) v).longValue());
"
319,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/math/complex/Complex.java","@@ -255,7 +255,7 @@ public boolean equals(Object other) {
                 if (rhs.isNaN()) {
                     ret = this.isNaN();
                 } else {
                  ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); 
                 }
             } catch (ClassCastException ex) {
                 // ignore exception
","@@ -255,7 +255,7 @@ public boolean equals(Object other) {
                 if (rhs.isNaN()) {
                     ret = this.isNaN();
                 } else {
                  ret = (real == rhs.real) && (imaginary == rhs.imaginary); 
                 }
             } catch (ClassCastException ex) {
                 // ignore exception
","
                 if (rhs.isNaN()) {
                     ret = this.isNaN();
                 } else {
                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); 
                 }
             } catch (ClassCastException ex) {
                 ","
                 if (rhs.isNaN()) {
                     ret = this.isNaN();
                 } else {
                    ret = (real == rhs.real) && (imaginary == rhs.imaginary); 
                 }
             } catch (ClassCastException ex) {
                 "
320,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/math/util/MathUtils.java","@@ -181,30 +181,43 @@ public static long binomialCoefficient(final int n, final int k) {
         if ((k == 1) || (k == n - 1)) {
             return n;
         }
      long result = Math.round(binomialCoefficientDouble(n, k));
      if (result == Long.MAX_VALUE) {
          throw new ArithmeticException(
              ""result too large to represent in a long integer"");
      }
         // Use symmetry for large k
         
         // We use the formula
         // (n choose k) = n! / (n-k)! / k!
         // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
         // which could be written
         // (n choose k) == (n-1 choose k-1) * n / k
             // For n <= 61, the naive implementation cannot overflow.
             // For n > 61 but n <= 66, the result cannot overflow,
             // but we must take care not to overflow intermediate values.
                 // We know that (result * i) is divisible by j,
                 // but (result * i) may overflow, so we split j:
                 // Filter out the gcd, d, so j/d and i/d are integer.
                 // result is divisible by (j/d) because (j/d)
                 // is relative prime to (i/d) and is a divisor of
                 // result * (i/d).
             // For n > 66, a result overflow might occur, so we check
             // the multiplication, taking care to not overflow
             // unnecessary.
         return result;
     }
 
@@ -231,9 +244,33 @@ public static long binomialCoefficient(final int n, final int k) {
      * @throws IllegalArgumentException if preconditions are not met.
      */
     public static double binomialCoefficientDouble(final int n, final int k) {
         
   
      return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5);
     }
     
     /**
@@ -274,11 +311,17 @@ public static double binomialCoefficientLog(final int n, final int k) {
          * For values small enough to do exact integer computation,
          * return the log of the exact value 
          */
         
         /*
          * Return the log of binomialCoefficientDouble for values that will not
          * overflow binomialCoefficientDouble
          */
         
         /*
          * Sum logs for values that could overflow
","@@ -181,30 +181,43 @@ public static long binomialCoefficient(final int n, final int k) {
         if ((k == 1) || (k == n - 1)) {
             return n;
         }
         // Use symmetry for large k
      if (k > n / 2)
          return binomialCoefficient(n, n - k);
         
         // We use the formula
         // (n choose k) = n! / (n-k)! / k!
         // (n choose k) == ((n-k+1)*...*n) / (1*...*k)
         // which could be written
         // (n choose k) == (n-1 choose k-1) * n / k
      long result = 1;
      if (n <= 61) {
             // For n <= 61, the naive implementation cannot overflow.
          for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
              result = result * i / j;
          }
      } else if (n <= 66) {
             // For n > 61 but n <= 66, the result cannot overflow,
             // but we must take care not to overflow intermediate values.
          for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
                 // We know that (result * i) is divisible by j,
                 // but (result * i) may overflow, so we split j:
                 // Filter out the gcd, d, so j/d and i/d are integer.
                 // result is divisible by (j/d) because (j/d)
                 // is relative prime to (i/d) and is a divisor of
                 // result * (i/d).
              long d = gcd(i, j);
              result = (result / (j / d)) * (i / d);
          }
      } else {
             // For n > 66, a result overflow might occur, so we check
             // the multiplication, taking care to not overflow
             // unnecessary.
          for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
              long d = gcd(i, j);
              result = mulAndCheck((result / (j / d)), (i / d));
          }
      }
         return result;
     }
 
@@ -231,9 +244,33 @@ public static long binomialCoefficient(final int n, final int k) {
      * @throws IllegalArgumentException if preconditions are not met.
      */
     public static double binomialCoefficientDouble(final int n, final int k) {
      if (n < k) {
          throw new IllegalArgumentException(
              ""must have n >= k for binomial coefficient (n,k)"");
      }
      if (n < 0) {
          throw new IllegalArgumentException(
              ""must have n >= 0 for binomial coefficient (n,k)"");
      }
      if ((n == k) || (k == 0)) {
          return 1d;
      }
      if ((k == 1) || (k == n - 1)) {
          return n;
      }
      if (k > n/2) {
          return binomialCoefficientDouble(n, n - k);
      }
      if (n < 67) {
          return binomialCoefficient(n,k);
      }
         
      double result = 1d;
      for (int i = 1; i <= k; i++) {
           result *= (double)(n - k + i) / (double)i;
      }
   
      return Math.floor(result + 0.5);
     }
     
     /**
@@ -274,11 +311,17 @@ public static double binomialCoefficientLog(final int n, final int k) {
          * For values small enough to do exact integer computation,
          * return the log of the exact value 
          */
      if (n < 67) {  
          return Math.log(binomialCoefficient(n,k));
      }
         
         /*
          * Return the log of binomialCoefficientDouble for values that will not
          * overflow binomialCoefficientDouble
          */
      if (n < 1030) { 
          return Math.log(binomialCoefficientDouble(n, k));
      } 
         
         /*
          * Sum logs for values that could overflow
","
         if ((k == 1) || (k == n - 1)) {
             return n;
         }
        long result = Math.round(binomialCoefficientDouble(n, k));
        if (result == Long.MAX_VALUE) {
            throw new ArithmeticException(
                ""result too large to represent in a long integer"");
        }
                  
                                                                                                                                                                                                                                          return result;
     }
 

  
     public static double binomialCoefficientDouble(final int n, final int k) {
         
   
        return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5);
     }
     
","
         if ((k == 1) || (k == n - 1)) {
             return n;
         }
                 if (k > n / 2)
            return binomialCoefficient(n, n - k);
         
                                                     long result = 1;
        if (n <= 61) {
                         for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
                result = result * i / j;
            }
        } else if (n <= 66) {
                                      for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
                                                                                                                      long d = gcd(i, j);
                result = (result / (j / d)) * (i / d);
            }
        } else {
                                                   for (int j = 1, i = n - k + 1; j <= k; i++, j++) {
                long d = gcd(i, j);
                result = mulAndCheck((result / (j / d)), (i / d));
            }
        }
         return result;
     }
 

  
     public static double binomialCoefficientDouble(final int n, final int k) {
        if (n < k) {
            throw new IllegalArgumentException(
                ""must have n >= k for binomial coefficient (n,k)"");
        }
        if (n < 0) {
            throw new IllegalArgumentException(
                ""must have n >= 0 for binomial coefficient (n,k)"");
        }
        if ((n == k) || (k == 0)) {
            return 1d;
        }
        if ((k == 1) || (k == n - 1)) {
            return n;
        }
        if (k > n/2) {
            return binomialCoefficientDouble(n, n - k);
        }
        if (n < 67) {
            return binomialCoefficient(n,k);
        }
         
        double result = 1d;
        for (int i = 1; i <= k; i++) {
             result *= (double)(n - k + i) / (double)i;
        }
   
        return Math.floor(result + 0.5);
     }
     

      
        if (n < 67) {  
            return Math.log(binomialCoefficient(n,k));
        }
        if (n < 1030) { 
            return Math.log(binomialCoefficientDouble(n, k));
        } 
"
321,"java.lang.ArrayIndexOutOfBoundsException","/src/java/org/apache/commons/math/linear/BigMatrixImpl.java","@@ -988,7 +988,7 @@ public BigDecimal getTrace() throws IllegalArgumentException {
         }
         final int nRows = this.getRowDimension();
         final int nCols = this.getColumnDimension();
      final BigDecimal[] out = new BigDecimal[v.length];
         for (int row = 0; row < nRows; row++) {
             BigDecimal sum = ZERO;
             for (int i = 0; i < nCols; i++) {
/src/java/org/apache/commons/math/linear/RealMatrixImpl.java @@ -776,7 +776,7 @@ public double getTrace() throws IllegalArgumentException {
         if (v.length != nCols) {
             throw new IllegalArgumentException(""vector has wrong length"");
         }
      final double[] out = new double[v.length];
         for (int row = 0; row < nRows; row++) {
             final double[] dataRow = data[row];
             double sum = 0;
","@@ -988,7 +988,7 @@ public BigDecimal getTrace() throws IllegalArgumentException {
         }
         final int nRows = this.getRowDimension();
         final int nCols = this.getColumnDimension();
      final BigDecimal[] out = new BigDecimal[nRows];
         for (int row = 0; row < nRows; row++) {
             BigDecimal sum = ZERO;
             for (int i = 0; i < nCols; i++) {
/src/java/org/apache/commons/math/linear/RealMatrixImpl.java @@ -776,7 +776,7 @@ public double getTrace() throws IllegalArgumentException {
         if (v.length != nCols) {
             throw new IllegalArgumentException(""vector has wrong length"");
         }
      final double[] out = new double[nRows];
         for (int row = 0; row < nRows; row++) {
             final double[] dataRow = data[row];
             double sum = 0;
","
         }
         final int nRows = this.getRowDimension();
         final int nCols = this.getColumnDimension();
        final BigDecimal[] out = new BigDecimal[v.length];
         for (int row = 0; row < nRows; row++) {
             BigDecimal sum = ZERO;
             for (int i = 0; i < nCols; i++) {

         if (v.length != nCols) {
             throw new IllegalArgumentException(""vector has wrong length"");
         }
        final double[] out = new double[v.length];
         for (int row = 0; row < nRows; row++) {
             final double[] dataRow = data[row];
             double sum = 0;
","
         }
         final int nRows = this.getRowDimension();
         final int nCols = this.getColumnDimension();
        final BigDecimal[] out = new BigDecimal[nRows];
         for (int row = 0; row < nRows; row++) {
             BigDecimal sum = ZERO;
             for (int i = 0; i < nCols; i++) {

         if (v.length != nCols) {
             throw new IllegalArgumentException(""vector has wrong length"");
         }
        final double[] out = new double[nRows];
         for (int row = 0; row < nRows; row++) {
             final double[] dataRow = data[row];
             double sum = 0;
"
322,"java.lang.StringIndexOutOfBoundsException","/src/java/org/apache/commons/math/complex/ComplexFormat.java","@@ -374,7 +374,8 @@ public Complex parse(String source, ParsePosition pos) {
         int n = getImaginaryCharacter().length();
         startIndex = pos.getIndex();
         int endIndex = startIndex + n;
      if (
             source.substring(startIndex, endIndex).compareTo(
             getImaginaryCharacter()) != 0) {
             // set index back to initial, error index should be the start index
","@@ -374,7 +374,8 @@ public Complex parse(String source, ParsePosition pos) {
         int n = getImaginaryCharacter().length();
         startIndex = pos.getIndex();
         int endIndex = startIndex + n;
      if ((startIndex >= source.length()) ||
          (endIndex > source.length()) ||
             source.substring(startIndex, endIndex).compareTo(
             getImaginaryCharacter()) != 0) {
             // set index back to initial, error index should be the start index
","
         int n = getImaginaryCharacter().length();
         startIndex = pos.getIndex();
         int endIndex = startIndex + n;
        if (
             source.substring(startIndex, endIndex).compareTo(
             getImaginaryCharacter()) != 0) {
             ","
         int n = getImaginaryCharacter().length();
         startIndex = pos.getIndex();
         int endIndex = startIndex + n;
        if ((startIndex >= source.length()) ||
            (endIndex > source.length()) ||
             source.substring(startIndex, endIndex).compareTo(
             getImaginaryCharacter()) != 0) {
             "
323,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java","@@ -261,7 +261,7 @@ public double getSlope() {
      * @return sum of squared errors associated with the regression model
      */
     public double getSumSquaredErrors() {
      return sumYY - sumXY * sumXY / sumXX;
     }
 
     /**
","@@ -261,7 +261,7 @@ public double getSlope() {
      * @return sum of squared errors associated with the regression model
      */
     public double getSumSquaredErrors() {
      return Math.max(0d, sumYY - sumXY * sumXY / sumXX);
     }
 
     /**
","
      
     public double getSumSquaredErrors() {
        return sumYY - sumXY * sumXY / sumXX;
     }
 
","
     public double getSumSquaredErrors() {
        return Math.max(0d, sumYY - sumXY * sumXY / sumXX);
     }
 
"
324,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/math/special/Gamma.java","@@ -34,7 +34,7 @@
     private static final long serialVersionUID = -6587513359895466954L;
 
     /** Maximum allowed numerical error. */
  private static final double DEFAULT_EPSILON = 10e-9;
 
     /** Lanczos coefficients */
     private static double[] lanczos =
","@@ -34,7 +34,7 @@
     private static final long serialVersionUID = -6587513359895466954L;
 
     /** Maximum allowed numerical error. */
  private static final double DEFAULT_EPSILON = 10e-15;
 
     /** Lanczos coefficients */
     private static double[] lanczos =
","
     private static final long serialVersionUID = -6587513359895466954L;
 
    private static final double DEFAULT_EPSILON = 10e-9;
 
     private static double[] lanczos =
","
     private static final long serialVersionUID = -6587513359895466954L;
 
    private static final double DEFAULT_EPSILON = 10e-15;
 
     private static double[] lanczos =
"
325,"java.lang.IllegalArgumentException","/src/java/org/apache/commons/math/analysis/BrentSolver.java","@@ -135,17 +135,31 @@ public double solve(double min, double max) throws MaxIterationsExceededExceptio
         
         // Verify bracketing
         double sign = yMin * yMax;
      if (sign >= 0) {
             // check if either value is close to a zero
                 // neither value is close to zero and min and max do not bracket root.
                 throw new IllegalArgumentException
                 (""Function values at endpoints do not have different signs."" +
                         ""  Endpoints: ["" + min + "","" + max + ""]"" + 
                         ""  Values: ["" + yMin + "","" + yMax + ""]"");
      } else {
             // solve using only the first endpoint as initial guess
             ret = solve(min, yMin, max, yMax, min, yMin);
             // either min or max is a root
         }
 
         return ret;
","@@ -135,17 +135,31 @@ public double solve(double min, double max) throws MaxIterationsExceededExceptio
         
         // Verify bracketing
         double sign = yMin * yMax;
      if (sign > 0) {
             // check if either value is close to a zero
          if (Math.abs(yMin) <= functionValueAccuracy) {
              setResult(min, 0);
              ret = min;
          } else if (Math.abs(yMax) <= functionValueAccuracy) {
              setResult(max, 0);
              ret = max;
          } else {
                 // neither value is close to zero and min and max do not bracket root.
                 throw new IllegalArgumentException
                 (""Function values at endpoints do not have different signs."" +
                         ""  Endpoints: ["" + min + "","" + max + ""]"" + 
                         ""  Values: ["" + yMin + "","" + yMax + ""]"");
          }
      } else if (sign < 0){
             // solve using only the first endpoint as initial guess
             ret = solve(min, yMin, max, yMax, min, yMin);
      } else {
             // either min or max is a root
          if (yMin == 0.0) {
              ret = min;
          } else {
              ret = max;
          }
         }
 
         return ret;
","
         
                  double sign = yMin * yMax;
        if (sign >= 0) {
                                               throw new IllegalArgumentException
                 (""Function values at endpoints do not have different signs."" +
                         ""  Endpoints: ["" + min + "","" + max + ""]"" + 
                         ""  Values: ["" + yMin + "","" + yMax + ""]"");
        } else {
                          ret = solve(min, yMin, max, yMax, min, yMin);
                      }
 
         return ret;
","
         
                  double sign = yMin * yMax;
        if (sign > 0) {
                         if (Math.abs(yMin) <= functionValueAccuracy) {
                setResult(min, 0);
                ret = min;
            } else if (Math.abs(yMax) <= functionValueAccuracy) {
                setResult(max, 0);
                ret = max;
            } else {
                                  throw new IllegalArgumentException
                 (""Function values at endpoints do not have different signs."" +
                         ""  Endpoints: ["" + min + "","" + max + ""]"" + 
                         ""  Values: ["" + yMin + "","" + yMax + ""]"");
            }
        } else if (sign < 0){
                          ret = solve(min, yMin, max, yMax, min, yMin);
        } else {
                         if (yMin == 0.0) {
                ret = min;
            } else {
                ret = max;
            }
         }
 
         return ret;
"
326,"java.lang.ArrayIndexOutOfBoundsException","/src/java/org/apache/commons/math/estimation/AbstractEstimator.java","@@ -163,7 +163,7 @@ public double getChiSquare(EstimationProblem problem) {
 
         // compute transpose(J).J, avoiding building big intermediate matrices
         final int rows = problem.getMeasurements().length;
      final int cols = problem.getAllParameters().length;
         final int max  = cols * rows;
         double[][] jTj = new double[cols][cols];
         for (int i = 0; i < cols; ++i) {
@@ -199,12 +199,12 @@ public double getChiSquare(EstimationProblem problem) {
     public double[] guessParametersErrors(EstimationProblem problem)
       throws EstimationException {
         int m = problem.getMeasurements().length;
      int p = problem.getAllParameters().length;
         if (m <= p) {
             throw new EstimationException(""no degrees of freedom ({0} measurements, {1} parameters)"",
                                           new Object[] { new Integer(m), new Integer(p)});
         }
      double[] errors = new double[problem.getAllParameters().length];
         final double c = Math.sqrt(getChiSquare(problem) / (m - p));
         double[][] covar = getCovariances(problem);
         for (int i = 0; i < errors.length; ++i) {
","@@ -163,7 +163,7 @@ public double getChiSquare(EstimationProblem problem) {
 
         // compute transpose(J).J, avoiding building big intermediate matrices
         final int rows = problem.getMeasurements().length;
      final int cols = problem.getUnboundParameters().length;
         final int max  = cols * rows;
         double[][] jTj = new double[cols][cols];
         for (int i = 0; i < cols; ++i) {
@@ -199,12 +199,12 @@ public double getChiSquare(EstimationProblem problem) {
     public double[] guessParametersErrors(EstimationProblem problem)
       throws EstimationException {
         int m = problem.getMeasurements().length;
      int p = problem.getUnboundParameters().length;
         if (m <= p) {
             throw new EstimationException(""no degrees of freedom ({0} measurements, {1} parameters)"",
                                           new Object[] { new Integer(m), new Integer(p)});
         }
      double[] errors = new double[problem.getUnboundParameters().length];
         final double c = Math.sqrt(getChiSquare(problem) / (m - p));
         double[][] covar = getCovariances(problem);
         for (int i = 0; i < errors.length; ++i) {
","
 
                  final int rows = problem.getMeasurements().length;
        final int cols = problem.getAllParameters().length;
         final int max  = cols * rows;
         double[][] jTj = new double[cols][cols];
         for (int i = 0; i < cols; ++i) {

     public double[] guessParametersErrors(EstimationProblem problem)
       throws EstimationException {
         int m = problem.getMeasurements().length;
        int p = problem.getAllParameters().length;
         if (m <= p) {
             throw new EstimationException(""no degrees of freedom ({0} measurements, {1} parameters)"",
                                           new Object[] { new Integer(m), new Integer(p)});
         }
        double[] errors = new double[problem.getAllParameters().length];
         final double c = Math.sqrt(getChiSquare(problem) / (m - p));
         double[][] covar = getCovariances(problem);
         for (int i = 0; i < errors.length; ++i) {
","
 
                  final int rows = problem.getMeasurements().length;
        final int cols = problem.getUnboundParameters().length;
         final int max  = cols * rows;
         double[][] jTj = new double[cols][cols];
         for (int i = 0; i < cols; ++i) {

     public double[] guessParametersErrors(EstimationProblem problem)
       throws EstimationException {
         int m = problem.getMeasurements().length;
        int p = problem.getUnboundParameters().length;
         if (m <= p) {
             throw new EstimationException(""no degrees of freedom ({0} measurements, {1} parameters)"",
                                           new Object[] { new Integer(m), new Integer(p)});
         }
        double[] errors = new double[problem.getUnboundParameters().length];
         final double c = Math.sqrt(getChiSquare(problem) / (m - p));
         double[][] covar = getCovariances(problem);
         for (int i = 0; i < errors.length; ++i) {
"
327,"org.apache.commons.math.MaxIterationsExceededException","/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java","@@ -106,8 +106,18 @@ public void setStandardDeviation(double sd) {
      * convergence exception is caught and 0 or 1 is returned.
      */
     public double cumulativeProbability(double x) throws MathException {
             return 0.5 * (1.0 + Erf.erf((x - mean) /
                     (standardDeviation * Math.sqrt(2.0))));
     }
     
     /**
","@@ -106,8 +106,18 @@ public void setStandardDeviation(double sd) {
      * convergence exception is caught and 0 or 1 is returned.
      */
     public double cumulativeProbability(double x) throws MathException {
      try {
             return 0.5 * (1.0 + Erf.erf((x - mean) /
                     (standardDeviation * Math.sqrt(2.0))));
      } catch (MaxIterationsExceededException ex) {
          if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38
              return 0.0d;
          } else if (x > (mean + 20 * standardDeviation)) {
              return 1.0d;
          } else {
              throw ex;
          }
      }
     }
     
     /**
","
    
     public double cumulativeProbability(double x) throws MathException {
             return 0.5 * (1.0 + Erf.erf((x - mean) /
                     (standardDeviation * Math.sqrt(2.0))));
     }
     
","
     public double cumulativeProbability(double x) throws MathException {
        try {
             return 0.5 * (1.0 + Erf.erf((x - mean) /
                     (standardDeviation * Math.sqrt(2.0))));
        } catch (MaxIterationsExceededException ex) {
            if (x < (mean - 20 * standardDeviation)) {                 return 0.0d;
            } else if (x > (mean + 20 * standardDeviation)) {
                return 1.0d;
            } else {
                throw ex;
            }
        }
     }
     
     "
328,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java","@@ -71,11 +71,28 @@ public double chiSquare(double[] expected, long[] observed)
             throw new IllegalArgumentException(
                 ""observed counts must be non-negative and expected counts must be postive"");
         }
         double sumSq = 0.0d;
         double dev = 0.0d;
         for (int i = 0; i < observed.length; i++) {
                 dev = ((double) observed[i] - expected[i]);
                 sumSq += dev * dev / expected[i];
         }
         return sumSq;
     }
","@@ -71,11 +71,28 @@ public double chiSquare(double[] expected, long[] observed)
             throw new IllegalArgumentException(
                 ""observed counts must be non-negative and expected counts must be postive"");
         }
      double sumExpected = 0d;
      double sumObserved = 0d;
      for (int i = 0; i < observed.length; i++) {
          sumExpected += expected[i];
          sumObserved += observed[i];
      }
      double ratio = 1.0d;
      boolean rescale = false;
      if (Math.abs(sumExpected - sumObserved) > 10E-6) {
          ratio = sumObserved / sumExpected;
          rescale = true;
      }
         double sumSq = 0.0d;
         double dev = 0.0d;
         for (int i = 0; i < observed.length; i++) {
          if (rescale) {
              dev = ((double) observed[i] - ratio * expected[i]);
              sumSq += dev * dev / (ratio * expected[i]);
          } else {
                 dev = ((double) observed[i] - expected[i]);
                 sumSq += dev * dev / expected[i];
          }
         }
         return sumSq;
     }
","
             throw new IllegalArgumentException(
                 ""observed counts must be non-negative and expected counts must be postive"");
         }
         double sumSq = 0.0d;
         double dev = 0.0d;
         for (int i = 0; i < observed.length; i++) {
                 dev = ((double) observed[i] - expected[i]);
                 sumSq += dev * dev / expected[i];
         }
         return sumSq;
     }
","
             throw new IllegalArgumentException(
                 ""observed counts must be non-negative and expected counts must be postive"");
         }
        double sumExpected = 0d;
        double sumObserved = 0d;
        for (int i = 0; i < observed.length; i++) {
            sumExpected += expected[i];
            sumObserved += observed[i];
        }
        double ratio = 1.0d;
        boolean rescale = false;
        if (Math.abs(sumExpected - sumObserved) > 10E-6) {
            ratio = sumObserved / sumExpected;
            rescale = true;
        }
         double sumSq = 0.0d;
         double dev = 0.0d;
         for (int i = 0; i < observed.length; i++) {
            if (rescale) {
                dev = ((double) observed[i] - ratio * expected[i]);
                sumSq += dev * dev / (ratio * expected[i]);
            } else {
                 dev = ((double) observed[i] - expected[i]);
                 sumSq += dev * dev / expected[i];
            }
         }
         return sumSq;
     }
"
329,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/math/util/MathUtils.java","@@ -540,6 +540,11 @@ public static int gcd(final int p, final int q) {
         int u = p;
         int v = q;
         if ((u == 0) || (v == 0)) {
             return (Math.abs(u) + Math.abs(v));
         }
         // keep u and v negative, as negative integers range down to
@@ -711,6 +716,9 @@ public static int lcm(int a, int b) {
             return 0;
         }
         int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));
         return lcm;
     }
 
","@@ -540,6 +540,11 @@ public static int gcd(final int p, final int q) {
         int u = p;
         int v = q;
         if ((u == 0) || (v == 0)) {
          if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {
              throw MathRuntimeException.createArithmeticException(
                      ""overflow: gcd({0}, {1}) is 2^31"",
                      new Object[] { p, q });
          }
             return (Math.abs(u) + Math.abs(v));
         }
         // keep u and v negative, as negative integers range down to
@@ -711,6 +716,9 @@ public static int lcm(int a, int b) {
             return 0;
         }
         int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));
      if (lcm == Integer.MIN_VALUE){
          throw new ArithmeticException(""overflow: lcm is 2^31"");
      }
         return lcm;
     }
 
","
         int u = p;
         int v = q;
         if ((u == 0) || (v == 0)) {
             return (Math.abs(u) + Math.abs(v));
         }
         
             return 0;
         }
         int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));
         return lcm;
     }
 
","
         int u = p;
         int v = q;
         if ((u == 0) || (v == 0)) {
            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {
                throw MathRuntimeException.createArithmeticException(
                        ""overflow: gcd({0}, {1}) is 2^31"",
                        new Object[] { p, q });
            }
             return (Math.abs(u) + Math.abs(v));
         }
         
             return 0;
         }
         int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));
        if (lcm == Integer.MIN_VALUE){
            throw new ArithmeticException(""overflow: lcm is 2^31"");
        }
         return lcm;
     }
 
"
330,"junit.framework.AssertionFailedError","/src/java/org/apache/commons/math/fraction/ProperFractionFormat.java","@@ -162,7 +162,11 @@ public Fraction parse(String source, ParsePosition pos) {
             return null;
         }
         
             // minus signs should be leading, invalid expression
 
         // parse '/'
         int startIndex = pos.getIndex();
@@ -197,7 +201,11 @@ public Fraction parse(String source, ParsePosition pos) {
             return null;
         }
         
             // minus signs must be leading, invalid
 
         int w = whole.intValue();
         int n = num.intValue();
","@@ -162,7 +162,11 @@ public Fraction parse(String source, ParsePosition pos) {
             return null;
         }
         
      if (num.intValue() < 0) {
             // minus signs should be leading, invalid expression
          pos.setIndex(initialIndex);
          return null;
      }
 
         // parse '/'
         int startIndex = pos.getIndex();
@@ -197,7 +201,11 @@ public Fraction parse(String source, ParsePosition pos) {
             return null;
         }
         
      if (den.intValue() < 0) {
             // minus signs must be leading, invalid
          pos.setIndex(initialIndex);
          return null;
      }
 
         int w = whole.intValue();
         int n = num.intValue();
","
             return null;
         }
         
              
                  int startIndex = pos.getIndex();

             return null;
         }
         
              
         int w = whole.intValue();
         int n = num.intValue();
","
             return null;
         }
         
        if (num.intValue() < 0) {
                         pos.setIndex(initialIndex);
            return null;
        }
 
                  int startIndex = pos.getIndex();

             return null;
         }
         
        if (den.intValue() < 0) {
                         pos.setIndex(initialIndex);
            return null;
        }
 
         int w = whole.intValue();
         int n = num.intValue();
"
331,"junit.framework.AssertionFailedError","/src/org/mockito/internal/invocation/InvocationMatcher.java","@@ -124,10 +124,12 @@ public void captureArgumentsFrom(Invocation invocation) {
                     ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));
                 }
             }
          for (int position = indexOfVararg; position < matchers.size(); position++) {
              Matcher m = matchers.get(position);
                 if (m instanceof CapturesArguments) {
                  ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);
                 }
             }
         } else {
@@ -140,6 +142,18 @@ public void captureArgumentsFrom(Invocation invocation) {
         }
     }
 
 
     public static List<InvocationMatcher> createFrom(List<Invocation> invocations) {
         LinkedList<InvocationMatcher> out = new LinkedList<InvocationMatcher>();
","@@ -124,10 +124,12 @@ public void captureArgumentsFrom(Invocation invocation) {
                     ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));
                 }
             }
          for (Matcher m : uniqueMatcherSet(indexOfVararg)) {
                 if (m instanceof CapturesArguments) {
                  Object rawArgument = invocation.getRawArguments()[indexOfVararg];
                  for (int i = 0; i < Array.getLength(rawArgument); i++) {
                      ((CapturesArguments) m).captureFrom(Array.get(rawArgument, i));
                  }
                 }
             }
         } else {
@@ -140,6 +142,18 @@ public void captureArgumentsFrom(Invocation invocation) {
         }
     }
 
  private Set<Matcher> uniqueMatcherSet(int indexOfVararg) {
      HashSet<Matcher> set = new HashSet<Matcher>();
      for (int position = indexOfVararg; position < matchers.size(); position++) {
          Matcher matcher = matchers.get(position);
          if(matcher instanceof MatcherDecorator) {
              set.add(((MatcherDecorator) matcher).getActualMatcher());
          } else {
              set.add(matcher);
          }
      }
      return set;
  }
 
     public static List<InvocationMatcher> createFrom(List<Invocation> invocations) {
         LinkedList<InvocationMatcher> out = new LinkedList<InvocationMatcher>();
","
                     ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));
                 }
             }
            for (int position = indexOfVararg; position < matchers.size(); position++) {
                Matcher m = matchers.get(position);
                 if (m instanceof CapturesArguments) {
                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);
                 }
             }
         } else {

         }
     }
 
 
     public static List<InvocationMatcher> createFrom(List<Invocation> invocations) {
         LinkedList<InvocationMatcher> out = new LinkedList<InvocationMatcher>();
","
                     ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));
                 }
             }
            for (Matcher m : uniqueMatcherSet(indexOfVararg)) {
                 if (m instanceof CapturesArguments) {
                    Object rawArgument = invocation.getRawArguments()[indexOfVararg];
                    for (int i = 0; i < Array.getLength(rawArgument); i++) {
                        ((CapturesArguments) m).captureFrom(Array.get(rawArgument, i));
                    }
                 }
             }
         } else {

         }
     }
 
    private Set<Matcher> uniqueMatcherSet(int indexOfVararg) {
        HashSet<Matcher> set = new HashSet<Matcher>();
        for (int position = indexOfVararg; position < matchers.size(); position++) {
            Matcher matcher = matchers.get(position);
            if(matcher instanceof MatcherDecorator) {
                set.add(((MatcherDecorator) matcher).getActualMatcher());
            } else {
                set.add(matcher);
            }
        }
        return set;
    }
 
     public static List<InvocationMatcher> createFrom(List<Invocation> invocations) {
         LinkedList<InvocationMatcher> out = new LinkedList<InvocationMatcher>();
"
332,"junit.framework.AssertionFailedError","/src/org/mockito/internal/util/Timer.java","@@ -1,5 +1,6 @@
 package org.mockito.internal.util;
 
 import org.mockito.exceptions.Reporter;
 
 public class Timer {
 
@@ -7,6 +8,7 @@
     private long startTime = -1;
 
     public Timer(long durationMillis) {
         this.durationMillis = durationMillis;
     }
 
@@ -25,4 +27,9 @@ public void start() {
         startTime = System.currentTimeMillis();
     }
 
 }
","@@ -1,5 +1,6 @@
 package org.mockito.internal.util;
 
 import org.mockito.exceptions.Reporter;
 
 public class Timer {
 
@@ -7,6 +8,7 @@
     private long startTime = -1;
 
     public Timer(long durationMillis) {
      validateInput(durationMillis);
         this.durationMillis = durationMillis;
     }
 
@@ -25,4 +27,9 @@ public void start() {
         startTime = System.currentTimeMillis();
     }
 
  private void validateInput(long durationMillis) {
      if (durationMillis < 0) {
          new Reporter().cannotCreateTimerWithNegativeDurationTime(durationMillis);
      }
  }
 }
","
 package org.mockito.internal.util;
 
 import org.mockito.exceptions.Reporter;
 
 public class Timer {
 

     private long startTime = -1;
 
     public Timer(long durationMillis) {
         this.durationMillis = durationMillis;
     }
 

         startTime = System.currentTimeMillis();
     }
 
 }
","
 package org.mockito.internal.util;
 
 import org.mockito.exceptions.Reporter;
 
 public class Timer {
 

     private long startTime = -1;
 
     public Timer(long durationMillis) {
        validateInput(durationMillis);
         this.durationMillis = durationMillis;
     }
 

         startTime = System.currentTimeMillis();
     }
 
    private void validateInput(long durationMillis) {
        if (durationMillis < 0) {
            new Reporter().cannotCreateTimerWithNegativeDurationTime(durationMillis);
        }
    }
 }
"
333,"java.lang.UnsupportedOperationException","/src/org/mockito/internal/invocation/InvocationMatcher.java","@@ -120,7 +120,18 @@ public Location getLocation() {
     public void captureArgumentsFrom(Invocation invocation) {
         if (invocation.getMethod().isVarArgs()) {
             int indexOfVararg = invocation.getRawArguments().length - 1;
          throw new UnsupportedOperationException();
 
         } else {
             for (int position = 0; position < matchers.size(); position++) {
","@@ -120,7 +120,18 @@ public Location getLocation() {
     public void captureArgumentsFrom(Invocation invocation) {
         if (invocation.getMethod().isVarArgs()) {
             int indexOfVararg = invocation.getRawArguments().length - 1;
          for (int position = 0; position < indexOfVararg; position++) {
              Matcher m = matchers.get(position);
              if (m instanceof CapturesArguments) {
                  ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));
              }
          }
          for (int position = indexOfVararg; position < matchers.size(); position++) {
              Matcher m = matchers.get(position);
              if (m instanceof CapturesArguments) {
                  ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);
              }
          }
 
         } else {
             for (int position = 0; position < matchers.size(); position++) {
","
     public void captureArgumentsFrom(Invocation invocation) {
         if (invocation.getMethod().isVarArgs()) {
             int indexOfVararg = invocation.getRawArguments().length - 1;
            throw new UnsupportedOperationException();
 
         } else {
             for (int position = 0; position < matchers.size(); position++) {
","
     public void captureArgumentsFrom(Invocation invocation) {
         if (invocation.getMethod().isVarArgs()) {
             int indexOfVararg = invocation.getRawArguments().length - 1;
            for (int position = 0; position < indexOfVararg; position++) {
                Matcher m = matchers.get(position);
                if (m instanceof CapturesArguments) {
                    ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));
                }
            }
            for (int position = indexOfVararg; position < matchers.size(); position++) {
                Matcher m = matchers.get(position);
                if (m instanceof CapturesArguments) {
                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);
                }
            }
 
         } else {
             for (int position = 0; position < matchers.size(); position++) {
"
334,"org.mockito.exceptions.base.MockitoException","/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java","@@ -376,6 +376,7 @@ private void readTypeVariables() {
             for (Type type : typeVariable.getBounds()) {
                 registerTypeVariablesOn(type);
             }
             registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));
         }
 
","@@ -376,6 +376,7 @@ private void readTypeVariables() {
             for (Type type : typeVariable.getBounds()) {
                 registerTypeVariablesOn(type);
             }
          registerTypeParametersOn(new TypeVariable[] { typeVariable });
             registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));
         }
 
","
             for (Type type : typeVariable.getBounds()) {
                 registerTypeVariablesOn(type);
             }
             registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));
         }
 
","
             for (Type type : typeVariable.getBounds()) {
                 registerTypeVariablesOn(type);
             }
            registerTypeParametersOn(new TypeVariable[] { typeVariable });
             registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));
         }
 
"
335,"java.lang.Exception","/src/org/mockito/exceptions/Reporter.java","@@ -421,7 +421,7 @@ public void noMoreInteractionsWanted(Invocation undesired, List<VerificationAwar
         throw new NoInteractionsWanted(join(
                 ""No interactions wanted here:"",
                 new LocationImpl(),
              ""But found this interaction on mock '"" + undesired.getMock() + ""':"",
                 undesired.getLocation(),
                 scenario
         ));
@@ -431,7 +431,7 @@ public void noMoreInteractionsWantedInOrder(Invocation undesired) {
         throw new VerificationInOrderFailure(join(
                 ""No interactions wanted here:"",
                 new LocationImpl(),
              ""But found this interaction on mock '"" + undesired.getMock() + ""':"",
                 undesired.getLocation()
         ));
     }
@@ -674,6 +674,9 @@ public void cannotInjectDependency(Field field, Object matchingMock, Exception d
     }
 
     private String exceptionCauseMessageIfAvailable(Exception details) {
         return details.getCause().getMessage();
     }
 
","@@ -421,7 +421,7 @@ public void noMoreInteractionsWanted(Invocation undesired, List<VerificationAwar
         throw new NoInteractionsWanted(join(
                 ""No interactions wanted here:"",
                 new LocationImpl(),
              ""But found this interaction on mock '"" + safelyGetMockName(undesired.getMock()) + ""':"",
                 undesired.getLocation(),
                 scenario
         ));
@@ -431,7 +431,7 @@ public void noMoreInteractionsWantedInOrder(Invocation undesired) {
         throw new VerificationInOrderFailure(join(
                 ""No interactions wanted here:"",
                 new LocationImpl(),
              ""But found this interaction on mock '"" + safelyGetMockName(undesired.getMock()) + ""':"",
                 undesired.getLocation()
         ));
     }
@@ -674,6 +674,9 @@ public void cannotInjectDependency(Field field, Object matchingMock, Exception d
     }
 
     private String exceptionCauseMessageIfAvailable(Exception details) {
      if (details.getCause() == null) {
          return details.getMessage();
      }
         return details.getCause().getMessage();
     }
 
","
         throw new NoInteractionsWanted(join(
                 ""No interactions wanted here:"",
                 new LocationImpl(),
                ""But found this interaction on mock '"" + undesired.getMock() + ""':"",
                 undesired.getLocation(),
                 scenario
         ));

         throw new VerificationInOrderFailure(join(
                 ""No interactions wanted here:"",
                 new LocationImpl(),
                ""But found this interaction on mock '"" + undesired.getMock() + ""':"",
                 undesired.getLocation()
         ));
     }

     }
 
     private String exceptionCauseMessageIfAvailable(Exception details) {
         return details.getCause().getMessage();
     }
 
","
         throw new NoInteractionsWanted(join(
                 ""No interactions wanted here:"",
                 new LocationImpl(),
                ""But found this interaction on mock '"" + safelyGetMockName(undesired.getMock()) + ""':"",
                 undesired.getLocation(),
                 scenario
         ));

         throw new VerificationInOrderFailure(join(
                 ""No interactions wanted here:"",
                 new LocationImpl(),
                ""But found this interaction on mock '"" + safelyGetMockName(undesired.getMock()) + ""':"",
                 undesired.getLocation()
         ));
     }

     }
 
     private String exceptionCauseMessageIfAvailable(Exception details) {
        if (details.getCause() == null) {
            return details.getMessage();
        }
         return details.getCause().getMessage();
     }
 
"
336,"junit.framework.AssertionFailedError","/src/org/mockito/internal/creation/DelegatingMethod.java","@@ -52,11 +52,19 @@ public boolean isAbstract() {
      */
     @Override
     public boolean equals(Object o) {
             return method.equals(o);
     }
 
     @Override
     public int hashCode() {
      return 1;
     }
 }
\ No newline at end of file
","@@ -52,11 +52,19 @@ public boolean isAbstract() {
      */
     @Override
     public boolean equals(Object o) {
      if (this == o) {
          return true;
      }
      if (o instanceof DelegatingMethod) {
          DelegatingMethod that = (DelegatingMethod) o;
          return method.equals(that.method);
      } else {
             return method.equals(o);
      }
     }
 
     @Override
     public int hashCode() {
      return method.hashCode();
     }
 }
\ No newline at end of file
","
      
     @Override
     public boolean equals(Object o) {
             return method.equals(o);
     }
 
     @Override
     public int hashCode() {
        return 1;
     }
 }
\ No newline at end of file
","
      
     @Override
     public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o instanceof DelegatingMethod) {
            DelegatingMethod that = (DelegatingMethod) o;
            return method.equals(that.method);
        } else {
             return method.equals(o);
        }
     }
 
     @Override
     public int hashCode() {
        return method.hashCode();
     }
 }
\ No newline at end of file
"
337,"org.mockito.exceptions.base.MockitoException","/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java","@@ -14,6 +14,7 @@
 import org.mockito.internal.util.MockUtil;
 import org.mockito.internal.util.reflection.GenericMetadataSupport;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.mock.MockCreationSettings;
 import org.mockito.stubbing.Answer;
 
 import java.io.IOException;
@@ -68,7 +69,7 @@ private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu
 
         // record deep stub answer
         return recordDeepStubAnswer(
              newDeepStubMock(returnTypeGenericMetadata),
                 container
         );
     }
@@ -84,22 +85,26 @@ private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu
      * @param parentMock The parent of the current deep stub mock.
      * @return The mock
      */
  private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {
         return mockitoCore().mock(
                 returnTypeGenericMetadata.rawType(),
              withSettingsUsing(returnTypeGenericMetadata)
         );
     }
 
  private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) {
         MockSettings mockSettings = returnTypeGenericMetadata.hasRawExtraInterfaces() ?
                 withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())
                 : withSettings();
 
      return mockSettings.serializable()
                 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));
     }
 
 
     private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {
         return new ReturnsDeepStubsSerializationFallback(returnTypeGenericMetadata);
","@@ -14,6 +14,7 @@
 import org.mockito.internal.util.MockUtil;
 import org.mockito.internal.util.reflection.GenericMetadataSupport;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.mock.MockCreationSettings;
 import org.mockito.stubbing.Answer;
 
 import java.io.IOException;
@@ -68,7 +69,7 @@ private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu
 
         // record deep stub answer
         return recordDeepStubAnswer(
              newDeepStubMock(returnTypeGenericMetadata, invocation.getMock()),
                 container
         );
     }
@@ -84,22 +85,26 @@ private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport retu
      * @param parentMock The parent of the current deep stub mock.
      * @return The mock
      */
  private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata, Object parentMock) {
      MockCreationSettings parentMockSettings = new MockUtil().getMockSettings(parentMock);
         return mockitoCore().mock(
                 returnTypeGenericMetadata.rawType(),
              withSettingsUsing(returnTypeGenericMetadata, parentMockSettings)
         );
     }
 
  private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata, MockCreationSettings parentMockSettings) {
         MockSettings mockSettings = returnTypeGenericMetadata.hasRawExtraInterfaces() ?
                 withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())
                 : withSettings();
 
      return propagateSerializationSettings(mockSettings, parentMockSettings)
                 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));
     }
 
  private MockSettings propagateSerializationSettings(MockSettings mockSettings, MockCreationSettings parentMockSettings) {
      return mockSettings.serializable(parentMockSettings.getSerializableMode());
  }
 
     private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {
         return new ReturnsDeepStubsSerializationFallback(returnTypeGenericMetadata);
","
 import org.mockito.internal.util.MockUtil;
 import org.mockito.internal.util.reflection.GenericMetadataSupport;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.mock.MockCreationSettings;
 import org.mockito.stubbing.Answer;
 
 import java.io.IOException;

 
                  return recordDeepStubAnswer(
                newDeepStubMock(returnTypeGenericMetadata),
                 container
         );
     }

  
    private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {
         return mockitoCore().mock(
                 returnTypeGenericMetadata.rawType(),
                withSettingsUsing(returnTypeGenericMetadata)
         );
     }
 
    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) {
         MockSettings mockSettings = returnTypeGenericMetadata.hasRawExtraInterfaces() ?
                 withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())
                 : withSettings();
 
        return mockSettings.serializable()
                 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));
     }
 
 
     private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {
         return new ReturnsDeepStubsSerializationFallback(returnTypeGenericMetadata);
","
 import org.mockito.internal.util.MockUtil;
 import org.mockito.internal.util.reflection.GenericMetadataSupport;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.mock.MockCreationSettings;
 import org.mockito.stubbing.Answer;
 
 import java.io.IOException;

 
                  return recordDeepStubAnswer(
                newDeepStubMock(returnTypeGenericMetadata, invocation.getMock()),
                 container
         );
     }

   
    private Object newDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata, Object parentMock) {
        MockCreationSettings parentMockSettings = new MockUtil().getMockSettings(parentMock);
         return mockitoCore().mock(
                 returnTypeGenericMetadata.rawType(),
                withSettingsUsing(returnTypeGenericMetadata, parentMockSettings)
         );
     }
 
    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata, MockCreationSettings parentMockSettings) {
         MockSettings mockSettings = returnTypeGenericMetadata.hasRawExtraInterfaces() ?
                 withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())
                 : withSettings();
 
        return propagateSerializationSettings(mockSettings, parentMockSettings)
                 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));
     }
 
    private MockSettings propagateSerializationSettings(MockSettings mockSettings, MockCreationSettings parentMockSettings) {
        return mockSettings.serializable(parentMockSettings.getSerializableMode());
    }
 
     private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {
         return new ReturnsDeepStubsSerializationFallback(returnTypeGenericMetadata);
"
338,"junit.framework.AssertionFailedError","/src/org/mockito/internal/verification/VerificationOverTimeImpl.java","@@ -88,7 +88,7 @@ public void verify(VerificationData data) {
             } catch (MockitoAssertionError e) {
                 error = handleVerifyException(e);
             }
          catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {
                 error = handleVerifyException(e);
             }
         }
","@@ -88,7 +88,7 @@ public void verify(VerificationData data) {
             } catch (MockitoAssertionError e) {
                 error = handleVerifyException(e);
             }
          catch (AssertionError e) {
                 error = handleVerifyException(e);
             }
         }
","
             } catch (MockitoAssertionError e) {
                 error = handleVerifyException(e);
             }
            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {
                 error = handleVerifyException(e);
             }
         }
","
             } catch (MockitoAssertionError e) {
                 error = handleVerifyException(e);
             }
            catch (AssertionError e) {
                 error = handleVerifyException(e);
             }
         }
"
339,"junit.framework.ComparisonFailure","/src/org/mockito/Matchers.java","@@ -119,7 +119,7 @@
      * @return <code>false</code>.
      */
     public static boolean anyBoolean() {
      return reportMatcher(Any.ANY).returnFalse();
     }
 
     /**
@@ -134,7 +134,7 @@ public static boolean anyBoolean() {
      * @return <code>0</code>.
      */
     public static byte anyByte() {
      return reportMatcher(Any.ANY).returnZero();
     }
 
     /**
@@ -149,7 +149,7 @@ public static byte anyByte() {
      * @return <code>0</code>.
      */
     public static char anyChar() {
      return reportMatcher(Any.ANY).returnChar();
     }
 
     /**
@@ -164,7 +164,7 @@ public static char anyChar() {
      * @return <code>0</code>.
      */
     public static int anyInt() {
      return reportMatcher(Any.ANY).returnZero();
     }
 
     /**
@@ -179,7 +179,7 @@ public static int anyInt() {
      * @return <code>0</code>.
      */
     public static long anyLong() {
      return reportMatcher(Any.ANY).returnZero();
     }
 
     /**
@@ -194,7 +194,7 @@ public static long anyLong() {
      * @return <code>0</code>.
      */
     public static float anyFloat() {
      return reportMatcher(Any.ANY).returnZero();
     }
 
     /**
@@ -209,7 +209,7 @@ public static float anyFloat() {
      * @return <code>0</code>.
      */
     public static double anyDouble() {
      return reportMatcher(Any.ANY).returnZero();
     }
 
     /**
@@ -224,7 +224,7 @@ public static double anyDouble() {
      * @return <code>0</code>.
      */
     public static short anyShort() {
      return reportMatcher(Any.ANY).returnZero();
     }
 
     /**
@@ -241,7 +241,7 @@ public static short anyShort() {
      * @return <code>null</code>.
      */
     public static <T> T anyObject() {
      return (T) reportMatcher(Any.ANY).returnNull();
     }
 
     /**
@@ -289,7 +289,7 @@ public static short anyShort() {
      * @return <code>null</code>.
      */
     public static <T> T any(Class<T> clazz) {
      return (T) reportMatcher(Any.ANY).returnFor(clazz);
     }
     
     /**
@@ -306,7 +306,7 @@ public static short anyShort() {
      * @return <code>null</code>.
      */
     public static <T> T any() {
      return (T) anyObject();
     }
 
     /**
@@ -321,7 +321,7 @@ public static short anyShort() {
      * @return empty String ("""")
      */
     public static String anyString() {
      return reportMatcher(Any.ANY).returnString();
     }
     
     /**
@@ -336,7 +336,7 @@ public static String anyString() {
      * @return empty List.
      */
     public static List anyList() {
      return reportMatcher(Any.ANY).returnList();
     }    
     
     /**
@@ -355,7 +355,7 @@ public static List anyList() {
      * @return empty List.
      */
     public static <T> List<T> anyListOf(Class<T> clazz) {
      return (List) reportMatcher(Any.ANY).returnList();
     }    
     
     /**
@@ -370,7 +370,7 @@ public static List anyList() {
      * @return empty Set
      */
     public static Set anySet() {
      return reportMatcher(Any.ANY).returnSet();
     }
     
     /**
@@ -389,7 +389,7 @@ public static Set anySet() {
      * @return empty Set
      */
     public static <T> Set<T> anySetOf(Class<T> clazz) {
      return (Set) reportMatcher(Any.ANY).returnSet();
     }
 
     /**
@@ -404,7 +404,7 @@ public static Set anySet() {
      * @return empty Map.
      */
     public static Map anyMap() {
      return reportMatcher(Any.ANY).returnMap();
     }
 
     /**
@@ -424,7 +424,7 @@ public static Map anyMap() {
      * @return empty Map.
      */
     public static <K, V>  Map<K, V> anyMapOf(Class<K> keyClazz, Class<V> valueClazz) {
      return reportMatcher(Any.ANY).returnMap();
     }
     
     /**
@@ -439,7 +439,7 @@ public static Map anyMap() {
      * @return empty Collection.
      */
     public static Collection anyCollection() {
      return reportMatcher(Any.ANY).returnList();
     }    
     
     /**
@@ -458,7 +458,7 @@ public static Collection anyCollection() {
      * @return empty Collection.
      */
     public static <T> Collection<T> anyCollectionOf(Class<T> clazz) {
      return (Collection) reportMatcher(Any.ANY).returnList();
     }    
 
     /**
","@@ -119,7 +119,7 @@
      * @return <code>false</code>.
      */
     public static boolean anyBoolean() {
      return reportMatcher(new InstanceOf(Boolean.class)).returnFalse();
     }
 
     /**
@@ -134,7 +134,7 @@ public static boolean anyBoolean() {
      * @return <code>0</code>.
      */
     public static byte anyByte() {
      return reportMatcher(new InstanceOf(Byte.class)).returnZero();
     }
 
     /**
@@ -149,7 +149,7 @@ public static byte anyByte() {
      * @return <code>0</code>.
      */
     public static char anyChar() {
      return reportMatcher(new InstanceOf(Character.class)).returnChar();
     }
 
     /**
@@ -164,7 +164,7 @@ public static char anyChar() {
      * @return <code>0</code>.
      */
     public static int anyInt() {
      return reportMatcher(new InstanceOf(Integer.class)).returnZero();
     }
 
     /**
@@ -179,7 +179,7 @@ public static int anyInt() {
      * @return <code>0</code>.
      */
     public static long anyLong() {
      return reportMatcher(new InstanceOf(Long.class)).returnZero();
     }
 
     /**
@@ -194,7 +194,7 @@ public static long anyLong() {
      * @return <code>0</code>.
      */
     public static float anyFloat() {
      return reportMatcher(new InstanceOf(Float.class)).returnZero();
     }
 
     /**
@@ -209,7 +209,7 @@ public static float anyFloat() {
      * @return <code>0</code>.
      */
     public static double anyDouble() {
      return reportMatcher(new InstanceOf(Double.class)).returnZero();
     }
 
     /**
@@ -224,7 +224,7 @@ public static double anyDouble() {
      * @return <code>0</code>.
      */
     public static short anyShort() {
      return reportMatcher(new InstanceOf(Short.class)).returnZero();
     }
 
     /**
@@ -241,7 +241,7 @@ public static short anyShort() {
      * @return <code>null</code>.
      */
     public static <T> T anyObject() {
      return (T) reportMatcher(new InstanceOf(Object.class)).returnNull();
     }
 
     /**
@@ -289,7 +289,7 @@ public static short anyShort() {
      * @return <code>null</code>.
      */
     public static <T> T any(Class<T> clazz) {
      return (T) reportMatcher(new InstanceOf(clazz)).returnFor(clazz);
     }
     
     /**
@@ -306,7 +306,7 @@ public static short anyShort() {
      * @return <code>null</code>.
      */
     public static <T> T any() {
      return (T) reportMatcher(Any.ANY).returnNull();
     }
 
     /**
@@ -321,7 +321,7 @@ public static short anyShort() {
      * @return empty String ("""")
      */
     public static String anyString() {
      return reportMatcher(new InstanceOf(String.class)).returnString();
     }
     
     /**
@@ -336,7 +336,7 @@ public static String anyString() {
      * @return empty List.
      */
     public static List anyList() {
      return reportMatcher(new InstanceOf(List.class)).returnList();
     }    
     
     /**
@@ -355,7 +355,7 @@ public static List anyList() {
      * @return empty List.
      */
     public static <T> List<T> anyListOf(Class<T> clazz) {
      return anyList();
     }    
     
     /**
@@ -370,7 +370,7 @@ public static List anyList() {
      * @return empty Set
      */
     public static Set anySet() {
      return reportMatcher(new InstanceOf(Set.class)).returnSet();
     }
     
     /**
@@ -389,7 +389,7 @@ public static Set anySet() {
      * @return empty Set
      */
     public static <T> Set<T> anySetOf(Class<T> clazz) {
      return anySet();
     }
 
     /**
@@ -404,7 +404,7 @@ public static Set anySet() {
      * @return empty Map.
      */
     public static Map anyMap() {
      return reportMatcher(new InstanceOf(Map.class)).returnMap();
     }
 
     /**
@@ -424,7 +424,7 @@ public static Map anyMap() {
      * @return empty Map.
      */
     public static <K, V>  Map<K, V> anyMapOf(Class<K> keyClazz, Class<V> valueClazz) {
      return anyMap();
     }
     
     /**
@@ -439,7 +439,7 @@ public static Map anyMap() {
      * @return empty Collection.
      */
     public static Collection anyCollection() {
      return reportMatcher(new InstanceOf(Collection.class)).returnList();
     }    
     
     /**
@@ -458,7 +458,7 @@ public static Collection anyCollection() {
      * @return empty Collection.
      */
     public static <T> Collection<T> anyCollectionOf(Class<T> clazz) {
      return anyCollection();
     }    
 
     /**
","
   
     public static boolean anyBoolean() {
        return reportMatcher(Any.ANY).returnFalse();
     }
 
     
   
     public static byte anyByte() {
        return reportMatcher(Any.ANY).returnZero();
     }
 
     
   
     public static char anyChar() {
        return reportMatcher(Any.ANY).returnChar();
     }
 
     
    
     public static int anyInt() {
        return reportMatcher(Any.ANY).returnZero();
     }
 
     
  
     public static long anyLong() {
        return reportMatcher(Any.ANY).returnZero();
     }
 
     
  
     public static float anyFloat() {
        return reportMatcher(Any.ANY).returnZero();
     }
 
     
   
     public static double anyDouble() {
        return reportMatcher(Any.ANY).returnZero();
     }
 
     
   
     public static short anyShort() {
        return reportMatcher(Any.ANY).returnZero();
     }
 
     
   
     public static <T> T anyObject() {
        return (T) reportMatcher(Any.ANY).returnNull();
     }
 
     
   
     public static <T> T any(Class<T> clazz) {
        return (T) reportMatcher(Any.ANY).returnFor(clazz);
     }
     
     
  
     public static <T> T any() {
        return (T) anyObject();
     }
 
     
  
     public static String anyString() {
        return reportMatcher(Any.ANY).returnString();
     }
     
     
   
     public static List anyList() {
        return reportMatcher(Any.ANY).returnList();
     }    
     
     
   
     public static <T> List<T> anyListOf(Class<T> clazz) {
        return (List) reportMatcher(Any.ANY).returnList();
     }    
     
     
  
     public static Set anySet() {
        return reportMatcher(Any.ANY).returnSet();
     }
     
     
    
     public static <T> Set<T> anySetOf(Class<T> clazz) {
        return (Set) reportMatcher(Any.ANY).returnSet();
     }
 
     
   
     public static Map anyMap() {
        return reportMatcher(Any.ANY).returnMap();
     }
 
     
    
     public static <K, V>  Map<K, V> anyMapOf(Class<K> keyClazz, Class<V> valueClazz) {
        return reportMatcher(Any.ANY).returnMap();
     }
     
     
   
     public static Collection anyCollection() {
        return reportMatcher(Any.ANY).returnList();
     }    
     
     
  
     public static <T> Collection<T> anyCollectionOf(Class<T> clazz) {
        return (Collection) reportMatcher(Any.ANY).returnList();
     }    
 
     ","
  
     public static boolean anyBoolean() {
        return reportMatcher(new InstanceOf(Boolean.class)).returnFalse();
     }
 
     
  
     public static byte anyByte() {
        return reportMatcher(new InstanceOf(Byte.class)).returnZero();
     }
 
     
  
     public static char anyChar() {
        return reportMatcher(new InstanceOf(Character.class)).returnChar();
     }
 
     
  
     public static int anyInt() {
        return reportMatcher(new InstanceOf(Integer.class)).returnZero();
     }
 
     
   
     public static long anyLong() {
        return reportMatcher(new InstanceOf(Long.class)).returnZero();
     }
 
     
  
     public static float anyFloat() {
        return reportMatcher(new InstanceOf(Float.class)).returnZero();
     }
 
     
   
     public static double anyDouble() {
        return reportMatcher(new InstanceOf(Double.class)).returnZero();
     }
 
     
   
     public static short anyShort() {
        return reportMatcher(new InstanceOf(Short.class)).returnZero();
     }
 
     
   
     public static <T> T anyObject() {
        return (T) reportMatcher(new InstanceOf(Object.class)).returnNull();
     }
 
     
   
     public static <T> T any(Class<T> clazz) {
        return (T) reportMatcher(new InstanceOf(clazz)).returnFor(clazz);
     }
     
     
   
     public static <T> T any() {
        return (T) reportMatcher(Any.ANY).returnNull();
     }
 
     
    
     public static String anyString() {
        return reportMatcher(new InstanceOf(String.class)).returnString();
     }
     
     
   
     public static List anyList() {
        return reportMatcher(new InstanceOf(List.class)).returnList();
     }    
     
     
  
     public static <T> List<T> anyListOf(Class<T> clazz) {
        return anyList();
     }    
     
     
     
     public static Set anySet() {
        return reportMatcher(new InstanceOf(Set.class)).returnSet();
     }
     
     
   
     public static <T> Set<T> anySetOf(Class<T> clazz) {
        return anySet();
     }
 
     
   
     public static Map anyMap() {
        return reportMatcher(new InstanceOf(Map.class)).returnMap();
     }
 
     
    
     public static <K, V>  Map<K, V> anyMapOf(Class<K> keyClazz, Class<V> valueClazz) {
        return anyMap();
     }
     
     
   
     public static Collection anyCollection() {
        return reportMatcher(new InstanceOf(Collection.class)).returnList();
     }    
     
     
     
     public static <T> Collection<T> anyCollectionOf(Class<T> clazz) {
        return anyCollection();
     }    
 
     "
340,"org.mockito.exceptions.base.MockitoException","/src/org/mockito/internal/stubbing/answers/CallsRealMethods.java","@@ -5,7 +5,9 @@
 package org.mockito.internal.stubbing.answers;
 
 import java.io.Serializable;
 import java.lang.reflect.Modifier;
 
 import org.mockito.internal.stubbing.defaultanswers.GloballyConfiguredAnswer;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 
@@ -33,6 +35,9 @@
     private static final long serialVersionUID = 9057165148930624087L;
 
     public Object answer(InvocationOnMock invocation) throws Throwable {
         return invocation.callRealMethod();
     }
 }
\ No newline at end of file
","@@ -5,7 +5,9 @@
 package org.mockito.internal.stubbing.answers;
 
 import java.io.Serializable;
 import java.lang.reflect.Modifier;
 
 import org.mockito.internal.stubbing.defaultanswers.GloballyConfiguredAnswer;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 
@@ -33,6 +35,9 @@
     private static final long serialVersionUID = 9057165148930624087L;
 
     public Object answer(InvocationOnMock invocation) throws Throwable {
  	if (Modifier.isAbstract(invocation.getMethod().getModifiers())) {
  		return new GloballyConfiguredAnswer().answer(invocation);
  	}
         return invocation.callRealMethod();
     }
 }
\ No newline at end of file
","
 package org.mockito.internal.stubbing.answers;
 
 import java.io.Serializable;
 import java.lang.reflect.Modifier;
 
 import org.mockito.internal.stubbing.defaultanswers.GloballyConfiguredAnswer;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 

     private static final long serialVersionUID = 9057165148930624087L;
 
     public Object answer(InvocationOnMock invocation) throws Throwable {
         return invocation.callRealMethod();
     }
 }
\ No newline at end of file
","
 package org.mockito.internal.stubbing.answers;
 
 import java.io.Serializable;
 import java.lang.reflect.Modifier;
 
 import org.mockito.internal.stubbing.defaultanswers.GloballyConfiguredAnswer;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 

     private static final long serialVersionUID = 9057165148930624087L;
 
     public Object answer(InvocationOnMock invocation) throws Throwable {
    	if (Modifier.isAbstract(invocation.getMethod().getModifiers())) {
    		return new GloballyConfiguredAnswer().answer(invocation);
    	}
         return invocation.callRealMethod();
     }
 }
\ No newline at end of file
"
341,"java.lang.StackOverflowError","/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java","@@ -76,7 +76,7 @@ protected void registerTypeVariablesOn(Type classType) {
 
             if (actualTypeArgument instanceof WildcardType) {
                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));
          } else {
                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);
             }
             // logger.log(""For '"" + parameterizedType + ""' found type variable : { '"" + typeParameter + ""("" + System.identityHashCode(typeParameter) + "")"" + ""' : '"" + actualTypeArgument + ""("" + System.identityHashCode(typeParameter) + "")"" + ""' }"");
","@@ -76,7 +76,7 @@ protected void registerTypeVariablesOn(Type classType) {
 
             if (actualTypeArgument instanceof WildcardType) {
                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));
          } else if (typeParameter != actualTypeArgument) {
                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);
             }
             // logger.log(""For '"" + parameterizedType + ""' found type variable : { '"" + typeParameter + ""("" + System.identityHashCode(typeParameter) + "")"" + ""' : '"" + actualTypeArgument + ""("" + System.identityHashCode(typeParameter) + "")"" + ""' }"");
","
 
             if (actualTypeArgument instanceof WildcardType) {
                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));
            } else {
                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);
             }
             ","
 
             if (actualTypeArgument instanceof WildcardType) {
                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));
            } else if (typeParameter != actualTypeArgument) {
                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);
             }
             "
342,"org.mockito.exceptions.misusing.MissingMethodInvocationException","/src/org/mockito/Mockito.java","@@ -1,921 +1,921 @@
 /*
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
 package org.mockito;
 
 import org.mockito.internal.MockitoCore;
 import org.mockito.internal.creation.MockSettingsImpl;
 import org.mockito.internal.debugging.MockitoDebuggerImpl;
 import org.mockito.internal.stubbing.answers.*;
 import org.mockito.internal.stubbing.defaultanswers.*;
 import org.mockito.internal.verification.VerificationModeFactory;
 import org.mockito.internal.verification.api.VerificationMode;
 import org.mockito.runners.MockitoJUnitRunner;
 import org.mockito.stubbing.*;
 
 /**
  * <p align=""left""><img src=""logo.jpg""/></p>
  * Mockito library enables mocks creation, verification and stubbing.
  * <p>
  * This javadoc content is also available on the <a href=""http://mockito.org"">http://mockito.org</a> web page. 
  * All documentation is kept in javadocs because it guarantees consistency between what's on the web and what's in the source code.
  * Also, it makes possible to access documentation straight from the IDE even if you work offline.   
  * 
  * <h1>Contents</h1>
  * 
  * <b> 
  *      <a href=""#1"">1. Let's verify some behaviour! </a><br/> 
  *      <a href=""#2"">2. How about some stubbing? </a><br/>
  *      <a href=""#3"">3. Argument matchers </a><br/>
  *      <a href=""#4"">4. Verifying exact number of invocations / at least once / never </a><br/> 
  *      <a href=""#5"">5. Stubbing void methods with exceptions </a><br/> 
  *      <a href=""#6"">6. Verification in order </a><br/> 
  *      <a href=""#7"">7. Making sure interaction(s) never happened on mock </a><br/> 
  *      <a href=""#8"">8. Finding redundant invocations </a><br/> 
  *      <a href=""#9"">9. Shorthand for mocks creation - &#064;Mock annotation </a><br/> 
  *      <a href=""#10"">10. Stubbing consecutive calls (iterator-style stubbing) </a><br/> 
  *      <a href=""#11"">11. Stubbing with callbacks </a><br/>
  *      <a href=""#12"">12. doThrow()|doAnswer()|doNothing()|doReturn() family of methods mostly for stubbing voids </a><br/>
  *      <a href=""#13"">13. Spying on real objects </a><br/>
  *      <a href=""#14"">14. Changing default return values of unstubbed invocations (Since 1.7) </a><br/>
  *      <a href=""#15"">15. Capturing arguments for further assertions (Since 1.8.0) </a><br/>
  *      <a href=""#16"">16. Real partial mocks (Since 1.8.0) </a><br/>
  *      <a href=""#17"">17. Resetting mocks (Since 1.8.0) </a><br/>
  *      <a href=""#18"">18. Troubleshooting & validating framework usage (Since 1.8.0) </a><br/>
  *      <a href=""#19"">19. Aliases for behavior driven development (Since 1.8.0) </a><br/>
  *      <a href=""#20"">20. (**New**) Serializable mocks (Since 1.8.1) </a><br/>
  * </b>
  * 
  * <p>
  * Following examples mock a List, because everyone knows its interface (methods
  * like add(), get(), clear() will be used). <br>
  * You probably wouldn't mock List class 'in real'.
  * 
  * <h3 id=""1"">1. Let's verify some behaviour!</h3>
  * 
  * <pre>
  * //Let's import Mockito statically so that the code looks clearer
  * import static org.mockito.Mockito.*;
  * 
  * //mock creation
  * List mockedList = mock(List.class);
  *
  * //using mock object
  * mockedList.add(""one"");
  * mockedList.clear();
  *
  * //verification
  * verify(mockedList).add(""one"");
  * verify(mockedList).clear();
  * </pre>
  * 
  * <p>
  * Once created, mock will remember all interactions. Then you can selectively
  * verify whatever interaction you are interested in.
  * 
  * <h3 id=""2"">2. How about some stubbing?</h3>
  * 
  * <pre>
  * //You can mock concrete classes, not only interfaces
  * LinkedList mockedList = mock(LinkedList.class);
  * 
  * //stubbing
  * when(mockedList.get(0)).thenReturn(""first"");
  * when(mockedList.get(1)).thenThrow(new RuntimeException());
  * 
  * //following prints ""first""
  * System.out.println(mockedList.get(0));
  * 
  * //following throws runtime exception
  * System.out.println(mockedList.get(1));
  * 
  * //following prints ""null"" because get(999) was not stubbed
  * System.out.println(mockedList.get(999));
  *  
  * //Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>
  * //If your code cares what get(0) returns then something else breaks (often before even verify() gets executed).
  * //If your code doesn't care what get(0) returns then it should not be stubbed. Not convinced? See <a href=""http://monkeyisland.pl/2008/04/26/asking-and-telling"">here</a>.
  * verify(mockedList).get(0);
  * </pre>
  * 
  * <ul>
  * <li> By default, for all methods that return value, mock returns null, an
  * empty collection or appropriate primitive/primitive wrapper value (e.g: 0,
  * false, ... for int/Integer, boolean/Boolean, ...). </li>
  * 
  * <li> Stubbing can be overridden: for example common stubbing can go to
  * fixture setup but the test methods can override it.
  * Please note that overridding stubbing is a potential code smell that points out too much stubbing</li>
  * 
  * <li> Once stubbed, the method will always return stubbed value regardless
  * of how many times it is called. </li>
  * 
  * <li> Last stubbing is more important - when you stubbed the same method with
  * the same arguments many times. </li>
  * 
  * </ul>
  * 
  * <h3 id=""3"">3. Argument matchers</h3>
  * 
  * Mockito verifies argument values in natural java style: by using an equals() method.
  * Sometimes, when extra flexibility is required then you might use argument matchers:  
  * 
  * <pre>
  * //stubbing using built-in anyInt() argument matcher
  * when(mockedList.get(anyInt())).thenReturn(""element"");
  * 
  * //stubbing using hamcrest (let's say isValid() returns your own hamcrest matcher):
  * when(mockedList.contains(argThat(isValid()))).thenReturn(""element"");
  * 
  * //following prints ""element""
  * System.out.println(mockedList.get(999));
  * 
  * //<b>you can also verify using an argument matcher</b>
  * verify(mockedList).get(anyInt());
  * </pre>
  * 
  * <p>
  * Argument matchers allow flexible verification or stubbing. 
  * {@link Matchers Click here to see} more built-in matchers 
  * and examples of <b>custom argument matchers / hamcrest matchers</b>.
  * <p>
  * For information solely on <b>custom argument matchers</b> check out javadoc for {@link ArgumentMatcher} class.
  * <p>
  * Be reasonable with using complicated argument matching.
  * The natural matching style using equals() with occasional anyX() matchers tend to give clean & simple tests.
  * Sometimes it's just better to refactor the code to allow equals() matching or even implement equals() method to help out with testing.
  * <p>
  * Also, read <a href=""#15"">section 15</a> or javadoc for {@link ArgumentCaptor} class.
  * {@link ArgumentCaptor} is a special implementation of an argument matcher that captures argument values for further assertions.  
  * <p>
  * <b>Warning on argument matchers:</b>
  * <p>
  * If you are using argument matchers, <b>all arguments</b> have to be provided
  * by matchers.
  * <p>
  * E.g: (example shows verification but the same applies to stubbing):
  * 
  * <pre>
  *   verify(mock).someMethod(anyInt(), anyString(), <b>eq(""third argument"")</b>);
  *   //above is correct - eq() is also an argument matcher
  *   
  *   verify(mock).someMethod(anyInt(), anyString(), <b>""third argument""</b>);
  *   //above is incorrect - exception will be thrown because third argument is given without an argument matcher.
  * </pre>
  * 
  * <h3 id=""4"">4. Verifying exact number of invocations / at least x / never</h3>
  * 
  * <pre>
  * //using mock 
  * mockedList.add(""once"");
  * 
  * mockedList.add(""twice"");
  * mockedList.add(""twice"");
  * 
  * mockedList.add(""three times"");
  * mockedList.add(""three times"");
  * mockedList.add(""three times"");
  * 
  * //following two verifications work exactly the same - times(1) is used by default
  * verify(mockedList).add(""once"");
  * verify(mockedList, times(1)).add(""once"");
  * 
  * //exact number of invocations verification
  * verify(mockedList, times(2)).add(""twice"");
  * verify(mockedList, times(3)).add(""three times"");
  * 
  * //verification using never(). never() is an alias to times(0)
  * verify(mockedList, never()).add(""never happened"");
  * 
  * //verification using atLeast()/atMost()
  * verify(mockedList, atLeastOnce()).add(""three times"");
  * verify(mockedList, atLeast(2)).add(""five times"");
  * verify(mockedList, atMost(5)).add(""three times"");
  * 
  * </pre>
  * 
  * <p>
  * <b>times(1) is the default.</b> Therefore using times(1) explicitly can be
  * omitted.
  * 
  * <h3 id=""5"">5. Stubbing void methods with exceptions</h3>
  * 
  * <pre>
  *   doThrow(new RuntimeException()).when(mockedList).clear();
  *   
  *   //following throws RuntimeException:
  *   mockedList.clear();
  * </pre>
  * 
  * Read more about doThrow|doAnswer family of methods in paragraph 12.
  * <p>
  * Initially, {@link Mockito#stubVoid(Object)} was used for stubbing voids.
  * Currently stubVoid() is deprecated in favor of {@link Mockito#doThrow(Throwable)}.
  * This is because of improved readability and consistency with the family of {@link Mockito#doAnswer(Answer)} methods. 
  * 
  * <h3 id=""6"">6. Verification in order</h3>
  * 
  * <pre>
  * List firstMock = mock(List.class);
  * List secondMock = mock(List.class);
  * 
  * //using mocks
  * firstMock.add(""was called first"");
  * secondMock.add(""was called second"");
  * 
  * //create inOrder object passing any mocks that need to be verified in order
  * InOrder inOrder = inOrder(firstMock, secondMock);
  * 
  * //following will make sure that firstMock was called before secondMock
  * inOrder.verify(firstMock).add(""was called first"");
  * inOrder.verify(secondMock).add(""was called second"");
  * </pre>
  * 
  * Verification in order is flexible - <b>you don't have to verify all
  * interactions</b> one-by-one but only those that you are interested in
  * testing in order.
  * <p>
  * Also, you can create InOrder object passing only mocks that are relevant for
  * in-order verification.
  * 
  * <h3 id=""7"">7. Making sure interaction(s) never happened on mock</h3>
  * 
  * <pre>
  * //using mocks - only mockOne is interacted
  * mockOne.add(""one"");
  * 
  * //ordinary verification
  * verify(mockOne).add(""one"");
  * 
  * //verify that method was never called on a mock
  * verify(mockOne, never()).add(""two"");
  * 
  * //verify that other mocks were not interacted
  * verifyZeroInteractions(mockTwo, mockThree);
  * 
  * </pre>
  * 
  * <h3 id=""8"">8. Finding redundant invocations</h3>
  * 
  * <pre>
  * //using mocks
  * mockedList.add(""one"");
  * mockedList.add(""two"");
  * 
  * verify(mockedList).add(""one"");
  * 
  * //following verification will fail 
  * verifyNoMoreInteractions(mockedList);
  * </pre>
  * 
  * A word of <b>warning</b>: 
  * Some users who did a lot of classic, expect-run-verify mocking tend to use verifyNoMoreInteractions() very often, even in every test method. 
  * verifyNoMoreInteractions() is not recommended to use in every test method. 
  * verifyNoMoreInteractions() is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.
  * Abusing it leads to overspecified, less maintainable tests. You can find further reading 
  * <a href=""http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/"">here</a>.
  * 
  * <p>   
  * See also {@link Mockito#never()} - it is more explicit and
  * communicates the intent well.
  * <p>
  * 
  * <h3 id=""9"">9. Shorthand for mocks creation - &#064;Mock annotation</h3>
  * 
  * <ul>
  * <li>Minimizes repetitive mock creation code.</li>
  * <li>Makes the test class more readable.</li>
  * <li>Makes the verification error easier to read because the <b>field name</b>
  * is used to identify the mock.</li>
  * </ul>
  * 
  * <pre>
  *   public class ArticleManagerTest { 
  *     
  *       &#064;Mock private ArticleCalculator calculator;
  *       &#064;Mock private ArticleDatabase database;
  *       &#064;Mock private UserProvider userProvider;
  *     
  *       private ArticleManager manager;
  * </pre>
  * 
  * <b>Important!</b> This needs to be somewhere in the base class or a test
  * runner:
  * 
  * <pre>
  * MockitoAnnotations.initMocks(testClass);
  * </pre>
  * 
  * You can use built-in runner: {@link MockitoJUnitRunner}.
  * <p>
  * Read more here: {@link MockitoAnnotations}
  * 
  * <h3 id=""10""> 10. Stubbing consecutive calls (iterator-style stubbing)</h3>
  * 
  * Sometimes we need to stub with different return value/exception for the same
  * method call. Typical use case could be mocking iterators. 
  * Original version of Mockito did not have this feature to promote simple mocking. 
  * For example, instead of iterators one could use {@link Iterable} or simply
  * collections. Those offer natural ways of stubbing (e.g. using real
  * collections). In rare scenarios stubbing consecutive calls could be useful,
  * though:
  * <p>
  * 
  * <pre>
  * when(mock.someMethod(""some arg""))
  *   .thenThrow(new RuntimeException())
  *   .thenReturn(""foo"");
  * 
  * //First call: throws runtime exception:
  * mock.someMethod(""some arg"");
  * 
  * //Second call: prints ""foo""
  * System.out.println(mock.someMethod(""some arg""));
  * 
  * //Any consecutive call: prints ""foo"" as well (last stubbing wins). 
  * System.out.println(mock.someMethod(""some arg""));
  * </pre>
  * 
  * Alternative, shorter version of consecutive stubbing:
  * 
  * <pre>
  * when(mock.someMethod(""some arg""))
  *   .thenReturn(""one"", ""two"", ""three"");
  * </pre>
  * 
  * <h3 id=""11""> 11. Stubbing with callbacks</h3>
  * 
  * Allows stubbing with generic {@link Answer} interface.
 *  <p>
  * Yet another controversial feature which was not included in Mockito
  * originally. We recommend using simple stubbing with thenReturn() or
  * thenThrow() only. Those two should be <b>just enough</b> to test/test-drive
  * any clean & simple code.
  * 
  * <pre>
  * when(mock.someMethod(anyString())).thenAnswer(new Answer() {
  *     Object answer(InvocationOnMock invocation) {
  *         Object[] args = invocation.getArguments();
  *         Object mock = invocation.getMock();
  *         return ""called with arguments: "" + args;
  *     }
  * });
  * 
  * //Following prints ""called with arguments: foo""
  * System.out.println(mock.someMethod(""foo""));
  * </pre>
  * 
  * <h3 id=""12""> 12. doThrow()|doAnswer()|doNothing()|doReturn() family of methods for stubbing voids (mostly)</h3>
  * 
  * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...
  * <p>
  * {@link Mockito#doThrow(Throwable)} replaces the {@link Mockito#stubVoid(Object)} method for stubbing voids. 
  * The main reason is improved readability and consistency with the family of doAnswer() methods.
  * <p>
  * Use doThrow() when you want to stub a void method with an exception:
  * <pre>
  *   doThrow(new RuntimeException()).when(mockedList).clear();
  *   
  *   //following throws RuntimeException:
  *   mockedList.clear();
  * </pre>
  * 
  * Read more about other methods:
  * <p>
  * {@link Mockito#doThrow(Throwable)}
  * <p>
  * {@link Mockito#doAnswer(Answer)}
  * <p>
  * {@link Mockito#doNothing()}
  * <p>
  * {@link Mockito#doReturn(Object)}
  * 
  * <h3 id=""13""> 13. Spying on real objects</h3>
  * 
  * You can create spies of real objects. When you use the spy then the <b>real</b> methods are called (unless a method was stubbed).
  * <p>
  * Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.
  * 
  * <p>
  * Spying on real objects can be associated with ""partial mocking"" concept. 
  * <b>Before the release 1.8</b>, Mockito spies were not real partial mocks. 
  * The reason was we thought partial mock is a code smell. 
  * At some point we found legitimate use cases for partial mocks 
  * (3rd party interfaces, interim refactoring of legacy code, the full article is <a href=
  * ""http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring""
  * >here</a>)
  * <p>
  *
  * <pre>
  *   List list = new LinkedList();
  *   List spy = spy(list);
  * 
  *   //optionally, you can stub out some methods:
  *   when(spy.size()).thenReturn(100);
  * 
  *   //using the spy calls <b>real</b> methods
  *   spy.add(""one"");
  *   spy.add(""two"");
  * 
  *   //prints ""one"" - the first element of a list
  *   System.out.println(spy.get(0));
  * 
  *   //size() method was stubbed - 100 is printed
  *   System.out.println(spy.size());
  * 
  *   //optionally, you can verify
  *   verify(spy).add(""one"");
  *   verify(spy).add(""two"");
  * </pre>
  * 
  * <h4>Important gotcha on spying real objects!</h4>
  * 
  * 1. Sometimes it's impossible to use {@link Mockito#when(Object)} for stubbing spies. Example:
  * 
  * <pre>
  *   List list = new LinkedList();
  *   List spy = spy(list);
  *   
  *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)
  *   when(spy.get(0)).thenReturn(""foo"");
  *   
  *   //You have to use doReturn() for stubbing
  *   doReturn(""foo"").when(spy).get(0);
  * </pre>
  * 
  * 2. Watch out for final methods. 
  * Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.
  * What will happen is the real method will be called *on mock* but *not on the real instance* you passed to the spy() method.
  * Typically you may get a NullPointerException because mock instances don't have fields initiated.
  * 
  * <h3 id=""14"">14. Changing default return values of unstubbed invocations (Since 1.7) </h3>
  * 
  * You can create a mock with specified strategy for its return values.
  * It's quite advanced feature and typically you don't need it to write decent tests.
  * However, it can be helpful for working with <b>legacy systems</b>.
  * <p>
  * It is the default answer so it will be used <b>only when you don't</b> stub the method call.
  * 
  * <pre>
  *   Foo mock = mock(Foo.class, Mockito.RETURNS_SMART_NULLS);
  *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer()); 
  * </pre>
  * 
  * <p>
  * Read more about this interesting implementation of <i>Answer</i>: {@link Mockito#RETURNS_SMART_NULLS}
  * 
  * <h3 id=""15"">15. Capturing arguments for further assertions (Since 1.8.0) </h3>
  * 
  * Mockito verifies argument values in natural java style: by using an equals() method.
  * This is also the recommended way of matching arguments because it makes tests clean & simple.
  * In some situations though, it is helpful to assert on certain arguments after the actual verification.
  * For example:
  * <pre>
  *   ArgumentCaptor&lt;Person&gt; argument = ArgumentCaptor.forClass(Person.class);
  *   verify(mock).doSomething(argument.capture());
  *   assertEquals(""John"", argument.getValue().getName());
  * </pre>
  * 
  * <b>Warning:</b> it is recommended to use ArgumentCaptor with verification <b>but not</b> with stubbing.
  * Using ArgumentCaptor with stubbing may decrease test readability because captor is created outside of assert (aka verify or 'then') block.
  * Also it may reduce defect localization because if stubbed method was not called then no argument is captured.
  * <p>
  * In a way ArgumentCaptor is related to custom argument matchers (see javadoc for {@link ArgumentMatcher} class).
  * Both techniques can be used for making sure certain arguments where passed to mocks. 
  * However, ArgumentCaptor may be a better fit if:
  * <ul>  
  * <li>custom argument matcher is not likely to be reused</li>
  * <li>you just need it to assert on argument values to complete verification</li>
  * </ul>
  * Custom argument matchers via {@link ArgumentMatcher} are usually better for stubbing.
  * 
  * <h3 id=""16"">16. Real partial mocks (Since 1.8.0) </h3>
  *  
  *  Finally, after many internal debates & discussions on the mailing list, partial mock support was added to Mockito.
  *  Previously we considered partial mocks as code smells. However, we found a legitimate use case for partial mocks - more reading:
  *  <a href=""http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring"">here</a>
  *  <p>
  *  <b>Before release 1.8</b> spy() was not producing real partial mocks and it was confusing for some users.
  *  Read more about spying: <a href=""#13"">here</a> or in javadoc for {@link Mockito#spy(Object)} method. 
  *  <p>
  *  <pre>
  *    //you can create partial mock with spy() method:    
  *    List list = spy(new LinkedList());
  *    
  *    //you can enable partial mock capabilities selectively on mocks:
  *    Foo mock = mock(Foo.class);
  *    //Be sure the real implementation is 'safe'.
  *    //If real implementation throws exceptions or depends on specific state of the object then you're in trouble.
  *    when(mock.someMethod()).thenCallRealMethod();
  *  </pre>
  *  
  * As usual you are going to read <b>the partial mock warning</b>:
  * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.
  * How does partial mock fit into this paradigm? Well, it just doesn't... 
  * Partial mock usually means that the complexity has been moved to a different method on the same object.
  * In most cases, this is not the way you want to design your application.
  * <p>
  * However, there are rare cases when partial mocks come handy: 
  * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
  * However, I wouldn't use partial mocks for new, test-driven & well-designed code.
  *  
  * <h3 id=""17"">17. Resetting mocks (Since 1.8.0) </h3>
  *  
  * Smart Mockito users hardly use this feature because they know it could be a sign of poor tests.
  * Normally, you don't need to reset your mocks, just create new mocks for each test method. 
  * <p>
  * Instead of reset() please consider writing simple, small and focused test methods over lengthy, over-specified tests.
  * <b>First potential code smell is reset() in the middle of the test method.</b> This probably means you're testing too much.
  * Follow the whisper of your test methods: ""Please keep us small & focused on single behavior"". 
  * There are several threads about it on mockito mailing list.
  * <p>
  * The only reason we added reset() method is to
  * make it possible to work with container-injected mocks.
  * See issue 55 (<a href=""http://code.google.com/p/mockito/issues/detail?id=55"">here</a>)
  * or FAQ (<a href=""http://code.google.com/p/mockito/wiki/FAQ"">here</a>).
  * <p>
  * <b>Don't harm yourself.</b> reset() in the middle of the test method is a code smell (you're probably testing too much). 
  * <pre>
  *   List mock = mock(List.class);
  *   when(mock.size()).thenReturn(10);
  *   mock.add(1);
  *   
  *   reset(mock);
  *   //at this point the mock forgot any interactions & stubbing
  * </pre>
  *  
  * <h3 id=""18"">18. Troubleshooting & validating framework usage (Since 1.8.0) </h3>
  * 
  * First of all, in case of any trouble, I encourage you to read the Mockito FAQ: 
  * <a href=""http://code.google.com/p/mockito/wiki/FAQ"">http://code.google.com/p/mockito/wiki/FAQ</a>
  * <p>
  * In case of questions you may also post to mockito mailing list: 
  * <a href=""http://groups.google.com/group/mockito"">http://groups.google.com/group/mockito</a>
  * <p>
  * Next, you should know that Mockito validates if you use it correctly <b>all the time</b>. 
  * However, there's a gotcha so please read the javadoc for {@link Mockito#validateMockitoUsage()}
  * 
  * <h3 id=""19"">19. Aliases for behavior driven development (Since 1.8.0) </h3>
  * 
  * Behavior Driven Development style of writing tests uses <b>//given //when //then</b> comments as fundamental parts of your test methods.
  * This is exactly how we write our tests and we warmly encourage you to do so!
  * <p>
  * Start learning about BDD here: <a href=""http://en.wikipedia.org/wiki/Behavior_Driven_Development"">http://en.wikipedia.org/wiki/Behavior_Driven_Development</a>
  * <p>
  * The problem is that current stubbing api with canonical role of <b>when</b> word does not integrate nicely with <b>//given //when //then</b> comments.
  * It's because stubbing belongs to <b>given</b> component of the test and not to the <b>when</b> component of the test. 
  * Hence {@link BDDMockito} class introduces an alias so that you stub method calls with {@link BDDMockito#given(Object)} method. 
  * Now it really nicely integrates with the <b>given</b> component of a BDD style test!  
  * <p>
  * Here is how the test might look like: 
  * <pre>
  * import static org.mockito.BDDMockito.*;
  * 
  * Seller seller = mock(Seller.class);
  * Shop shop = new Shop(seller);
  * 
  * public void shouldBuyBread() throws Exception {
  *   //given  
  *   given(seller.askForBread()).willReturn(new Bread());
  *   
  *   //when
  *   Goods goods = shop.buyBread();
  *   
  *   //then
  *   assertThat(goods, containBread());
  * }  
  * </pre>
  * 
  * <h3 id=""20"">20. (**New**) Serializable mocks (Since 1.8.1) </h3>
  * 
  * Mocks can be made serializable. With this feature you can use a mock in a place that requires dependencies to be serializable.
  * <p>
  * WARNING: This should be rarely used in unit testing. 
  * <p>
  * The behaviour was implemented for a specific use case of a BDD spec that had an unreliable external dependency.  This
  * was in a web environment and the objects from the external dependency were being serialized to pass between layers. 
  * <p>
  * To create serializable mock use {@link MockSettings#serializable()}:
  * <pre>
  *   List serializableMock = mock(List.class, withSettings().serializable());
  * </pre>
  * <p>
  * The mock can be serialized assuming all the normal <a href='http://java.sun.com/j2se/1.5.0/docs/api/java/io/Serializable.html'>
  * serialization requirements</a> are met by the class.
  * <p>
  * Making a real object spy serializable is a bit more effort as the spy(...) method does not have an overloaded version 
  * which accepts MockSettings. No worries, you will hardly ever use it.
  * 
  * <pre>
  * List<Object> list = new ArrayList<Object>();
  * List<Object> spy = mock(ArrayList.class, withSettings()
  *                 .spiedInstance(list)
  *                 .defaultAnswer(CALLS_REAL_METHODS)
  *                 .serializable());
  * </pre>
  */
 @SuppressWarnings(""unchecked"")
 public class Mockito extends Matchers {
     
     private static final MockitoCore MOCKITO_CORE = new MockitoCore();
     
     /**
      * The default Answer of every mock <b>if</b> the mock was not stubbed. 
      * Typically it just returns some empty value. 
      * <p>
      * {@link Answer} can be used to define the return values of unstubbed invocations. 
      * <p>
      * This implementation first tries the global configuration. 
      * If there is no global configuration then it uses {@link ReturnsEmptyValues} (returns zeros, empty collections, nulls, etc.)
      */
     public static final Answer<Object> RETURNS_DEFAULTS = new GloballyConfiguredAnswer();
     
     /**
      * Optional Answer to be used with {@link Mockito#mock(Class, Answer)}
      * <p>
      * {@link Answer} can be used to define the return values of unstubbed invocations.
      * <p>
      * This implementation can be helpful when working with legacy code.
      * Unstubbed methods often return null. If your code uses the object returned by an unstubbed call you get a NullPointerException.
      * This implementation of Answer <b>returns SmartNull instead of null</b>.
      * SmartNull gives nicer exception message than NPE because it points out the line where unstubbed method was called. You just click on the stack trace.
      * <p>
      * ReturnsSmartNulls first tries to return ordinary return values (see {@link ReturnsMoreEmptyValues})
      * then it tries to return SmartNull. If the return type is final then plain null is returned.
      * <p>
      * ReturnsSmartNulls will be probably the default return values strategy in Mockito 2.0
      * <p>
      * Example:
      * <pre>
      *   Foo mock = (Foo.class, RETURNS_SMART_NULLS);
      *   
      *   //calling unstubbed method here:
      *   Stuff stuff = mock.getStuff();
      *   
      *   //using object returned by unstubbed call:
      *   stuff.doSomething();
      *   
      *   //Above doesn't yield NullPointerException this time!
      *   //Instead, SmartNullPointerException is thrown. 
      *   //Exception's cause links to unstubbed <i>mock.getStuff()</i> - just click on the stack trace.  
      * </pre>
      */
     public static final Answer<Object> RETURNS_SMART_NULLS = new ReturnsSmartNulls();
     
     /**
      * Optional Answer to be used with {@link Mockito#mock(Class, Answer)}
      * <p>
      * {@link Answer} can be used to define the return values of unstubbed invocations.
      * <p>
      * This implementation can be helpful when working with legacy code. 
      * <p>
      * ReturnsMocks first tries to return ordinary return values (see {@link ReturnsMoreEmptyValues})
      * then it tries to return mocks. If the return type cannot be mocked (e.g. is final) then plain null is returned.
      * <p>
      */
     public static final Answer<Object> RETURNS_MOCKS = new ReturnsMocks();
 
     /**
      * Optional Answer to be used with {@link Mockito#mock(Class, Answer)}
      * <p>
      * {@link Answer} can be used to define the return values of unstubbed invocations.
      * <p>
      * This implementation can be helpful when working with legacy code.
      * When this implementation is used, unstubbed methods will delegate to the real implementation.
      * This is a way to create a partial mock object that calls real methods by default.
      * <p>
      * As usual you are going to read <b>the partial mock warning</b>:
      * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.
      * How does partial mock fit into this paradigm? Well, it just doesn't... 
      * Partial mock usually means that the complexity has been moved to a different method on the same object.
      * In most cases, this is not the way you want to design your application.
      * <p>
      * However, there are rare cases when partial mocks come handy: 
      * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
      * However, I wouldn't use partial mocks for new, test-driven & well-designed code.
      * <p>
      * Example:
      * <pre>
      * Foo mock = mock(Foo.class, CALLS_REAL_METHODS);
      *
      * // this calls the real implementation of Foo.getSomething()
      * value = mock.getSomething();
      *
      * when(mock.getSomething()).thenReturn(fakeValue);
      *
      * // now fakeValue is returned
      * value = mock.getSomething();
      * </pre>
      */
     public static final Answer<Object> CALLS_REAL_METHODS = new CallsRealMethods();
     
     /**
      * Creates mock object of given class or interface.
      * <p>
      * See examples in javadoc for {@link Mockito} class
      * 
      * @param classToMock class or interface to mock
      * @return mock object
      */
     public static <T> T mock(Class<T> classToMock) {
         return mock(classToMock, withSettings().defaultAnswer(RETURNS_DEFAULTS));
     }
     
     /**
      * Specifies mock name. Naming mocks can be helpful for debugging - the name is used in all verification errors. 
      * <p>
      * Beware that naming mocks is not a solution for complex code which uses too many mocks or collaborators. 
      * <b>If you have too many mocks then refactor the code</b> so that it's easy to test/debug without necessity of naming mocks.
      * <p>
      * <b>If you use &#064;Mock annotation then you've got naming mocks for free!</b> &#064;Mock uses field name as mock name. {@link Mock Read more.}
      * <p>
      * 
      * See examples in javadoc for {@link Mockito} class
      * 
      * @param classToMock class or interface to mock
      * @param name of the mock 
      * @return mock object
      */
     public static <T> T mock(Class<T> classToMock, String name) {
         return mock(classToMock, withSettings()
                 .name(name)
                 .defaultAnswer(RETURNS_DEFAULTS));
     }
     
     /**
      * @deprecated
      * <b>Please use mock(Foo.class, defaultAnswer);</b>
      * <p>
      * See {@link Mockito#mock(Class, Answer)}
      * <p>
      * Why it is deprecated? ReturnValues is being replaced by Answer
      * for better consistency & interoperability of the framework. 
      * Answer interface has been in Mockito for a while and it has the same responsibility as ReturnValues.
      * There's no point in mainting exactly the same interfaces.
      * <p>
      * Creates mock with a specified strategy for its return values. 
      * It's quite advanced feature and typically you don't need it to write decent tests.
      * However it can be helpful when working with legacy systems.
      * <p>
      * Obviously return values are used only when you don't stub the method call.
      *
      * <pre>
      *   Foo mock = mock(Foo.class, Mockito.RETURNS_SMART_NULLS);
      *   Foo mockTwo = mock(Foo.class, new YourOwnReturnValues()); 
      * </pre>
      * 
      * <p>See examples in javadoc for {@link Mockito} class</p>
      * 
      * @param classToMock class or interface to mock
      * @param returnValues default return values for unstubbed methods
      *
      * @return mock object
      */
     @Deprecated
     public static <T> T mock(Class<T> classToMock, ReturnValues returnValues) {
         return mock(classToMock, withSettings().defaultAnswer(new AnswerReturnValuesAdapter(returnValues)));
     }
     
     /**
      * Creates mock with a specified strategy for its answers to interactions. 
      * It's quite advanced feature and typically you don't need it to write decent tests.
      * However it can be helpful when working with legacy systems.
      * <p>
      * It is the default answer so it will be used <b>only when you don't</b> stub the method call.
      *
      * <pre>
      *   Foo mock = mock(Foo.class, RETURNS_SMART_NULLS);
      *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer()); 
      * </pre>
      * 
      * <p>See examples in javadoc for {@link Mockito} class</p>
      * 
      * @param classToMock class or interface to mock
      * @param defaultAnswer default answer for unstubbed methods
      *
      * @return mock object
      */
     public static <T> T mock(Class<T> classToMock, Answer defaultAnswer) {
         return mock(classToMock, withSettings().defaultAnswer(defaultAnswer));
     }
     
     /**
      * Creates a mock with some non-standard settings.
      * <p>
      * The number of configuration points for a mock grows 
      * so we need a fluent way to introduce new configuration without adding more and more overloaded Mockito.mock() methods. 
      * Hence {@link MockSettings}.
      * <pre>
      *   Listener mock = mock(Listener.class, withSettings()
      *     .name(""firstListner"").defaultBehavior(RETURNS_SMART_NULLS));
      *   );  
      * </pre>
      * <b>Use it carefully and occasionally</b>. What might be reason your test needs non-standard mocks? 
      * Is the code under test so complicated that it requires non-standard mocks? 
      * Wouldn't you prefer to refactor the code under test so it is testable in a simple way?
      * <p>
      * See also {@link Mockito#withSettings()}
      * <p>
      * See examples in javadoc for {@link Mockito} class
      * 
      * @param classToMock class or interface to mock
      * @param mockSettings additional mock settings
      * @return mock object
      */
     public static <T> T mock(Class<T> classToMock, MockSettings mockSettings) {
      return MOCKITO_CORE.mock(classToMock, mockSettings);
     }
     
     /**
      * Creates a spy of the real object. The spy calls <b>real</b> methods unless they are stubbed.
      * <p>
      * Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.
      * <p>
      * As usual you are going to read <b>the partial mock warning</b>:
      * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.
      * How does partial mock fit into this paradigm? Well, it just doesn't... 
      * Partial mock usually means that the complexity has been moved to a different method on the same object.
      * In most cases, this is not the way you want to design your application.
      * <p>
      * However, there are rare cases when partial mocks come handy: 
      * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
      * However, I wouldn't use partial mocks for new, test-driven & well-designed code.
      * <p>
      * Example:
      * 
      * <pre>
      *   List list = new LinkedList();
      *   List spy = spy(list);
      * 
      *   //optionally, you can stub out some methods:
      *   when(spy.size()).thenReturn(100);
      * 
      *   //using the spy calls <b>real</b> methods
      *   spy.add(""one"");
      *   spy.add(""two"");
      * 
      *   //prints ""one"" - the first element of a list
      *   System.out.println(spy.get(0));
      * 
      *   //size() method was stubbed - 100 is printed
      *   System.out.println(spy.size());
      * 
      *   //optionally, you can verify
      *   verify(spy).add(""one"");
      *   verify(spy).add(""two"");
      * </pre>
      * 
      * <h4>Important gotcha on spying real objects!</h4>
      * 
      * 1. Sometimes it's impossible to use {@link Mockito#when(Object)} for stubbing spies. Example:
      * 
      * <pre>
      *   List list = new LinkedList();
      *   List spy = spy(list);
      *   
      *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)
      *   when(spy.get(0)).thenReturn(""foo"");
      *   
      *   //You have to use doReturn() for stubbing
      *   doReturn(""foo"").when(spy).get(0);
      * </pre>
      * 
      * 2. Watch out for final methods. 
      * Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.
      * What will happen is the real method will be called *on mock* but *not on the real instance* you passed to the spy() method.
      * Typically you may get a NullPointerException because mock instances don't have fields initiated.
      * 
      * <p>
      * See examples in javadoc for {@link Mockito} class
      * 
      * @param object
      *            to spy on
      * @return a spy of the real object
      */
     public static <T> T spy(T object) {
         return MOCKITO_CORE.mock((Class<T>) object.getClass(), withSettings()
                 .spiedInstance(object)
              .defaultAnswer(CALLS_REAL_METHODS)); 
     }
 
     /**
      * <pre>
      *   //Instead of:
      *   stub(mock.count()).toReturn(10);
      * 
      *   //Please do:
      *   when(mock.count()).thenReturn(10);
      * </pre> 
      * 
      * Many users found stub() confusing therefore stub() has been deprecated in favor of {@link Mockito#when(Object)} 
      * <p>
      * How to fix deprecation warnings? Typically it's just few minutes of search & replace job:
      * <pre>
      *   Mockito.stub;  <i>replace with:</i>  Mockito.when;
      *   stub(          <i>replace with:</i>  when(
      *   .toReturn(     <i>replace with:</i>  .thenReturn(
      *   .toThrow(      <i>replace with:</i>  .thenThrow(
      *   .toAnswer(     <i>replace with:</i>  .thenAnswer(
      * </pre>
      * If you're an existing user then sorry for making your code littered with deprecation warnings. 
/src/org/mockito/internal/MockitoCore.java @@ -1,38 +1,39 @@
 /*
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
 package org.mockito.internal;
 
 import org.mockito.InOrder;
 import org.mockito.MockSettings;
 import org.mockito.exceptions.Reporter;
 import org.mockito.exceptions.misusing.NotAMockException;
 import org.mockito.internal.creation.MockSettingsImpl;
 import org.mockito.internal.invocation.Invocation;
 import org.mockito.internal.progress.IOngoingStubbing;
 import org.mockito.internal.progress.MockingProgress;
 import org.mockito.internal.progress.ThreadSafeMockingProgress;
 import org.mockito.internal.stubbing.OngoingStubbingImpl;
 import org.mockito.internal.stubbing.StubberImpl;
 import org.mockito.internal.util.MockUtil;
 import org.mockito.internal.verification.api.VerificationMode;
 import org.mockito.stubbing.*;
 
 import java.util.Arrays;
 import java.util.List;
 
 @SuppressWarnings(""unchecked"")
 public class MockitoCore {
 
     private final Reporter reporter = new Reporter();
     private final MockUtil mockUtil = new MockUtil();
     private final MockingProgress mockingProgress = new ThreadSafeMockingProgress();
     
  public <T> T mock(Class<T> classToMock, MockSettings mockSettings, boolean shouldResetOngoingStubbing) { return mock(classToMock, mockSettings); }
  public <T> T mock(Class<T> classToMock, MockSettings mockSettings) {
         mockingProgress.validateState();
             mockingProgress.resetOngoingStubbing();
         return mockUtil.createMock(classToMock, (MockSettingsImpl) mockSettings);
     }
     
","@@ -1,921 +1,921 @@
 /*
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
 package org.mockito;
 
 import org.mockito.internal.MockitoCore;
 import org.mockito.internal.creation.MockSettingsImpl;
 import org.mockito.internal.debugging.MockitoDebuggerImpl;
 import org.mockito.internal.stubbing.answers.*;
 import org.mockito.internal.stubbing.defaultanswers.*;
 import org.mockito.internal.verification.VerificationModeFactory;
 import org.mockito.internal.verification.api.VerificationMode;
 import org.mockito.runners.MockitoJUnitRunner;
 import org.mockito.stubbing.*;
 
 /**
  * <p align=""left""><img src=""logo.jpg""/></p>
  * Mockito library enables mocks creation, verification and stubbing.
  * <p>
  * This javadoc content is also available on the <a href=""http://mockito.org"">http://mockito.org</a> web page. 
  * All documentation is kept in javadocs because it guarantees consistency between what's on the web and what's in the source code.
  * Also, it makes possible to access documentation straight from the IDE even if you work offline.   
  * 
  * <h1>Contents</h1>
  * 
  * <b> 
  *      <a href=""#1"">1. Let's verify some behaviour! </a><br/> 
  *      <a href=""#2"">2. How about some stubbing? </a><br/>
  *      <a href=""#3"">3. Argument matchers </a><br/>
  *      <a href=""#4"">4. Verifying exact number of invocations / at least once / never </a><br/> 
  *      <a href=""#5"">5. Stubbing void methods with exceptions </a><br/> 
  *      <a href=""#6"">6. Verification in order </a><br/> 
  *      <a href=""#7"">7. Making sure interaction(s) never happened on mock </a><br/> 
  *      <a href=""#8"">8. Finding redundant invocations </a><br/> 
  *      <a href=""#9"">9. Shorthand for mocks creation - &#064;Mock annotation </a><br/> 
  *      <a href=""#10"">10. Stubbing consecutive calls (iterator-style stubbing) </a><br/> 
  *      <a href=""#11"">11. Stubbing with callbacks </a><br/>
  *      <a href=""#12"">12. doThrow()|doAnswer()|doNothing()|doReturn() family of methods mostly for stubbing voids </a><br/>
  *      <a href=""#13"">13. Spying on real objects </a><br/>
  *      <a href=""#14"">14. Changing default return values of unstubbed invocations (Since 1.7) </a><br/>
  *      <a href=""#15"">15. Capturing arguments for further assertions (Since 1.8.0) </a><br/>
  *      <a href=""#16"">16. Real partial mocks (Since 1.8.0) </a><br/>
  *      <a href=""#17"">17. Resetting mocks (Since 1.8.0) </a><br/>
  *      <a href=""#18"">18. Troubleshooting & validating framework usage (Since 1.8.0) </a><br/>
  *      <a href=""#19"">19. Aliases for behavior driven development (Since 1.8.0) </a><br/>
  *      <a href=""#20"">20. (**New**) Serializable mocks (Since 1.8.1) </a><br/>
  * </b>
  * 
  * <p>
  * Following examples mock a List, because everyone knows its interface (methods
  * like add(), get(), clear() will be used). <br>
  * You probably wouldn't mock List class 'in real'.
  * 
  * <h3 id=""1"">1. Let's verify some behaviour!</h3>
  * 
  * <pre>
  * //Let's import Mockito statically so that the code looks clearer
  * import static org.mockito.Mockito.*;
  * 
  * //mock creation
  * List mockedList = mock(List.class);
  *
  * //using mock object
  * mockedList.add(""one"");
  * mockedList.clear();
  *
  * //verification
  * verify(mockedList).add(""one"");
  * verify(mockedList).clear();
  * </pre>
  * 
  * <p>
  * Once created, mock will remember all interactions. Then you can selectively
  * verify whatever interaction you are interested in.
  * 
  * <h3 id=""2"">2. How about some stubbing?</h3>
  * 
  * <pre>
  * //You can mock concrete classes, not only interfaces
  * LinkedList mockedList = mock(LinkedList.class);
  * 
  * //stubbing
  * when(mockedList.get(0)).thenReturn(""first"");
  * when(mockedList.get(1)).thenThrow(new RuntimeException());
  * 
  * //following prints ""first""
  * System.out.println(mockedList.get(0));
  * 
  * //following throws runtime exception
  * System.out.println(mockedList.get(1));
  * 
  * //following prints ""null"" because get(999) was not stubbed
  * System.out.println(mockedList.get(999));
  *  
  * //Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>
  * //If your code cares what get(0) returns then something else breaks (often before even verify() gets executed).
  * //If your code doesn't care what get(0) returns then it should not be stubbed. Not convinced? See <a href=""http://monkeyisland.pl/2008/04/26/asking-and-telling"">here</a>.
  * verify(mockedList).get(0);
  * </pre>
  * 
  * <ul>
  * <li> By default, for all methods that return value, mock returns null, an
  * empty collection or appropriate primitive/primitive wrapper value (e.g: 0,
  * false, ... for int/Integer, boolean/Boolean, ...). </li>
  * 
  * <li> Stubbing can be overridden: for example common stubbing can go to
  * fixture setup but the test methods can override it.
  * Please note that overridding stubbing is a potential code smell that points out too much stubbing</li>
  * 
  * <li> Once stubbed, the method will always return stubbed value regardless
  * of how many times it is called. </li>
  * 
  * <li> Last stubbing is more important - when you stubbed the same method with
  * the same arguments many times. </li>
  * 
  * </ul>
  * 
  * <h3 id=""3"">3. Argument matchers</h3>
  * 
  * Mockito verifies argument values in natural java style: by using an equals() method.
  * Sometimes, when extra flexibility is required then you might use argument matchers:  
  * 
  * <pre>
  * //stubbing using built-in anyInt() argument matcher
  * when(mockedList.get(anyInt())).thenReturn(""element"");
  * 
  * //stubbing using hamcrest (let's say isValid() returns your own hamcrest matcher):
  * when(mockedList.contains(argThat(isValid()))).thenReturn(""element"");
  * 
  * //following prints ""element""
  * System.out.println(mockedList.get(999));
  * 
  * //<b>you can also verify using an argument matcher</b>
  * verify(mockedList).get(anyInt());
  * </pre>
  * 
  * <p>
  * Argument matchers allow flexible verification or stubbing. 
  * {@link Matchers Click here to see} more built-in matchers 
  * and examples of <b>custom argument matchers / hamcrest matchers</b>.
  * <p>
  * For information solely on <b>custom argument matchers</b> check out javadoc for {@link ArgumentMatcher} class.
  * <p>
  * Be reasonable with using complicated argument matching.
  * The natural matching style using equals() with occasional anyX() matchers tend to give clean & simple tests.
  * Sometimes it's just better to refactor the code to allow equals() matching or even implement equals() method to help out with testing.
  * <p>
  * Also, read <a href=""#15"">section 15</a> or javadoc for {@link ArgumentCaptor} class.
  * {@link ArgumentCaptor} is a special implementation of an argument matcher that captures argument values for further assertions.  
  * <p>
  * <b>Warning on argument matchers:</b>
  * <p>
  * If you are using argument matchers, <b>all arguments</b> have to be provided
  * by matchers.
  * <p>
  * E.g: (example shows verification but the same applies to stubbing):
  * 
  * <pre>
  *   verify(mock).someMethod(anyInt(), anyString(), <b>eq(""third argument"")</b>);
  *   //above is correct - eq() is also an argument matcher
  *   
  *   verify(mock).someMethod(anyInt(), anyString(), <b>""third argument""</b>);
  *   //above is incorrect - exception will be thrown because third argument is given without an argument matcher.
  * </pre>
  * 
  * <h3 id=""4"">4. Verifying exact number of invocations / at least x / never</h3>
  * 
  * <pre>
  * //using mock 
  * mockedList.add(""once"");
  * 
  * mockedList.add(""twice"");
  * mockedList.add(""twice"");
  * 
  * mockedList.add(""three times"");
  * mockedList.add(""three times"");
  * mockedList.add(""three times"");
  * 
  * //following two verifications work exactly the same - times(1) is used by default
  * verify(mockedList).add(""once"");
  * verify(mockedList, times(1)).add(""once"");
  * 
  * //exact number of invocations verification
  * verify(mockedList, times(2)).add(""twice"");
  * verify(mockedList, times(3)).add(""three times"");
  * 
  * //verification using never(). never() is an alias to times(0)
  * verify(mockedList, never()).add(""never happened"");
  * 
  * //verification using atLeast()/atMost()
  * verify(mockedList, atLeastOnce()).add(""three times"");
  * verify(mockedList, atLeast(2)).add(""five times"");
  * verify(mockedList, atMost(5)).add(""three times"");
  * 
  * </pre>
  * 
  * <p>
  * <b>times(1) is the default.</b> Therefore using times(1) explicitly can be
  * omitted.
  * 
  * <h3 id=""5"">5. Stubbing void methods with exceptions</h3>
  * 
  * <pre>
  *   doThrow(new RuntimeException()).when(mockedList).clear();
  *   
  *   //following throws RuntimeException:
  *   mockedList.clear();
  * </pre>
  * 
  * Read more about doThrow|doAnswer family of methods in paragraph 12.
  * <p>
  * Initially, {@link Mockito#stubVoid(Object)} was used for stubbing voids.
  * Currently stubVoid() is deprecated in favor of {@link Mockito#doThrow(Throwable)}.
  * This is because of improved readability and consistency with the family of {@link Mockito#doAnswer(Answer)} methods. 
  * 
  * <h3 id=""6"">6. Verification in order</h3>
  * 
  * <pre>
  * List firstMock = mock(List.class);
  * List secondMock = mock(List.class);
  * 
  * //using mocks
  * firstMock.add(""was called first"");
  * secondMock.add(""was called second"");
  * 
  * //create inOrder object passing any mocks that need to be verified in order
  * InOrder inOrder = inOrder(firstMock, secondMock);
  * 
  * //following will make sure that firstMock was called before secondMock
  * inOrder.verify(firstMock).add(""was called first"");
  * inOrder.verify(secondMock).add(""was called second"");
  * </pre>
  * 
  * Verification in order is flexible - <b>you don't have to verify all
  * interactions</b> one-by-one but only those that you are interested in
  * testing in order.
  * <p>
  * Also, you can create InOrder object passing only mocks that are relevant for
  * in-order verification.
  * 
  * <h3 id=""7"">7. Making sure interaction(s) never happened on mock</h3>
  * 
  * <pre>
  * //using mocks - only mockOne is interacted
  * mockOne.add(""one"");
  * 
  * //ordinary verification
  * verify(mockOne).add(""one"");
  * 
  * //verify that method was never called on a mock
  * verify(mockOne, never()).add(""two"");
  * 
  * //verify that other mocks were not interacted
  * verifyZeroInteractions(mockTwo, mockThree);
  * 
  * </pre>
  * 
  * <h3 id=""8"">8. Finding redundant invocations</h3>
  * 
  * <pre>
  * //using mocks
  * mockedList.add(""one"");
  * mockedList.add(""two"");
  * 
  * verify(mockedList).add(""one"");
  * 
  * //following verification will fail 
  * verifyNoMoreInteractions(mockedList);
  * </pre>
  * 
  * A word of <b>warning</b>: 
  * Some users who did a lot of classic, expect-run-verify mocking tend to use verifyNoMoreInteractions() very often, even in every test method. 
  * verifyNoMoreInteractions() is not recommended to use in every test method. 
  * verifyNoMoreInteractions() is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.
  * Abusing it leads to overspecified, less maintainable tests. You can find further reading 
  * <a href=""http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/"">here</a>.
  * 
  * <p>   
  * See also {@link Mockito#never()} - it is more explicit and
  * communicates the intent well.
  * <p>
  * 
  * <h3 id=""9"">9. Shorthand for mocks creation - &#064;Mock annotation</h3>
  * 
  * <ul>
  * <li>Minimizes repetitive mock creation code.</li>
  * <li>Makes the test class more readable.</li>
  * <li>Makes the verification error easier to read because the <b>field name</b>
  * is used to identify the mock.</li>
  * </ul>
  * 
  * <pre>
  *   public class ArticleManagerTest { 
  *     
  *       &#064;Mock private ArticleCalculator calculator;
  *       &#064;Mock private ArticleDatabase database;
  *       &#064;Mock private UserProvider userProvider;
  *     
  *       private ArticleManager manager;
  * </pre>
  * 
  * <b>Important!</b> This needs to be somewhere in the base class or a test
  * runner:
  * 
  * <pre>
  * MockitoAnnotations.initMocks(testClass);
  * </pre>
  * 
  * You can use built-in runner: {@link MockitoJUnitRunner}.
  * <p>
  * Read more here: {@link MockitoAnnotations}
  * 
  * <h3 id=""10""> 10. Stubbing consecutive calls (iterator-style stubbing)</h3>
  * 
  * Sometimes we need to stub with different return value/exception for the same
  * method call. Typical use case could be mocking iterators. 
  * Original version of Mockito did not have this feature to promote simple mocking. 
  * For example, instead of iterators one could use {@link Iterable} or simply
  * collections. Those offer natural ways of stubbing (e.g. using real
  * collections). In rare scenarios stubbing consecutive calls could be useful,
  * though:
  * <p>
  * 
  * <pre>
  * when(mock.someMethod(""some arg""))
  *   .thenThrow(new RuntimeException())
  *   .thenReturn(""foo"");
  * 
  * //First call: throws runtime exception:
  * mock.someMethod(""some arg"");
  * 
  * //Second call: prints ""foo""
  * System.out.println(mock.someMethod(""some arg""));
  * 
  * //Any consecutive call: prints ""foo"" as well (last stubbing wins). 
  * System.out.println(mock.someMethod(""some arg""));
  * </pre>
  * 
  * Alternative, shorter version of consecutive stubbing:
  * 
  * <pre>
  * when(mock.someMethod(""some arg""))
  *   .thenReturn(""one"", ""two"", ""three"");
  * </pre>
  * 
  * <h3 id=""11""> 11. Stubbing with callbacks</h3>
  * 
  * Allows stubbing with generic {@link Answer} interface.
 *  <p>
  * Yet another controversial feature which was not included in Mockito
  * originally. We recommend using simple stubbing with thenReturn() or
  * thenThrow() only. Those two should be <b>just enough</b> to test/test-drive
  * any clean & simple code.
  * 
  * <pre>
  * when(mock.someMethod(anyString())).thenAnswer(new Answer() {
  *     Object answer(InvocationOnMock invocation) {
  *         Object[] args = invocation.getArguments();
  *         Object mock = invocation.getMock();
  *         return ""called with arguments: "" + args;
  *     }
  * });
  * 
  * //Following prints ""called with arguments: foo""
  * System.out.println(mock.someMethod(""foo""));
  * </pre>
  * 
  * <h3 id=""12""> 12. doThrow()|doAnswer()|doNothing()|doReturn() family of methods for stubbing voids (mostly)</h3>
  * 
  * Stubbing voids requires different approach from {@link Mockito#when(Object)} because the compiler does not like void methods inside brackets...
  * <p>
  * {@link Mockito#doThrow(Throwable)} replaces the {@link Mockito#stubVoid(Object)} method for stubbing voids. 
  * The main reason is improved readability and consistency with the family of doAnswer() methods.
  * <p>
  * Use doThrow() when you want to stub a void method with an exception:
  * <pre>
  *   doThrow(new RuntimeException()).when(mockedList).clear();
  *   
  *   //following throws RuntimeException:
  *   mockedList.clear();
  * </pre>
  * 
  * Read more about other methods:
  * <p>
  * {@link Mockito#doThrow(Throwable)}
  * <p>
  * {@link Mockito#doAnswer(Answer)}
  * <p>
  * {@link Mockito#doNothing()}
  * <p>
  * {@link Mockito#doReturn(Object)}
  * 
  * <h3 id=""13""> 13. Spying on real objects</h3>
  * 
  * You can create spies of real objects. When you use the spy then the <b>real</b> methods are called (unless a method was stubbed).
  * <p>
  * Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.
  * 
  * <p>
  * Spying on real objects can be associated with ""partial mocking"" concept. 
  * <b>Before the release 1.8</b>, Mockito spies were not real partial mocks. 
  * The reason was we thought partial mock is a code smell. 
  * At some point we found legitimate use cases for partial mocks 
  * (3rd party interfaces, interim refactoring of legacy code, the full article is <a href=
  * ""http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring""
  * >here</a>)
  * <p>
  *
  * <pre>
  *   List list = new LinkedList();
  *   List spy = spy(list);
  * 
  *   //optionally, you can stub out some methods:
  *   when(spy.size()).thenReturn(100);
  * 
  *   //using the spy calls <b>real</b> methods
  *   spy.add(""one"");
  *   spy.add(""two"");
  * 
  *   //prints ""one"" - the first element of a list
  *   System.out.println(spy.get(0));
  * 
  *   //size() method was stubbed - 100 is printed
  *   System.out.println(spy.size());
  * 
  *   //optionally, you can verify
  *   verify(spy).add(""one"");
  *   verify(spy).add(""two"");
  * </pre>
  * 
  * <h4>Important gotcha on spying real objects!</h4>
  * 
  * 1. Sometimes it's impossible to use {@link Mockito#when(Object)} for stubbing spies. Example:
  * 
  * <pre>
  *   List list = new LinkedList();
  *   List spy = spy(list);
  *   
  *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)
  *   when(spy.get(0)).thenReturn(""foo"");
  *   
  *   //You have to use doReturn() for stubbing
  *   doReturn(""foo"").when(spy).get(0);
  * </pre>
  * 
  * 2. Watch out for final methods. 
  * Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.
  * What will happen is the real method will be called *on mock* but *not on the real instance* you passed to the spy() method.
  * Typically you may get a NullPointerException because mock instances don't have fields initiated.
  * 
  * <h3 id=""14"">14. Changing default return values of unstubbed invocations (Since 1.7) </h3>
  * 
  * You can create a mock with specified strategy for its return values.
  * It's quite advanced feature and typically you don't need it to write decent tests.
  * However, it can be helpful for working with <b>legacy systems</b>.
  * <p>
  * It is the default answer so it will be used <b>only when you don't</b> stub the method call.
  * 
  * <pre>
  *   Foo mock = mock(Foo.class, Mockito.RETURNS_SMART_NULLS);
  *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer()); 
  * </pre>
  * 
  * <p>
  * Read more about this interesting implementation of <i>Answer</i>: {@link Mockito#RETURNS_SMART_NULLS}
  * 
  * <h3 id=""15"">15. Capturing arguments for further assertions (Since 1.8.0) </h3>
  * 
  * Mockito verifies argument values in natural java style: by using an equals() method.
  * This is also the recommended way of matching arguments because it makes tests clean & simple.
  * In some situations though, it is helpful to assert on certain arguments after the actual verification.
  * For example:
  * <pre>
  *   ArgumentCaptor&lt;Person&gt; argument = ArgumentCaptor.forClass(Person.class);
  *   verify(mock).doSomething(argument.capture());
  *   assertEquals(""John"", argument.getValue().getName());
  * </pre>
  * 
  * <b>Warning:</b> it is recommended to use ArgumentCaptor with verification <b>but not</b> with stubbing.
  * Using ArgumentCaptor with stubbing may decrease test readability because captor is created outside of assert (aka verify or 'then') block.
  * Also it may reduce defect localization because if stubbed method was not called then no argument is captured.
  * <p>
  * In a way ArgumentCaptor is related to custom argument matchers (see javadoc for {@link ArgumentMatcher} class).
  * Both techniques can be used for making sure certain arguments where passed to mocks. 
  * However, ArgumentCaptor may be a better fit if:
  * <ul>  
  * <li>custom argument matcher is not likely to be reused</li>
  * <li>you just need it to assert on argument values to complete verification</li>
  * </ul>
  * Custom argument matchers via {@link ArgumentMatcher} are usually better for stubbing.
  * 
  * <h3 id=""16"">16. Real partial mocks (Since 1.8.0) </h3>
  *  
  *  Finally, after many internal debates & discussions on the mailing list, partial mock support was added to Mockito.
  *  Previously we considered partial mocks as code smells. However, we found a legitimate use case for partial mocks - more reading:
  *  <a href=""http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring"">here</a>
  *  <p>
  *  <b>Before release 1.8</b> spy() was not producing real partial mocks and it was confusing for some users.
  *  Read more about spying: <a href=""#13"">here</a> or in javadoc for {@link Mockito#spy(Object)} method. 
  *  <p>
  *  <pre>
  *    //you can create partial mock with spy() method:    
  *    List list = spy(new LinkedList());
  *    
  *    //you can enable partial mock capabilities selectively on mocks:
  *    Foo mock = mock(Foo.class);
  *    //Be sure the real implementation is 'safe'.
  *    //If real implementation throws exceptions or depends on specific state of the object then you're in trouble.
  *    when(mock.someMethod()).thenCallRealMethod();
  *  </pre>
  *  
  * As usual you are going to read <b>the partial mock warning</b>:
  * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.
  * How does partial mock fit into this paradigm? Well, it just doesn't... 
  * Partial mock usually means that the complexity has been moved to a different method on the same object.
  * In most cases, this is not the way you want to design your application.
  * <p>
  * However, there are rare cases when partial mocks come handy: 
  * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
  * However, I wouldn't use partial mocks for new, test-driven & well-designed code.
  *  
  * <h3 id=""17"">17. Resetting mocks (Since 1.8.0) </h3>
  *  
  * Smart Mockito users hardly use this feature because they know it could be a sign of poor tests.
  * Normally, you don't need to reset your mocks, just create new mocks for each test method. 
  * <p>
  * Instead of reset() please consider writing simple, small and focused test methods over lengthy, over-specified tests.
  * <b>First potential code smell is reset() in the middle of the test method.</b> This probably means you're testing too much.
  * Follow the whisper of your test methods: ""Please keep us small & focused on single behavior"". 
  * There are several threads about it on mockito mailing list.
  * <p>
  * The only reason we added reset() method is to
  * make it possible to work with container-injected mocks.
  * See issue 55 (<a href=""http://code.google.com/p/mockito/issues/detail?id=55"">here</a>)
  * or FAQ (<a href=""http://code.google.com/p/mockito/wiki/FAQ"">here</a>).
  * <p>
  * <b>Don't harm yourself.</b> reset() in the middle of the test method is a code smell (you're probably testing too much). 
  * <pre>
  *   List mock = mock(List.class);
  *   when(mock.size()).thenReturn(10);
  *   mock.add(1);
  *   
  *   reset(mock);
  *   //at this point the mock forgot any interactions & stubbing
  * </pre>
  *  
  * <h3 id=""18"">18. Troubleshooting & validating framework usage (Since 1.8.0) </h3>
  * 
  * First of all, in case of any trouble, I encourage you to read the Mockito FAQ: 
  * <a href=""http://code.google.com/p/mockito/wiki/FAQ"">http://code.google.com/p/mockito/wiki/FAQ</a>
  * <p>
  * In case of questions you may also post to mockito mailing list: 
  * <a href=""http://groups.google.com/group/mockito"">http://groups.google.com/group/mockito</a>
  * <p>
  * Next, you should know that Mockito validates if you use it correctly <b>all the time</b>. 
  * However, there's a gotcha so please read the javadoc for {@link Mockito#validateMockitoUsage()}
  * 
  * <h3 id=""19"">19. Aliases for behavior driven development (Since 1.8.0) </h3>
  * 
  * Behavior Driven Development style of writing tests uses <b>//given //when //then</b> comments as fundamental parts of your test methods.
  * This is exactly how we write our tests and we warmly encourage you to do so!
  * <p>
  * Start learning about BDD here: <a href=""http://en.wikipedia.org/wiki/Behavior_Driven_Development"">http://en.wikipedia.org/wiki/Behavior_Driven_Development</a>
  * <p>
  * The problem is that current stubbing api with canonical role of <b>when</b> word does not integrate nicely with <b>//given //when //then</b> comments.
  * It's because stubbing belongs to <b>given</b> component of the test and not to the <b>when</b> component of the test. 
  * Hence {@link BDDMockito} class introduces an alias so that you stub method calls with {@link BDDMockito#given(Object)} method. 
  * Now it really nicely integrates with the <b>given</b> component of a BDD style test!  
  * <p>
  * Here is how the test might look like: 
  * <pre>
  * import static org.mockito.BDDMockito.*;
  * 
  * Seller seller = mock(Seller.class);
  * Shop shop = new Shop(seller);
  * 
  * public void shouldBuyBread() throws Exception {
  *   //given  
  *   given(seller.askForBread()).willReturn(new Bread());
  *   
  *   //when
  *   Goods goods = shop.buyBread();
  *   
  *   //then
  *   assertThat(goods, containBread());
  * }  
  * </pre>
  * 
  * <h3 id=""20"">20. (**New**) Serializable mocks (Since 1.8.1) </h3>
  * 
  * Mocks can be made serializable. With this feature you can use a mock in a place that requires dependencies to be serializable.
  * <p>
  * WARNING: This should be rarely used in unit testing. 
  * <p>
  * The behaviour was implemented for a specific use case of a BDD spec that had an unreliable external dependency.  This
  * was in a web environment and the objects from the external dependency were being serialized to pass between layers. 
  * <p>
  * To create serializable mock use {@link MockSettings#serializable()}:
  * <pre>
  *   List serializableMock = mock(List.class, withSettings().serializable());
  * </pre>
  * <p>
  * The mock can be serialized assuming all the normal <a href='http://java.sun.com/j2se/1.5.0/docs/api/java/io/Serializable.html'>
  * serialization requirements</a> are met by the class.
  * <p>
  * Making a real object spy serializable is a bit more effort as the spy(...) method does not have an overloaded version 
  * which accepts MockSettings. No worries, you will hardly ever use it.
  * 
  * <pre>
  * List<Object> list = new ArrayList<Object>();
  * List<Object> spy = mock(ArrayList.class, withSettings()
  *                 .spiedInstance(list)
  *                 .defaultAnswer(CALLS_REAL_METHODS)
  *                 .serializable());
  * </pre>
  */
 @SuppressWarnings(""unchecked"")
 public class Mockito extends Matchers {
     
     private static final MockitoCore MOCKITO_CORE = new MockitoCore();
     
     /**
      * The default Answer of every mock <b>if</b> the mock was not stubbed. 
      * Typically it just returns some empty value. 
      * <p>
      * {@link Answer} can be used to define the return values of unstubbed invocations. 
      * <p>
      * This implementation first tries the global configuration. 
      * If there is no global configuration then it uses {@link ReturnsEmptyValues} (returns zeros, empty collections, nulls, etc.)
      */
     public static final Answer<Object> RETURNS_DEFAULTS = new GloballyConfiguredAnswer();
     
     /**
      * Optional Answer to be used with {@link Mockito#mock(Class, Answer)}
      * <p>
      * {@link Answer} can be used to define the return values of unstubbed invocations.
      * <p>
      * This implementation can be helpful when working with legacy code.
      * Unstubbed methods often return null. If your code uses the object returned by an unstubbed call you get a NullPointerException.
      * This implementation of Answer <b>returns SmartNull instead of null</b>.
      * SmartNull gives nicer exception message than NPE because it points out the line where unstubbed method was called. You just click on the stack trace.
      * <p>
      * ReturnsSmartNulls first tries to return ordinary return values (see {@link ReturnsMoreEmptyValues})
      * then it tries to return SmartNull. If the return type is final then plain null is returned.
      * <p>
      * ReturnsSmartNulls will be probably the default return values strategy in Mockito 2.0
      * <p>
      * Example:
      * <pre>
      *   Foo mock = (Foo.class, RETURNS_SMART_NULLS);
      *   
      *   //calling unstubbed method here:
      *   Stuff stuff = mock.getStuff();
      *   
      *   //using object returned by unstubbed call:
      *   stuff.doSomething();
      *   
      *   //Above doesn't yield NullPointerException this time!
      *   //Instead, SmartNullPointerException is thrown. 
      *   //Exception's cause links to unstubbed <i>mock.getStuff()</i> - just click on the stack trace.  
      * </pre>
      */
     public static final Answer<Object> RETURNS_SMART_NULLS = new ReturnsSmartNulls();
     
     /**
      * Optional Answer to be used with {@link Mockito#mock(Class, Answer)}
      * <p>
      * {@link Answer} can be used to define the return values of unstubbed invocations.
      * <p>
      * This implementation can be helpful when working with legacy code. 
      * <p>
      * ReturnsMocks first tries to return ordinary return values (see {@link ReturnsMoreEmptyValues})
      * then it tries to return mocks. If the return type cannot be mocked (e.g. is final) then plain null is returned.
      * <p>
      */
     public static final Answer<Object> RETURNS_MOCKS = new ReturnsMocks();
 
     /**
      * Optional Answer to be used with {@link Mockito#mock(Class, Answer)}
      * <p>
      * {@link Answer} can be used to define the return values of unstubbed invocations.
      * <p>
      * This implementation can be helpful when working with legacy code.
      * When this implementation is used, unstubbed methods will delegate to the real implementation.
      * This is a way to create a partial mock object that calls real methods by default.
      * <p>
      * As usual you are going to read <b>the partial mock warning</b>:
      * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.
      * How does partial mock fit into this paradigm? Well, it just doesn't... 
      * Partial mock usually means that the complexity has been moved to a different method on the same object.
      * In most cases, this is not the way you want to design your application.
      * <p>
      * However, there are rare cases when partial mocks come handy: 
      * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
      * However, I wouldn't use partial mocks for new, test-driven & well-designed code.
      * <p>
      * Example:
      * <pre>
      * Foo mock = mock(Foo.class, CALLS_REAL_METHODS);
      *
      * // this calls the real implementation of Foo.getSomething()
      * value = mock.getSomething();
      *
      * when(mock.getSomething()).thenReturn(fakeValue);
      *
      * // now fakeValue is returned
      * value = mock.getSomething();
      * </pre>
      */
     public static final Answer<Object> CALLS_REAL_METHODS = new CallsRealMethods();
     
     /**
      * Creates mock object of given class or interface.
      * <p>
      * See examples in javadoc for {@link Mockito} class
      * 
      * @param classToMock class or interface to mock
      * @return mock object
      */
     public static <T> T mock(Class<T> classToMock) {
         return mock(classToMock, withSettings().defaultAnswer(RETURNS_DEFAULTS));
     }
     
     /**
      * Specifies mock name. Naming mocks can be helpful for debugging - the name is used in all verification errors. 
      * <p>
      * Beware that naming mocks is not a solution for complex code which uses too many mocks or collaborators. 
      * <b>If you have too many mocks then refactor the code</b> so that it's easy to test/debug without necessity of naming mocks.
      * <p>
      * <b>If you use &#064;Mock annotation then you've got naming mocks for free!</b> &#064;Mock uses field name as mock name. {@link Mock Read more.}
      * <p>
      * 
      * See examples in javadoc for {@link Mockito} class
      * 
      * @param classToMock class or interface to mock
      * @param name of the mock 
      * @return mock object
      */
     public static <T> T mock(Class<T> classToMock, String name) {
         return mock(classToMock, withSettings()
                 .name(name)
                 .defaultAnswer(RETURNS_DEFAULTS));
     }
     
     /**
      * @deprecated
      * <b>Please use mock(Foo.class, defaultAnswer);</b>
      * <p>
      * See {@link Mockito#mock(Class, Answer)}
      * <p>
      * Why it is deprecated? ReturnValues is being replaced by Answer
      * for better consistency & interoperability of the framework. 
      * Answer interface has been in Mockito for a while and it has the same responsibility as ReturnValues.
      * There's no point in mainting exactly the same interfaces.
      * <p>
      * Creates mock with a specified strategy for its return values. 
      * It's quite advanced feature and typically you don't need it to write decent tests.
      * However it can be helpful when working with legacy systems.
      * <p>
      * Obviously return values are used only when you don't stub the method call.
      *
      * <pre>
      *   Foo mock = mock(Foo.class, Mockito.RETURNS_SMART_NULLS);
      *   Foo mockTwo = mock(Foo.class, new YourOwnReturnValues()); 
      * </pre>
      * 
      * <p>See examples in javadoc for {@link Mockito} class</p>
      * 
      * @param classToMock class or interface to mock
      * @param returnValues default return values for unstubbed methods
      *
      * @return mock object
      */
     @Deprecated
     public static <T> T mock(Class<T> classToMock, ReturnValues returnValues) {
         return mock(classToMock, withSettings().defaultAnswer(new AnswerReturnValuesAdapter(returnValues)));
     }
     
     /**
      * Creates mock with a specified strategy for its answers to interactions. 
      * It's quite advanced feature and typically you don't need it to write decent tests.
      * However it can be helpful when working with legacy systems.
      * <p>
      * It is the default answer so it will be used <b>only when you don't</b> stub the method call.
      *
      * <pre>
      *   Foo mock = mock(Foo.class, RETURNS_SMART_NULLS);
      *   Foo mockTwo = mock(Foo.class, new YourOwnAnswer()); 
      * </pre>
      * 
      * <p>See examples in javadoc for {@link Mockito} class</p>
      * 
      * @param classToMock class or interface to mock
      * @param defaultAnswer default answer for unstubbed methods
      *
      * @return mock object
      */
     public static <T> T mock(Class<T> classToMock, Answer defaultAnswer) {
         return mock(classToMock, withSettings().defaultAnswer(defaultAnswer));
     }
     
     /**
      * Creates a mock with some non-standard settings.
      * <p>
      * The number of configuration points for a mock grows 
      * so we need a fluent way to introduce new configuration without adding more and more overloaded Mockito.mock() methods. 
      * Hence {@link MockSettings}.
      * <pre>
      *   Listener mock = mock(Listener.class, withSettings()
      *     .name(""firstListner"").defaultBehavior(RETURNS_SMART_NULLS));
      *   );  
      * </pre>
      * <b>Use it carefully and occasionally</b>. What might be reason your test needs non-standard mocks? 
      * Is the code under test so complicated that it requires non-standard mocks? 
      * Wouldn't you prefer to refactor the code under test so it is testable in a simple way?
      * <p>
      * See also {@link Mockito#withSettings()}
      * <p>
      * See examples in javadoc for {@link Mockito} class
      * 
      * @param classToMock class or interface to mock
      * @param mockSettings additional mock settings
      * @return mock object
      */
     public static <T> T mock(Class<T> classToMock, MockSettings mockSettings) {
      return MOCKITO_CORE.mock(classToMock, mockSettings, true);
     }
     
     /**
      * Creates a spy of the real object. The spy calls <b>real</b> methods unless they are stubbed.
      * <p>
      * Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.
      * <p>
      * As usual you are going to read <b>the partial mock warning</b>:
      * Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.
      * How does partial mock fit into this paradigm? Well, it just doesn't... 
      * Partial mock usually means that the complexity has been moved to a different method on the same object.
      * In most cases, this is not the way you want to design your application.
      * <p>
      * However, there are rare cases when partial mocks come handy: 
      * dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
      * However, I wouldn't use partial mocks for new, test-driven & well-designed code.
      * <p>
      * Example:
      * 
      * <pre>
      *   List list = new LinkedList();
      *   List spy = spy(list);
      * 
      *   //optionally, you can stub out some methods:
      *   when(spy.size()).thenReturn(100);
      * 
      *   //using the spy calls <b>real</b> methods
      *   spy.add(""one"");
      *   spy.add(""two"");
      * 
      *   //prints ""one"" - the first element of a list
      *   System.out.println(spy.get(0));
      * 
      *   //size() method was stubbed - 100 is printed
      *   System.out.println(spy.size());
      * 
      *   //optionally, you can verify
      *   verify(spy).add(""one"");
      *   verify(spy).add(""two"");
      * </pre>
      * 
      * <h4>Important gotcha on spying real objects!</h4>
      * 
      * 1. Sometimes it's impossible to use {@link Mockito#when(Object)} for stubbing spies. Example:
      * 
      * <pre>
      *   List list = new LinkedList();
      *   List spy = spy(list);
      *   
      *   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)
      *   when(spy.get(0)).thenReturn(""foo"");
      *   
      *   //You have to use doReturn() for stubbing
      *   doReturn(""foo"").when(spy).get(0);
      * </pre>
      * 
      * 2. Watch out for final methods. 
      * Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.
      * What will happen is the real method will be called *on mock* but *not on the real instance* you passed to the spy() method.
      * Typically you may get a NullPointerException because mock instances don't have fields initiated.
      * 
      * <p>
      * See examples in javadoc for {@link Mockito} class
      * 
      * @param object
      *            to spy on
      * @return a spy of the real object
      */
     public static <T> T spy(T object) {
         return MOCKITO_CORE.mock((Class<T>) object.getClass(), withSettings()
                 .spiedInstance(object)
              .defaultAnswer(CALLS_REAL_METHODS), true); 
     }
 
     /**
      * <pre>
      *   //Instead of:
      *   stub(mock.count()).toReturn(10);
      * 
      *   //Please do:
      *   when(mock.count()).thenReturn(10);
      * </pre> 
      * 
      * Many users found stub() confusing therefore stub() has been deprecated in favor of {@link Mockito#when(Object)} 
      * <p>
      * How to fix deprecation warnings? Typically it's just few minutes of search & replace job:
      * <pre>
      *   Mockito.stub;  <i>replace with:</i>  Mockito.when;
      *   stub(          <i>replace with:</i>  when(
      *   .toReturn(     <i>replace with:</i>  .thenReturn(
      *   .toThrow(      <i>replace with:</i>  .thenThrow(
      *   .toAnswer(     <i>replace with:</i>  .thenAnswer(
      * </pre>
      * If you're an existing user then sorry for making your code littered with deprecation warnings. 
/src/org/mockito/internal/MockitoCore.java @@ -1,38 +1,39 @@
 /*
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
 package org.mockito.internal;
 
 import org.mockito.InOrder;
 import org.mockito.MockSettings;
 import org.mockito.exceptions.Reporter;
 import org.mockito.exceptions.misusing.NotAMockException;
 import org.mockito.internal.creation.MockSettingsImpl;
 import org.mockito.internal.invocation.Invocation;
 import org.mockito.internal.progress.IOngoingStubbing;
 import org.mockito.internal.progress.MockingProgress;
 import org.mockito.internal.progress.ThreadSafeMockingProgress;
 import org.mockito.internal.stubbing.OngoingStubbingImpl;
 import org.mockito.internal.stubbing.StubberImpl;
 import org.mockito.internal.util.MockUtil;
 import org.mockito.internal.verification.api.VerificationMode;
 import org.mockito.stubbing.*;
 
 import java.util.Arrays;
 import java.util.List;
 
 @SuppressWarnings(""unchecked"")
 public class MockitoCore {
 
     private final Reporter reporter = new Reporter();
     private final MockUtil mockUtil = new MockUtil();
     private final MockingProgress mockingProgress = new ThreadSafeMockingProgress();
     
  public <T> T mock(Class<T> classToMock, MockSettings mockSettings, boolean shouldResetOngoingStubbing) {
         mockingProgress.validateState();
      if (shouldResetOngoingStubbing) {
             mockingProgress.resetOngoingStubbing();
      }
         return mockUtil.createMock(classToMock, (MockSettingsImpl) mockSettings);
     }
     
","
 package org.mockito;
 
 import org.mockito.internal.MockitoCore;
 import org.mockito.internal.creation.MockSettingsImpl;
 import org.mockito.internal.debugging.MockitoDebuggerImpl;
 import org.mockito.internal.stubbing.answers.*;
 import org.mockito.internal.stubbing.defaultanswers.*;
 import org.mockito.internal.verification.VerificationModeFactory;
 import org.mockito.internal.verification.api.VerificationMode;
 import org.mockito.runners.MockitoJUnitRunner;
 import org.mockito.stubbing.*;
 
 @SuppressWarnings(""unchecked"")
 public class Mockito extends Matchers {
     
     private static final MockitoCore MOCKITO_CORE = new MockitoCore();
     
     public static final Answer<Object> RETURNS_DEFAULTS = new GloballyConfiguredAnswer();
     
     
     public static final Answer<Object> RETURNS_SMART_NULLS = new ReturnsSmartNulls();
   
     public static final Answer<Object> RETURNS_MOCKS = new ReturnsMocks();
 
 
     public static final Answer<Object> CALLS_REAL_METHODS = new CallsRealMethods();     public static <T> T mock(Class<T> classToMock) {
         return mock(classToMock, withSettings().defaultAnswer(RETURNS_DEFAULTS));
     }
  
     public static <T> T mock(Class<T> classToMock, String name) {
         return mock(classToMock, withSettings()
                 .name(name)
                 .defaultAnswer(RETURNS_DEFAULTS));
     }
     
     @Deprecated
     public static <T> T mock(Class<T> classToMock, ReturnValues returnValues) {
         return mock(classToMock, withSettings().defaultAnswer(new AnswerReturnValuesAdapter(returnValues)));
     }
     
     public static <T> T mock(Class<T> classToMock, Answer defaultAnswer) {
         return mock(classToMock, withSettings().defaultAnswer(defaultAnswer));
     }     public static <T> T mock(Class<T> classToMock, MockSettings mockSettings) {
        return MOCKITO_CORE.mock(classToMock, mockSettings);
     }
     
     public static <T> T spy(T object) {
         return MOCKITO_CORE.mock((Class<T>) object.getClass(), withSettings()
                 .spiedInstance(object)
                .defaultAnswer(CALLS_REAL_METHODS)); 
     }
 
     

 package org.mockito.internal;
 
 import org.mockito.InOrder;
 import org.mockito.MockSettings;
 import org.mockito.exceptions.Reporter;
 import org.mockito.exceptions.misusing.NotAMockException;
 import org.mockito.internal.creation.MockSettingsImpl;
 import org.mockito.internal.invocation.Invocation;
 import org.mockito.internal.progress.IOngoingStubbing;
 import org.mockito.internal.progress.MockingProgress;
 import org.mockito.internal.progress.ThreadSafeMockingProgress;
 import org.mockito.internal.stubbing.OngoingStubbingImpl;
 import org.mockito.internal.stubbing.StubberImpl;
 import org.mockito.internal.util.MockUtil;
 import org.mockito.internal.verification.api.VerificationMode;
 import org.mockito.stubbing.*;
 
 import java.util.Arrays;
 import java.util.List;
 
 @SuppressWarnings(""unchecked"")
 public class MockitoCore {
 
     private final Reporter reporter = new Reporter();
     private final MockUtil mockUtil = new MockUtil();
     private final MockingProgress mockingProgress = new ThreadSafeMockingProgress();
     
    public <T> T mock(Class<T> classToMock, MockSettings mockSettings, boolean shouldResetOngoingStubbing) { return mock(classToMock, mockSettings); }
    public <T> T mock(Class<T> classToMock, MockSettings mockSettings) {
         mockingProgress.validateState();
             mockingProgress.resetOngoingStubbing();
         return mockUtil.createMock(classToMock, (MockSettingsImpl) mockSettings);
     }
     
","
 package org.mockito;
 
 import org.mockito.internal.MockitoCore;
 import org.mockito.internal.creation.MockSettingsImpl;
 import org.mockito.internal.debugging.MockitoDebuggerImpl;
 import org.mockito.internal.stubbing.answers.*;
 import org.mockito.internal.stubbing.defaultanswers.*;
 import org.mockito.internal.verification.VerificationModeFactory;
 import org.mockito.internal.verification.api.VerificationMode;
 import org.mockito.runners.MockitoJUnitRunner;
 import org.mockito.stubbing.*;
 
 @SuppressWarnings(""unchecked"")
 public class Mockito extends Matchers {
     
     private static final MockitoCore MOCKITO_CORE = new MockitoCore();
     public static final Answer<Object> RETURNS_DEFAULTS = new GloballyConfiguredAnswer();
     public static final Answer<Object> RETURNS_SMART_NULLS = new ReturnsSmartNulls();
     
     public static final Answer<Object> RETURNS_MOCKS = new ReturnsMocks();     public static final Answer<Object> CALLS_REAL_METHODS = new CallsRealMethods();
     
     public static <T> T mock(Class<T> classToMock) {
         return mock(classToMock, withSettings().defaultAnswer(RETURNS_DEFAULTS));
     }
     public static <T> T mock(Class<T> classToMock, String name) {
         return mock(classToMock, withSettings()
                 .name(name)
                 .defaultAnswer(RETURNS_DEFAULTS));
     }
     
     @Deprecated
     public static <T> T mock(Class<T> classToMock, ReturnValues returnValues) {
         return mock(classToMock, withSettings().defaultAnswer(new AnswerReturnValuesAdapter(returnValues)));
     }
     public static <T> T mock(Class<T> classToMock, Answer defaultAnswer) {
         return mock(classToMock, withSettings().defaultAnswer(defaultAnswer));
     }
     public static <T> T mock(Class<T> classToMock, MockSettings mockSettings) {
        return MOCKITO_CORE.mock(classToMock, mockSettings, true);
     }
     
     public static <T> T spy(T object) {
         return MOCKITO_CORE.mock((Class<T>) object.getClass(), withSettings()
                 .spiedInstance(object)
                .defaultAnswer(CALLS_REAL_METHODS), true); 
     }
 

 package org.mockito.internal;
 
 import org.mockito.InOrder;
 import org.mockito.MockSettings;
 import org.mockito.exceptions.Reporter;
 import org.mockito.exceptions.misusing.NotAMockException;
 import org.mockito.internal.creation.MockSettingsImpl;
 import org.mockito.internal.invocation.Invocation;
 import org.mockito.internal.progress.IOngoingStubbing;
 import org.mockito.internal.progress.MockingProgress;
 import org.mockito.internal.progress.ThreadSafeMockingProgress;
 import org.mockito.internal.stubbing.OngoingStubbingImpl;
 import org.mockito.internal.stubbing.StubberImpl;
 import org.mockito.internal.util.MockUtil;
 import org.mockito.internal.verification.api.VerificationMode;
 import org.mockito.stubbing.*;
 
 import java.util.Arrays;
 import java.util.List;
 
 @SuppressWarnings(""unchecked"")
 public class MockitoCore {
 
     private final Reporter reporter = new Reporter();
     private final MockUtil mockUtil = new MockUtil();
     private final MockingProgress mockingProgress = new ThreadSafeMockingProgress();
     
    public <T> T mock(Class<T> classToMock, MockSettings mockSettings, boolean shouldResetOngoingStubbing) {
         mockingProgress.validateState();
        if (shouldResetOngoingStubbing) {
             mockingProgress.resetOngoingStubbing();
        }
         return mockUtil.createMock(classToMock, (MockSettingsImpl) mockSettings);
     }
     
"
343,"junit.framework.AssertionFailedError","/src/org/mockito/internal/configuration/injection/FinalMockCandidateFilter.java","@@ -1,6 +1,7 @@
 package org.mockito.internal.configuration.injection;
 
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.util.reflection.BeanPropertySetter;
 import org.mockito.internal.util.reflection.FieldSetter;
 
 import java.lang.reflect.Field;
@@ -22,7 +23,9 @@ public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Fie
             return new OngoingInjecter() {
                 public boolean thenInject() {
                     try {
                             new FieldSetter(fieldInstance, field).set(matchingMock);
                     } catch (Exception e) {
                         throw new MockitoException(""Problems injecting dependency in "" + field.getName(), e);
                     }
","@@ -1,6 +1,7 @@
 package org.mockito.internal.configuration.injection;
 
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.util.reflection.BeanPropertySetter;
 import org.mockito.internal.util.reflection.FieldSetter;
 
 import java.lang.reflect.Field;
@@ -22,7 +23,9 @@ public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Fie
             return new OngoingInjecter() {
                 public boolean thenInject() {
                     try {
                      if (!new BeanPropertySetter(fieldInstance, field).set(matchingMock)) {
                             new FieldSetter(fieldInstance, field).set(matchingMock);
                      }
                     } catch (Exception e) {
                         throw new MockitoException(""Problems injecting dependency in "" + field.getName(), e);
                     }
","
 package org.mockito.internal.configuration.injection;
 
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.util.reflection.FieldSetter;
 
 import java.lang.reflect.Field;

             return new OngoingInjecter() {
                 public boolean thenInject() {
                     try {
                             new FieldSetter(fieldInstance, field).set(matchingMock);
                     } catch (Exception e) {
                         throw new MockitoException(""Problems injecting dependency in "" + field.getName(), e);
                     }
","
 package org.mockito.internal.configuration.injection;
 
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.util.reflection.BeanPropertySetter;
 import org.mockito.internal.util.reflection.FieldSetter;
 
 import java.lang.reflect.Field;

             return new OngoingInjecter() {
                 public boolean thenInject() {
                     try {
                        if (!new BeanPropertySetter(fieldInstance, field).set(matchingMock)) {
                             new FieldSetter(fieldInstance, field).set(matchingMock);
                        }
                     } catch (Exception e) {
                         throw new MockitoException(""Problems injecting dependency in "" + field.getName(), e);
                     }
"
344,"junit.framework.AssertionFailedError","/src/org/mockito/internal/MockHandler.java","@@ -17,6 +17,7 @@
 import org.mockito.internal.stubbing.OngoingStubbingImpl;
 import org.mockito.internal.stubbing.StubbedInvocationMatcher;
 import org.mockito.internal.stubbing.VoidMethodStubbableImpl;
 import org.mockito.internal.verification.MockAwareVerificationMode;
 import org.mockito.internal.verification.VerificationDataImpl;
 import org.mockito.stubbing.Answer;
 import org.mockito.stubbing.VoidMethodStubbable;
@@ -73,9 +74,11 @@ public Object handle(Invocation invocation) throws Throwable {
         if (verificationMode != null) {
             //We need to check if verification was started on the correct mock 
             // - see VerifyingWithAnExtraCallToADifferentMockTest
                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl.getInvocations(), invocationMatcher);            
                 verificationMode.verify(data);
                 return null;
         }
         
         invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);
/src/org/mockito/internal/MockitoCore.java @@ -20,6 +20,7 @@
 import org.mockito.internal.stubbing.OngoingStubbingImpl;
 import org.mockito.internal.stubbing.StubberImpl;
 import org.mockito.internal.util.MockUtil;
 import org.mockito.internal.verification.MockAwareVerificationMode;
 import org.mockito.internal.verification.VerificationDataImpl;
 import org.mockito.internal.verification.VerificationModeFactory;
 import org.mockito.internal.verification.api.InOrderContext;
@@ -70,7 +71,7 @@ public IOngoingStubbing stub() {
         } else if (!mockUtil.isMock(mock)) {
             reporter.notAMockPassedToVerify();
         }
      mockingProgress.verificationStarted(mode);
         return mock;
     }
     
","@@ -17,6 +17,7 @@
 import org.mockito.internal.stubbing.OngoingStubbingImpl;
 import org.mockito.internal.stubbing.StubbedInvocationMatcher;
 import org.mockito.internal.stubbing.VoidMethodStubbableImpl;
 import org.mockito.internal.verification.MockAwareVerificationMode;
 import org.mockito.internal.verification.VerificationDataImpl;
 import org.mockito.stubbing.Answer;
 import org.mockito.stubbing.VoidMethodStubbable;
@@ -73,9 +74,11 @@ public Object handle(Invocation invocation) throws Throwable {
         if (verificationMode != null) {
             //We need to check if verification was started on the correct mock 
             // - see VerifyingWithAnExtraCallToADifferentMockTest
          if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {
                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl.getInvocations(), invocationMatcher);            
                 verificationMode.verify(data);
                 return null;
          }
         }
         
         invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);
/src/org/mockito/internal/MockitoCore.java @@ -20,6 +20,7 @@
 import org.mockito.internal.stubbing.OngoingStubbingImpl;
 import org.mockito.internal.stubbing.StubberImpl;
 import org.mockito.internal.util.MockUtil;
 import org.mockito.internal.verification.MockAwareVerificationMode;
 import org.mockito.internal.verification.VerificationDataImpl;
 import org.mockito.internal.verification.VerificationModeFactory;
 import org.mockito.internal.verification.api.InOrderContext;
@@ -70,7 +71,7 @@ public IOngoingStubbing stub() {
         } else if (!mockUtil.isMock(mock)) {
             reporter.notAMockPassedToVerify();
         }
      mockingProgress.verificationStarted(new MockAwareVerificationMode(mock, mode));
         return mock;
     }
     
","
 import org.mockito.internal.stubbing.OngoingStubbingImpl;
 import org.mockito.internal.stubbing.StubbedInvocationMatcher;
 import org.mockito.internal.stubbing.VoidMethodStubbableImpl;
 import org.mockito.internal.verification.VerificationDataImpl;
 import org.mockito.stubbing.Answer;
 import org.mockito.stubbing.VoidMethodStubbable;

         if (verificationMode != null) {
                                           VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl.getInvocations(), invocationMatcher);            
                 verificationMode.verify(data);
                 return null;
         }
         
         invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);

 import org.mockito.internal.stubbing.OngoingStubbingImpl;
 import org.mockito.internal.stubbing.StubberImpl;
 import org.mockito.internal.util.MockUtil;
 import org.mockito.internal.verification.VerificationDataImpl;
 import org.mockito.internal.verification.VerificationModeFactory;
 import org.mockito.internal.verification.api.InOrderContext;

         } else if (!mockUtil.isMock(mock)) {
             reporter.notAMockPassedToVerify();
         }
        mockingProgress.verificationStarted(mode);
         return mock;
     }
     
","
 import org.mockito.internal.stubbing.OngoingStubbingImpl;
 import org.mockito.internal.stubbing.StubbedInvocationMatcher;
 import org.mockito.internal.stubbing.VoidMethodStubbableImpl;
 import org.mockito.internal.verification.MockAwareVerificationMode;
 import org.mockito.internal.verification.VerificationDataImpl;
 import org.mockito.stubbing.Answer;
 import org.mockito.stubbing.VoidMethodStubbable;

         if (verificationMode != null) {
                                      if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {
                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl.getInvocations(), invocationMatcher);            
                 verificationMode.verify(data);
                 return null;
            }
         }
         
         invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);

 import org.mockito.internal.stubbing.OngoingStubbingImpl;
 import org.mockito.internal.stubbing.StubberImpl;
 import org.mockito.internal.util.MockUtil;
 import org.mockito.internal.verification.MockAwareVerificationMode;
 import org.mockito.internal.verification.VerificationDataImpl;
 import org.mockito.internal.verification.VerificationModeFactory;
 import org.mockito.internal.verification.api.InOrderContext;

         } else if (!mockUtil.isMock(mock)) {
             reporter.notAMockPassedToVerify();
         }
        mockingProgress.verificationStarted(new MockAwareVerificationMode(mock, mode));
         return mock;
     }
     
"
345,"java.lang.ClassCastException","/src/org/mockito/internal/util/reflection/GenericMaster.java","@@ -17,8 +17,12 @@ public Class getGenericType(Field field) {
         Type generic = field.getGenericType();
         if (generic != null && generic instanceof ParameterizedType) {
             Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];
                 return (Class) actual;
                 //in case of nested generics we don't go deep
         }
         
         return Object.class;
","@@ -17,8 +17,12 @@ public Class getGenericType(Field field) {
         Type generic = field.getGenericType();
         if (generic != null && generic instanceof ParameterizedType) {
             Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];
          if (actual instanceof Class) {
                 return (Class) actual;
          } else if (actual instanceof ParameterizedType) {
                 //in case of nested generics we don't go deep
              return (Class) ((ParameterizedType) actual).getRawType();
          }
         }
         
         return Object.class;
","
         Type generic = field.getGenericType();
         if (generic != null && generic instanceof ParameterizedType) {
             Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];
                 return (Class) actual;
                          }
         
         return Object.class;
","
         Type generic = field.getGenericType();
         if (generic != null && generic instanceof ParameterizedType) {
             Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];
            if (actual instanceof Class) {
                 return (Class) actual;
            } else if (actual instanceof ParameterizedType) {
                                 return (Class) ((ParameterizedType) actual).getRawType();
            }
         }
         
         return Object.class;
"
346,"junit.framework.AssertionFailedError","/src/org/mockito/internal/MockHandler.java","@@ -74,12 +74,14 @@ public Object handle(Invocation invocation) throws Throwable {
         if (verificationMode != null) {
             //We need to check if verification was started on the correct mock 
             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
          if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                
                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            
                 verificationMode.verify(data);
                 return null;
                 // this means there is an invocation on a different mock. Re-adding verification mode 
                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
             }
         }
         
","@@ -74,12 +74,14 @@ public Object handle(Invocation invocation) throws Throwable {
         if (verificationMode != null) {
             //We need to check if verification was started on the correct mock 
             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
          if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                
                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            
                 verificationMode.verify(data);
                 return null;
          } else {
                 // this means there is an invocation on a different mock. Re-adding verification mode 
                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)
              mockingProgress.verificationStarted(verificationMode);
             }
         }
         
","
         if (verificationMode != null) {
                                      if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                
                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            
                 verificationMode.verify(data);
                 return null;
                                               }
         }
         
","
         if (verificationMode != null) {
                                      if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                
                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            
                 verificationMode.verify(data);
                 return null;
            } else {
                                                  mockingProgress.verificationStarted(verificationMode);
             }
         }
         
"
347,"java.io.NotSerializableException","/src/org/mockito/internal/creation/MockSettingsImpl.java","@@ -17,9 +17,11 @@
     private Object spiedInstance;
     private Answer<Object> defaultAnswer;
     private MockName mockName;
 
     public MockSettings serializable() {
      return this.extraInterfaces(java.io.Serializable.class);
     }
 
     public MockSettings extraInterfaces(Class<?>... extraInterfaces) {
@@ -71,7 +73,7 @@ public MockSettings defaultAnswer(Answer defaultAnswer) {
     }
 
     public boolean isSerializable() {
      return extraInterfaces != null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);
     }
 
     public void initiateMockName(Class classToMock) {
/src/org/mockito/internal/util/MockUtil.java @@ -16,6 +16,7 @@
 import org.mockito.internal.creation.jmock.ClassImposterizer;
 import org.mockito.internal.util.reflection.LenientCopyTool;
 
 import java.io.Serializable;
 
 @SuppressWarnings(""unchecked"")
 public class MockUtil {
@@ -42,7 +43,11 @@ public MockUtil() {
         Class<?>[] interfaces = settings.getExtraInterfaces();
 
         Class<?>[] ancillaryTypes;
             ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;
 
         Object spiedInstance = settings.getSpiedInstance();
         
","@@ -17,9 +17,11 @@
     private Object spiedInstance;
     private Answer<Object> defaultAnswer;
     private MockName mockName;
  private boolean serializable;
 
     public MockSettings serializable() {
      this.serializable = true;
      return this;
     }
 
     public MockSettings extraInterfaces(Class<?>... extraInterfaces) {
@@ -71,7 +73,7 @@ public MockSettings defaultAnswer(Answer defaultAnswer) {
     }
 
     public boolean isSerializable() {
      return serializable;
     }
 
     public void initiateMockName(Class classToMock) {
/src/org/mockito/internal/util/MockUtil.java @@ -16,6 +16,7 @@
 import org.mockito.internal.creation.jmock.ClassImposterizer;
 import org.mockito.internal.util.reflection.LenientCopyTool;
 
 import java.io.Serializable;
 
 @SuppressWarnings(""unchecked"")
 public class MockUtil {
@@ -42,7 +43,11 @@ public MockUtil() {
         Class<?>[] interfaces = settings.getExtraInterfaces();
 
         Class<?>[] ancillaryTypes;
      if (settings.isSerializable()) {
          ancillaryTypes = interfaces == null ? new Class<?>[] {Serializable.class} : new ArrayUtils().concat(interfaces, Serializable.class);
      } else {
             ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;
      }
 
         Object spiedInstance = settings.getSpiedInstance();
         
","
     private Object spiedInstance;
     private Answer<Object> defaultAnswer;
     private MockName mockName;
 
     public MockSettings serializable() {
        return this.extraInterfaces(java.io.Serializable.class);
     }
 
     public MockSettings extraInterfaces(Class<?>... extraInterfaces) {

     }
 
     public boolean isSerializable() {
        return extraInterfaces != null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);
     }
 
     public void initiateMockName(Class classToMock) {

 import org.mockito.internal.creation.jmock.ClassImposterizer;
 import org.mockito.internal.util.reflection.LenientCopyTool;
 
 
 @SuppressWarnings(""unchecked"")
 public class MockUtil {

         Class<?>[] interfaces = settings.getExtraInterfaces();
 
         Class<?>[] ancillaryTypes;
             ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;
 
         Object spiedInstance = settings.getSpiedInstance();
         
","
     private Object spiedInstance;
     private Answer<Object> defaultAnswer;
     private MockName mockName;
    private boolean serializable;
 
     public MockSettings serializable() {
        this.serializable = true;
        return this;
     }
 
     public MockSettings extraInterfaces(Class<?>... extraInterfaces) {

     }
 
     public boolean isSerializable() {
        return serializable;
     }
 
     public void initiateMockName(Class classToMock) {

 import org.mockito.internal.creation.jmock.ClassImposterizer;
 import org.mockito.internal.util.reflection.LenientCopyTool;
 
 import java.io.Serializable;
 
 @SuppressWarnings(""unchecked"")
 public class MockUtil {

         Class<?>[] interfaces = settings.getExtraInterfaces();
 
         Class<?>[] ancillaryTypes;
        if (settings.isSerializable()) {
            ancillaryTypes = interfaces == null ? new Class<?>[] {Serializable.class} : new ArrayUtils().concat(interfaces, Serializable.class);
        } else {
             ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;
        }
 
         Object spiedInstance = settings.getSpiedInstance();
         
"
348,"java.lang.NullPointerException","/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java","@@ -84,6 +84,8 @@ Object returnValueFor(Class<?> type) {
             return Primitives.defaultValueForPrimitiveOrWrapper(type);
             //new instances are used instead of Collections.emptyList(), etc.
             //to avoid UnsupportedOperationException if code under test modifies returned collection
         } else if (type == Collection.class) {
             return new LinkedList<Object>();
         } else if (type == Set.class) {
","@@ -84,6 +84,8 @@ Object returnValueFor(Class<?> type) {
             return Primitives.defaultValueForPrimitiveOrWrapper(type);
             //new instances are used instead of Collections.emptyList(), etc.
             //to avoid UnsupportedOperationException if code under test modifies returned collection
      } else if (type == Iterable.class) {
          return new ArrayList<Object>(0);
         } else if (type == Collection.class) {
             return new LinkedList<Object>();
         } else if (type == Set.class) {
","
             return Primitives.defaultValueForPrimitiveOrWrapper(type);
                                   } else if (type == Collection.class) {
             return new LinkedList<Object>();
         } else if (type == Set.class) {
","
             return Primitives.defaultValueForPrimitiveOrWrapper(type);
                                  } else if (type == Iterable.class) {
            return new ArrayList<Object>(0);
         } else if (type == Collection.class) {
             return new LinkedList<Object>();
         } else if (type == Set.class) {
"
349,"java.lang.RuntimeException","/src/org/mockito/internal/matchers/Equality.java","@@ -10,7 +10,9 @@
 public class Equality {
 
     public static boolean areEqual(Object o1, Object o2) {
      if (o1 == null || o2 == null) {
             return o1 == null && o2 == null;
         } else if (isArray(o1)) {
             return isArray(o2) && areArraysEqual(o1, o2);
","@@ -10,7 +10,9 @@
 public class Equality {
 
     public static boolean areEqual(Object o1, Object o2) {
      if (o1 == o2 ) {
          return true;
	} else if (o1 == null || o2 == null) {
             return o1 == null && o2 == null;
         } else if (isArray(o1)) {
             return isArray(o2) && areArraysEqual(o1, o2);
","
 public class Equality {
 
     public static boolean areEqual(Object o1, Object o2) {
        if (o1 == null || o2 == null) {
             return o1 == null && o2 == null;
         } else if (isArray(o1)) {
             return isArray(o2) && areArraysEqual(o1, o2);
","
 public class Equality {
 
     public static boolean areEqual(Object o1, Object o2) {
        if (o1 == o2 ) {
            return true;
        } else if (o1 == null || o2 == null) {
             return o1 == null && o2 == null;
         } else if (isArray(o1)) {
             return isArray(o2) && areArraysEqual(o1, o2);
"
350,"junit.framework.ComparisonFailure","/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java","@@ -29,9 +29,10 @@ public ByteBuddyMockMaker() {
                 settings.getTypeToMock(),
                 settings.getExtraInterfaces()
         );
         T mockInstance = null;
         try {
          mockInstance = classInstantiator.instantiate(mockedProxyType);
             MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;
             mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));
 
@@ -42,7 +43,7 @@ public ByteBuddyMockMaker() {
                     ""  class to mock : "" + describeClass(mockedProxyType),
                     ""  created class : "" + describeClass(settings.getTypeToMock()),
                     ""  proxy instance class : "" + describeClass(mockInstance),
                  ""  instance creation by : "" + classInstantiator.getClass().getSimpleName(),
                     """",
                     ""You might experience classloading issues, please ask the mockito mailing-list."",
                     """"
","@@ -29,9 +29,10 @@ public ByteBuddyMockMaker() {
                 settings.getTypeToMock(),
                 settings.getExtraInterfaces()
         );
      Instantiator instantiator = new InstantiatorProvider().getInstantiator(settings);
         T mockInstance = null;
         try {
          mockInstance = instantiator.newInstance(mockedProxyType);
             MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;
             mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));
 
@@ -42,7 +43,7 @@ public ByteBuddyMockMaker() {
                     ""  class to mock : "" + describeClass(mockedProxyType),
                     ""  created class : "" + describeClass(settings.getTypeToMock()),
                     ""  proxy instance class : "" + describeClass(mockInstance),
                  ""  instance creation by : "" + instantiator.getClass().getSimpleName(),
                     """",
                     ""You might experience classloading issues, please ask the mockito mailing-list."",
                     """"
","
                 settings.getTypeToMock(),
                 settings.getExtraInterfaces()
         );
         T mockInstance = null;
         try {
            mockInstance = classInstantiator.instantiate(mockedProxyType);
             MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;
             mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));
 

                     ""  class to mock : "" + describeClass(mockedProxyType),
                     ""  created class : "" + describeClass(settings.getTypeToMock()),
                     ""  proxy instance class : "" + describeClass(mockInstance),
                    ""  instance creation by : "" + classInstantiator.getClass().getSimpleName(),
                     """",
                     ""You might experience classloading issues, please ask the mockito mailing-list."",
                     """"
","
                 settings.getTypeToMock(),
                 settings.getExtraInterfaces()
         );
        Instantiator instantiator = new InstantiatorProvider().getInstantiator(settings);
         T mockInstance = null;
         try {
            mockInstance = instantiator.newInstance(mockedProxyType);
             MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;
             mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));
 

                     ""  class to mock : "" + describeClass(mockedProxyType),
                     ""  created class : "" + describeClass(settings.getTypeToMock()),
                     ""  proxy instance class : "" + describeClass(mockInstance),
                    ""  instance creation by : "" + instantiator.getClass().getSimpleName(),
                     """",
                     ""You might experience classloading issues, please ask the mockito mailing-list."",
                     """"
"
351,"junit.framework.AssertionFailedError","/src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java","@@ -111,7 +111,7 @@ private boolean injectMockCandidates(Class<?> awaitingInjectionClazz, Set<Object
     private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) {
         for (Iterator<Field> it = orderedInstanceFields.iterator(); it.hasNext(); ) {
             Field field = it.next();
          Object injected = mockCandidateFilter.filterCandidate(mocks, field, instance).thenInject();
             if (injected != null) {
                 injectionOccurred |= true;
                 mocks.remove(injected);
/src/org/mockito/internal/configuration/injection/filter/FinalMockCandidateFilter.java @@ -10,6 +10,7 @@
 
 import java.lang.reflect.Field;
 import java.util.Collection;
 import java.util.List;
 
 /**
  * This node returns an actual injecter which will be either :
@@ -20,7 +21,7 @@
  * </ul>
  */
 public class FinalMockCandidateFilter implements MockCandidateFilter {
  public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance) {
         if(mocks.size() == 1) {
             final Object matchingMock = mocks.iterator().next();
 
/src/org/mockito/internal/configuration/injection/filter/MockCandidateFilter.java @@ -6,13 +6,14 @@
 
 import java.lang.reflect.Field;
 import java.util.Collection;
 import java.util.List;
 
 public interface MockCandidateFilter {
 
     OngoingInjecter filterCandidate(
             Collection<Object> mocks,
             Field fieldToBeInjected,
          Object fieldInstance
     );
 
 }
/src/org/mockito/internal/configuration/injection/filter/NameBasedCandidateFilter.java @@ -20,7 +20,7 @@ public NameBasedCandidateFilter(MockCandidateFilter next) {
 	}
 
 	public OngoingInjecter filterCandidate(Collection<Object> mocks,
		Field field, Object fieldInstance) {
 		List<Object> mockNameMatches = new ArrayList<Object>();
 		if (mocks.size() > 1) {
 			for (Object mock : mocks) {
@@ -28,7 +28,7 @@ public OngoingInjecter filterCandidate(Collection<Object> mocks,
 					mockNameMatches.add(mock);
 				}
 			}
		return next.filterCandidate(mockNameMatches, field,
 					fieldInstance);
 			/*
 			 * In this case we have to check whether we have conflicting naming
@@ -39,7 +39,23 @@ public OngoingInjecter filterCandidate(Collection<Object> mocks,
 			 * whenever we find a field that does match its name with the mock
 			 * name, we should take that field instead.
 			 */


 		}
	return next.filterCandidate(mocks, field, fieldInstance);
 	}
 }
/src/org/mockito/internal/configuration/injection/filter/TypeBasedCandidateFilter.java @@ -17,7 +17,7 @@ public TypeBasedCandidateFilter(MockCandidateFilter next) {
         this.next = next;
     }
 
  public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) {
         List<Object> mockTypeMatches = new ArrayList<Object>();
         for (Object mock : mocks) {
             if (field.getType().isAssignableFrom(mock.getClass())) {
@@ -25,6 +25,6 @@ public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Ob
             }
         }
 
      return next.filterCandidate(mockTypeMatches, field, fieldInstance);
     }
 }
","@@ -111,7 +111,7 @@ private boolean injectMockCandidates(Class<?> awaitingInjectionClazz, Set<Object
     private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) {
         for (Iterator<Field> it = orderedInstanceFields.iterator(); it.hasNext(); ) {
             Field field = it.next();
          Object injected = mockCandidateFilter.filterCandidate(mocks, field, orderedInstanceFields, instance).thenInject();
             if (injected != null) {
                 injectionOccurred |= true;
                 mocks.remove(injected);
/src/org/mockito/internal/configuration/injection/filter/FinalMockCandidateFilter.java @@ -10,6 +10,7 @@
 
 import java.lang.reflect.Field;
 import java.util.Collection;
 import java.util.List;
 
 /**
  * This node returns an actual injecter which will be either :
@@ -20,7 +21,7 @@
  * </ul>
  */
 public class FinalMockCandidateFilter implements MockCandidateFilter {
  public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, List<Field> fields, final Object fieldInstance) {
         if(mocks.size() == 1) {
             final Object matchingMock = mocks.iterator().next();
 
/src/org/mockito/internal/configuration/injection/filter/MockCandidateFilter.java @@ -6,13 +6,14 @@
 
 import java.lang.reflect.Field;
 import java.util.Collection;
 import java.util.List;
 
 public interface MockCandidateFilter {
 
     OngoingInjecter filterCandidate(
             Collection<Object> mocks,
             Field fieldToBeInjected,
          List<Field> fields, Object instance
     );
 
 }
/src/org/mockito/internal/configuration/injection/filter/NameBasedCandidateFilter.java @@ -20,7 +20,7 @@ public NameBasedCandidateFilter(MockCandidateFilter next) {
 	}
 
 	public OngoingInjecter filterCandidate(Collection<Object> mocks,
			Field field, List<Field> fields, Object fieldInstance) {
 		List<Object> mockNameMatches = new ArrayList<Object>();
 		if (mocks.size() > 1) {
 			for (Object mock : mocks) {
@@ -28,7 +28,7 @@ public OngoingInjecter filterCandidate(Collection<Object> mocks,
 					mockNameMatches.add(mock);
 				}
 			}
			return next.filterCandidate(mockNameMatches, field, fields,
 					fieldInstance);
 			/*
 			 * In this case we have to check whether we have conflicting naming
@@ -39,7 +39,23 @@ public OngoingInjecter filterCandidate(Collection<Object> mocks,
 			 * whenever we find a field that does match its name with the mock
 			 * name, we should take that field instead.
 			 */
		} else if (mocks.size() == 1) {
			String mockName = mockUtil.getMockName(mocks.iterator().next())
					.toString();

			for (Field otherField : fields) {
				if (!otherField.equals(field)
						&& otherField.getType().equals(field.getType())
						&& otherField.getName().equals(mockName)) {

					return new OngoingInjecter() {
						public Object thenInject() {
							return null;
						}
					};
				}
			}
 		}
		return next.filterCandidate(mocks, field, fields, fieldInstance);
 	}
 }
/src/org/mockito/internal/configuration/injection/filter/TypeBasedCandidateFilter.java @@ -17,7 +17,7 @@ public TypeBasedCandidateFilter(MockCandidateFilter next) {
         this.next = next;
     }
 
  public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, List<Field> fields, Object fieldInstance) {
         List<Object> mockTypeMatches = new ArrayList<Object>();
         for (Object mock : mocks) {
             if (field.getType().isAssignableFrom(mock.getClass())) {
@@ -25,6 +25,6 @@ public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Ob
             }
         }
 
      return next.filterCandidate(mockTypeMatches, field, fields, fieldInstance);
     }
 }
","
     private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) {
         for (Iterator<Field> it = orderedInstanceFields.iterator(); it.hasNext(); ) {
             Field field = it.next();
            Object injected = mockCandidateFilter.filterCandidate(mocks, field, instance).thenInject();
             if (injected != null) {
                 injectionOccurred |= true;
                 mocks.remove(injected);

 
 import java.lang.reflect.Field;
 import java.util.Collection;
 
 public class FinalMockCandidateFilter implements MockCandidateFilter {
    public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance) {
         if(mocks.size() == 1) {
             final Object matchingMock = mocks.iterator().next();
 

 
 import java.lang.reflect.Field;
 import java.util.Collection;
 
 public interface MockCandidateFilter {
 
     OngoingInjecter filterCandidate(
             Collection<Object> mocks,
             Field fieldToBeInjected,
            Object fieldInstance
     );
 
 }

 	}
 
 	public OngoingInjecter filterCandidate(Collection<Object> mocks,
			Field field, Object fieldInstance) {
 		List<Object> mockNameMatches = new ArrayList<Object>();
 		if (mocks.size() > 1) {
 			for (Object mock : mocks) {

 					mockNameMatches.add(mock);
 				}
 			}
			return next.filterCandidate(mockNameMatches, field,
 					fieldInstance);
 			
 		}
-		return next.filterCandidate(mocks, field, fieldInstance);
 	}
 }

         this.next = next;
     }
 
    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) {
         List<Object> mockTypeMatches = new ArrayList<Object>();
         for (Object mock : mocks) {
             if (field.getType().isAssignableFrom(mock.getClass())) {

             }
         }
 
        return next.filterCandidate(mockTypeMatches, field, fieldInstance);
     }
 }
","
     private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) {
         for (Iterator<Field> it = orderedInstanceFields.iterator(); it.hasNext(); ) {
             Field field = it.next();
            Object injected = mockCandidateFilter.filterCandidate(mocks, field, orderedInstanceFields, instance).thenInject();
             if (injected != null) {
                 injectionOccurred |= true;
                 mocks.remove(injected);

 
 import java.lang.reflect.Field;
 import java.util.Collection;
 import java.util.List;
 public class FinalMockCandidateFilter implements MockCandidateFilter {
    public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, List<Field> fields, final Object fieldInstance) {
         if(mocks.size() == 1) {
             final Object matchingMock = mocks.iterator().next();
 

 
 import java.lang.reflect.Field;
 import java.util.Collection;
 import java.util.List;
 
 public interface MockCandidateFilter {
 
     OngoingInjecter filterCandidate(
             Collection<Object> mocks,
             Field fieldToBeInjected,
            List<Field> fields, Object instance
     );
 
 }

 	}
 
 	public OngoingInjecter filterCandidate(Collection<Object> mocks,
			Field field, List<Field> fields, Object fieldInstance) {
 		List<Object> mockNameMatches = new ArrayList<Object>();
 		if (mocks.size() > 1) {
 			for (Object mock : mocks) {

 					mockNameMatches.add(mock);
 				}
 			}
			return next.filterCandidate(mockNameMatches, field, fields,
 					fieldInstance);
		} else if (mocks.size() == 1) {
			String mockName = mockUtil.getMockName(mocks.iterator().next())
					.toString();			for (Field otherField : fields) {
				if (!otherField.equals(field)
						&& otherField.getType().equals(field.getType())
						&& otherField.getName().equals(mockName)) {					return new OngoingInjecter() {
						public Object thenInject() {
							return null;
						}
					};
				}
			}
 		}
		return next.filterCandidate(mocks, field, fields, fieldInstance);
 	}
 }

         this.next = next;
     }
 
    public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, List<Field> fields, Object fieldInstance) {
         List<Object> mockTypeMatches = new ArrayList<Object>();
         for (Object mock : mocks) {
             if (field.getType().isAssignableFrom(mock.getClass())) {

             }
         }
 
        return next.filterCandidate(mockTypeMatches, field, fields, fieldInstance);
     }
 }
"
352,"org.mockito.internal.creation.instance.InstantationException","/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java","@@ -14,18 +14,23 @@ public ConstructorInstantiator(Object outerClassInstance) {
         if (outerClassInstance == null) {
             return noArgConstructor(cls);
         }
      return withOuterClass(cls);
     }
 
  private <T> T withOuterClass(Class<T> cls) {
         try {
             //this is kind of overengineered because we don't need to support more params
             //however, I know we will be needing it :)
          Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());
          return c.newInstance(outerClassInstance);
         } catch (Exception e) {
             throw paramsException(cls, e);
         }
     }
 
     private static <T> InstantationException paramsException(Class<T> cls, Exception e) {
@@ -33,6 +38,17 @@ public ConstructorInstantiator(Object outerClassInstance) {
                 + cls.getSimpleName() + ""'.\nPlease ensure that the outer instance has correct type and that the target class has parameter-less constructor."", e);
     }
 
 
     private static <T> T noArgConstructor(Class<T> cls) {
         try {
","@@ -14,18 +14,23 @@ public ConstructorInstantiator(Object outerClassInstance) {
         if (outerClassInstance == null) {
             return noArgConstructor(cls);
         }
      return withParams(cls, outerClassInstance);
     }
 
  private static <T> T withParams(Class<T> cls, Object... params) {
         try {
             //this is kind of overengineered because we don't need to support more params
             //however, I know we will be needing it :)
          for (Constructor<?> constructor : cls.getDeclaredConstructors()) {
              Class<?>[] types = constructor.getParameterTypes();
              if (paramsMatch(types, params)) {
                  return (T) constructor.newInstance(params);
              }
          }
         } catch (Exception e) {
             throw paramsException(cls, e);
         }
      throw paramsException(cls, null);
     }
 
     private static <T> InstantationException paramsException(Class<T> cls, Exception e) {
@@ -33,6 +38,17 @@ public ConstructorInstantiator(Object outerClassInstance) {
                 + cls.getSimpleName() + ""'.\nPlease ensure that the outer instance has correct type and that the target class has parameter-less constructor."", e);
     }
 
  private static boolean paramsMatch(Class<?>[] types, Object[] params) {
      if (params.length != types.length) {
          return false;
      }
      for (int i = 0; i < params.length; i++) {
          if (!types[i].isInstance(params[i])) {
              return false;
          }
      }
      return true;
  }
 
     private static <T> T noArgConstructor(Class<T> cls) {
         try {
","
         if (outerClassInstance == null) {
             return noArgConstructor(cls);
         }
        return withOuterClass(cls);
     }
 
    private <T> T withOuterClass(Class<T> cls) {
         try {
                                      Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());
            return c.newInstance(outerClassInstance);
         } catch (Exception e) {
             throw paramsException(cls, e);
         }
     }
 
     private static <T> InstantationException paramsException(Class<T> cls, Exception e) {

                 + cls.getSimpleName() + ""'.\nPlease ensure that the outer instance has correct type and that the target class has parameter-less constructor."", e);
     }
 
 
     private static <T> T noArgConstructor(Class<T> cls) {
         try {
","
         if (outerClassInstance == null) {
             return noArgConstructor(cls);
         }
        return withParams(cls, outerClassInstance);
     }
 
    private static <T> T withParams(Class<T> cls, Object... params) {
         try {
                                      for (Constructor<?> constructor : cls.getDeclaredConstructors()) {
                Class<?>[] types = constructor.getParameterTypes();
                if (paramsMatch(types, params)) {
                    return (T) constructor.newInstance(params);
                }
            }
         } catch (Exception e) {
             throw paramsException(cls, e);
         }
        throw paramsException(cls, null);
     }
 
     private static <T> InstantationException paramsException(Class<T> cls, Exception e) {

                 + cls.getSimpleName() + ""'.\nPlease ensure that the outer instance has correct type and that the target class has parameter-less constructor."", e);
     }
 
    private static boolean paramsMatch(Class<?>[] types, Object[] params) {
        if (params.length != types.length) {
            return false;
        }
        for (int i = 0; i < params.length; i++) {
            if (!types[i].isInstance(params[i])) {
                return false;
            }
        }
        return true;
    }
 
     private static <T> T noArgConstructor(Class<T> cls) {
         try {
"
353,"java.io.NotSerializableException","/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java","@@ -41,14 +41,16 @@
     
     private static final long serialVersionUID = -7105341425736035847L;
 
  private MockitoCore mockitoCore = new MockitoCore();
  private ReturnsEmptyValues delegate = new ReturnsEmptyValues();
 
     public Object answer(InvocationOnMock invocation) throws Throwable {
         GenericMetadataSupport returnTypeGenericMetadata =
                 actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());
 
         Class<?> rawType = returnTypeGenericMetadata.rawType();
         if (!mockitoCore.isTypeMockable(rawType)) {
             return delegate.returnValueFor(rawType);
         }
@@ -56,7 +58,17 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
         return getMock(invocation, returnTypeGenericMetadata);
     }
 
 
 
     private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {
     	InternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());
@@ -97,6 +109,7 @@ private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericM
                 : withSettings();
 
         return mockSettings
                 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));
     }
 
@@ -111,7 +124,7 @@ protected GenericMetadataSupport actualParameterizedType(Object mock) {
 
     private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {
 
      container.addAnswer(new Answer<Object>() {
             public Object answer(InvocationOnMock invocation) throws Throwable {
                 return mock;
             }
@@ -120,7 +133,9 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
         return mock;
     }
 	
 		
 	
 
     protected GenericMetadataSupport actualParameterizedType(Object mock) {
","@@ -41,14 +41,16 @@
     
     private static final long serialVersionUID = -7105341425736035847L;
 
  private transient MockitoCore mockitoCore;
  private transient ReturnsEmptyValues delegate;
 
     public Object answer(InvocationOnMock invocation) throws Throwable {
         GenericMetadataSupport returnTypeGenericMetadata =
                 actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());
 
         Class<?> rawType = returnTypeGenericMetadata.rawType();
      instantiateMockitoCoreIfNeeded();
      instantiateDelegateIfNeeded();
         if (!mockitoCore.isTypeMockable(rawType)) {
             return delegate.returnValueFor(rawType);
         }
@@ -56,7 +58,17 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
         return getMock(invocation, returnTypeGenericMetadata);
     }
 
  private synchronized void instantiateMockitoCoreIfNeeded() {
      if (mockitoCore == null) {
          mockitoCore = new MockitoCore();
      }
  }
 
  private synchronized void instantiateDelegateIfNeeded() {
      if (delegate == null) {
          delegate = new ReturnsEmptyValues();
      }
  }
 
     private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {
     	InternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());
@@ -97,6 +109,7 @@ private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericM
                 : withSettings();
 
         return mockSettings
		        .serializable()
                 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));
     }
 
@@ -111,7 +124,7 @@ protected GenericMetadataSupport actualParameterizedType(Object mock) {
 
     private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {
 
      container.addAnswer(new SerializableAnswer() {
             public Object answer(InvocationOnMock invocation) throws Throwable {
                 return mock;
             }
@@ -120,7 +133,9 @@ public Object answer(InvocationOnMock invocation) throws Throwable {
         return mock;
     }
 	
	abstract class SerializableAnswer implements Answer<Object>, Serializable {
 		
	}
 	
 
     protected GenericMetadataSupport actualParameterizedType(Object mock) {
","
     
     private static final long serialVersionUID = -7105341425736035847L;
 
    private MockitoCore mockitoCore = new MockitoCore();
    private ReturnsEmptyValues delegate = new ReturnsEmptyValues();
 
     public Object answer(InvocationOnMock invocation) throws Throwable {
         GenericMetadataSupport returnTypeGenericMetadata =
                 actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());
 
         Class<?> rawType = returnTypeGenericMetadata.rawType();
         if (!mockitoCore.isTypeMockable(rawType)) {
             return delegate.returnValueFor(rawType);
         }

         return getMock(invocation, returnTypeGenericMetadata);
     }
 
 
 
     private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {
     	InternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());

                 : withSettings();
 
         return mockSettings
+		        .serializable()
                 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));
     }
 

 
     private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {
 
        container.addAnswer(new Answer<Object>() {
             public Object answer(InvocationOnMock invocation) throws Throwable {
                 return mock;
             }

         return mock;
     }
 	
+	abstract class SerializableAnswer implements Answer<Object>, Serializable {
 		
+	}
 	
 
     protected GenericMetadataSupport actualParameterizedType(Object mock) {
","
     
     private static final long serialVersionUID = -7105341425736035847L;
 
    private transient MockitoCore mockitoCore;
    private transient ReturnsEmptyValues delegate;
 
     public Object answer(InvocationOnMock invocation) throws Throwable {
         GenericMetadataSupport returnTypeGenericMetadata =
                 actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());
 
         Class<?> rawType = returnTypeGenericMetadata.rawType();
        instantiateMockitoCoreIfNeeded();
        instantiateDelegateIfNeeded();
         if (!mockitoCore.isTypeMockable(rawType)) {
             return delegate.returnValueFor(rawType);
         }

         return getMock(invocation, returnTypeGenericMetadata);
     }
 
    private synchronized void instantiateMockitoCoreIfNeeded() {
        if (mockitoCore == null) {
            mockitoCore = new MockitoCore();
        }
    }
 
    private synchronized void instantiateDelegateIfNeeded() {
        if (delegate == null) {
            delegate = new ReturnsEmptyValues();
        }
    }
 
     private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {
     	InternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());

                 : withSettings();
 
         return mockSettings
		        .serializable()
                 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));
     }
 

 
     private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {
 
        container.addAnswer(new SerializableAnswer() {
             public Object answer(InvocationOnMock invocation) throws Throwable {
                 return mock;
             }

         return mock;
     }
 	
	abstract class SerializableAnswer implements Answer<Object>, Serializable {
 		
	}
 	
 
     protected GenericMetadataSupport actualParameterizedType(Object mock) {
"
354,"junit.framework.AssertionFailedError","/src/org/mockito/internal/configuration/DefaultInjectionEngine.java","@@ -90,7 +90,8 @@ public void injectMocksOnFields(Set<Field> injectMocksFields, Set<Object> mocks,
 
     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {
         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {
          mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();
         }
     }
 
","@@ -90,7 +90,8 @@ public void injectMocksOnFields(Set<Field> injectMocksFields, Set<Object> mocks,
 
     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {
         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {
          Object injected = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();
          mocks.remove(injected);
         }
     }
 
","
 
     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {
         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {
            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();
         }
     }
 
","
 
     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {
         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {
            Object injected = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();
            mocks.remove(injected);
         }
     }
 
"
355,"junit.framework.AssertionFailedError","/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java","@@ -73,7 +73,7 @@ public Object answer(InvocationOnMock invocation) {
             //see issue 184.
             //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).
             //Only for compareTo() method by the Comparable interface
          return 1;
         }
         
         Class<?> returnType = invocation.getMethod().getReturnType();
","@@ -73,7 +73,7 @@ public Object answer(InvocationOnMock invocation) {
             //see issue 184.
             //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).
             //Only for compareTo() method by the Comparable interface
          return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;
         }
         
         Class<?> returnType = invocation.getMethod().getReturnType();
","
                                                   return 1;
         }
         
         Class<?> returnType = invocation.getMethod().getReturnType();
","
                                                   return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;
         }
         
         Class<?> returnType = invocation.getMethod().getReturnType();
"
356,"java.lang.Exception","/src/org/mockito/internal/matchers/Same.java","@@ -26,7 +26,7 @@ public boolean matches(Object actual) {
     public void describeTo(Description description) {
         description.appendText(""same("");
         appendQuoting(description);
      description.appendText(wanted.toString());
         appendQuoting(description);
         description.appendText("")"");
     }
","@@ -26,7 +26,7 @@ public boolean matches(Object actual) {
     public void describeTo(Description description) {
         description.appendText(""same("");
         appendQuoting(description);
      description.appendText(wanted == null ? ""null"" : wanted.toString());
         appendQuoting(description);
         description.appendText("")"");
     }
","
     public void describeTo(Description description) {
         description.appendText(""same("");
         appendQuoting(description);
        description.appendText(wanted.toString());
         appendQuoting(description);
         description.appendText("")"");
     }
","
     public void describeTo(Description description) {
         description.appendText(""same("");
         appendQuoting(description);
        description.appendText(wanted == null ? ""null"" : wanted.toString());
         appendQuoting(description);
         description.appendText("")"");
     }
"
357,"java.lang.ClassCastException","/src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java","@@ -1,85 +1,108 @@
 /*
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
 package org.mockito.internal.stubbing.defaultanswers;
 
 import org.mockito.MockSettings;
 import org.mockito.internal.InternalMockHandler;
 import org.mockito.internal.creation.settings.CreationSettings;
 import org.mockito.internal.stubbing.InvocationContainerImpl;
 import org.mockito.internal.stubbing.StubbedInvocationMatcher;
 import org.mockito.internal.util.MockCreationValidator;
 import org.mockito.internal.util.MockUtil;
 import org.mockito.internal.util.reflection.GenericMetadataSupport;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 
 import java.io.Serializable;
 
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.withSettings;
 
 /**
  * Returning deep stub implementation.
  *
  * Will return previously created mock if the invocation matches.
  *
  * <p>Supports nested generic information, with this answer you can write code like this :
  *
  * <pre class=""code""><code class=""java"">
  *     interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; {}
  *
  *     GenericsNest&lt;?&gt; mock = mock(GenericsNest.class, new ReturnsGenericDeepStubs());
  *     Number number = mock.entrySet().iterator().next().getValue().iterator().next();
  * </code></pre>
  * </p>
  *
  * @see org.mockito.Mockito#RETURNS_DEEP_STUBS
  * @see org.mockito.Answers#RETURNS_DEEP_STUBS
  */
 public class ReturnsDeepStubs implements Answer<Object>, Serializable {
     
     private static final long serialVersionUID = -7105341425736035847L;
 
     private ReturnsEmptyValues delegate = new ReturnsEmptyValues();
 
     public Object answer(InvocationOnMock invocation) throws Throwable {
         GenericMetadataSupport returnTypeGenericMetadata =
                 actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());
 
         Class<?> rawType = returnTypeGenericMetadata.rawType();
         if (!new MockCreationValidator().isTypeMockable(rawType)) {
             return delegate.returnValueFor(rawType);
         }
 
      return getMock(invocation);
     }
 
  private Object getMock(InvocationOnMock invocation) throws Throwable {
     	InternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());
     	InvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();
 
         // matches invocation for verification
         for (StubbedInvocationMatcher stubbedInvocationMatcher : container.getStubbedInvocations()) {
     		if(container.getInvocationForStubbing().matches(stubbedInvocationMatcher.getInvocation())) {
     			return stubbedInvocationMatcher.answer(invocation);
     		}
 		}
 
         // deep stub
      return recordDeepStubMock(invocation, container);
     }
 
     /**
      * Creates a mock using the Generics Metadata.
      *
      * @param returnTypeGenericMetadata The metadata to use to create the new mock.
      * @return The mock
      */
 
 
 
 
  private Object recordDeepStubMock(InvocationOnMock invocation, InvocationContainerImpl container) {
      Class<?> clz = invocation.getMethod().getReturnType();
      final Object mock = org.mockito.Mockito.mock(clz, this);
 
         container.addAnswer(new Answer<Object>() {
","@@ -1,85 +1,108 @@
 /*
  * Copyright (c) 2007 Mockito contributors
  * This program is made available under the terms of the MIT License.
  */
 package org.mockito.internal.stubbing.defaultanswers;
 
 import org.mockito.MockSettings;
 import org.mockito.internal.InternalMockHandler;
 import org.mockito.internal.creation.settings.CreationSettings;
 import org.mockito.internal.stubbing.InvocationContainerImpl;
 import org.mockito.internal.stubbing.StubbedInvocationMatcher;
 import org.mockito.internal.util.MockCreationValidator;
 import org.mockito.internal.util.MockUtil;
 import org.mockito.internal.util.reflection.GenericMetadataSupport;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 
 import java.io.Serializable;
 
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.withSettings;
 
 /**
  * Returning deep stub implementation.
  *
  * Will return previously created mock if the invocation matches.
  *
  * <p>Supports nested generic information, with this answer you can write code like this :
  *
  * <pre class=""code""><code class=""java"">
  *     interface GenericsNest&lt;K extends Comparable&lt;K&gt; & Cloneable&gt; extends Map&lt;K, Set&lt;Number&gt;&gt; {}
  *
  *     GenericsNest&lt;?&gt; mock = mock(GenericsNest.class, new ReturnsGenericDeepStubs());
  *     Number number = mock.entrySet().iterator().next().getValue().iterator().next();
  * </code></pre>
  * </p>
  *
  * @see org.mockito.Mockito#RETURNS_DEEP_STUBS
  * @see org.mockito.Answers#RETURNS_DEEP_STUBS
  */
 public class ReturnsDeepStubs implements Answer<Object>, Serializable {
     
     private static final long serialVersionUID = -7105341425736035847L;
 
     private ReturnsEmptyValues delegate = new ReturnsEmptyValues();
 
     public Object answer(InvocationOnMock invocation) throws Throwable {
         GenericMetadataSupport returnTypeGenericMetadata =
                 actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());
 
         Class<?> rawType = returnTypeGenericMetadata.rawType();
         if (!new MockCreationValidator().isTypeMockable(rawType)) {
             return delegate.returnValueFor(rawType);
         }
 
      return getMock(invocation, returnTypeGenericMetadata);
     }
 
  private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {
     	InternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());
     	InvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();
 
         // matches invocation for verification
         for (StubbedInvocationMatcher stubbedInvocationMatcher : container.getStubbedInvocations()) {
     		if(container.getInvocationForStubbing().matches(stubbedInvocationMatcher.getInvocation())) {
     			return stubbedInvocationMatcher.answer(invocation);
     		}
 		}
 
         // deep stub
      return recordDeepStubMock(createNewDeepStubMock(returnTypeGenericMetadata), container);
     }
 
     /**
      * Creates a mock using the Generics Metadata.
      *
      * @param returnTypeGenericMetadata The metadata to use to create the new mock.
      * @return The mock
      */
  private Object createNewDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {
      return mock(
              returnTypeGenericMetadata.rawType(),
              withSettingsUsing(returnTypeGenericMetadata)
      );
  }
 
  private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) {
      MockSettings mockSettings =
              returnTypeGenericMetadata.rawExtraInterfaces().length > 0 ?
              withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())
              : withSettings();
 
      return mockSettings
              .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));
  }
 
  private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {
      return new ReturnsDeepStubs() {
          @Override
          protected GenericMetadataSupport actualParameterizedType(Object mock) {
              return returnTypeGenericMetadata;
          }
      };
  }
 
  private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {
 
         container.addAnswer(new Answer<Object>() {
","
 package org.mockito.internal.stubbing.defaultanswers;
 
 import org.mockito.internal.InternalMockHandler;
 import org.mockito.internal.creation.settings.CreationSettings;
 import org.mockito.internal.stubbing.InvocationContainerImpl;
 import org.mockito.internal.stubbing.StubbedInvocationMatcher;
 import org.mockito.internal.util.MockCreationValidator;
 import org.mockito.internal.util.MockUtil;
 import org.mockito.internal.util.reflection.GenericMetadataSupport;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 
 import java.io.Serializable;
 public class ReturnsDeepStubs implements Answer<Object>, Serializable {
     
     private static final long serialVersionUID = -7105341425736035847L;
 
     private ReturnsEmptyValues delegate = new ReturnsEmptyValues();
 
     public Object answer(InvocationOnMock invocation) throws Throwable {
         GenericMetadataSupport returnTypeGenericMetadata =
                 actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());
 
         Class<?> rawType = returnTypeGenericMetadata.rawType();
         if (!new MockCreationValidator().isTypeMockable(rawType)) {
             return delegate.returnValueFor(rawType);
         }
 
        return getMock(invocation);
     }
 
    private Object getMock(InvocationOnMock invocation) throws Throwable {
     	InternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());
     	InvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();
 
                  for (StubbedInvocationMatcher stubbedInvocationMatcher : container.getStubbedInvocations()) {
     		if(container.getInvocationForStubbing().matches(stubbedInvocationMatcher.getInvocation())) {
     			return stubbedInvocationMatcher.answer(invocation);
     		}
 		}
 
                 return recordDeepStubMock(invocation, container);
     }
 
 
 
 
 
    private Object recordDeepStubMock(InvocationOnMock invocation, InvocationContainerImpl container) {
        Class<?> clz = invocation.getMethod().getReturnType();
        final Object mock = org.mockito.Mockito.mock(clz, this);
 
         container.addAnswer(new Answer<Object>() {
","
 package org.mockito.internal.stubbing.defaultanswers;
 
 import org.mockito.MockSettings;
 import org.mockito.internal.InternalMockHandler;
 import org.mockito.internal.creation.settings.CreationSettings;
 import org.mockito.internal.stubbing.InvocationContainerImpl;
 import org.mockito.internal.stubbing.StubbedInvocationMatcher;
 import org.mockito.internal.util.MockCreationValidator;
 import org.mockito.internal.util.MockUtil;
 import org.mockito.internal.util.reflection.GenericMetadataSupport;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 
 import java.io.Serializable;
 
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.withSettings;
 
 public class ReturnsDeepStubs implements Answer<Object>, Serializable {
     
     private static final long serialVersionUID = -7105341425736035847L;
 
     private ReturnsEmptyValues delegate = new ReturnsEmptyValues();
 
     public Object answer(InvocationOnMock invocation) throws Throwable {
         GenericMetadataSupport returnTypeGenericMetadata =
                 actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());
 
         Class<?> rawType = returnTypeGenericMetadata.rawType();
         if (!new MockCreationValidator().isTypeMockable(rawType)) {
             return delegate.returnValueFor(rawType);
         }
 
        return getMock(invocation, returnTypeGenericMetadata);
     }
 
    private Object getMock(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {
     	InternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());
     	InvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();
 
                  for (StubbedInvocationMatcher stubbedInvocationMatcher : container.getStubbedInvocations()) {
     		if(container.getInvocationForStubbing().matches(stubbedInvocationMatcher.getInvocation())) {
     			return stubbedInvocationMatcher.answer(invocation);
     		}
 		}
 
                 return recordDeepStubMock(createNewDeepStubMock(returnTypeGenericMetadata), container);
     }
    private Object createNewDeepStubMock(GenericMetadataSupport returnTypeGenericMetadata) {
        return mock(
                returnTypeGenericMetadata.rawType(),
                withSettingsUsing(returnTypeGenericMetadata)
        );
    }
 
    private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) {
        MockSettings mockSettings =
                returnTypeGenericMetadata.rawExtraInterfaces().length > 0 ?
                withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())
                : withSettings();
 
        return mockSettings
                .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));
    }
 
    private ReturnsDeepStubs returnsDeepStubsAnswerUsing(final GenericMetadataSupport returnTypeGenericMetadata) {
        return new ReturnsDeepStubs() {
            @Override
            protected GenericMetadataSupport actualParameterizedType(Object mock) {
                return returnTypeGenericMetadata;
            }
        };
    }
 
    private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {
 
         container.addAnswer(new Answer<Object>() {
"
358,"junit.framework.AssertionFailedError","/src/org/mockito/internal/util/MockUtil.java","@@ -61,8 +61,7 @@ public MockUtil() {
 
     public <T> void resetMock(T mock) {
         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);
      MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);
      MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));
         ((Factory) mock).setCallback(0, newFilter);
     }
 
","@@ -61,8 +61,7 @@ public MockUtil() {
 
     public <T> void resetMock(T mock) {
         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);
      MethodInterceptorFilter newFilter = newMethodInterceptorFilter(oldMockHandler.getMockSettings());
         ((Factory) mock).setCallback(0, newFilter);
     }
 
","
 
     public <T> void resetMock(T mock) {
         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);
        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);
        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));
         ((Factory) mock).setCallback(0, newFilter);
     }
 
","
 
     public <T> void resetMock(T mock) {
         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);
        MethodInterceptorFilter newFilter = newMethodInterceptorFilter(oldMockHandler.getMockSettings());
         ((Factory) mock).setCallback(0, newFilter);
     }
 
"
359,"java.lang.ClassCastException","/src/org/mockito/internal/util/Primitives.java","@@ -63,6 +63,6 @@ public static boolean isPrimitiveWrapper(Class<?> type) {
         primitiveValues.put(int.class, 0);
         primitiveValues.put(long.class, 0L);
         primitiveValues.put(float.class, 0F);
      primitiveValues.put(double.class, 0);
     }
 }
\ No newline at end of file
","@@ -63,6 +63,6 @@ public static boolean isPrimitiveWrapper(Class<?> type) {
         primitiveValues.put(int.class, 0);
         primitiveValues.put(long.class, 0L);
         primitiveValues.put(float.class, 0F);
      primitiveValues.put(double.class, 0D);
     }
 }
\ No newline at end of file
","
         primitiveValues.put(int.class, 0);
         primitiveValues.put(long.class, 0L);
         primitiveValues.put(float.class, 0F);
        primitiveValues.put(double.class, 0);
     }
 }
\ No newline at end of file
","
         primitiveValues.put(int.class, 0);
         primitiveValues.put(long.class, 0L);
         primitiveValues.put(float.class, 0F);
        primitiveValues.put(double.class, 0D);
     }
 }
\ No newline at end of file
"
360,"junit.framework.AssertionFailedError","/src/org/mockito/internal/configuration/SpyAnnotationEngine.java","@@ -16,6 +16,7 @@
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.util.MockUtil;
 
 import static org.mockito.Mockito.withSettings;
 
 @SuppressWarnings({""unchecked""})
 public class SpyAnnotationEngine implements AnnotationEngine {
@@ -46,7 +47,10 @@ public void process(Class<?> context, Object testClass) {
                         // instance has been spied earlier
                         Mockito.reset(instance);
                     } else {
                      field.set(testClass, Mockito.spy(instance));
                     }
                 } catch (IllegalAccessException e) {
                     throw new MockitoException(""Problems initiating spied field "" + field.getName(), e);
","@@ -16,6 +16,7 @@
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.util.MockUtil;
 
 import static org.mockito.Mockito.withSettings;
 
 @SuppressWarnings({""unchecked""})
 public class SpyAnnotationEngine implements AnnotationEngine {
@@ -46,7 +47,10 @@ public void process(Class<?> context, Object testClass) {
                         // instance has been spied earlier
                         Mockito.reset(instance);
                     } else {
                      field.set(testClass, Mockito.mock(instance.getClass(), withSettings()
                              .spiedInstance(instance)
                              .defaultAnswer(Mockito.CALLS_REAL_METHODS)
                              .name(field.getName())));
                     }
                 } catch (IllegalAccessException e) {
                     throw new MockitoException(""Problems initiating spied field "" + field.getName(), e);
","
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.util.MockUtil;
 
 
 @SuppressWarnings({""unchecked""})
 public class SpyAnnotationEngine implements AnnotationEngine {

                                                  Mockito.reset(instance);
                     } else {
                        field.set(testClass, Mockito.spy(instance));
                     }
                 } catch (IllegalAccessException e) {
                     throw new MockitoException(""Problems initiating spied field "" + field.getName(), e);
","
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.util.MockUtil;
 
 import static org.mockito.Mockito.withSettings;
 
 @SuppressWarnings({""unchecked""})
 public class SpyAnnotationEngine implements AnnotationEngine {

                                                  Mockito.reset(instance);
                     } else {
                        field.set(testClass, Mockito.mock(instance.getClass(), withSettings()
                                .spiedInstance(instance)
                                .defaultAnswer(Mockito.CALLS_REAL_METHODS)
                                .name(field.getName())));
                     }
                 } catch (IllegalAccessException e) {
                     throw new MockitoException(""Problems initiating spied field "" + field.getName(), e);
"
361,"junit.framework.ComparisonFailure","/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java","@@ -6,6 +6,7 @@
 
 import java.io.Serializable;
 import java.lang.reflect.Method;
 import java.util.Arrays;
 
 import org.mockito.Mockito;
 import org.mockito.cglib.proxy.MethodInterceptor;
@@ -57,7 +58,8 @@ public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr
         }
 
 		private String formatMethodCall() {
		return invocation.getMethod().getName() + ""()"";
 		}
     }
 
","@@ -6,6 +6,7 @@
 
 import java.io.Serializable;
 import java.lang.reflect.Method;
 import java.util.Arrays;
 
 import org.mockito.Mockito;
 import org.mockito.cglib.proxy.MethodInterceptor;
@@ -57,7 +58,8 @@ public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr
         }
 
 		private String formatMethodCall() {
			String args = Arrays.toString(invocation.getArguments());
			return invocation.getMethod().getName() + ""("" + args.substring(1, args.length() - 1) +	"")"";
 		}
     }
 
","
 
 import java.io.Serializable;
 import java.lang.reflect.Method;
 
 import org.mockito.Mockito;
 import org.mockito.cglib.proxy.MethodInterceptor;

         }
 
 		private String formatMethodCall() {
-			return invocation.getMethod().getName() + ""()"";
 		}
     }
 
","
 
 import java.io.Serializable;
 import java.lang.reflect.Method;
 import java.util.Arrays;
 
 import org.mockito.Mockito;
 import org.mockito.cglib.proxy.MethodInterceptor;

         }
 
 		private String formatMethodCall() {
			String args = Arrays.toString(invocation.getArguments());
			return invocation.getMethod().getName() + ""("" + args.substring(1, args.length() - 1) +	"")"";
 		}
     }
 
"
362,"java.lang.ArrayIndexOutOfBoundsException","/src/org/mockito/internal/invocation/InvocationMatcher.java","@@ -103,7 +103,7 @@ public String toString(PrintSettings printSettings) {
     public void captureArgumentsFrom(Invocation i) {
         int k = 0;
         for (Matcher m : matchers) {
          if (m instanceof CapturesArguments) {
                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);
             }
             k++;
","@@ -103,7 +103,7 @@ public String toString(PrintSettings printSettings) {
     public void captureArgumentsFrom(Invocation i) {
         int k = 0;
         for (Matcher m : matchers) {
          if (m instanceof CapturesArguments && i.getArguments().length > k) {
                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);
             }
             k++;
","
     public void captureArgumentsFrom(Invocation i) {
         int k = 0;
         for (Matcher m : matchers) {
            if (m instanceof CapturesArguments) {
                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);
             }
             k++;
","
     public void captureArgumentsFrom(Invocation i) {
         int k = 0;
         for (Matcher m : matchers) {
            if (m instanceof CapturesArguments && i.getArguments().length > k) {
                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);
             }
             k++;
"
363,"java.lang.NullPointerException","/src/org/mockito/internal/invocation/Invocation.java","@@ -8,6 +8,7 @@
 
 import org.hamcrest.Matcher;
 import org.mockito.exceptions.PrintableInvocation;
 import org.mockito.exceptions.Reporter;
 import org.mockito.internal.debugging.Location;
 import org.mockito.internal.invocation.realmethod.RealMethod;
 import org.mockito.internal.matchers.*;
@@ -199,6 +200,9 @@ public int getArgumentsCount() {
     }
 
     public Object callRealMethod() throws Throwable {
         return realMethod.invoke(mock, rawArguments);
     }
 
","@@ -8,6 +8,7 @@
 
 import org.hamcrest.Matcher;
 import org.mockito.exceptions.PrintableInvocation;
 import org.mockito.exceptions.Reporter;
 import org.mockito.internal.debugging.Location;
 import org.mockito.internal.invocation.realmethod.RealMethod;
 import org.mockito.internal.matchers.*;
@@ -199,6 +200,9 @@ public int getArgumentsCount() {
     }
 
     public Object callRealMethod() throws Throwable {
      if (this.getMethod().getDeclaringClass().isInterface()) {
          new Reporter().cannotCallRealMethodOnInterface();
      }
         return realMethod.invoke(mock, rawArguments);
     }
 
","
 
 import org.hamcrest.Matcher;
 import org.mockito.exceptions.PrintableInvocation;
 import org.mockito.internal.debugging.Location;
 import org.mockito.internal.invocation.realmethod.RealMethod;
 import org.mockito.internal.matchers.*;

     }
 
     public Object callRealMethod() throws Throwable {
         return realMethod.invoke(mock, rawArguments);
     }
 
","
 
 import org.hamcrest.Matcher;
 import org.mockito.exceptions.PrintableInvocation;
 import org.mockito.exceptions.Reporter;
 import org.mockito.internal.debugging.Location;
 import org.mockito.internal.invocation.realmethod.RealMethod;
 import org.mockito.internal.matchers.*;

     }
 
     public Object callRealMethod() throws Throwable {
        if (this.getMethod().getDeclaringClass().isInterface()) {
            new Reporter().cannotCallRealMethodOnInterface();
        }
         return realMethod.invoke(mock, rawArguments);
     }
 
"
364,"junit.framework.AssertionFailedError","/src/org/mockito/internal/invocation/InvocationMatcher.java","@@ -95,8 +95,19 @@ public boolean hasSameMethod(Invocation candidate) {
         Method m1 = invocation.getMethod();
         Method m2 = candidate.getMethod();
         
         	/* Avoid unnecessary cloning */
      return m1.equals(m2);
     }
     
     public Location getLocation() {
","@@ -95,8 +95,19 @@ public boolean hasSameMethod(Invocation candidate) {
         Method m1 = invocation.getMethod();
         Method m2 = candidate.getMethod();
         
      if (m1.getName() != null && m1.getName().equals(m2.getName())) {
         	/* Avoid unnecessary cloning */
      	Class[] params1 = m1.getParameterTypes();
      	Class[] params2 = m2.getParameterTypes();
      	if (params1.length == params2.length) {
      	    for (int i = 0; i < params1.length; i++) {
      		if (params1[i] != params2[i])
      		    return false;
      	    }
      	    return true;
      	}
      }
      return false;
     }
     
     public Location getLocation() {
","
         Method m1 = invocation.getMethod();
         Method m2 = candidate.getMethod();
         
        return m1.equals(m2);
     }
     
     public Location getLocation() {
","
         Method m1 = invocation.getMethod();
         Method m2 = candidate.getMethod();
         
        if (m1.getName() != null && m1.getName().equals(m2.getName())) {
        	Class[] params1 = m1.getParameterTypes();
        	Class[] params2 = m2.getParameterTypes();
        	if (params1.length == params2.length) {
        	    for (int i = 0; i < params1.length; i++) {
        		if (params1[i] != params2[i])
        		    return false;
        	    }
        	    return true;
        	}
        }
        return false;
     }
     
     public Location getLocation() {
"
365,"java.lang.NullPointerException","/src/org/mockito/Matchers.java","@@ -359,7 +359,7 @@ public static Collection anyCollection() {
      * @return <code>null</code>.
      */
     public static <T> T isA(Class<T> clazz) {
      return reportMatcher(new InstanceOf(clazz)).<T>returnNull();
     }
 
     /**
@@ -476,7 +476,7 @@ public static short eq(short value) {
      * @return <code>null</code>.
      */
     public static <T> T eq(T value) {
      return reportMatcher(new Equals(value)).<T>returnNull();
     }  
 
     /**
@@ -513,7 +513,7 @@ public static short eq(short value) {
      * @return <code>null</code>.
      */
     public static <T> T same(T value) {
      return reportMatcher(new Same(value)).<T>returnNull();
     }
 
     /**
","@@ -359,7 +359,7 @@ public static Collection anyCollection() {
      * @return <code>null</code>.
      */
     public static <T> T isA(Class<T> clazz) {
      return reportMatcher(new InstanceOf(clazz)).<T>returnFor(clazz);
     }
 
     /**
@@ -476,7 +476,7 @@ public static short eq(short value) {
      * @return <code>null</code>.
      */
     public static <T> T eq(T value) {
      return (T) reportMatcher(new Equals(value)).<T>returnFor((Class) value.getClass());
     }  
 
     /**
@@ -513,7 +513,7 @@ public static short eq(short value) {
      * @return <code>null</code>.
      */
     public static <T> T same(T value) {
      return (T) reportMatcher(new Same(value)).<T>returnFor((Class) value.getClass());
     }
 
     /**
","
     public static <T> T isA(Class<T> clazz) {
        return reportMatcher(new InstanceOf(clazz)).<T>returnNull();
     }
 

     public static <T> T eq(T value) {
        return reportMatcher(new Equals(value)).<T>returnNull();
     }  
 

     public static <T> T same(T value) {
        return reportMatcher(new Same(value)).<T>returnNull();
     }
 
","
     public static <T> T isA(Class<T> clazz) {
        return reportMatcher(new InstanceOf(clazz)).<T>returnFor(clazz);
     }
 

     public static <T> T eq(T value) {
        return (T) reportMatcher(new Equals(value)).<T>returnFor((Class) value.getClass());
     }  
 

     public static <T> T same(T value) {
        return (T) reportMatcher(new Same(value)).<T>returnFor((Class) value.getClass());
     }
 
"
366,"junit.framework.AssertionFailedError","/src/org/mockito/exceptions/Reporter.java","@@ -435,10 +435,11 @@ public void misplacedArgumentMatcher(Location location) {
                 ));
     }
 
  public void smartNullPointerException(Location location) {
         throw new SmartNullPointerException(join(
                 ""You have a NullPointerException here:"",
                 new Location(),
                 ""Because this method was *not* stubbed correctly:"",
                 location,
                 """"
/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java @@ -53,7 +53,7 @@ public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr
                 return ""SmartNull returned by unstubbed "" + formatMethodCall()  + "" method on mock"";
             }
 
          new Reporter().smartNullPointerException(location);
             return null;
         }
 
","@@ -435,10 +435,11 @@ public void misplacedArgumentMatcher(Location location) {
                 ));
     }
 
  public void smartNullPointerException(Object obj, Location location) {
         throw new SmartNullPointerException(join(
                 ""You have a NullPointerException here:"",
                 new Location(),
              obj,
                 ""Because this method was *not* stubbed correctly:"",
                 location,
                 """"
/src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java @@ -53,7 +53,7 @@ public Object intercept(Object obj, Method method, Object[] args, MethodProxy pr
                 return ""SmartNull returned by unstubbed "" + formatMethodCall()  + "" method on mock"";
             }
 
          new Reporter().smartNullPointerException(obj, location);
             return null;
         }
 
","
                 ));
     }
 
    public void smartNullPointerException(Location location) {
         throw new SmartNullPointerException(join(
                 ""You have a NullPointerException here:"",
                 new Location(),
                 ""Because this method was *not* stubbed correctly:"",
                 location,
                 """"

                 return ""SmartNull returned by unstubbed "" + formatMethodCall()  + "" method on mock"";
             }
 
            new Reporter().smartNullPointerException(location);
             return null;
         }
 
","
                 ));
     }
 
    public void smartNullPointerException(Object obj, Location location) {
         throw new SmartNullPointerException(join(
                 ""You have a NullPointerException here:"",
                 new Location(),
                obj,
                 ""Because this method was *not* stubbed correctly:"",
                 location,
                 """"

                 return ""SmartNull returned by unstubbed "" + formatMethodCall()  + "" method on mock"";
             }
 
            new Reporter().smartNullPointerException(obj, location);
             return null;
         }
 
"
367,"java.lang.NullPointerException","/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java","@@ -45,6 +45,6 @@ private boolean safelyMatches(Matcher m, Object arg) {
     }
 
     private boolean toStringEquals(Matcher m, Object arg) {
      return StringDescription.toString(m).equals(arg.toString());
     }
 }
","@@ -45,6 +45,6 @@ private boolean safelyMatches(Matcher m, Object arg) {
     }
 
     private boolean toStringEquals(Matcher m, Object arg) {
      return StringDescription.toString(m).equals(arg == null? ""null"" : arg.toString());
     }
 }
","
     }
 
     private boolean toStringEquals(Matcher m, Object arg) {
        return StringDescription.toString(m).equals(arg.toString());
     }
 }
","
     }
 
     private boolean toStringEquals(Matcher m, Object arg) {
        return StringDescription.toString(m).equals(arg == null? ""null"" : arg.toString());
     }
 }
"
368,"java.lang.UnsupportedOperationException","/src/main/java/org/joda/time/Period.java","@@ -1625,13 +1625,19 @@ public Period normalizedStandard(PeriodType type) {
         int years = getYears();
         int months = getMonths();
         if (years != 0 || months != 0) {
          years = FieldUtils.safeAdd(years, months / 12);
          months = months % 12;
          if (years != 0) {
              result = result.withYears(years);
             }
          if (months != 0) {
              result = result.withMonths(months);
             }
         }
         return result;
","@@ -1625,13 +1625,19 @@ public Period normalizedStandard(PeriodType type) {
         int years = getYears();
         int months = getMonths();
         if (years != 0 || months != 0) {
          long totalMonths = years * 12L + months;
          if (type.isSupported(DurationFieldType.YEARS_TYPE)) {
              int normalizedYears = FieldUtils.safeToInt(totalMonths / 12);
              result = result.withYears(normalizedYears);
              totalMonths = totalMonths - (normalizedYears * 12);
             }
          if (type.isSupported(DurationFieldType.MONTHS_TYPE)) {
              int normalizedMonths = FieldUtils.safeToInt(totalMonths);
              result = result.withMonths(normalizedMonths);
              totalMonths = totalMonths - normalizedMonths;
          }
          if (totalMonths != 0) {
              throw new UnsupportedOperationException(""Unable to normalize as PeriodType is missing either years or months but period has a month/year amount: "" + toString());
             }
         }
         return result;
","
         int years = getYears();
         int months = getMonths();
         if (years != 0 || months != 0) {
            years = FieldUtils.safeAdd(years, months / 12);
            months = months % 12;
            if (years != 0) {
                result = result.withYears(years);
             }
            if (months != 0) {
                result = result.withMonths(months);
             }
         }
         return result;
","
         int years = getYears();
         int months = getMonths();
         if (years != 0 || months != 0) {
            long totalMonths = years * 12L + months;
            if (type.isSupported(DurationFieldType.YEARS_TYPE)) {
                int normalizedYears = FieldUtils.safeToInt(totalMonths / 12);
                result = result.withYears(normalizedYears);
                totalMonths = totalMonths - (normalizedYears * 12);
             }
            if (type.isSupported(DurationFieldType.MONTHS_TYPE)) {
                int normalizedMonths = FieldUtils.safeToInt(totalMonths);
                result = result.withMonths(normalizedMonths);
                totalMonths = totalMonths - normalizedMonths;
            }
            if (totalMonths != 0) {
                throw new UnsupportedOperationException(""Unable to normalize as PeriodType is missing either years or months but period has a month/year amount: "" + toString());
             }
         }
         return result;
"
369,"junit.framework.ComparisonFailure","/src/main/java/org/joda/time/MutableDateTime.java","@@ -636,7 +636,9 @@ public void add(DurationFieldType type, int amount) {
         if (type == null) {
             throw new IllegalArgumentException(""Field must not be null"");
         }
             setMillis(type.getField(getChronology()).add(getMillis(), amount));
     }
 
     //-----------------------------------------------------------------------
@@ -657,7 +659,9 @@ public void setYear(final int year) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addYears(final int years) {
             setMillis(getChronology().years().add(getMillis(), years));
     }
 
     //-----------------------------------------------------------------------
@@ -678,7 +682,9 @@ public void setWeekyear(final int weekyear) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addWeekyears(final int weekyears) {
             setMillis(getChronology().weekyears().add(getMillis(), weekyears));
     }
 
     //-----------------------------------------------------------------------
@@ -699,7 +705,9 @@ public void setMonthOfYear(final int monthOfYear) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addMonths(final int months) {
             setMillis(getChronology().months().add(getMillis(), months));
     }
 
     //-----------------------------------------------------------------------
@@ -720,7 +728,9 @@ public void setWeekOfWeekyear(final int weekOfWeekyear) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addWeeks(final int weeks) {
             setMillis(getChronology().weeks().add(getMillis(), weeks));
     }
 
     //-----------------------------------------------------------------------
@@ -761,7 +771,9 @@ public void setDayOfWeek(final int dayOfWeek) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addDays(final int days) {
             setMillis(getChronology().days().add(getMillis(), days));
     }
 
     //-----------------------------------------------------------------------
@@ -782,7 +794,9 @@ public void setHourOfDay(final int hourOfDay) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addHours(final int hours) {
             setMillis(getChronology().hours().add(getMillis(), hours));
     }
     
     //-----------------------------------------------------------------------
@@ -813,7 +827,9 @@ public void setMinuteOfHour(final int minuteOfHour) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addMinutes(final int minutes) {
             setMillis(getChronology().minutes().add(getMillis(), minutes));
     }
 
     //-----------------------------------------------------------------------
@@ -844,7 +860,9 @@ public void setSecondOfMinute(final int secondOfMinute) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addSeconds(final int seconds) {
             setMillis(getChronology().seconds().add(getMillis(), seconds));
     }
 
     //-----------------------------------------------------------------------
@@ -877,7 +895,9 @@ public void setMillisOfSecond(final int millisOfSecond) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addMillis(final int millis) {
             setMillis(getChronology().millis().add(getMillis(), millis));
     }
 
     //-----------------------------------------------------------------------
","@@ -636,7 +636,9 @@ public void add(DurationFieldType type, int amount) {
         if (type == null) {
             throw new IllegalArgumentException(""Field must not be null"");
         }
      if (amount != 0) {
             setMillis(type.getField(getChronology()).add(getMillis(), amount));
      }
     }
 
     //-----------------------------------------------------------------------
@@ -657,7 +659,9 @@ public void setYear(final int year) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addYears(final int years) {
      if (years != 0) {
             setMillis(getChronology().years().add(getMillis(), years));
      }
     }
 
     //-----------------------------------------------------------------------
@@ -678,7 +682,9 @@ public void setWeekyear(final int weekyear) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addWeekyears(final int weekyears) {
      if (weekyears != 0) {
             setMillis(getChronology().weekyears().add(getMillis(), weekyears));
      }
     }
 
     //-----------------------------------------------------------------------
@@ -699,7 +705,9 @@ public void setMonthOfYear(final int monthOfYear) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addMonths(final int months) {
      if (months != 0) {
             setMillis(getChronology().months().add(getMillis(), months));
      }
     }
 
     //-----------------------------------------------------------------------
@@ -720,7 +728,9 @@ public void setWeekOfWeekyear(final int weekOfWeekyear) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addWeeks(final int weeks) {
      if (weeks != 0) {
             setMillis(getChronology().weeks().add(getMillis(), weeks));
      }
     }
 
     //-----------------------------------------------------------------------
@@ -761,7 +771,9 @@ public void setDayOfWeek(final int dayOfWeek) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addDays(final int days) {
      if (days != 0) {
             setMillis(getChronology().days().add(getMillis(), days));
      }
     }
 
     //-----------------------------------------------------------------------
@@ -782,7 +794,9 @@ public void setHourOfDay(final int hourOfDay) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addHours(final int hours) {
      if (hours != 0) {
             setMillis(getChronology().hours().add(getMillis(), hours));
      }
     }
     
     //-----------------------------------------------------------------------
@@ -813,7 +827,9 @@ public void setMinuteOfHour(final int minuteOfHour) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addMinutes(final int minutes) {
      if (minutes != 0) {
             setMillis(getChronology().minutes().add(getMillis(), minutes));
      }
     }
 
     //-----------------------------------------------------------------------
@@ -844,7 +860,9 @@ public void setSecondOfMinute(final int secondOfMinute) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addSeconds(final int seconds) {
      if (seconds != 0) {
             setMillis(getChronology().seconds().add(getMillis(), seconds));
      }
     }
 
     //-----------------------------------------------------------------------
@@ -877,7 +895,9 @@ public void setMillisOfSecond(final int millisOfSecond) {
      * @throws IllegalArgumentException if the value is invalid
      */
     public void addMillis(final int millis) {
      if (millis != 0) {
             setMillis(getChronology().millis().add(getMillis(), millis));
      }
     }
 
     //-----------------------------------------------------------------------
","
         if (type == null) {
             throw new IllegalArgumentException(""Field must not be null"");
         }
             setMillis(type.getField(getChronology()).add(getMillis(), amount));
     }
 
     
   
     public void addYears(final int years) {
             setMillis(getChronology().years().add(getMillis(), years));
     }
 
     
     
     public void addWeekyears(final int weekyears) {
             setMillis(getChronology().weekyears().add(getMillis(), weekyears));
     }
 
     
   
     public void addMonths(final int months) {
             setMillis(getChronology().months().add(getMillis(), months));
     }
 
     
    
     public void addWeeks(final int weeks) {
             setMillis(getChronology().weeks().add(getMillis(), weeks));
     }
 
     
    
     public void addDays(final int days) {
             setMillis(getChronology().days().add(getMillis(), days));
     }
 
     
      
     public void addHours(final int hours) {
             setMillis(getChronology().hours().add(getMillis(), hours));
     }
     
     
      
     public void addMinutes(final int minutes) {
             setMillis(getChronology().minutes().add(getMillis(), minutes));
     }
 
     
     
     public void addSeconds(final int seconds) {
             setMillis(getChronology().seconds().add(getMillis(), seconds));
     }
 
     
    
     public void addMillis(final int millis) {
             setMillis(getChronology().millis().add(getMillis(), millis));
     }
 
     ","
         if (type == null) {
             throw new IllegalArgumentException(""Field must not be null"");
         }
        if (amount != 0) {
             setMillis(type.getField(getChronology()).add(getMillis(), amount));
        }
     }
 
     
      
     public void addYears(final int years) {
        if (years != 0) {
             setMillis(getChronology().years().add(getMillis(), years));
        }
     }
 
     
      
     public void addWeekyears(final int weekyears) {
        if (weekyears != 0) {
             setMillis(getChronology().weekyears().add(getMillis(), weekyears));
        }
     }
 
     
     
     public void addMonths(final int months) {
        if (months != 0) {
             setMillis(getChronology().months().add(getMillis(), months));
        }
     }
 
     
    
     public void addWeeks(final int weeks) {
        if (weeks != 0) {
             setMillis(getChronology().weeks().add(getMillis(), weeks));
        }
     }
 
     
     
     public void addDays(final int days) {
        if (days != 0) {
             setMillis(getChronology().days().add(getMillis(), days));
        }
     }
 
     
    
     public void addHours(final int hours) {
        if (hours != 0) {
             setMillis(getChronology().hours().add(getMillis(), hours));
        }
     }
     
     
    
     public void addMinutes(final int minutes) {
        if (minutes != 0) {
             setMillis(getChronology().minutes().add(getMillis(), minutes));
        }
     }
 
     
  
     public void addSeconds(final int seconds) {
        if (seconds != 0) {
             setMillis(getChronology().seconds().add(getMillis(), seconds));
        }
     }
 
     
     
     public void addMillis(final int millis) {
        if (millis != 0) {
             setMillis(getChronology().millis().add(getMillis(), millis));
        }
     }
 
     "
370,"junit.framework.AssertionFailedError","/src/main/java/org/joda/time/Partial.java","@@ -214,11 +214,20 @@ public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {
             DateTimeFieldType loopType = types[i];
             DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
             if (i > 0) {
                 int compare = lastUnitField.compareTo(loopUnitField);
                 if (compare < 0) {
                     throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" +
                             types[i - 1].getName() + "" < "" + loopType.getName());
              } else if (compare == 0) {
                     if (types[i - 1].getRangeDurationType() == null) {
                         if (loopType.getRangeDurationType() == null) {
                             throw new IllegalArgumentException(""Types array must not contain duplicate: "" +
/src/main/java/org/joda/time/field/UnsupportedDurationField.java @@ -224,9 +224,6 @@ public long getUnitMillis() {
      * @return zero always
      */
     public int compareTo(DurationField durationField) {
      if (durationField.isSupported()) {
          return 1;
      }
         return 0;
     }
 
","@@ -214,11 +214,20 @@ public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {
             DateTimeFieldType loopType = types[i];
             DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
             if (i > 0) {
              if (loopUnitField.isSupported() == false) {
                  if (lastUnitField.isSupported()) {
                      throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" +
                                      types[i - 1].getName() + "" < "" + loopType.getName());
                  } else {
                      throw new IllegalArgumentException(""Types array must not contain duplicate unsupported: "" +
                                      types[i - 1].getName() + "" and "" + loopType.getName());
                  }
              }
                 int compare = lastUnitField.compareTo(loopUnitField);
                 if (compare < 0) {
                     throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" +
                             types[i - 1].getName() + "" < "" + loopType.getName());
              } else if (compare == 0 && lastUnitField.equals(loopUnitField)) {
                     if (types[i - 1].getRangeDurationType() == null) {
                         if (loopType.getRangeDurationType() == null) {
                             throw new IllegalArgumentException(""Types array must not contain duplicate: "" +
/src/main/java/org/joda/time/field/UnsupportedDurationField.java @@ -224,9 +224,6 @@ public long getUnitMillis() {
      * @return zero always
      */
     public int compareTo(DurationField durationField) {
         return 0;
     }
 
","
             DateTimeFieldType loopType = types[i];
             DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
             if (i > 0) {
                 int compare = lastUnitField.compareTo(loopUnitField);
                 if (compare < 0) {
                     throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" +
                             types[i - 1].getName() + "" < "" + loopType.getName());
                } else if (compare == 0) {
                     if (types[i - 1].getRangeDurationType() == null) {
                         if (loopType.getRangeDurationType() == null) {
                             throw new IllegalArgumentException(""Types array must not contain duplicate: "" +

    
     public int compareTo(DurationField durationField) {
        if (durationField.isSupported()) {
            return 1;
        }
         return 0;
     }
 
","
             DateTimeFieldType loopType = types[i];
             DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
             if (i > 0) {
                if (loopUnitField.isSupported() == false) {
                    if (lastUnitField.isSupported()) {
                        throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" +
                                        types[i - 1].getName() + "" < "" + loopType.getName());
                    } else {
                        throw new IllegalArgumentException(""Types array must not contain duplicate unsupported: "" +
                                        types[i - 1].getName() + "" and "" + loopType.getName());
                    }
                }
                 int compare = lastUnitField.compareTo(loopUnitField);
                 if (compare < 0) {
                     throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" +
                             types[i - 1].getName() + "" < "" + loopType.getName());
                } else if (compare == 0 && lastUnitField.equals(loopUnitField)) {
                     if (types[i - 1].getRangeDurationType() == null) {
                         if (loopType.getRangeDurationType() == null) {
                             throw new IllegalArgumentException(""Types array must not contain duplicate: "" +

   
     public int compareTo(DurationField durationField) {
         return 0;
     }
 
"
371,"junit.framework.AssertionFailedError","/src/main/java/org/joda/time/Partial.java","@@ -461,7 +461,7 @@ public Partial with(DateTimeFieldType fieldType, int value) {
             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
             // use public constructor to ensure full validation
             // this isn't overly efficient, but is safe
          Partial newPartial = new Partial(iChronology, newTypes, newValues);
             iChronology.validate(newPartial, newValues);
             return newPartial;
         }
","@@ -461,7 +461,7 @@ public Partial with(DateTimeFieldType fieldType, int value) {
             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
             // use public constructor to ensure full validation
             // this isn't overly efficient, but is safe
          Partial newPartial = new Partial(newTypes, newValues, iChronology);
             iChronology.validate(newPartial, newValues);
             return newPartial;
         }
","
             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
                                      Partial newPartial = new Partial(iChronology, newTypes, newValues);
             iChronology.validate(newPartial, newValues);
             return newPartial;
         }
","
             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);
                                      Partial newPartial = new Partial(newTypes, newValues, iChronology);
             iChronology.validate(newPartial, newValues);
             return newPartial;
         }
"
372,"junit.framework.AssertionFailedError","/src/org/mockito/internal/stubbing/answers/AnswersValidator.java","@@ -25,8 +25,16 @@ public void validate(Answer<?> answer, Invocation invocation) {
             validateDoNothing((DoesNothing) answer, invocation);
         }
         
     }
 
 
     private void validateDoNothing(DoesNothing answer, Invocation invocation) {
         if (!invocation.isVoid()) {
","@@ -25,8 +25,16 @@ public void validate(Answer<?> answer, Invocation invocation) {
             validateDoNothing((DoesNothing) answer, invocation);
         }
         
      if (answer instanceof CallsRealMethods) {
          validateMockingConcreteClass((CallsRealMethods) answer, invocation);
      }
     }
 
  private void validateMockingConcreteClass(CallsRealMethods answer, Invocation invocation) {
      if (invocation.getMethod().getDeclaringClass().isInterface()) {
          reporter.cannotCallRealMethodOnInterface();
      }
  }
 
     private void validateDoNothing(DoesNothing answer, Invocation invocation) {
         if (!invocation.isVoid()) {
","
             validateDoNothing((DoesNothing) answer, invocation);
         }
         
     }
 
 
     private void validateDoNothing(DoesNothing answer, Invocation invocation) {
         if (!invocation.isVoid()) {
","
             validateDoNothing((DoesNothing) answer, invocation);
         }
         
        if (answer instanceof CallsRealMethods) {
            validateMockingConcreteClass((CallsRealMethods) answer, invocation);
        }
     }
 
    private void validateMockingConcreteClass(CallsRealMethods answer, Invocation invocation) {
        if (invocation.getMethod().getDeclaringClass().isInterface()) {
            reporter.cannotCallRealMethodOnInterface();
        }
    }
 
     private void validateDoNothing(DoesNothing answer, Invocation invocation) {
         if (!invocation.isVoid()) {
"
373,"java.lang.IllegalArgumentException","/src/main/java/org/joda/time/Partial.java","@@ -215,7 +215,7 @@ public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {
             DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
             if (i > 0) {
                 int compare = lastUnitField.compareTo(loopUnitField);
              if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {
                     throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" +
                             types[i - 1].getName() + "" < "" + loopType.getName());
                 } else if (compare == 0) {
@@ -446,6 +446,9 @@ public Partial with(DateTimeFieldType fieldType, int value) {
                         if (compare > 0) {
                             break;
                         } else if (compare == 0) {
                             DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                             DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                             if (rangeField.compareTo(loopRangeField) > 0) {
/src/main/java/org/joda/time/field/UnsupportedDurationField.java @@ -224,6 +224,9 @@ public long getUnitMillis() {
      * @return zero always
      */
     public int compareTo(DurationField durationField) {
         return 0;
     }
 
","@@ -215,7 +215,7 @@ public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {
             DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
             if (i > 0) {
                 int compare = lastUnitField.compareTo(loopUnitField);
              if (compare < 0) {
                     throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" +
                             types[i - 1].getName() + "" < "" + loopType.getName());
                 } else if (compare == 0) {
@@ -446,6 +446,9 @@ public Partial with(DateTimeFieldType fieldType, int value) {
                         if (compare > 0) {
                             break;
                         } else if (compare == 0) {
                          if (fieldType.getRangeDurationType() == null) {
                              break;
                          }
                             DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                             DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                             if (rangeField.compareTo(loopRangeField) > 0) {
/src/main/java/org/joda/time/field/UnsupportedDurationField.java @@ -224,6 +224,9 @@ public long getUnitMillis() {
      * @return zero always
      */
     public int compareTo(DurationField durationField) {
      if (durationField.isSupported()) {
          return 1;
      }
         return 0;
     }
 
","
             DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
             if (i > 0) {
                 int compare = lastUnitField.compareTo(loopUnitField);
                if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {
                     throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" +
                             types[i - 1].getName() + "" < "" + loopType.getName());
                 } else if (compare == 0) {

                         if (compare > 0) {
                             break;
                         } else if (compare == 0) {
                             DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                             DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                             if (rangeField.compareTo(loopRangeField) > 0) {

     
     public int compareTo(DurationField durationField) {
         return 0;
     }
 
","
             DurationField loopUnitField = loopType.getDurationType().getField(iChronology);
             if (i > 0) {
                 int compare = lastUnitField.compareTo(loopUnitField);
                if (compare < 0) {
                     throw new IllegalArgumentException(""Types array must be in order largest-smallest: "" +
                             types[i - 1].getName() + "" < "" + loopType.getName());
                 } else if (compare == 0) {

                         if (compare > 0) {
                             break;
                         } else if (compare == 0) {
                            if (fieldType.getRangeDurationType() == null) {
                                break;
                            }
                             DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);
                             DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);
                             if (rangeField.compareTo(loopRangeField) > 0) {

     
     public int compareTo(DurationField durationField) {
        if (durationField.isSupported()) {
            return 1;
        }
         return 0;
     }
 
"
374,"java.lang.IllegalArgumentException","/src/main/java/org/joda/time/DateTimeZone.java","@@ -276,14 +276,17 @@ public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff
         if (hoursOffset < -23 || hoursOffset > 23) {
             throw new IllegalArgumentException(""Hours out of range: "" + hoursOffset);
         }
      if (minutesOffset < 0 || minutesOffset > 59) {
             throw new IllegalArgumentException(""Minutes out of range: "" + minutesOffset);
         }
         int offset = 0;
         try {
             int hoursInMinutes = hoursOffset * 60;
             if (hoursInMinutes < 0) {
              minutesOffset = hoursInMinutes - minutesOffset;
             } else {
                 minutesOffset = hoursInMinutes + minutesOffset;
             }
","@@ -276,14 +276,17 @@ public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff
         if (hoursOffset < -23 || hoursOffset > 23) {
             throw new IllegalArgumentException(""Hours out of range: "" + hoursOffset);
         }
      if (minutesOffset < -59 || minutesOffset > 59) {
             throw new IllegalArgumentException(""Minutes out of range: "" + minutesOffset);
         }
      if (hoursOffset > 0 && minutesOffset < 0) {
          throw new IllegalArgumentException(""Positive hours must not have negative minutes: "" + minutesOffset);
      }
         int offset = 0;
         try {
             int hoursInMinutes = hoursOffset * 60;
             if (hoursInMinutes < 0) {
              minutesOffset = hoursInMinutes - Math.abs(minutesOffset);
             } else {
                 minutesOffset = hoursInMinutes + minutesOffset;
             }
","
         if (hoursOffset < -23 || hoursOffset > 23) {
             throw new IllegalArgumentException(""Hours out of range: "" + hoursOffset);
         }
        if (minutesOffset < 0 || minutesOffset > 59) {
             throw new IllegalArgumentException(""Minutes out of range: "" + minutesOffset);
         }
         int offset = 0;
         try {
             int hoursInMinutes = hoursOffset * 60;
             if (hoursInMinutes < 0) {
                minutesOffset = hoursInMinutes - minutesOffset;
             } else {
                 minutesOffset = hoursInMinutes + minutesOffset;
             }
","
         if (hoursOffset < -23 || hoursOffset > 23) {
             throw new IllegalArgumentException(""Hours out of range: "" + hoursOffset);
         }
        if (minutesOffset < -59 || minutesOffset > 59) {
             throw new IllegalArgumentException(""Minutes out of range: "" + minutesOffset);
         }
        if (hoursOffset > 0 && minutesOffset < 0) {
            throw new IllegalArgumentException(""Positive hours must not have negative minutes: "" + minutesOffset);
        }
         int offset = 0;
         try {
             int hoursInMinutes = hoursOffset * 60;
             if (hoursInMinutes < 0) {
                minutesOffset = hoursInMinutes - Math.abs(minutesOffset);
             } else {
                 minutesOffset = hoursInMinutes + minutesOffset;
             }
"
375,"junit.framework.AssertionFailedError","/src/main/java/org/joda/time/chrono/GJChronology.java","@@ -193,6 +193,10 @@ public static synchronized GJChronology getInstance(
             cutoverInstant = DEFAULT_CUTOVER;
         } else {
             cutoverInstant = gregorianCutover.toInstant();
         }
 
         GJChronology chrono;
@@ -976,6 +980,17 @@ public long add(long instant, int value) {
                 if (instant < iCutover) {
                     // Only adjust if gap fully crossed.
                     if (instant + iGapDuration < iCutover) {
                         instant = gregorianToJulian(instant);
                     }
                 }
@@ -998,6 +1013,17 @@ public long add(long instant, long value) {
                 if (instant < iCutover) {
                     // Only adjust if gap fully crossed.
                     if (instant + iGapDuration < iCutover) {
                         instant = gregorianToJulian(instant);
                     }
                 }
","@@ -193,6 +193,10 @@ public static synchronized GJChronology getInstance(
             cutoverInstant = DEFAULT_CUTOVER;
         } else {
             cutoverInstant = gregorianCutover.toInstant();
          LocalDate cutoverDate = new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone));
          if (cutoverDate.getYear() <= 0) {
              throw new IllegalArgumentException(""Cutover too early. Must be on or after 0001-01-01."");
          }
         }
 
         GJChronology chrono;
@@ -976,6 +980,17 @@ public long add(long instant, int value) {
                 if (instant < iCutover) {
                     // Only adjust if gap fully crossed.
                     if (instant + iGapDuration < iCutover) {
                      if (iConvertByWeekyear) {
                          int wyear = iGregorianChronology.weekyear().get(instant);
                          if (wyear <= 0) {
                              instant = iGregorianChronology.weekyear().add(instant, -1);
                          }
                      } else {
                          int year = iGregorianChronology.year().get(instant);
                          if (year <= 0) {
                              instant = iGregorianChronology.year().add(instant, -1);
                          }
                      }
                         instant = gregorianToJulian(instant);
                     }
                 }
@@ -998,6 +1013,17 @@ public long add(long instant, long value) {
                 if (instant < iCutover) {
                     // Only adjust if gap fully crossed.
                     if (instant + iGapDuration < iCutover) {
                      if (iConvertByWeekyear) {
                          int wyear = iGregorianChronology.weekyear().get(instant);
                          if (wyear <= 0) {
                              instant = iGregorianChronology.weekyear().add(instant, -1);
                          }
                      } else {
                          int year = iGregorianChronology.year().get(instant);
                          if (year <= 0) {
                              instant = iGregorianChronology.year().add(instant, -1);
                          }
                      }
                         instant = gregorianToJulian(instant);
                     }
                 }
","
             cutoverInstant = DEFAULT_CUTOVER;
         } else {
             cutoverInstant = gregorianCutover.toInstant();
         }
 
         GJChronology chrono;

                 if (instant < iCutover) {
                                          if (instant + iGapDuration < iCutover) {
                         instant = gregorianToJulian(instant);
                     }
                 }

                 if (instant < iCutover) {
                                          if (instant + iGapDuration < iCutover) {
                         instant = gregorianToJulian(instant);
                     }
                 }
","
             cutoverInstant = DEFAULT_CUTOVER;
         } else {
             cutoverInstant = gregorianCutover.toInstant();
            LocalDate cutoverDate = new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone));
            if (cutoverDate.getYear() <= 0) {
                throw new IllegalArgumentException(""Cutover too early. Must be on or after 0001-01-01."");
            }
         }
 
         GJChronology chrono;

                 if (instant < iCutover) {
                                          if (instant + iGapDuration < iCutover) {
                        if (iConvertByWeekyear) {
                            int wyear = iGregorianChronology.weekyear().get(instant);
                            if (wyear <= 0) {
                                instant = iGregorianChronology.weekyear().add(instant, -1);
                            }
                        } else {
                            int year = iGregorianChronology.year().get(instant);
                            if (year <= 0) {
                                instant = iGregorianChronology.year().add(instant, -1);
                            }
                        }
                         instant = gregorianToJulian(instant);
                     }
                 }

                 if (instant < iCutover) {
                                          if (instant + iGapDuration < iCutover) {
                        if (iConvertByWeekyear) {
                            int wyear = iGregorianChronology.weekyear().get(instant);
                            if (wyear <= 0) {
                                instant = iGregorianChronology.weekyear().add(instant, -1);
                            }
                        } else {
                            int year = iGregorianChronology.year().get(instant);
                            if (year <= 0) {
                                instant = iGregorianChronology.year().add(instant, -1);
                            }
                        }
                         instant = gregorianToJulian(instant);
                     }
                 }
"
376,"org.joda.time.IllegalFieldValueException","/src/main/java/org/joda/time/format/DateTimeFormatter.java","@@ -705,9 +705,9 @@ public int parseInto(ReadWritableInstant instant, String text, int position) {
         
         long instantMillis = instant.getMillis();
         Chronology chrono = instant.getChronology();
         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
         chrono = selectChronology(chrono);
      int defaultYear = chrono.year().get(instantLocal);
         
         DateTimeParserBucket bucket = new DateTimeParserBucket(
             instantLocal, chrono, iLocale, iPivotYear, defaultYear);
","@@ -705,9 +705,9 @@ public int parseInto(ReadWritableInstant instant, String text, int position) {
         
         long instantMillis = instant.getMillis();
         Chronology chrono = instant.getChronology();
      int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);
         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
         chrono = selectChronology(chrono);
         
         DateTimeParserBucket bucket = new DateTimeParserBucket(
             instantLocal, chrono, iLocale, iPivotYear, defaultYear);
","
         
         long instantMillis = instant.getMillis();
         Chronology chrono = instant.getChronology();
         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
         chrono = selectChronology(chrono);
        int defaultYear = chrono.year().get(instantLocal);
         
         DateTimeParserBucket bucket = new DateTimeParserBucket(
             instantLocal, chrono, iLocale, iPivotYear, defaultYear);
","
         
         long instantMillis = instant.getMillis();
         Chronology chrono = instant.getChronology();
        int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);
         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);
         chrono = selectChronology(chrono);
         
         DateTimeParserBucket bucket = new DateTimeParserBucket(
             instantLocal, chrono, iLocale, iPivotYear, defaultYear);
"
377,"junit.framework.AssertionFailedError","/src/main/java/org/joda/time/DateTimeZone.java","@@ -255,16 +255,19 @@ public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff
         if (hoursOffset == 0 && minutesOffset == 0) {
             return DateTimeZone.UTC;
         }
         if (minutesOffset < 0 || minutesOffset > 59) {
             throw new IllegalArgumentException(""Minutes out of range: "" + minutesOffset);
         }
         int offset = 0;
         try {
          int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);
             if (hoursInMinutes < 0) {
              minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);
             } else {
              minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);
             }
             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);
         } catch (ArithmeticException ex) {
@@ -280,6 +283,9 @@ public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff
      * @return the DateTimeZone object for the offset
      */
     public static DateTimeZone forOffsetMillis(int millisOffset) {
         String id = printOffset(millisOffset);
         return fixedOffsetZone(id, millisOffset);
     }
","@@ -255,16 +255,19 @@ public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff
         if (hoursOffset == 0 && minutesOffset == 0) {
             return DateTimeZone.UTC;
         }
      if (hoursOffset < -23 || hoursOffset > 23) {
          throw new IllegalArgumentException(""Hours out of range: "" + hoursOffset);
      }
         if (minutesOffset < 0 || minutesOffset > 59) {
             throw new IllegalArgumentException(""Minutes out of range: "" + minutesOffset);
         }
         int offset = 0;
         try {
          int hoursInMinutes = hoursOffset * 60;
             if (hoursInMinutes < 0) {
              minutesOffset = hoursInMinutes - minutesOffset;
             } else {
              minutesOffset = hoursInMinutes + minutesOffset;
             }
             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);
         } catch (ArithmeticException ex) {
@@ -280,6 +283,9 @@ public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOff
      * @return the DateTimeZone object for the offset
      */
     public static DateTimeZone forOffsetMillis(int millisOffset) {
      if (millisOffset < -MAX_MILLIS || millisOffset > MAX_MILLIS) {
          throw new IllegalArgumentException(""Millis out of range: "" + millisOffset);
      }
         String id = printOffset(millisOffset);
         return fixedOffsetZone(id, millisOffset);
     }
","
         if (hoursOffset == 0 && minutesOffset == 0) {
             return DateTimeZone.UTC;
         }
         if (minutesOffset < 0 || minutesOffset > 59) {
             throw new IllegalArgumentException(""Minutes out of range: "" + minutesOffset);
         }
         int offset = 0;
         try {
            int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);
             if (hoursInMinutes < 0) {
                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);
             } else {
                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);
             }
             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);
         } catch (ArithmeticException ex) {

    
     public static DateTimeZone forOffsetMillis(int millisOffset) {
         String id = printOffset(millisOffset);
         return fixedOffsetZone(id, millisOffset);
     }
","
         if (hoursOffset == 0 && minutesOffset == 0) {
             return DateTimeZone.UTC;
         }
        if (hoursOffset < -23 || hoursOffset > 23) {
            throw new IllegalArgumentException(""Hours out of range: "" + hoursOffset);
        }
         if (minutesOffset < 0 || minutesOffset > 59) {
             throw new IllegalArgumentException(""Minutes out of range: "" + minutesOffset);
         }
         int offset = 0;
         try {
            int hoursInMinutes = hoursOffset * 60;
             if (hoursInMinutes < 0) {
                minutesOffset = hoursInMinutes - minutesOffset;
             } else {
                minutesOffset = hoursInMinutes + minutesOffset;
             }
             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);
         } catch (ArithmeticException ex) {

    
     public static DateTimeZone forOffsetMillis(int millisOffset) {
        if (millisOffset < -MAX_MILLIS || millisOffset > MAX_MILLIS) {
            throw new IllegalArgumentException(""Millis out of range: "" + millisOffset);
        }
         String id = printOffset(millisOffset);
         return fixedOffsetZone(id, millisOffset);
     }
"
378,"org.joda.time.IllegalFieldValueException","/src/main/java/org/joda/time/base/BaseSingleFieldPeriod.java","@@ -49,6 +49,7 @@
     /** Serialization version. */
     private static final long serialVersionUID = 9386874258972L;
     /** The start of 1972. */
 
     /** The period in the units of this period. */
     private volatile int iPeriod;
@@ -101,7 +102,7 @@ protected static int between(ReadablePartial start, ReadablePartial end, Readabl
             throw new IllegalArgumentException(""ReadablePartial objects must be contiguous"");
         }
         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();
      int[] values = chrono.get(zeroInstance, chrono.set(start, 0L), chrono.set(end, 0L));
         return values[0];
     }
 
","@@ -49,6 +49,7 @@
     /** Serialization version. */
     private static final long serialVersionUID = 9386874258972L;
     /** The start of 1972. */
  private static final long START_1972 = 2L * 365L * 86400L * 1000L;
 
     /** The period in the units of this period. */
     private volatile int iPeriod;
@@ -101,7 +102,7 @@ protected static int between(ReadablePartial start, ReadablePartial end, Readabl
             throw new IllegalArgumentException(""ReadablePartial objects must be contiguous"");
         }
         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();
      int[] values = chrono.get(zeroInstance, chrono.set(start, START_1972), chrono.set(end, START_1972));
         return values[0];
     }
 
","
          private static final long serialVersionUID = 9386874258972L;
      
          private volatile int iPeriod;

             throw new IllegalArgumentException(""ReadablePartial objects must be contiguous"");
         }
         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();
        int[] values = chrono.get(zeroInstance, chrono.set(start, 0L), chrono.set(end, 0L));
         return values[0];
     }
 
","
          private static final long serialVersionUID = 9386874258972L;
         private static final long START_1972 = 2L * 365L * 86400L * 1000L;
 
          private volatile int iPeriod;

             throw new IllegalArgumentException(""ReadablePartial objects must be contiguous"");
         }
         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();
        int[] values = chrono.get(zeroInstance, chrono.set(start, START_1972), chrono.set(end, START_1972));
         return values[0];
     }
 
"
379,"junit.framework.AssertionFailedError","/src/main/java/org/joda/time/LocalDate.java","@@ -207,9 +207,10 @@ public static LocalDate fromCalendarFields(Calendar calendar) {
         if (calendar == null) {
             throw new IllegalArgumentException(""The calendar must not be null"");
         }
         int yearOfEra = calendar.get(Calendar.YEAR);
         return new LocalDate(
          yearOfEra,
             calendar.get(Calendar.MONTH) + 1,
             calendar.get(Calendar.DAY_OF_MONTH)
         );
@@ -240,7 +241,12 @@ public static LocalDate fromDateFields(Date date) {
         if (date == null) {
             throw new IllegalArgumentException(""The date must not be null"");
         }
             // handle years in era BC
         return new LocalDate(
             date.getYear() + 1900,
             date.getMonth() + 1,
/src/main/java/org/joda/time/LocalDateTime.java @@ -196,9 +196,10 @@ public static LocalDateTime fromCalendarFields(Calendar calendar) {
         if (calendar == null) {
             throw new IllegalArgumentException(""The calendar must not be null"");
         }
         int yearOfEra = calendar.get(Calendar.YEAR);
         return new LocalDateTime(
          yearOfEra,
             calendar.get(Calendar.MONTH) + 1,
             calendar.get(Calendar.DAY_OF_MONTH),
             calendar.get(Calendar.HOUR_OF_DAY),
@@ -233,7 +234,12 @@ public static LocalDateTime fromDateFields(Date date) {
         if (date == null) {
             throw new IllegalArgumentException(""The date must not be null"");
         }
             // handle years in era BC
         return new LocalDateTime(
             date.getYear() + 1900,
             date.getMonth() + 1,
","@@ -207,9 +207,10 @@ public static LocalDate fromCalendarFields(Calendar calendar) {
         if (calendar == null) {
             throw new IllegalArgumentException(""The calendar must not be null"");
         }
      int era = calendar.get(Calendar.ERA);
         int yearOfEra = calendar.get(Calendar.YEAR);
         return new LocalDate(
          (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),
             calendar.get(Calendar.MONTH) + 1,
             calendar.get(Calendar.DAY_OF_MONTH)
         );
@@ -240,7 +241,12 @@ public static LocalDate fromDateFields(Date date) {
         if (date == null) {
             throw new IllegalArgumentException(""The date must not be null"");
         }
      if (date.getTime() < 0) {
             // handle years in era BC
          GregorianCalendar cal = new GregorianCalendar();
          cal.setTime(date);
          return fromCalendarFields(cal);
      }
         return new LocalDate(
             date.getYear() + 1900,
             date.getMonth() + 1,
/src/main/java/org/joda/time/LocalDateTime.java @@ -196,9 +196,10 @@ public static LocalDateTime fromCalendarFields(Calendar calendar) {
         if (calendar == null) {
             throw new IllegalArgumentException(""The calendar must not be null"");
         }
      int era = calendar.get(Calendar.ERA);
         int yearOfEra = calendar.get(Calendar.YEAR);
         return new LocalDateTime(
          (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),
             calendar.get(Calendar.MONTH) + 1,
             calendar.get(Calendar.DAY_OF_MONTH),
             calendar.get(Calendar.HOUR_OF_DAY),
@@ -233,7 +234,12 @@ public static LocalDateTime fromDateFields(Date date) {
         if (date == null) {
             throw new IllegalArgumentException(""The date must not be null"");
         }
      if (date.getTime() < 0) {
             // handle years in era BC
          GregorianCalendar cal = new GregorianCalendar();
          cal.setTime(date);
          return fromCalendarFields(cal);
      }
         return new LocalDateTime(
             date.getYear() + 1900,
             date.getMonth() + 1,
","
         if (calendar == null) {
             throw new IllegalArgumentException(""The calendar must not be null"");
         }
         int yearOfEra = calendar.get(Calendar.YEAR);
         return new LocalDate(
            yearOfEra,
             calendar.get(Calendar.MONTH) + 1,
             calendar.get(Calendar.DAY_OF_MONTH)
         );

         if (date == null) {
             throw new IllegalArgumentException(""The date must not be null"");
         }
                      return new LocalDate(
             date.getYear() + 1900,
             date.getMonth() + 1,

         if (calendar == null) {
             throw new IllegalArgumentException(""The calendar must not be null"");
         }
         int yearOfEra = calendar.get(Calendar.YEAR);
         return new LocalDateTime(
            yearOfEra,
             calendar.get(Calendar.MONTH) + 1,
             calendar.get(Calendar.DAY_OF_MONTH),
             calendar.get(Calendar.HOUR_OF_DAY),

         if (date == null) {
             throw new IllegalArgumentException(""The date must not be null"");
         }
                      return new LocalDateTime(
             date.getYear() + 1900,
             date.getMonth() + 1,
","
         if (calendar == null) {
             throw new IllegalArgumentException(""The calendar must not be null"");
         }
        int era = calendar.get(Calendar.ERA);
         int yearOfEra = calendar.get(Calendar.YEAR);
         return new LocalDate(
            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),
             calendar.get(Calendar.MONTH) + 1,
             calendar.get(Calendar.DAY_OF_MONTH)
         );

         if (date == null) {
             throw new IllegalArgumentException(""The date must not be null"");
         }
        if (date.getTime() < 0) {
                         GregorianCalendar cal = new GregorianCalendar();
            cal.setTime(date);
            return fromCalendarFields(cal);
        }
         return new LocalDate(
             date.getYear() + 1900,
             date.getMonth() + 1,

         if (calendar == null) {
             throw new IllegalArgumentException(""The calendar must not be null"");
         }
        int era = calendar.get(Calendar.ERA);
         int yearOfEra = calendar.get(Calendar.YEAR);
         return new LocalDateTime(
            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),
             calendar.get(Calendar.MONTH) + 1,
             calendar.get(Calendar.DAY_OF_MONTH),
             calendar.get(Calendar.HOUR_OF_DAY),

         if (date == null) {
             throw new IllegalArgumentException(""The date must not be null"");
         }
        if (date.getTime() < 0) {
                         GregorianCalendar cal = new GregorianCalendar();
            cal.setTime(date);
            return fromCalendarFields(cal);
        }
         return new LocalDateTime(
             date.getYear() + 1900,
             date.getMonth() + 1,
"
380,"junit.framework.AssertionFailedError","/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java","@@ -65,10 +65,11 @@
 
     static Chronology cLenientISO;
 
  static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();
  static {
      cVerbose.set(Boolean.FALSE);
  }
 
     /**
      * Gets a flag indicating that verbose logging is required.
","@@ -65,10 +65,11 @@
 
     static Chronology cLenientISO;
 
  static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>() {
      protected Boolean initialValue() {
          return Boolean.FALSE;
      }
  };
 
     /**
      * Gets a flag indicating that verbose logging is required.
","
 
     static Chronology cLenientISO;
 
    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();
    static {
        cVerbose.set(Boolean.FALSE);
    }
 
","
 
     static Chronology cLenientISO;
 
    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>() {
        protected Boolean initialValue() {
            return Boolean.FALSE;
        }
    };
"
381,"org.joda.time.IllegalFieldValueException","/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java","@@ -206,7 +206,12 @@ public long add(long instant, long months) {
         if (valueToAdd == 0) {
             return values;
         }
             // month is largest field and being added to, such as month-day
         if (DateTimeUtils.isContiguous(partial)) {
             long instant = 0L;
             for (int i = 0, isize = partial.size(); i < isize; i++) {
","@@ -206,7 +206,12 @@ public long add(long instant, long months) {
         if (valueToAdd == 0) {
             return values;
         }
      if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) {
             // month is largest field and being added to, such as month-day
          int curMonth0 = partial.getValue(0) - 1;
          int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1;
          return set(partial, 0, values, newMonth);
      }
         if (DateTimeUtils.isContiguous(partial)) {
             long instant = 0L;
             for (int i = 0, isize = partial.size(); i < isize; i++) {
","
         if (valueToAdd == 0) {
             return values;
         }
                      if (DateTimeUtils.isContiguous(partial)) {
             long instant = 0L;
             for (int i = 0, isize = partial.size(); i < isize; i++) {
","
         if (valueToAdd == 0) {
             return values;
         }
        if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) {
                         int curMonth0 = partial.getValue(0) - 1;
            int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1;
            return set(partial, 0, values, newMonth);
        }
         if (DateTimeUtils.isContiguous(partial)) {
             long instant = 0L;
             for (int i = 0, isize = partial.size(); i < isize; i++) {
"
382,"junit.framework.ComparisonFailure","/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java","@@ -1095,7 +1095,7 @@ public int calculatePrintedLength(ReadablePeriod period, Locale locale) {
             if (iFieldType >= SECONDS_MILLIS) {
                 // valueLong contains the seconds and millis fields
                 // the minimum output is 0.000, which is 4 or 5 digits with a negative
              sum = Math.max(sum, 4);
                 // plus one for the decimal point
                 sum++;
                 if (iFieldType == SECONDS_OPTIONAL_MILLIS &&
@@ -1130,6 +1130,7 @@ public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {
             if (iPrefix != null) {
                 iPrefix.printTo(buf, value);
             }
             int minDigits = iMinPrintedDigits;
             if (minDigits <= 1) {
                 FormatUtils.appendUnpaddedInteger(buf, value);
@@ -1139,6 +1140,9 @@ public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {
             if (iFieldType >= SECONDS_MILLIS) {
                 int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);
                 if (iFieldType == SECONDS_MILLIS || dp > 0) {
                     buf.append('.');
                     FormatUtils.appendPaddedInteger(buf, dp, 3);
                 }
","@@ -1095,7 +1095,7 @@ public int calculatePrintedLength(ReadablePeriod period, Locale locale) {
             if (iFieldType >= SECONDS_MILLIS) {
                 // valueLong contains the seconds and millis fields
                 // the minimum output is 0.000, which is 4 or 5 digits with a negative
              sum = (valueLong < 0 ? Math.max(sum, 5) : Math.max(sum, 4));
                 // plus one for the decimal point
                 sum++;
                 if (iFieldType == SECONDS_OPTIONAL_MILLIS &&
@@ -1130,6 +1130,7 @@ public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {
             if (iPrefix != null) {
                 iPrefix.printTo(buf, value);
             }
          int bufLen = buf.length();
             int minDigits = iMinPrintedDigits;
             if (minDigits <= 1) {
                 FormatUtils.appendUnpaddedInteger(buf, value);
@@ -1139,6 +1140,9 @@ public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {
             if (iFieldType >= SECONDS_MILLIS) {
                 int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);
                 if (iFieldType == SECONDS_MILLIS || dp > 0) {
                  if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) {
                      buf.insert(bufLen, '-');
                  }
                     buf.append('.');
                     FormatUtils.appendPaddedInteger(buf, dp, 3);
                 }
","
             if (iFieldType >= SECONDS_MILLIS) {
                                                  sum = Math.max(sum, 4);
                                  sum++;
                 if (iFieldType == SECONDS_OPTIONAL_MILLIS &&

             if (iPrefix != null) {
                 iPrefix.printTo(buf, value);
             }
             int minDigits = iMinPrintedDigits;
             if (minDigits <= 1) {
                 FormatUtils.appendUnpaddedInteger(buf, value);

             if (iFieldType >= SECONDS_MILLIS) {
                 int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);
                 if (iFieldType == SECONDS_MILLIS || dp > 0) {
                     buf.append('.');
                     FormatUtils.appendPaddedInteger(buf, dp, 3);
                 }
","
             if (iFieldType >= SECONDS_MILLIS) {
                                                  sum = (valueLong < 0 ? Math.max(sum, 5) : Math.max(sum, 4));
                                  sum++;
                 if (iFieldType == SECONDS_OPTIONAL_MILLIS &&

             if (iPrefix != null) {
                 iPrefix.printTo(buf, value);
             }
            int bufLen = buf.length();
             int minDigits = iMinPrintedDigits;
             if (minDigits <= 1) {
                 FormatUtils.appendUnpaddedInteger(buf, value);

             if (iFieldType >= SECONDS_MILLIS) {
                 int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);
                 if (iFieldType == SECONDS_MILLIS || dp > 0) {
                    if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) {
                        buf.insert(bufLen, '-');
                    }
                     buf.append('.');
                     FormatUtils.appendPaddedInteger(buf, dp, 3);
                 }
"
383,"junit.framework.AssertionFailedError","/src/main/java/org/joda/time/field/FieldUtils.java","@@ -135,6 +135,9 @@ public static int safeMultiply(int val1, int val2) {
     public static long safeMultiply(long val1, int val2) {
         switch (val2) {
             case -1:
                 return -val1;
             case 0:
                 return 0L;
","@@ -135,6 +135,9 @@ public static int safeMultiply(int val1, int val2) {
     public static long safeMultiply(long val1, int val2) {
         switch (val2) {
             case -1:
              if (val1 == Long.MIN_VALUE) {
                  throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
              }
                 return -val1;
             case 0:
                 return 0L;
","
     public static long safeMultiply(long val1, int val2) {
         switch (val2) {
             case -1:
                 return -val1;
             case 0:
                 return 0L;
","
     public static long safeMultiply(long val1, int val2) {
         switch (val2) {
             case -1:
                if (val1 == Long.MIN_VALUE) {
                    throw new ArithmeticException(""Multiplication overflows a long: "" + val1 + "" * "" + val2);
                }
                 return -val1;
             case 0:
                 return 0L;
"
384,"junit.framework.AssertionFailedError","/src/main/java/org/joda/time/DateTimeZone.java","@@ -1164,19 +1164,32 @@ public long adjustOffset(long instant, boolean earlierOrLater) {
         // a bit messy, but will work in all non-pathological cases
         
         // evaluate 3 hours before and after to work out if anything is happening
      long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);
      long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);
      if (instantBefore == instantAfter) {
             return instant;  // not an overlap (less than is a gap, equal is normal case)
         }
         
         // work out range of instants that have duplicate local times
      long local = convertUTCToLocal(instant);
      return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);
         
         // calculate result
           // currently in later offset
           // currently in earlier offset
     }
 //    System.out.println(new DateTime(transitionStart, DateTimeZone.UTC) + "" "" + new DateTime(transitionStart, this));
 
","@@ -1164,19 +1164,32 @@ public long adjustOffset(long instant, boolean earlierOrLater) {
         // a bit messy, but will work in all non-pathological cases
         
         // evaluate 3 hours before and after to work out if anything is happening
      long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR;
      long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR;
      long offsetBefore = getOffset(instantBefore);
      long offsetAfter = getOffset(instantAfter);
      if (offsetBefore <= offsetAfter) {
             return instant;  // not an overlap (less than is a gap, equal is normal case)
         }
         
         // work out range of instants that have duplicate local times
      long diff = offsetBefore - offsetAfter;
      long transition = nextTransition(instantBefore);
      long overlapStart = transition - diff;
      long overlapEnd = transition + diff;
      if (instant < overlapStart || instant >= overlapEnd) {
        return instant;  // not an overlap
      }
         
         // calculate result
      long afterStart = instant - overlapStart;
      if (afterStart >= diff) {
           // currently in later offset
        return earlierOrLater ? instant : instant - diff;
      } else {
           // currently in earlier offset
        return earlierOrLater ? instant + diff : instant;
      }
     }
 //    System.out.println(new DateTime(transitionStart, DateTimeZone.UTC) + "" "" + new DateTime(transitionStart, this));
 
","
                  
                 long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);
        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);
        if (instantBefore == instantAfter) {
             return instant;           }
         
                 long local = convertUTCToLocal(instant);
        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);
         
                                    }
  
","
                  
                 long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR;
        long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR;
        long offsetBefore = getOffset(instantBefore);
        long offsetAfter = getOffset(instantAfter);
        if (offsetBefore <= offsetAfter) {
             return instant;           }
         
                 long diff = offsetBefore - offsetAfter;
        long transition = nextTransition(instantBefore);
        long overlapStart = transition - diff;
        long overlapEnd = transition + diff;
        if (instant < overlapStart || instant >= overlapEnd) {
          return instant;          }
         
                 long afterStart = instant - overlapStart;
        if (afterStart >= diff) {
                     return earlierOrLater ? instant : instant - diff;
        } else {
                     return earlierOrLater ? instant + diff : instant;
        }
     }
  
"
385,"junit.framework.AssertionFailedError","/src/main/java/org/joda/time/format/DateTimeFormatter.java","@@ -706,7 +706,7 @@ public int parseInto(ReadWritableInstant instant, String text, int position) {
         chrono = selectChronology(chrono);
         
         DateTimeParserBucket bucket = new DateTimeParserBucket(
          instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);
         int newPos = parser.parseInto(bucket, text, position);
         instant.setMillis(bucket.computeMillis(false, text));
         if (iOffsetParsed && bucket.getOffsetInteger() != null) {
","@@ -706,7 +706,7 @@ public int parseInto(ReadWritableInstant instant, String text, int position) {
         chrono = selectChronology(chrono);
         
         DateTimeParserBucket bucket = new DateTimeParserBucket(
          instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal));
         int newPos = parser.parseInto(bucket, text, position);
         instant.setMillis(bucket.computeMillis(false, text));
         if (iOffsetParsed && bucket.getOffsetInteger() != null) {
","
         chrono = selectChronology(chrono);
         
         DateTimeParserBucket bucket = new DateTimeParserBucket(
            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);
         int newPos = parser.parseInto(bucket, text, position);
         instant.setMillis(bucket.computeMillis(false, text));
         if (iOffsetParsed && bucket.getOffsetInteger() != null) {
","
         chrono = selectChronology(chrono);
         
         DateTimeParserBucket bucket = new DateTimeParserBucket(
            instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal));
         int newPos = parser.parseInto(bucket, text, position);
         instant.setMillis(bucket.computeMillis(false, text));
         if (iOffsetParsed && bucket.getOffsetInteger() != null) {
"
386,"java.lang.IllegalArgumentException","/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java","@@ -2539,12 +2539,18 @@ public int estimateParsedLength() {
 
         public int parseInto(DateTimeParserBucket bucket, String text, int position) {
             String str = text.substring(position);
             for (String id : ALL_IDS) {
                 if (str.startsWith(id)) {
                  bucket.setZone(DateTimeZone.forID(id));
                  return position + id.length();
                 }
             }
             return ~position;
         }
     }
","@@ -2539,12 +2539,18 @@ public int estimateParsedLength() {
 
         public int parseInto(DateTimeParserBucket bucket, String text, int position) {
             String str = text.substring(position);
          String best = null;
             for (String id : ALL_IDS) {
                 if (str.startsWith(id)) {
              	if (best == null || id.length() > best.length()) {
              		best = id;
              	}
                 }
             }
          if (best != null) {
              bucket.setZone(DateTimeZone.forID(best));
              return position + best.length();
          }
             return ~position;
         }
     }
","
 
         public int parseInto(DateTimeParserBucket bucket, String text, int position) {
             String str = text.substring(position);
             for (String id : ALL_IDS) {
                 if (str.startsWith(id)) {
                    bucket.setZone(DateTimeZone.forID(id));
                    return position + id.length();
                 }
             }
             return ~position;
         }
     }
","
 
         public int parseInto(DateTimeParserBucket bucket, String text, int position) {
             String str = text.substring(position);
            String best = null;
             for (String id : ALL_IDS) {
                 if (str.startsWith(id)) {
                	if (best == null || id.length() > best.length()) {
                		best = id;
                	}
                 }
             }
            if (best != null) {
                bucket.setZone(DateTimeZone.forID(best));
                return position + best.length();
            }
             return ~position;
         }
     }
"
387,"org.joda.time.IllegalFieldValueException","/src/main/java/org/joda/time/chrono/GJChronology.java","@@ -361,9 +361,21 @@ public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
 
         // Assume date is Gregorian.
         long instant;
             instant = iGregorianChronology.getDateTimeMillis
                 (year, monthOfYear, dayOfMonth,
                  hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
         if (instant < iCutoverMillis) {
             // Maybe it's Julian.
             instant = iJulianChronology.getDateTimeMillis
","@@ -361,9 +361,21 @@ public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,
 
         // Assume date is Gregorian.
         long instant;
      try {
             instant = iGregorianChronology.getDateTimeMillis
                 (year, monthOfYear, dayOfMonth,
                  hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
      } catch (IllegalFieldValueException ex) {
          if (monthOfYear != 2 || dayOfMonth != 29) {
              throw ex;
          }
          instant = iGregorianChronology.getDateTimeMillis
              (year, monthOfYear, 28,
               hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
          if (instant >= iCutoverMillis) {
              throw ex;
          }
      }
         if (instant < iCutoverMillis) {
             // Maybe it's Julian.
             instant = iJulianChronology.getDateTimeMillis
","
 
                  long instant;
             instant = iGregorianChronology.getDateTimeMillis
                 (year, monthOfYear, dayOfMonth,
                  hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
         if (instant < iCutoverMillis) {
                          instant = iJulianChronology.getDateTimeMillis
","
 
                  long instant;
        try {
             instant = iGregorianChronology.getDateTimeMillis
                 (year, monthOfYear, dayOfMonth,
                  hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
        } catch (IllegalFieldValueException ex) {
            if (monthOfYear != 2 || dayOfMonth != 29) {
                throw ex;
            }
            instant = iGregorianChronology.getDateTimeMillis
                (year, monthOfYear, 28,
                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);
            if (instant >= iCutoverMillis) {
                throw ex;
            }
        }
         if (instant < iCutoverMillis) {
                          instant = iJulianChronology.getDateTimeMillis
"
388,"junit.framework.ComparisonFailure","/src/main/java/org/joda/time/DateTimeZone.java","@@ -897,7 +897,7 @@ public int getOffsetFromLocal(long instantLocal) {
                     return offsetLocal;
                 }
             }
      } else if (offsetLocal > 0) {
             long prev = previousTransition(instantAdjusted);
             if (prev < instantAdjusted) {
                 int offsetPrev = getOffset(prev);
","@@ -897,7 +897,7 @@ public int getOffsetFromLocal(long instantLocal) {
                     return offsetLocal;
                 }
             }
      } else if (offsetLocal >= 0) {
             long prev = previousTransition(instantAdjusted);
             if (prev < instantAdjusted) {
                 int offsetPrev = getOffset(prev);
","
                     return offsetLocal;
                 }
             }
        } else if (offsetLocal > 0) {
             long prev = previousTransition(instantAdjusted);
             if (prev < instantAdjusted) {
                 int offsetPrev = getOffset(prev);
","
                     return offsetLocal;
                 }
             }
        } else if (offsetLocal >= 0) {
             long prev = previousTransition(instantAdjusted);
             if (prev < instantAdjusted) {
                 int offsetPrev = getOffset(prev);
"
389,"junit.framework.ComparisonFailure","/src/main/java/org/joda/time/tz/DefaultNameProvider.java","@@ -63,22 +63,32 @@ public String getName(Locale locale, String id, String nameKey) {
         if (byNameKeyCache == null) {
             byIdCache.put(id, byNameKeyCache = createCache());
             
             String[][] zoneStringsLoc = DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings();
             String[] setLoc = null;
             for (String[] strings : zoneStringsLoc) {
               if (strings != null && strings.length == 5 && id.equals(strings[0])) {
                 setLoc = strings;
             
            byNameKeyCache.put(setLoc[2], new String[] {setLoc[2], setLoc[1]});
               // need to handle case where summer and winter have the same
               // abbreviation, such as EST in Australia [1716305]
               // we handle this by appending ""-Summer"", cf ZoneInfoCompiler
            if (setLoc[2].equals(setLoc[4])) {
                byNameKeyCache.put(setLoc[4] + ""-Summer"", new String[] {setLoc[4], setLoc[3]});
               } else {
                byNameKeyCache.put(setLoc[4], new String[] {setLoc[4], setLoc[3]});
            }
              break;
               }
             }
         }
","@@ -63,22 +63,32 @@ public String getName(Locale locale, String id, String nameKey) {
         if (byNameKeyCache == null) {
             byIdCache.put(id, byNameKeyCache = createCache());
             
          String[][] zoneStringsEn = DateTimeUtils.getDateFormatSymbols(Locale.ENGLISH).getZoneStrings();
          String[] setEn = null;
          for (String[] strings : zoneStringsEn) {
            if (strings != null && strings.length == 5 && id.equals(strings[0])) {
              setEn = strings;
              break;
            }
          }
             String[][] zoneStringsLoc = DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings();
             String[] setLoc = null;
             for (String[] strings : zoneStringsLoc) {
               if (strings != null && strings.length == 5 && id.equals(strings[0])) {
                 setLoc = strings;
              break;
            }
          }
             
          if (setEn != null && setLoc != null) {
            byNameKeyCache.put(setEn[2], new String[] {setLoc[2], setLoc[1]});
               // need to handle case where summer and winter have the same
               // abbreviation, such as EST in Australia [1716305]
               // we handle this by appending ""-Summer"", cf ZoneInfoCompiler
            if (setEn[2].equals(setEn[4])) {
                byNameKeyCache.put(setEn[4] + ""-Summer"", new String[] {setLoc[4], setLoc[3]});
               } else {
                byNameKeyCache.put(setEn[4], new String[] {setLoc[4], setLoc[3]});
               }
             }
         }
","
         if (byNameKeyCache == null) {
             byIdCache.put(id, byNameKeyCache = createCache());
             
             String[][] zoneStringsLoc = DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings();
             String[] setLoc = null;
             for (String[] strings : zoneStringsLoc) {
               if (strings != null && strings.length == 5 && id.equals(strings[0])) {
                 setLoc = strings;
             
              byNameKeyCache.put(setLoc[2], new String[] {setLoc[2], setLoc[1]});
                                                           if (setLoc[2].equals(setLoc[4])) {
                  byNameKeyCache.put(setLoc[4] + ""-Summer"", new String[] {setLoc[4], setLoc[3]});
               } else {
                  byNameKeyCache.put(setLoc[4], new String[] {setLoc[4], setLoc[3]});
              }
                break;
               }
             }
         }
","
         if (byNameKeyCache == null) {
             byIdCache.put(id, byNameKeyCache = createCache());
             
            String[][] zoneStringsEn = DateTimeUtils.getDateFormatSymbols(Locale.ENGLISH).getZoneStrings();
            String[] setEn = null;
            for (String[] strings : zoneStringsEn) {
              if (strings != null && strings.length == 5 && id.equals(strings[0])) {
                setEn = strings;
                break;
              }
            }
             String[][] zoneStringsLoc = DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings();
             String[] setLoc = null;
             for (String[] strings : zoneStringsLoc) {
               if (strings != null && strings.length == 5 && id.equals(strings[0])) {
                 setLoc = strings;
                break;
              }
            }
             
            if (setEn != null && setLoc != null) {
              byNameKeyCache.put(setEn[2], new String[] {setLoc[2], setLoc[1]});
                                                           if (setEn[2].equals(setEn[4])) {
                  byNameKeyCache.put(setEn[4] + ""-Summer"", new String[] {setLoc[4], setLoc[3]});
               } else {
                  byNameKeyCache.put(setEn[4], new String[] {setLoc[4], setLoc[3]});
               }
             }
         }
"
390,"junit.framework.AssertionFailedError","/src/main/java/org/joda/time/base/BasePeriod.java","@@ -219,8 +219,13 @@ protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri
      * @param duration  the duration, in milliseconds
      */
     protected BasePeriod(long duration) {
      this(duration, null, null);
         // bug [3264409]
     }
 
     /**
","@@ -219,8 +219,13 @@ protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, Peri
      * @param duration  the duration, in milliseconds
      */
     protected BasePeriod(long duration) {
      super();
         // bug [3264409]
      iType = PeriodType.time();
      int[] values = ISOChronology.getInstanceUTC().get(this, duration);
      iType = PeriodType.standard();
      iValues = new int[8];
      System.arraycopy(values, 0, iValues, 4, 4);
     }
 
     /**
","
     
     protected BasePeriod(long duration) {
        this(duration, null, null);
              }
","
    
     protected BasePeriod(long duration) {
        super();
                 iType = PeriodType.time();
        int[] values = ISOChronology.getInstanceUTC().get(this, duration);
        iType = PeriodType.standard();
        iValues = new int[8];
        System.arraycopy(values, 0, iValues, 4, 4);
     }
 
"
391,"junit.framework.ComparisonFailure","/src/main/java/org/joda/time/DateTimeZone.java","@@ -561,6 +561,11 @@ private static synchronized String getConvertedId(String id) {
             // Backwards compatibility with TimeZone.
             map = new HashMap<String, String>();
             map.put(""GMT"", ""UTC"");
             map.put(""MIT"", ""Pacific/Apia"");
             map.put(""HST"", ""Pacific/Honolulu"");  // JDK 1.1 compatible
             map.put(""AST"", ""America/Anchorage"");
@@ -569,23 +574,19 @@ private static synchronized String getConvertedId(String id) {
             map.put(""PNT"", ""America/Phoenix"");
             map.put(""CST"", ""America/Chicago"");
             map.put(""EST"", ""America/New_York"");  // JDK 1.1 compatible
          map.put(""IET"", ""America/Indianapolis"");
             map.put(""PRT"", ""America/Puerto_Rico"");
             map.put(""CNT"", ""America/St_Johns"");
          map.put(""AGT"", ""America/Buenos_Aires"");
             map.put(""BET"", ""America/Sao_Paulo"");
          map.put(""WET"", ""Europe/London"");
          map.put(""ECT"", ""Europe/Paris"");
             map.put(""ART"", ""Africa/Cairo"");
             map.put(""CAT"", ""Africa/Harare"");
          map.put(""EET"", ""Europe/Bucharest"");
             map.put(""EAT"", ""Africa/Addis_Ababa"");
          map.put(""MET"", ""Asia/Tehran"");
             map.put(""NET"", ""Asia/Yerevan"");
             map.put(""PLT"", ""Asia/Karachi"");
          map.put(""IST"", ""Asia/Calcutta"");
             map.put(""BST"", ""Asia/Dhaka"");
          map.put(""VST"", ""Asia/Saigon"");
             map.put(""CTT"", ""Asia/Shanghai"");
             map.put(""JST"", ""Asia/Tokyo"");
             map.put(""ACT"", ""Australia/Darwin"");
","@@ -561,6 +561,11 @@ private static synchronized String getConvertedId(String id) {
             // Backwards compatibility with TimeZone.
             map = new HashMap<String, String>();
             map.put(""GMT"", ""UTC"");
          map.put(""WET"", ""WET"");
          map.put(""CET"", ""CET"");
          map.put(""MET"", ""CET"");
          map.put(""ECT"", ""CET"");
          map.put(""EET"", ""EET"");
             map.put(""MIT"", ""Pacific/Apia"");
             map.put(""HST"", ""Pacific/Honolulu"");  // JDK 1.1 compatible
             map.put(""AST"", ""America/Anchorage"");
@@ -569,23 +574,19 @@ private static synchronized String getConvertedId(String id) {
             map.put(""PNT"", ""America/Phoenix"");
             map.put(""CST"", ""America/Chicago"");
             map.put(""EST"", ""America/New_York"");  // JDK 1.1 compatible
          map.put(""IET"", ""America/Indiana/Indianapolis"");
             map.put(""PRT"", ""America/Puerto_Rico"");
             map.put(""CNT"", ""America/St_Johns"");
          map.put(""AGT"", ""America/Argentina/Buenos_Aires"");
             map.put(""BET"", ""America/Sao_Paulo"");
             map.put(""ART"", ""Africa/Cairo"");
             map.put(""CAT"", ""Africa/Harare"");
             map.put(""EAT"", ""Africa/Addis_Ababa"");
             map.put(""NET"", ""Asia/Yerevan"");
             map.put(""PLT"", ""Asia/Karachi"");
          map.put(""IST"", ""Asia/Kolkata"");
             map.put(""BST"", ""Asia/Dhaka"");
          map.put(""VST"", ""Asia/Ho_Chi_Minh"");
             map.put(""CTT"", ""Asia/Shanghai"");
             map.put(""JST"", ""Asia/Tokyo"");
             map.put(""ACT"", ""Australia/Darwin"");
","
                          map = new HashMap<String, String>();
             map.put(""GMT"", ""UTC"");
             map.put(""MIT"", ""Pacific/Apia"");
             map.put(""HST"", ""Pacific/Honolulu"");               map.put(""AST"", ""America/Anchorage"");

             map.put(""PNT"", ""America/Phoenix"");
             map.put(""CST"", ""America/Chicago"");
             map.put(""EST"", ""America/New_York"");              map.put(""IET"", ""America/Indianapolis"");
             map.put(""PRT"", ""America/Puerto_Rico"");
             map.put(""CNT"", ""America/St_Johns"");
            map.put(""AGT"", ""America/Buenos_Aires"");
             map.put(""BET"", ""America/Sao_Paulo"");
            map.put(""WET"", ""Europe/London"");
            map.put(""ECT"", ""Europe/Paris"");
             map.put(""ART"", ""Africa/Cairo"");
             map.put(""CAT"", ""Africa/Harare"");
            map.put(""EET"", ""Europe/Bucharest"");
             map.put(""EAT"", ""Africa/Addis_Ababa"");
            map.put(""MET"", ""Asia/Tehran"");
             map.put(""NET"", ""Asia/Yerevan"");
             map.put(""PLT"", ""Asia/Karachi"");
            map.put(""IST"", ""Asia/Calcutta"");
             map.put(""BST"", ""Asia/Dhaka"");
            map.put(""VST"", ""Asia/Saigon"");
             map.put(""CTT"", ""Asia/Shanghai"");
             map.put(""JST"", ""Asia/Tokyo"");
             map.put(""ACT"", ""Australia/Darwin"");
","
                          map = new HashMap<String, String>();
             map.put(""GMT"", ""UTC"");
            map.put(""WET"", ""WET"");
            map.put(""CET"", ""CET"");
            map.put(""MET"", ""CET"");
            map.put(""ECT"", ""CET"");
            map.put(""EET"", ""EET"");
             map.put(""MIT"", ""Pacific/Apia"");
             map.put(""HST"", ""Pacific/Honolulu"");               map.put(""AST"", ""America/Anchorage"");

             map.put(""PNT"", ""America/Phoenix"");
             map.put(""CST"", ""America/Chicago"");
             map.put(""EST"", ""America/New_York"");              map.put(""IET"", ""America/Indiana/Indianapolis"");
             map.put(""PRT"", ""America/Puerto_Rico"");
             map.put(""CNT"", ""America/St_Johns"");
            map.put(""AGT"", ""America/Argentina/Buenos_Aires"");
             map.put(""BET"", ""America/Sao_Paulo"");
             map.put(""ART"", ""Africa/Cairo"");
             map.put(""CAT"", ""Africa/Harare"");
             map.put(""EAT"", ""Africa/Addis_Ababa"");
             map.put(""NET"", ""Asia/Yerevan"");
             map.put(""PLT"", ""Asia/Karachi"");
            map.put(""IST"", ""Asia/Kolkata"");
             map.put(""BST"", ""Asia/Dhaka"");
            map.put(""VST"", ""Asia/Ho_Chi_Minh"");
             map.put(""CTT"", ""Asia/Shanghai"");
             map.put(""JST"", ""Asia/Tokyo"");
             map.put(""ACT"", ""Australia/Darwin"");
"
392,"junit.framework.ComparisonFailure","/src/main/java/org/joda/time/DateTimeZone.java","@@ -896,6 +896,15 @@ public int getOffsetFromLocal(long instantLocal) {
                     return offsetLocal;
                 }
             }
         }
         return offsetAdjusted;
     }
","@@ -896,6 +896,15 @@ public int getOffsetFromLocal(long instantLocal) {
                     return offsetLocal;
                 }
             }
      } else if (offsetLocal > 0) {
          long prev = previousTransition(instantAdjusted);
          if (prev < instantAdjusted) {
              int offsetPrev = getOffset(prev);
              int diff = offsetPrev - offsetLocal;
              if (instantAdjusted - prev <= diff) {
                  return offsetPrev;
              }
          }
         }
         return offsetAdjusted;
     }
","
                     return offsetLocal;
                 }
             }
         }
         return offsetAdjusted;
     }
","
                     return offsetLocal;
                 }
             }
        } else if (offsetLocal > 0) {
            long prev = previousTransition(instantAdjusted);
            if (prev < instantAdjusted) {
                int offsetPrev = getOffset(prev);
                int diff = offsetPrev - offsetLocal;
                if (instantAdjusted - prev <= diff) {
                    return offsetPrev;
                }
            }
         }
         return offsetAdjusted;
     }
"
393,"junit.framework.ComparisonFailure","/src/main/java/org/joda/time/chrono/ZonedChronology.java","@@ -433,7 +433,7 @@ public long add(long instant, int value) {
             } else {
                long localInstant = iZone.convertUTCToLocal(instant);
                localInstant = iField.add(localInstant, value);
             return iZone.convertLocalToUTC(localInstant, false);
             }
         }
 
@@ -445,7 +445,7 @@ public long add(long instant, long value) {
             } else {
                long localInstant = iZone.convertUTCToLocal(instant);
                localInstant = iField.add(localInstant, value);
             return iZone.convertLocalToUTC(localInstant, false);
             }
         }
 
@@ -457,14 +457,14 @@ public long addWrapField(long instant, int value) {
             } else {
                 long localInstant = iZone.convertUTCToLocal(instant);
                 localInstant = iField.addWrapField(localInstant, value);
              return iZone.convertLocalToUTC(localInstant, false);
             }
         }
 
         public long set(long instant, int value) {
             long localInstant = iZone.convertUTCToLocal(instant);
             localInstant = iField.set(localInstant, value);
          long result = iZone.convertLocalToUTC(localInstant, false);
             if (get(result) != value) {
                 throw new IllegalFieldValueException(iField.getType(), new Integer(value),
                     ""Illegal instant due to time zone offset transition: "" +
@@ -478,7 +478,7 @@ public long set(long instant, String text, Locale locale) {
             // cannot verify that new value stuck because set may be lenient
             long localInstant = iZone.convertUTCToLocal(instant);
             localInstant = iField.set(localInstant, text, locale);
          return iZone.convertLocalToUTC(localInstant, false);
         }
 
         public int getDifference(long minuendInstant, long subtrahendInstant) {
@@ -525,7 +525,7 @@ public long roundFloor(long instant) {
             } else {
                 long localInstant = iZone.convertUTCToLocal(instant);
                 localInstant = iField.roundFloor(localInstant);
              return iZone.convertLocalToUTC(localInstant, false);
             }
         }
 
@@ -537,7 +537,7 @@ public long roundCeiling(long instant) {
             } else {
                 long localInstant = iZone.convertUTCToLocal(instant);
                 localInstant = iField.roundCeiling(localInstant);
              return iZone.convertLocalToUTC(localInstant, false);
             }
         }
 
","@@ -433,7 +433,7 @@ public long add(long instant, int value) {
             } else {
                long localInstant = iZone.convertUTCToLocal(instant);
                localInstant = iField.add(localInstant, value);
             return iZone.convertLocalToUTC(localInstant, false, instant);
             }
         }
 
@@ -445,7 +445,7 @@ public long add(long instant, long value) {
             } else {
                long localInstant = iZone.convertUTCToLocal(instant);
                localInstant = iField.add(localInstant, value);
             return iZone.convertLocalToUTC(localInstant, false, instant);
             }
         }
 
@@ -457,14 +457,14 @@ public long addWrapField(long instant, int value) {
             } else {
                 long localInstant = iZone.convertUTCToLocal(instant);
                 localInstant = iField.addWrapField(localInstant, value);
              return iZone.convertLocalToUTC(localInstant, false, instant);
             }
         }
 
         public long set(long instant, int value) {
             long localInstant = iZone.convertUTCToLocal(instant);
             localInstant = iField.set(localInstant, value);
          long result = iZone.convertLocalToUTC(localInstant, false, instant);
             if (get(result) != value) {
                 throw new IllegalFieldValueException(iField.getType(), new Integer(value),
                     ""Illegal instant due to time zone offset transition: "" +
@@ -478,7 +478,7 @@ public long set(long instant, String text, Locale locale) {
             // cannot verify that new value stuck because set may be lenient
             long localInstant = iZone.convertUTCToLocal(instant);
             localInstant = iField.set(localInstant, text, locale);
          return iZone.convertLocalToUTC(localInstant, false, instant);
         }
 
         public int getDifference(long minuendInstant, long subtrahendInstant) {
@@ -525,7 +525,7 @@ public long roundFloor(long instant) {
             } else {
                 long localInstant = iZone.convertUTCToLocal(instant);
                 localInstant = iField.roundFloor(localInstant);
              return iZone.convertLocalToUTC(localInstant, false, instant);
             }
         }
 
@@ -537,7 +537,7 @@ public long roundCeiling(long instant) {
             } else {
                 long localInstant = iZone.convertUTCToLocal(instant);
                 localInstant = iField.roundCeiling(localInstant);
              return iZone.convertLocalToUTC(localInstant, false, instant);
             }
         }
 
","
             } else {
                long localInstant = iZone.convertUTCToLocal(instant);
                localInstant = iField.add(localInstant, value);
               return iZone.convertLocalToUTC(localInstant, false);
             }
         }
 

             } else {
                long localInstant = iZone.convertUTCToLocal(instant);
                localInstant = iField.add(localInstant, value);
               return iZone.convertLocalToUTC(localInstant, false);
             }
         }
 

             } else {
                 long localInstant = iZone.convertUTCToLocal(instant);
                 localInstant = iField.addWrapField(localInstant, value);
                return iZone.convertLocalToUTC(localInstant, false);
             }
         }
 
         public long set(long instant, int value) {
             long localInstant = iZone.convertUTCToLocal(instant);
             localInstant = iField.set(localInstant, value);
            long result = iZone.convertLocalToUTC(localInstant, false);
             if (get(result) != value) {
                 throw new IllegalFieldValueException(iField.getType(), new Integer(value),
                     ""Illegal instant due to time zone offset transition: "" +

                          long localInstant = iZone.convertUTCToLocal(instant);
             localInstant = iField.set(localInstant, text, locale);
            return iZone.convertLocalToUTC(localInstant, false);
         }
 
         public int getDifference(long minuendInstant, long subtrahendInstant) {

             } else {
                 long localInstant = iZone.convertUTCToLocal(instant);
                 localInstant = iField.roundFloor(localInstant);
                return iZone.convertLocalToUTC(localInstant, false);
             }
         }
 

             } else {
                 long localInstant = iZone.convertUTCToLocal(instant);
                 localInstant = iField.roundCeiling(localInstant);
                return iZone.convertLocalToUTC(localInstant, false);
             }
         }
 
","
             } else {
                long localInstant = iZone.convertUTCToLocal(instant);
                localInstant = iField.add(localInstant, value);
               return iZone.convertLocalToUTC(localInstant, false, instant);
             }
         }
 

             } else {
                long localInstant = iZone.convertUTCToLocal(instant);
                localInstant = iField.add(localInstant, value);
               return iZone.convertLocalToUTC(localInstant, false, instant);
             }
         }
 

             } else {
                 long localInstant = iZone.convertUTCToLocal(instant);
                 localInstant = iField.addWrapField(localInstant, value);
                return iZone.convertLocalToUTC(localInstant, false, instant);
             }
         }
 
         public long set(long instant, int value) {
             long localInstant = iZone.convertUTCToLocal(instant);
             localInstant = iField.set(localInstant, value);
            long result = iZone.convertLocalToUTC(localInstant, false, instant);
             if (get(result) != value) {
                 throw new IllegalFieldValueException(iField.getType(), new Integer(value),
                     ""Illegal instant due to time zone offset transition: "" +

                          long localInstant = iZone.convertUTCToLocal(instant);
             localInstant = iField.set(localInstant, text, locale);
            return iZone.convertLocalToUTC(localInstant, false, instant);
         }
 
         public int getDifference(long minuendInstant, long subtrahendInstant) {

             } else {
                 long localInstant = iZone.convertUTCToLocal(instant);
                 localInstant = iField.roundFloor(localInstant);
                return iZone.convertLocalToUTC(localInstant, false, instant);
             }
         }
 

             } else {
                 long localInstant = iZone.convertUTCToLocal(instant);
                 localInstant = iField.roundCeiling(localInstant);
                return iZone.convertLocalToUTC(localInstant, false, instant);
             }
         }
 
"
394,"junit.framework.AssertionFailedError","/src/main/java/org/joda/time/format/DateTimeParserBucket.java","@@ -352,6 +352,11 @@ public long computeMillis(boolean resetFields, String text) {
             for (int i = 0; i < count; i++) {
                 millis = savedFields[i].set(millis, resetFields);
             }
         } catch (IllegalFieldValueException e) {
             if (text != null) {
                 e.prependMessage(""Cannot parse \"""" + text + '""');
","@@ -352,6 +352,11 @@ public long computeMillis(boolean resetFields, String text) {
             for (int i = 0; i < count; i++) {
                 millis = savedFields[i].set(millis, resetFields);
             }
          if (resetFields) {
              for (int i = 0; i < count; i++) {
                  millis = savedFields[i].set(millis, i == (count - 1));
              }
          }
         } catch (IllegalFieldValueException e) {
             if (text != null) {
                 e.prependMessage(""Cannot parse \"""" + text + '""');
","
             for (int i = 0; i < count; i++) {
                 millis = savedFields[i].set(millis, resetFields);
             }
         } catch (IllegalFieldValueException e) {
             if (text != null) {
                 e.prependMessage(""Cannot parse \"""" + text + '""');
","
             for (int i = 0; i < count; i++) {
                 millis = savedFields[i].set(millis, resetFields);
             }
            if (resetFields) {
                for (int i = 0; i < count; i++) {
                    millis = savedFields[i].set(millis, i == (count - 1));
                }
            }
         } catch (IllegalFieldValueException e) {
             if (text != null) {
                 e.prependMessage(""Cannot parse \"""" + text + '""');
"
395,"java.lang.IllegalArgumentException","/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java","@@ -798,9 +798,11 @@ private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean no
         int size = elementPairs.size();
         if (size >= 2 && elementPairs.get(0) instanceof Separator) {
             Separator sep = (Separator) elementPairs.get(0);
                 PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);
                 sep = sep.finish(f.getPrinter(), f.getParser());
                 return new PeriodFormatter(sep, sep);
         }
         Object[] comp = createComposite(elementPairs);
         if (notPrinter) {
","@@ -798,9 +798,11 @@ private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean no
         int size = elementPairs.size();
         if (size >= 2 && elementPairs.get(0) instanceof Separator) {
             Separator sep = (Separator) elementPairs.get(0);
          if (sep.iAfterParser == null && sep.iAfterPrinter == null) {
                 PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);
                 sep = sep.finish(f.getPrinter(), f.getParser());
                 return new PeriodFormatter(sep, sep);
          }
         }
         Object[] comp = createComposite(elementPairs);
         if (notPrinter) {
","
         int size = elementPairs.size();
         if (size >= 2 && elementPairs.get(0) instanceof Separator) {
             Separator sep = (Separator) elementPairs.get(0);
                 PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);
                 sep = sep.finish(f.getPrinter(), f.getParser());
                 return new PeriodFormatter(sep, sep);
         }
         Object[] comp = createComposite(elementPairs);
         if (notPrinter) {
","
         int size = elementPairs.size();
         if (size >= 2 && elementPairs.get(0) instanceof Separator) {
             Separator sep = (Separator) elementPairs.get(0);
            if (sep.iAfterParser == null && sep.iAfterPrinter == null) {
                 PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);
                 sep = sep.finish(f.getPrinter(), f.getParser());
                 return new PeriodFormatter(sep, sep);
            }
         }
         Object[] comp = createComposite(elementPairs);
         if (notPrinter) {
"
